const __vite__fileDeps = ["assets/angular-html-DZQ5UQWW.js", "assets/html-CqhC7HHo.js", "assets/javascript-Dch3xQiY.js", "assets/css-CbYhyuC0.js", "assets/angular-ts-DOuPvTiZ.js", "assets/scss-DqznleHU.js", "assets/apl-D9TNySCV.js", "assets/xml-KWQaRJyt.js", "assets/java-ClXEvkw9.js", "assets/json-CupVZNk8.js", "assets/asciidoc-CF5eOCvB.js", "assets/yaml-C5gCGmDW.js", "assets/csv-B2DkETJQ.js", "assets/c-RCJZWN-0.js", "assets/clojure-BF6G6X0H.js", "assets/coffee-B4DZ7swD.js", "assets/cpp-B9__le0e.js", "assets/glsl-DNg5e6rY.js", "assets/sql-DbK06e1c.js", "assets/csharp-DISxKEhY.js", "assets/diff-DvyTQcux.js", "assets/docker-DNR26wTC.js", "assets/elixir-DjCTzIqv.js", "assets/elm-CTSLo1i4.js", "assets/erlang-DS9ZWoKD.js", "assets/go-BJn7Ek5W.js", "assets/groovy-wChcbJ1V.js", "assets/haskell-DAGYewaG.js", "assets/jsx-CsyrCbsw.js", "assets/julia-CnoVwgV8.js", "assets/python-DwuVtWc2.js", "assets/r-BXfENWL6.js", "assets/kotlin-BIxS-Weu.js", "assets/less-Du6_OKDb.js", "assets/make-B9S9BZZh.js", "assets/objective-c-DHmGyzbM.js", "assets/ocaml-RqY_Nz63.js", "assets/perl-InL218rs.js", "assets/ruby-CPHW1Myo.js", "assets/shellscript-BZfs-ost.js", "assets/lua-BPmF2VOm.js", "assets/rust-DGxQkqYo.js", "assets/sass-CMDmr8et.js", "assets/scala-vMsNTMhM.js", "assets/swift-Dez-Qvcc.js", "assets/toml-BT9ZzGyQ.js", "assets/typescript-DC8MraHL.js", "assets/astro-U9VgAVQT.js", "assets/stylus-DSrLtGYv.js", "assets/postcss-DXT9h7v2.js", "assets/tsx-BlxWTfDV.js", "assets/blade-HiqCVk8k.js", "assets/cobol-DgBJixdi.js", "assets/crystal-DwllXkRF.js", "assets/erb-C4FIxXpw.js", "assets/fortran-fixed-form-CdVjoHtb.js", "assets/fortran-free-form-D6pmzCqS.js", "assets/fsharp-C-VjhQSu.js", "assets/markdown-BdfWgkoX.js", "assets/gdresource-nSffpn2A.js", "assets/gdshader-B_SUYfiV.js", "assets/gdscript-B474tPdy.js", "assets/git-commit-BleTlbuD.js", "assets/git-rebase-CtmYztAk.js", "assets/glimmer-js-Bhx_sfM5.js", "assets/glimmer-ts-61dai_V5.js", "assets/graphql-Cac5VMXA.js", "assets/hack-OhUXFOZr.js", "assets/haml-BsKmeTIz.js", "assets/handlebars-C0vBBVRa.js", "assets/html-derivative-CvQVKW9i.js", "assets/http-mWhOz2-8.js", "assets/hxml-C5imjkyf.js", "assets/haxe-Dit6kIrv.js", "assets/imba-BXg-Svbq.js", "assets/jinja-DwshyRC8.js", "assets/jison-5Ig0VrXv.js", "assets/latex-DhY63DBA.js", "assets/tex-Dk885XYG.js", "assets/gnuplot-nclm9rTJ.js", "assets/liquid-Dj-jsJFu.js", "assets/marko-DTTVzMRa.js", "assets/mdc-Bn_uTtpR.js", "assets/nginx-Bo7Ko850.js", "assets/nim-0XdZC7BR.js", "assets/php-DdJTc9Za.js", "assets/pug-BmZh5kCX.js", "assets/qml-DcMLa_hy.js", "assets/razor-CtZ59qoM.js", "assets/rst-5AUMhdsS.js", "assets/cmake-DXZpi2gR.js", "assets/sas-WQZNIjpJ.js", "assets/shaderlab-DBpbMEBh.js", "assets/hlsl-DmDrTTlz.js", "assets/shellsession-4WldjxEd.js", "assets/soy-DhLnWwFA.js", "assets/sparql-BgtC_-ln.js", "assets/turtle-C15OxdQ5.js", "assets/stata-8O9LehIm.js", "assets/svelte-DavKDhWY.js", "assets/twig-llAgFoxS.js", "assets/vue-DwKRC_TW.js", "assets/jsonc-DYI1rfmx.js", "assets/json5-Bh8mriwU.js", "assets/vue-html-BQKlc1uT.js", "assets/wikitext-2Gt4HDrj.js", "assets/ini-DeVv6D4_.js", "assets/vb-beD-FUib.js", "assets/xsl-bm8RKyr3.js", "assets/bat-BPiaQZfK.js", "assets/raku-D384ylkT.js", "assets/powershell-9ZOzOPqN.js", "assets/dart-DZLoTQm4.js", "assets/bibtex-BaedD2tq.js", "assets/ConsoleInspector-CScDT6Zw.js", "assets/index-fw5NnR3n.js", "assets/stripIndent-YObSZ0C4.js", "assets/analytics-99_lWGz8.js", "assets/login-nmFSgkQU.js", "assets/index-Cim1HUmG.js", "assets/index-DX5qHRIi.js", "assets/index-DlE5WDmH.js", "assets/index-eoFC3xUZ.js", "assets/components-B64jh5hJ.js", "assets/LoadingDots-C83QcpuT.js", "assets/index-CB4veLy4.js", "assets/index-CNyZagvz.js", "assets/index-CmQ84u7v.js", "assets/index-CzIEtgTK.js", "assets/index-DgC2sezN.js", "assets/index-CXL-M3S7.js", "assets/index-CdaH1m_X.js", "assets/index-Cq3hXmRr.js"]
  , __vite__mapDeps = i => i.map(i => __vite__fileDeps[i]);
import {g as Eh, r as S, j as v, x as Ay, M as Cx, i as ky, R as Cr} from "./index-fw5NnR3n.js";
import {u as Ie, t as da, s as Ry, C as hr, g as WF, a as GF, b as qF} from "./stripIndent-YObSZ0C4.js";
import {c as be, W as KF, b as YF, B as XF, u as Kt, I as im, d as a_, e as ak, f as au, g as sm, h as lk, j as l_, C as om, k as He, P as Mo, l as qi, m as QF, L as Lf, E as JF, n as c_, i as ZF, a as e6} from "./login-nmFSgkQU.js";
import {r as fa, m as ck, u as Fl, n as uk, o as t6} from "./components-B64jh5hJ.js";
import {e as yg, a as wt, p as lu, c as nr, B as ct, l as pa, s as Rr, A as Ir, b as Yr, r as _r} from "./analytics-99_lWGz8.js";
import {L as n6} from "./LoadingDots-C83QcpuT.js";
const r6 = 5
  , ld = 6
  , cd = 10;
let i6 = (t, e, n, r) => (t.events = t.events || {},
t.events[n + cd] || (t.events[n + cd] = r(i => {
    t.events[n].reduceRight( (s, o) => (o(s),
    s), {
        shared: {},
        ...i
    })
}
)),
t.events[n] = t.events[n] || [],
t.events[n].push(e),
() => {
    let i = t.events[n]
      , s = i.indexOf(e);
    i.splice(s, 1),
    i.length || (delete t.events[n],
    t.events[n + cd](),
    delete t.events[n + cd])
}
)
  , s6 = 1e3
  , hk = (t, e) => i6(t, r => {
    let i = e(r);
    i && t.events[ld].push(i)
}
, r6, r => {
    let i = t.listen;
    t.listen = (...o) => (!t.lc && !t.active && (t.active = !0,
    r()),
    i(...o));
    let s = t.off;
    return t.events[ld] = [],
    t.off = () => {
        s(),
        setTimeout( () => {
            if (t.active && !t.lc) {
                t.active = !1;
                for (let o of t.events[ld])
                    o();
                t.events[ld] = []
            }
        }
        , s6)
    }
    ,
    () => {
        t.listen = i,
        t.off = s
    }
}
)
  , o6 = (t, e, n) => {
    Array.isArray(t) || (t = [t]);
    let r, i, s = () => {
        if (i === yg)
            return;
        i = yg;
        let c = t.map(u => u.get());
        if (!r || c.some( (u, h) => u !== r[h])) {
            r = c;
            let u = e(...c);
            u && u.then && u.t ? u.then(h => {
                r === c && o.set(h)
            }
            ) : (o.set(u),
            i = yg)
        }
    }
    , o = wt(void 0), a = o.get;
    o.get = () => (s(),
    a());
    let l = s;
    return hk(o, () => {
        let c = t.map(u => u.listen(l));
        return s(),
        () => {
            for (let u of c)
                u()
        }
    }
    ),
    o
}
  , sl = (t, e) => o6(t, e)
  , ma = (t={}) => {
    let e = wt(t);
    return e.setKey = function(n, r) {
        let i = e.value;
        typeof r > "u" && n in e.value ? (e.value = {
            ...e.value
        },
        delete e.value[n],
        e.notify(i, n)) : e.value[n] !== r && (e.value = {
            ...e.value,
            [n]: r
        },
        e.notify(i, n))
    }
    ,
    e
}
;
var An = function() {
    return An = Object.assign || function(e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n)
                Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }
    ,
    An.apply(this, arguments)
};
function Iy(t, e) {
    var n = {};
    for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}
function dk(t, e, n) {
    if (n || arguments.length === 2)
        for (var r = 0, i = e.length, s; r < i; r++)
            (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)),
            s[r] = e[r]);
    return t.concat(s || Array.prototype.slice.call(e))
}
const a6 = "modulepreload"
  , l6 = function(t) {
    return "/" + t
}
  , Tx = {}
  , K = function(e, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
        document.getElementsByTagName("link");
        const s = document.querySelector("meta[property=csp-nonce]")
          , o = s?.nonce || s?.getAttribute("nonce");
        i = Promise.all(n.map(a => {
            if (a = l6(a),
            a in Tx)
                return;
            Tx[a] = !0;
            const l = a.endsWith(".css")
              , c = l ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${a}"]${c}`))
                return;
            const u = document.createElement("link");
            if (u.rel = l ? "stylesheet" : a6,
            l || (u.as = "script",
            u.crossOrigin = ""),
            u.href = a,
            o && u.setAttribute("nonce", o),
            document.head.appendChild(u),
            l)
                return new Promise( (h, d) => {
                    u.addEventListener("load", h),
                    u.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${a}`)))
                }
                )
        }
        ))
    }
    return i.then( () => e()).catch(s => {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = s,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw s
    }
    )
};
var Ax = {};
function kx(t) {
    return Array.isArray(t) ? t : [t]
}
const u_ = ""
  , Rx = " "
  , vg = "\\"
  , c6 = /^\s+$/
  , u6 = /(?:[^\\]|^)\\$/
  , h6 = /^\\!/
  , d6 = /^\\#/
  , f6 = /\r?\n/g
  , p6 = /^\.*\/|^\.+$/
  , xg = "/";
let fk = "node-ignore";
typeof Symbol < "u" && (fk = Symbol.for("node-ignore"));
const Ix = fk
  , m6 = (t, e, n) => Object.defineProperty(t, e, {
    value: n
})
  , g6 = /([0-z])-([0-z])/g
  , pk = () => !1
  , _6 = t => t.replace(g6, (e, n, r) => n.charCodeAt(0) <= r.charCodeAt(0) ? e : u_)
  , b6 = t => {
    const {length: e} = t;
    return t.slice(0, e - e % 2)
}
  , y6 = [[/^\uFEFF/, () => u_], [/((?:\\\\)*?)(\\?\s+)$/, (t, e, n) => e + (n.indexOf("\\") === 0 ? Rx : u_)], [/(\\+?)\s/g, (t, e) => {
    const {length: n} = e;
    return e.slice(0, n - n % 2) + Rx
}
], [/[\\$.|*+(){^]/g, t => `\\${t}`], [/(?!\\)\?/g, () => "[^/]"], [/^\//, () => "^"], [/\//g, () => "\\/"], [/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"], [/^(?=[^^])/, function() {
    return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)"
}
], [/\\\/\\\*\\\*(?=\\\/|$)/g, (t, e, n) => e + 6 < n.length ? "(?:\\/[^\\/]+)*" : "\\/.+"], [/(^|[^\\]+)(\\\*)+(?=.+)/g, (t, e, n) => {
    const r = n.replace(/\\\*/g, "[^\\/]*");
    return e + r
}
], [/\\\\\\(?=[$.|*+(){^])/g, () => vg], [/\\\\/g, () => vg], [/(\\)?\[([^\]/]*?)(\\*)($|\])/g, (t, e, n, r, i) => e === vg ? `\\[${n}${b6(r)}${i}` : i === "]" && r.length % 2 === 0 ? `[${_6(n)}${r}]` : "[]"], [/(?:[^*])$/, t => /\/$/.test(t) ? `${t}$` : `${t}(?=$|\\/$)`], [/(\^|\\\/)?\\\*$/, (t, e) => `${e ? `${e}[^/]+` : "[^/]*"}(?=$|\\/$)`]]
  , Px = Object.create(null)
  , v6 = (t, e) => {
    let n = Px[t];
    return n || (n = y6.reduce( (r, [i,s]) => r.replace(i, s.bind(t)), t),
    Px[t] = n),
    e ? new RegExp(n,"i") : new RegExp(n)
}
  , Py = t => typeof t == "string"
  , x6 = t => t && Py(t) && !c6.test(t) && !u6.test(t) && t.indexOf("#") !== 0
  , E6 = t => t.split(f6);
class S6 {
    constructor(e, n, r, i) {
        this.origin = e,
        this.pattern = n,
        this.negative = r,
        this.regex = i
    }
}
const w6 = (t, e) => {
    const n = t;
    let r = !1;
    t.indexOf("!") === 0 && (r = !0,
    t = t.substr(1)),
    t = t.replace(h6, "!").replace(d6, "#");
    const i = v6(t, e);
    return new S6(n,t,r,i)
}
  , C6 = (t, e) => {
    throw new e(t)
}
  , es = (t, e, n) => Py(t) ? t ? es.isNotRelative(t) ? n(`path should be a \`path.relative()\`d string, but got "${e}"`, RangeError) : !0 : n("path must not be empty", TypeError) : n(`path must be a string, but got \`${e}\``, TypeError)
  , mk = t => p6.test(t);
es.isNotRelative = mk;
es.convert = t => t;
class T6 {
    constructor({ignorecase: e=!0, ignoreCase: n=e, allowRelativePaths: r=!1}={}) {
        m6(this, Ix, !0),
        this._rules = [],
        this._ignoreCase = n,
        this._allowRelativePaths = r,
        this._initCache()
    }
    _initCache() {
        this._ignoreCache = Object.create(null),
        this._testCache = Object.create(null)
    }
    _addPattern(e) {
        if (e && e[Ix]) {
            this._rules = this._rules.concat(e._rules),
            this._added = !0;
            return
        }
        if (x6(e)) {
            const n = w6(e, this._ignoreCase);
            this._added = !0,
            this._rules.push(n)
        }
    }
    add(e) {
        return this._added = !1,
        kx(Py(e) ? E6(e) : e).forEach(this._addPattern, this),
        this._added && this._initCache(),
        this
    }
    addPattern(e) {
        return this.add(e)
    }
    _testOne(e, n) {
        let r = !1
          , i = !1;
        return this._rules.forEach(s => {
            const {negative: o} = s;
            if (i === o && r !== i || o && !r && !i && !n)
                return;
            s.regex.test(e) && (r = !o,
            i = o)
        }
        ),
        {
            ignored: r,
            unignored: i
        }
    }
    _test(e, n, r, i) {
        const s = e && es.convert(e);
        return es(s, e, this._allowRelativePaths ? pk : C6),
        this._t(s, n, r, i)
    }
    _t(e, n, r, i) {
        if (e in n)
            return n[e];
        if (i || (i = e.split(xg)),
        i.pop(),
        !i.length)
            return n[e] = this._testOne(e, r);
        const s = this._t(i.join(xg) + xg, n, r, i);
        return n[e] = s.ignored ? s : this._testOne(e, r)
    }
    ignores(e) {
        return this._test(e, this._ignoreCache, !1).ignored
    }
    createFilter() {
        return e => !this.ignores(e)
    }
    filter(e) {
        return kx(e).filter(this.createFilter())
    }
    test(e) {
        return this._test(e, this._testCache, !0)
    }
}
const Of = t => new T6(t)
  , A6 = t => es(t && es.convert(t), t, pk);
Of.isPathValid = A6;
Of.default = Of;
var k6 = Of;
if (typeof lu < "u" && (Ax && Ax.IGNORE_TEST_WIN32 || lu.platform === "win32")) {
    const t = n => /^\\\\\?\\/.test(n) || /["<>|\u0000-\u001F]+/u.test(n) ? n : n.replace(/\\/g, "/");
    es.convert = t;
    const e = /^[a-z]:\//i;
    es.isNotRelative = n => e.test(n) || mk(n)
}
const R6 = Eh(k6)
  , gk = "project"
  , jt = `/home/${gk}`
  , Dx = "bolt_file_selections"
  , Lx = "bolt_file_modifications"
  , Ox = "running_commands"
  , h_ = 5
  , Dy = 5
  , I6 = Dy * 1024 * 1024
  , _k = new Set([".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg", ".pdf", ".txt", ".doc", ".docx", ".py", ".ipynb", ".js", ".mjs", ".cjs", ".jsx", ".html", ".css", ".scss", ".sass", ".ts", ".tsx", ".java", ".cs", ".php", ".c", ".cc", ".cpp", ".cxx", ".h", ".hh", ".hpp", ".rs", ".swift", ".go", ".rb", ".kt", ".kts", ".scala", ".sh", ".bash", ".zsh", ".bat", ".csv", ".log", ".ini", ".cfg", ".config", ".json", ".yaml", ".yml", ".toml", ".lua", ".sql", ".md", ".tex", ".latex", ".asm", ".ino", ".s"])
  , P6 = [..._k].join(",");
function hi(t) {
    return t.replace(/\/+$/g, "")
}
function Pt(t) {
    return t.length > 0 && !t.startsWith("/") && (t = `${jt}/${t}`),
    t
}
function Fn(t) {
    return t.startsWith(`${jt}/`) && (t = t.slice(jt.length + 1)),
    t
}
const D6 = ".bolt/ignore"
  , L6 = ".boltignore"
  , O6 = ".gitignore"
  , N6 = new Set(["package-lock.json", "yarn.lock", "pnpm-lock.yaml", "pnpm-workspace.yaml", "npm-shrinkwrap.json"])
  , M6 = /(\/|^)favicon\.(\w+?)$/
  , B6 = /(\/|^)\.(git|bolt)(\/?)ignore$/
  , F6 = /(\/|^)\.bolt(\/|$)/;
function j6({path: t, contents: e, isBinary: n}) {
    const r = N6.has(hi(t).split("/").pop())
      , i = t.endsWith(".svg")
      , s = M6.test(t)
      , o = B6.test(t)
      , a = F6.test(t)
      , l = (e.length ?? 0) > 5e4;
    return n || r || l || i || s || o || a
}
const H6 = new RegExp(`^${jt}/`);
function Ly(t) {
    return bk(e => {
        const n = Pt(e);
        return t[n]?.type === "file" && t[n].content
    }
    )
}
function U6(t) {
    return bk(e => t[e]?.type === "file" && t[e].contents)
}
function V6(t="", e="") {
    const n = R6();
    for (const r of [e, t])
        r.split(`
`).reverse().forEach(i => {
            i.trim() && n.add(i)
        }
        );
    return r => j6(r) || n.test(r.path.replace(H6, "")).ignored
}
function bk(t) {
    const e = t(L6)
      , n = t(D6)
      , r = e || n || ""
      , i = t(O6) || "";
    return V6(r, i)
}
function yk(t, e) {
    return e > (t === "personal" ? 2e5 : 1e6)
}
const $6 = new TextEncoder;
function z6(t) {
    return $6.encode(t).length
}
function W6(t) {
    const e = Ly(t);
    let n = 0;
    return Object.entries(t).forEach( ([r,i]) => {
        i?.type === "file" && !e({
            path: r,
            contents: i.content,
            isBinary: i.isBinary
        }) && (n += z6(i.content))
    }
    ),
    n
}
function Nx(t, e=200) {
    const {port1: n, port2: r} = new MessageChannel;
    let i;
    const s = new Promise(l => {
        i = l
    }
    )
      , o = () => {
        i(),
        r.close()
    }
      , a = setTimeout( () => {
        const l = t.src;
        t.src = l,
        o()
    }
    , e);
    return r.addEventListener("message", l => {
        const c = l.data;
        c == null || typeof c != "object" || c.type === "LOCALSERVICE_WINDOW_RELOADED" && (clearTimeout(a),
        o())
    }
    ),
    t.contentWindow?.postMessage({
        type: "LOCALSERVICE_RELOAD_WINDOW",
        callback: n
    }, "*", [n]),
    s
}
function Ee(t, e, {checkForDefaultPrevented: n=!0}={}) {
    return function(i) {
        if (t?.(i),
        n === !1 || !i.defaultPrevented)
            return e?.(i)
    }
}
function G6(t, e) {
    typeof t == "function" ? t(e) : t != null && (t.current = e)
}
function Sh(...t) {
    return e => t.forEach(n => G6(n, e))
}
function rt(...t) {
    return S.useCallback(Sh(...t), t)
}
function q6(t, e) {
    const n = S.createContext(e);
    function r(s) {
        const {children: o, ...a} = s
          , l = S.useMemo( () => a, Object.values(a));
        return v.jsx(n.Provider, {
            value: l,
            children: o
        })
    }
    function i(s) {
        const o = S.useContext(n);
        if (o)
            return o;
        if (e !== void 0)
            return e;
        throw new Error(`\`${s}\` must be used within \`${t}\``)
    }
    return r.displayName = t + "Provider",
    [r, i]
}
function cs(t, e=[]) {
    let n = [];
    function r(s, o) {
        const a = S.createContext(o)
          , l = n.length;
        n = [...n, o];
        function c(h) {
            const {scope: d, children: f, ...g} = h
              , _ = d?.[t][l] || a
              , m = S.useMemo( () => g, Object.values(g));
            return v.jsx(_.Provider, {
                value: m,
                children: f
            })
        }
        function u(h, d) {
            const f = d?.[t][l] || a
              , g = S.useContext(f);
            if (g)
                return g;
            if (o !== void 0)
                return o;
            throw new Error(`\`${h}\` must be used within \`${s}\``)
        }
        return c.displayName = s + "Provider",
        [c, u]
    }
    const i = () => {
        const s = n.map(o => S.createContext(o));
        return function(a) {
            const l = a?.[t] || s;
            return S.useMemo( () => ({
                [`__scope${t}`]: {
                    ...a,
                    [t]: l
                }
            }), [a, l])
        }
    }
    ;
    return i.scopeName = t,
    [r, K6(i, ...e)]
}
function K6(...t) {
    const e = t[0];
    if (t.length === 1)
        return e;
    const n = () => {
        const r = t.map(i => ({
            useScope: i(),
            scopeName: i.scopeName
        }));
        return function(s) {
            const o = r.reduce( (a, {useScope: l, scopeName: c}) => {
                const h = l(s)[`__scope${c}`];
                return {
                    ...a,
                    ...h
                }
            }
            , {});
            return S.useMemo( () => ({
                [`__scope${e.scopeName}`]: o
            }), [o])
        }
    }
    ;
    return n.scopeName = e.scopeName,
    n
}
var Fs = S.forwardRef( (t, e) => {
    const {children: n, ...r} = t
      , i = S.Children.toArray(n)
      , s = i.find(Y6);
    if (s) {
        const o = s.props.children
          , a = i.map(l => l === s ? S.Children.count(o) > 1 ? S.Children.only(null) : S.isValidElement(o) ? o.props.children : null : l);
        return v.jsx(d_, {
            ...r,
            ref: e,
            children: S.isValidElement(o) ? S.cloneElement(o, void 0, a) : null
        })
    }
    return v.jsx(d_, {
        ...r,
        ref: e,
        children: n
    })
}
);
Fs.displayName = "Slot";
var d_ = S.forwardRef( (t, e) => {
    const {children: n, ...r} = t;
    if (S.isValidElement(n)) {
        const i = Q6(n);
        return S.cloneElement(n, {
            ...X6(r, n.props),
            ref: e ? Sh(e, i) : i
        })
    }
    return S.Children.count(n) > 1 ? S.Children.only(null) : null
}
);
d_.displayName = "SlotClone";
var vk = ({children: t}) => v.jsx(v.Fragment, {
    children: t
});
function Y6(t) {
    return S.isValidElement(t) && t.type === vk
}
function X6(t, e) {
    const n = {
        ...e
    };
    for (const r in e) {
        const i = t[r]
          , s = e[r];
        /^on[A-Z]/.test(r) ? i && s ? n[r] = (...a) => {
            s(...a),
            i(...a)
        }
        : i && (n[r] = i) : r === "style" ? n[r] = {
            ...i,
            ...s
        } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "))
    }
    return {
        ...t,
        ...n
    }
}
function Q6(t) {
    let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get
      , n = e && "isReactWarning"in e && e.isReactWarning;
    return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get,
    n = e && "isReactWarning"in e && e.isReactWarning,
    n ? t.props.ref : t.props.ref || t.ref)
}
var J6 = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"]
  , We = J6.reduce( (t, e) => {
    const n = S.forwardRef( (r, i) => {
        const {asChild: s, ...o} = r
          , a = s ? Fs : e;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        v.jsx(a, {
            ...o,
            ref: i
        })
    }
    );
    return n.displayName = `Primitive.${e}`,
    {
        ...t,
        [e]: n
    }
}
, {});
function am(t, e) {
    t && fa.flushSync( () => t.dispatchEvent(e))
}
function vn(t) {
    const e = S.useRef(t);
    return S.useEffect( () => {
        e.current = t
    }
    ),
    S.useMemo( () => (...n) => e.current?.(...n), [])
}
function xk(t, e=globalThis?.document) {
    const n = vn(t);
    S.useEffect( () => {
        const r = i => {
            i.key === "Escape" && n(i)
        }
        ;
        return e.addEventListener("keydown", r, {
            capture: !0
        }),
        () => e.removeEventListener("keydown", r, {
            capture: !0
        })
    }
    , [n, e])
}
var Z6 = "DismissableLayer", f_ = "dismissableLayer.update", e4 = "dismissableLayer.pointerDownOutside", t4 = "dismissableLayer.focusOutside", Mx, Ek = S.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), wh = S.forwardRef( (t, e) => {
    const {disableOutsidePointerEvents: n=!1, onEscapeKeyDown: r, onPointerDownOutside: i, onFocusOutside: s, onInteractOutside: o, onDismiss: a, ...l} = t
      , c = S.useContext(Ek)
      , [u,h] = S.useState(null)
      , d = u?.ownerDocument ?? globalThis?.document
      , [,f] = S.useState({})
      , g = rt(e, A => h(A))
      , _ = Array.from(c.layers)
      , [m] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1)
      , p = _.indexOf(m)
      , b = u ? _.indexOf(u) : -1
      , y = c.layersWithOutsidePointerEventsDisabled.size > 0
      , x = b >= p
      , E = i4(A => {
        const C = A.target
          , k = [...c.branches].some(I => I.contains(C));
        !x || k || (i?.(A),
        o?.(A),
        A.defaultPrevented || a?.())
    }
    , d)
      , w = s4(A => {
        const C = A.target;
        [...c.branches].some(I => I.contains(C)) || (s?.(A),
        o?.(A),
        A.defaultPrevented || a?.())
    }
    , d);
    return xk(A => {
        b === c.layers.size - 1 && (r?.(A),
        !A.defaultPrevented && a && (A.preventDefault(),
        a()))
    }
    , d),
    S.useEffect( () => {
        if (u)
            return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (Mx = d.body.style.pointerEvents,
            d.body.style.pointerEvents = "none"),
            c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            Bx(),
            () => {
                n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = Mx)
            }
    }
    , [u, d, n, c]),
    S.useEffect( () => () => {
        u && (c.layers.delete(u),
        c.layersWithOutsidePointerEventsDisabled.delete(u),
        Bx())
    }
    , [u, c]),
    S.useEffect( () => {
        const A = () => f({});
        return document.addEventListener(f_, A),
        () => document.removeEventListener(f_, A)
    }
    , []),
    v.jsx(We.div, {
        ...l,
        ref: g,
        style: {
            pointerEvents: y ? x ? "auto" : "none" : void 0,
            ...t.style
        },
        onFocusCapture: Ee(t.onFocusCapture, w.onFocusCapture),
        onBlurCapture: Ee(t.onBlurCapture, w.onBlurCapture),
        onPointerDownCapture: Ee(t.onPointerDownCapture, E.onPointerDownCapture)
    })
}
);
wh.displayName = Z6;
var n4 = "DismissableLayerBranch"
  , r4 = S.forwardRef( (t, e) => {
    const n = S.useContext(Ek)
      , r = S.useRef(null)
      , i = rt(e, r);
    return S.useEffect( () => {
        const s = r.current;
        if (s)
            return n.branches.add(s),
            () => {
                n.branches.delete(s)
            }
    }
    , [n.branches]),
    v.jsx(We.div, {
        ...t,
        ref: i
    })
}
);
r4.displayName = n4;
function i4(t, e=globalThis?.document) {
    const n = vn(t)
      , r = S.useRef(!1)
      , i = S.useRef( () => {}
    );
    return S.useEffect( () => {
        const s = a => {
            if (a.target && !r.current) {
                let l = function() {
                    Sk(e4, n, c, {
                        discrete: !0
                    })
                };
                const c = {
                    originalEvent: a
                };
                a.pointerType === "touch" ? (e.removeEventListener("click", i.current),
                i.current = l,
                e.addEventListener("click", i.current, {
                    once: !0
                })) : l()
            } else
                e.removeEventListener("click", i.current);
            r.current = !1
        }
          , o = window.setTimeout( () => {
            e.addEventListener("pointerdown", s)
        }
        , 0);
        return () => {
            window.clearTimeout(o),
            e.removeEventListener("pointerdown", s),
            e.removeEventListener("click", i.current)
        }
    }
    , [e, n]),
    {
        onPointerDownCapture: () => r.current = !0
    }
}
function s4(t, e=globalThis?.document) {
    const n = vn(t)
      , r = S.useRef(!1);
    return S.useEffect( () => {
        const i = s => {
            s.target && !r.current && Sk(t4, n, {
                originalEvent: s
            }, {
                discrete: !1
            })
        }
        ;
        return e.addEventListener("focusin", i),
        () => e.removeEventListener("focusin", i)
    }
    , [e, n]),
    {
        onFocusCapture: () => r.current = !0,
        onBlurCapture: () => r.current = !1
    }
}
function Bx() {
    const t = new CustomEvent(f_);
    document.dispatchEvent(t)
}
function Sk(t, e, n, {discrete: r}) {
    const i = n.originalEvent.target
      , s = new CustomEvent(t,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    e && i.addEventListener(t, e, {
        once: !0
    }),
    r ? am(i, s) : i.dispatchEvent(s)
}
var hn = globalThis?.document ? S.useLayoutEffect : () => {}
  , o4 = Ay.useId || ( () => {}
)
  , a4 = 0;
function Ci(t) {
    const [e,n] = S.useState(o4());
    return hn( () => {
        n(r => r ?? String(a4++))
    }
    , [t]),
    e ? `radix-${e}` : ""
}
const l4 = ["top", "right", "bottom", "left"]
  , vi = Math.min
  , cr = Math.max
  , Nf = Math.round
  , ud = Math.floor
  , js = t => ({
    x: t,
    y: t
})
  , c4 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , u4 = {
    start: "end",
    end: "start"
};
function p_(t, e, n) {
    return cr(t, vi(e, n))
}
function ts(t, e) {
    return typeof t == "function" ? t(e) : t
}
function ns(t) {
    return t.split("-")[0]
}
function jl(t) {
    return t.split("-")[1]
}
function Oy(t) {
    return t === "x" ? "y" : "x"
}
function Ny(t) {
    return t === "y" ? "height" : "width"
}
function Hs(t) {
    return ["top", "bottom"].includes(ns(t)) ? "y" : "x"
}
function My(t) {
    return Oy(Hs(t))
}
function h4(t, e, n) {
    n === void 0 && (n = !1);
    const r = jl(t)
      , i = My(t)
      , s = Ny(i);
    let o = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return e.reference[s] > e.floating[s] && (o = Mf(o)),
    [o, Mf(o)]
}
function d4(t) {
    const e = Mf(t);
    return [m_(t), e, m_(e)]
}
function m_(t) {
    return t.replace(/start|end/g, e => u4[e])
}
function f4(t, e, n) {
    const r = ["left", "right"]
      , i = ["right", "left"]
      , s = ["top", "bottom"]
      , o = ["bottom", "top"];
    switch (t) {
    case "top":
    case "bottom":
        return n ? e ? i : r : e ? r : i;
    case "left":
    case "right":
        return e ? s : o;
    default:
        return []
    }
}
function p4(t, e, n, r) {
    const i = jl(t);
    let s = f4(ns(t), n === "start", r);
    return i && (s = s.map(o => o + "-" + i),
    e && (s = s.concat(s.map(m_)))),
    s
}
function Mf(t) {
    return t.replace(/left|right|bottom|top/g, e => c4[e])
}
function m4(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}
function wk(t) {
    return typeof t != "number" ? m4(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}
function Bf(t) {
    const {x: e, y: n, width: r, height: i} = t;
    return {
        width: r,
        height: i,
        top: n,
        left: e,
        right: e + r,
        bottom: n + i,
        x: e,
        y: n
    }
}
function Fx(t, e, n) {
    let {reference: r, floating: i} = t;
    const s = Hs(e)
      , o = My(e)
      , a = Ny(o)
      , l = ns(e)
      , c = s === "y"
      , u = r.x + r.width / 2 - i.width / 2
      , h = r.y + r.height / 2 - i.height / 2
      , d = r[a] / 2 - i[a] / 2;
    let f;
    switch (l) {
    case "top":
        f = {
            x: u,
            y: r.y - i.height
        };
        break;
    case "bottom":
        f = {
            x: u,
            y: r.y + r.height
        };
        break;
    case "right":
        f = {
            x: r.x + r.width,
            y: h
        };
        break;
    case "left":
        f = {
            x: r.x - i.width,
            y: h
        };
        break;
    default:
        f = {
            x: r.x,
            y: r.y
        }
    }
    switch (jl(e)) {
    case "start":
        f[o] -= d * (n && c ? -1 : 1);
        break;
    case "end":
        f[o] += d * (n && c ? -1 : 1);
        break
    }
    return f
}
const g4 = async (t, e, n) => {
    const {placement: r="bottom", strategy: i="absolute", middleware: s=[], platform: o} = n
      , a = s.filter(Boolean)
      , l = await (o.isRTL == null ? void 0 : o.isRTL(e));
    let c = await o.getElementRects({
        reference: t,
        floating: e,
        strategy: i
    })
      , {x: u, y: h} = Fx(c, r, l)
      , d = r
      , f = {}
      , g = 0;
    for (let _ = 0; _ < a.length; _++) {
        const {name: m, fn: p} = a[_]
          , {x: b, y, data: x, reset: E} = await p({
            x: u,
            y: h,
            initialPlacement: r,
            placement: d,
            strategy: i,
            middlewareData: f,
            rects: c,
            platform: o,
            elements: {
                reference: t,
                floating: e
            }
        });
        u = b ?? u,
        h = y ?? h,
        f = {
            ...f,
            [m]: {
                ...f[m],
                ...x
            }
        },
        E && g <= 50 && (g++,
        typeof E == "object" && (E.placement && (d = E.placement),
        E.rects && (c = E.rects === !0 ? await o.getElementRects({
            reference: t,
            floating: e,
            strategy: i
        }) : E.rects),
        {x: u, y: h} = Fx(c, d, l)),
        _ = -1)
    }
    return {
        x: u,
        y: h,
        placement: d,
        strategy: i,
        middlewareData: f
    }
}
;
async function cu(t, e) {
    var n;
    e === void 0 && (e = {});
    const {x: r, y: i, platform: s, rects: o, elements: a, strategy: l} = t
      , {boundary: c="clippingAncestors", rootBoundary: u="viewport", elementContext: h="floating", altBoundary: d=!1, padding: f=0} = ts(e, t)
      , g = wk(f)
      , m = a[d ? h === "floating" ? "reference" : "floating" : h]
      , p = Bf(await s.getClippingRect({
        element: (n = await (s.isElement == null ? void 0 : s.isElement(m))) == null || n ? m : m.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
        boundary: c,
        rootBoundary: u,
        strategy: l
    }))
      , b = h === "floating" ? {
        x: r,
        y: i,
        width: o.floating.width,
        height: o.floating.height
    } : o.reference
      , y = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating))
      , x = await (s.isElement == null ? void 0 : s.isElement(y)) ? await (s.getScale == null ? void 0 : s.getScale(y)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , E = Bf(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: b,
        offsetParent: y,
        strategy: l
    }) : b);
    return {
        top: (p.top - E.top + g.top) / x.y,
        bottom: (E.bottom - p.bottom + g.bottom) / x.y,
        left: (p.left - E.left + g.left) / x.x,
        right: (E.right - p.right + g.right) / x.x
    }
}
const _4 = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
        const {x: n, y: r, placement: i, rects: s, platform: o, elements: a, middlewareData: l} = e
          , {element: c, padding: u=0} = ts(t, e) || {};
        if (c == null)
            return {};
        const h = wk(u)
          , d = {
            x: n,
            y: r
        }
          , f = My(i)
          , g = Ny(f)
          , _ = await o.getDimensions(c)
          , m = f === "y"
          , p = m ? "top" : "left"
          , b = m ? "bottom" : "right"
          , y = m ? "clientHeight" : "clientWidth"
          , x = s.reference[g] + s.reference[f] - d[f] - s.floating[g]
          , E = d[f] - s.reference[f]
          , w = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
        let A = w ? w[y] : 0;
        (!A || !await (o.isElement == null ? void 0 : o.isElement(w))) && (A = a.floating[y] || s.floating[g]);
        const C = x / 2 - E / 2
          , k = A / 2 - _[g] / 2 - 1
          , I = vi(h[p], k)
          , N = vi(h[b], k)
          , O = I
          , M = A - _[g] - N
          , H = A / 2 - _[g] / 2 + C
          , $ = p_(O, H, M)
          , J = !l.arrow && jl(i) != null && H !== $ && s.reference[g] / 2 - (H < O ? I : N) - _[g] / 2 < 0
          , Q = J ? H < O ? H - O : H - M : 0;
        return {
            [f]: d[f] + Q,
            data: {
                [f]: $,
                centerOffset: H - $ - Q,
                ...J && {
                    alignmentOffset: Q
                }
            },
            reset: J
        }
    }
})
  , b4 = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "flip",
        options: t,
        async fn(e) {
            var n, r;
            const {placement: i, middlewareData: s, rects: o, initialPlacement: a, platform: l, elements: c} = e
              , {mainAxis: u=!0, crossAxis: h=!0, fallbackPlacements: d, fallbackStrategy: f="bestFit", fallbackAxisSideDirection: g="none", flipAlignment: _=!0, ...m} = ts(t, e);
            if ((n = s.arrow) != null && n.alignmentOffset)
                return {};
            const p = ns(i)
              , b = Hs(a)
              , y = ns(a) === a
              , x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating))
              , E = d || (y || !_ ? [Mf(a)] : d4(a))
              , w = g !== "none";
            !d && w && E.push(...p4(a, _, g, x));
            const A = [a, ...E]
              , C = await cu(e, m)
              , k = [];
            let I = ((r = s.flip) == null ? void 0 : r.overflows) || [];
            if (u && k.push(C[p]),
            h) {
                const H = h4(i, o, x);
                k.push(C[H[0]], C[H[1]])
            }
            if (I = [...I, {
                placement: i,
                overflows: k
            }],
            !k.every(H => H <= 0)) {
                var N, O;
                const H = (((N = s.flip) == null ? void 0 : N.index) || 0) + 1
                  , $ = A[H];
                if ($)
                    return {
                        data: {
                            index: H,
                            overflows: I
                        },
                        reset: {
                            placement: $
                        }
                    };
                let J = (O = I.filter(Q => Q.overflows[0] <= 0).sort( (Q, ee) => Q.overflows[1] - ee.overflows[1])[0]) == null ? void 0 : O.placement;
                if (!J)
                    switch (f) {
                    case "bestFit":
                        {
                            var M;
                            const Q = (M = I.filter(ee => {
                                if (w) {
                                    const D = Hs(ee.placement);
                                    return D === b || D === "y"
                                }
                                return !0
                            }
                            ).map(ee => [ee.placement, ee.overflows.filter(D => D > 0).reduce( (D, L) => D + L, 0)]).sort( (ee, D) => ee[1] - D[1])[0]) == null ? void 0 : M[0];
                            Q && (J = Q);
                            break
                        }
                    case "initialPlacement":
                        J = a;
                        break
                    }
                if (i !== J)
                    return {
                        reset: {
                            placement: J
                        }
                    }
            }
            return {}
        }
    }
};
function jx(t, e) {
    return {
        top: t.top - e.height,
        right: t.right - e.width,
        bottom: t.bottom - e.height,
        left: t.left - e.width
    }
}
function Hx(t) {
    return l4.some(e => t[e] >= 0)
}
const y4 = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "hide",
        options: t,
        async fn(e) {
            const {rects: n} = e
              , {strategy: r="referenceHidden", ...i} = ts(t, e);
            switch (r) {
            case "referenceHidden":
                {
                    const s = await cu(e, {
                        ...i,
                        elementContext: "reference"
                    })
                      , o = jx(s, n.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: o,
                            referenceHidden: Hx(o)
                        }
                    }
                }
            case "escaped":
                {
                    const s = await cu(e, {
                        ...i,
                        altBoundary: !0
                    })
                      , o = jx(s, n.floating);
                    return {
                        data: {
                            escapedOffsets: o,
                            escaped: Hx(o)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
};
async function v4(t, e) {
    const {placement: n, platform: r, elements: i} = t
      , s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating))
      , o = ns(n)
      , a = jl(n)
      , l = Hs(n) === "y"
      , c = ["left", "top"].includes(o) ? -1 : 1
      , u = s && l ? -1 : 1
      , h = ts(e, t);
    let {mainAxis: d, crossAxis: f, alignmentAxis: g} = typeof h == "number" ? {
        mainAxis: h,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...h
    };
    return a && typeof g == "number" && (f = a === "end" ? g * -1 : g),
    l ? {
        x: f * u,
        y: d * c
    } : {
        x: d * c,
        y: f * u
    }
}
const x4 = function(t) {
    return t === void 0 && (t = 0),
    {
        name: "offset",
        options: t,
        async fn(e) {
            var n, r;
            const {x: i, y: s, placement: o, middlewareData: a} = e
              , l = await v4(e, t);
            return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
                x: i + l.x,
                y: s + l.y,
                data: {
                    ...l,
                    placement: o
                }
            }
        }
    }
}
  , E4 = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "shift",
        options: t,
        async fn(e) {
            const {x: n, y: r, placement: i} = e
              , {mainAxis: s=!0, crossAxis: o=!1, limiter: a={
                fn: m => {
                    let {x: p, y: b} = m;
                    return {
                        x: p,
                        y: b
                    }
                }
            }, ...l} = ts(t, e)
              , c = {
                x: n,
                y: r
            }
              , u = await cu(e, l)
              , h = Hs(ns(i))
              , d = Oy(h);
            let f = c[d]
              , g = c[h];
            if (s) {
                const m = d === "y" ? "top" : "left"
                  , p = d === "y" ? "bottom" : "right"
                  , b = f + u[m]
                  , y = f - u[p];
                f = p_(b, f, y)
            }
            if (o) {
                const m = h === "y" ? "top" : "left"
                  , p = h === "y" ? "bottom" : "right"
                  , b = g + u[m]
                  , y = g - u[p];
                g = p_(b, g, y)
            }
            const _ = a.fn({
                ...e,
                [d]: f,
                [h]: g
            });
            return {
                ..._,
                data: {
                    x: _.x - n,
                    y: _.y - r
                }
            }
        }
    }
}
  , S4 = function(t) {
    return t === void 0 && (t = {}),
    {
        options: t,
        fn(e) {
            const {x: n, y: r, placement: i, rects: s, middlewareData: o} = e
              , {offset: a=0, mainAxis: l=!0, crossAxis: c=!0} = ts(t, e)
              , u = {
                x: n,
                y: r
            }
              , h = Hs(i)
              , d = Oy(h);
            let f = u[d]
              , g = u[h];
            const _ = ts(a, e)
              , m = typeof _ == "number" ? {
                mainAxis: _,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ..._
            };
            if (l) {
                const y = d === "y" ? "height" : "width"
                  , x = s.reference[d] - s.floating[y] + m.mainAxis
                  , E = s.reference[d] + s.reference[y] - m.mainAxis;
                f < x ? f = x : f > E && (f = E)
            }
            if (c) {
                var p, b;
                const y = d === "y" ? "width" : "height"
                  , x = ["top", "left"].includes(ns(i))
                  , E = s.reference[h] - s.floating[y] + (x && ((p = o.offset) == null ? void 0 : p[h]) || 0) + (x ? 0 : m.crossAxis)
                  , w = s.reference[h] + s.reference[y] + (x ? 0 : ((b = o.offset) == null ? void 0 : b[h]) || 0) - (x ? m.crossAxis : 0);
                g < E ? g = E : g > w && (g = w)
            }
            return {
                [d]: f,
                [h]: g
            }
        }
    }
}
  , w4 = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "size",
        options: t,
        async fn(e) {
            const {placement: n, rects: r, platform: i, elements: s} = e
              , {apply: o= () => {}
            , ...a} = ts(t, e)
              , l = await cu(e, a)
              , c = ns(n)
              , u = jl(n)
              , h = Hs(n) === "y"
              , {width: d, height: f} = r.floating;
            let g, _;
            c === "top" || c === "bottom" ? (g = c,
            _ = u === (await (i.isRTL == null ? void 0 : i.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (_ = c,
            g = u === "end" ? "top" : "bottom");
            const m = f - l.top - l.bottom
              , p = d - l.left - l.right
              , b = vi(f - l[g], m)
              , y = vi(d - l[_], p)
              , x = !e.middlewareData.shift;
            let E = b
              , w = y;
            if (h ? w = u || x ? vi(y, p) : p : E = u || x ? vi(b, m) : m,
            x && !u) {
                const C = cr(l.left, 0)
                  , k = cr(l.right, 0)
                  , I = cr(l.top, 0)
                  , N = cr(l.bottom, 0);
                h ? w = d - 2 * (C !== 0 || k !== 0 ? C + k : cr(l.left, l.right)) : E = f - 2 * (I !== 0 || N !== 0 ? I + N : cr(l.top, l.bottom))
            }
            await o({
                ...e,
                availableWidth: w,
                availableHeight: E
            });
            const A = await i.getDimensions(s.floating);
            return d !== A.width || f !== A.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function Hl(t) {
    return Ck(t) ? (t.nodeName || "").toLowerCase() : "#document"
}
function pr(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function us(t) {
    var e;
    return (e = (Ck(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}
function Ck(t) {
    return t instanceof Node || t instanceof pr(t).Node
}
function Zr(t) {
    return t instanceof Element || t instanceof pr(t).Element
}
function Ii(t) {
    return t instanceof HTMLElement || t instanceof pr(t).HTMLElement
}
function Ux(t) {
    return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof pr(t).ShadowRoot
}
function Ch(t) {
    const {overflow: e, overflowX: n, overflowY: r, display: i} = ei(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i)
}
function C4(t) {
    return ["table", "td", "th"].includes(Hl(t))
}
function lm(t) {
    return [":popover-open", ":modal"].some(e => {
        try {
            return t.matches(e)
        } catch {
            return !1
        }
    }
    )
}
function By(t) {
    const e = Fy()
      , n = Zr(t) ? ei(t) : t;
    return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r))
}
function T4(t) {
    let e = Us(t);
    for (; Ii(e) && !vl(e); ) {
        if (By(e))
            return e;
        if (lm(e))
            return null;
        e = Us(e)
    }
    return null
}
function Fy() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function vl(t) {
    return ["html", "body", "#document"].includes(Hl(t))
}
function ei(t) {
    return pr(t).getComputedStyle(t)
}
function cm(t) {
    return Zr(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.scrollX,
        scrollTop: t.scrollY
    }
}
function Us(t) {
    if (Hl(t) === "html")
        return t;
    const e = t.assignedSlot || t.parentNode || Ux(t) && t.host || us(t);
    return Ux(e) ? e.host : e
}
function Tk(t) {
    const e = Us(t);
    return vl(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Ii(e) && Ch(e) ? e : Tk(e)
}
function uu(t, e, n) {
    var r;
    e === void 0 && (e = []),
    n === void 0 && (n = !0);
    const i = Tk(t)
      , s = i === ((r = t.ownerDocument) == null ? void 0 : r.body)
      , o = pr(i);
    if (s) {
        const a = g_(o);
        return e.concat(o, o.visualViewport || [], Ch(i) ? i : [], a && n ? uu(a) : [])
    }
    return e.concat(i, uu(i, [], n))
}
function g_(t) {
    return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
}
function Ak(t) {
    const e = ei(t);
    let n = parseFloat(e.width) || 0
      , r = parseFloat(e.height) || 0;
    const i = Ii(t)
      , s = i ? t.offsetWidth : n
      , o = i ? t.offsetHeight : r
      , a = Nf(n) !== s || Nf(r) !== o;
    return a && (n = s,
    r = o),
    {
        width: n,
        height: r,
        $: a
    }
}
function jy(t) {
    return Zr(t) ? t : t.contextElement
}
function ol(t) {
    const e = jy(t);
    if (!Ii(e))
        return js(1);
    const n = e.getBoundingClientRect()
      , {width: r, height: i, $: s} = Ak(e);
    let o = (s ? Nf(n.width) : n.width) / r
      , a = (s ? Nf(n.height) : n.height) / i;
    return (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: o,
        y: a
    }
}
const A4 = js(0);
function kk(t) {
    const e = pr(t);
    return !Fy() || !e.visualViewport ? A4 : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function k4(t, e, n) {
    return e === void 0 && (e = !1),
    !n || e && n !== pr(t) ? !1 : e
}
function Wo(t, e, n, r) {
    e === void 0 && (e = !1),
    n === void 0 && (n = !1);
    const i = t.getBoundingClientRect()
      , s = jy(t);
    let o = js(1);
    e && (r ? Zr(r) && (o = ol(r)) : o = ol(t));
    const a = k4(s, n, r) ? kk(s) : js(0);
    let l = (i.left + a.x) / o.x
      , c = (i.top + a.y) / o.y
      , u = i.width / o.x
      , h = i.height / o.y;
    if (s) {
        const d = pr(s)
          , f = r && Zr(r) ? pr(r) : r;
        let g = d
          , _ = g_(g);
        for (; _ && r && f !== g; ) {
            const m = ol(_)
              , p = _.getBoundingClientRect()
              , b = ei(_)
              , y = p.left + (_.clientLeft + parseFloat(b.paddingLeft)) * m.x
              , x = p.top + (_.clientTop + parseFloat(b.paddingTop)) * m.y;
            l *= m.x,
            c *= m.y,
            u *= m.x,
            h *= m.y,
            l += y,
            c += x,
            g = pr(_),
            _ = g_(g)
        }
    }
    return Bf({
        width: u,
        height: h,
        x: l,
        y: c
    })
}
function R4(t) {
    let {elements: e, rect: n, offsetParent: r, strategy: i} = t;
    const s = i === "fixed"
      , o = us(r)
      , a = e ? lm(e.floating) : !1;
    if (r === o || a && s)
        return n;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , c = js(1);
    const u = js(0)
      , h = Ii(r);
    if ((h || !h && !s) && ((Hl(r) !== "body" || Ch(o)) && (l = cm(r)),
    Ii(r))) {
        const d = Wo(r);
        c = ol(r),
        u.x = d.x + r.clientLeft,
        u.y = d.y + r.clientTop
    }
    return {
        width: n.width * c.x,
        height: n.height * c.y,
        x: n.x * c.x - l.scrollLeft * c.x + u.x,
        y: n.y * c.y - l.scrollTop * c.y + u.y
    }
}
function I4(t) {
    return Array.from(t.getClientRects())
}
function Rk(t) {
    return Wo(us(t)).left + cm(t).scrollLeft
}
function P4(t) {
    const e = us(t)
      , n = cm(t)
      , r = t.ownerDocument.body
      , i = cr(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth)
      , s = cr(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
    let o = -n.scrollLeft + Rk(t);
    const a = -n.scrollTop;
    return ei(r).direction === "rtl" && (o += cr(e.clientWidth, r.clientWidth) - i),
    {
        width: i,
        height: s,
        x: o,
        y: a
    }
}
function D4(t, e) {
    const n = pr(t)
      , r = us(t)
      , i = n.visualViewport;
    let s = r.clientWidth
      , o = r.clientHeight
      , a = 0
      , l = 0;
    if (i) {
        s = i.width,
        o = i.height;
        const c = Fy();
        (!c || c && e === "fixed") && (a = i.offsetLeft,
        l = i.offsetTop)
    }
    return {
        width: s,
        height: o,
        x: a,
        y: l
    }
}
function L4(t, e) {
    const n = Wo(t, !0, e === "fixed")
      , r = n.top + t.clientTop
      , i = n.left + t.clientLeft
      , s = Ii(t) ? ol(t) : js(1)
      , o = t.clientWidth * s.x
      , a = t.clientHeight * s.y
      , l = i * s.x
      , c = r * s.y;
    return {
        width: o,
        height: a,
        x: l,
        y: c
    }
}
function Vx(t, e, n) {
    let r;
    if (e === "viewport")
        r = D4(t, n);
    else if (e === "document")
        r = P4(us(t));
    else if (Zr(e))
        r = L4(e, n);
    else {
        const i = kk(t);
        r = {
            ...e,
            x: e.x - i.x,
            y: e.y - i.y
        }
    }
    return Bf(r)
}
function Ik(t, e) {
    const n = Us(t);
    return n === e || !Zr(n) || vl(n) ? !1 : ei(n).position === "fixed" || Ik(n, e)
}
function O4(t, e) {
    const n = e.get(t);
    if (n)
        return n;
    let r = uu(t, [], !1).filter(a => Zr(a) && Hl(a) !== "body")
      , i = null;
    const s = ei(t).position === "fixed";
    let o = s ? Us(t) : t;
    for (; Zr(o) && !vl(o); ) {
        const a = ei(o)
          , l = By(o);
        !l && a.position === "fixed" && (i = null),
        (s ? !l && !i : !l && a.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Ch(o) && !l && Ik(t, o)) ? r = r.filter(u => u !== o) : i = a,
        o = Us(o)
    }
    return e.set(t, r),
    r
}
function N4(t) {
    let {element: e, boundary: n, rootBoundary: r, strategy: i} = t;
    const o = [...n === "clippingAncestors" ? lm(e) ? [] : O4(e, this._c) : [].concat(n), r]
      , a = o[0]
      , l = o.reduce( (c, u) => {
        const h = Vx(e, u, i);
        return c.top = cr(h.top, c.top),
        c.right = vi(h.right, c.right),
        c.bottom = vi(h.bottom, c.bottom),
        c.left = cr(h.left, c.left),
        c
    }
    , Vx(e, a, i));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function M4(t) {
    const {width: e, height: n} = Ak(t);
    return {
        width: e,
        height: n
    }
}
function B4(t, e, n) {
    const r = Ii(e)
      , i = us(e)
      , s = n === "fixed"
      , o = Wo(t, !0, s, e);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = js(0);
    if (r || !r && !s)
        if ((Hl(e) !== "body" || Ch(i)) && (a = cm(e)),
        r) {
            const h = Wo(e, !0, s, e);
            l.x = h.x + e.clientLeft,
            l.y = h.y + e.clientTop
        } else
            i && (l.x = Rk(i));
    const c = o.left + a.scrollLeft - l.x
      , u = o.top + a.scrollTop - l.y;
    return {
        x: c,
        y: u,
        width: o.width,
        height: o.height
    }
}
function Eg(t) {
    return ei(t).position === "static"
}
function $x(t, e) {
    return !Ii(t) || ei(t).position === "fixed" ? null : e ? e(t) : t.offsetParent
}
function Pk(t, e) {
    const n = pr(t);
    if (lm(t))
        return n;
    if (!Ii(t)) {
        let i = Us(t);
        for (; i && !vl(i); ) {
            if (Zr(i) && !Eg(i))
                return i;
            i = Us(i)
        }
        return n
    }
    let r = $x(t, e);
    for (; r && C4(r) && Eg(r); )
        r = $x(r, e);
    return r && vl(r) && Eg(r) && !By(r) ? n : r || T4(t) || n
}
const F4 = async function(t) {
    const e = this.getOffsetParent || Pk
      , n = this.getDimensions
      , r = await n(t.floating);
    return {
        reference: B4(t.reference, await e(t.floating), t.strategy),
        floating: {
            x: 0,
            y: 0,
            width: r.width,
            height: r.height
        }
    }
};
function j4(t) {
    return ei(t).direction === "rtl"
}
const H4 = {
    convertOffsetParentRelativeRectToViewportRelativeRect: R4,
    getDocumentElement: us,
    getClippingRect: N4,
    getOffsetParent: Pk,
    getElementRects: F4,
    getClientRects: I4,
    getDimensions: M4,
    getScale: ol,
    isElement: Zr,
    isRTL: j4
};
function U4(t, e) {
    let n = null, r;
    const i = us(t);
    function s() {
        var a;
        clearTimeout(r),
        (a = n) == null || a.disconnect(),
        n = null
    }
    function o(a, l) {
        a === void 0 && (a = !1),
        l === void 0 && (l = 1),
        s();
        const {left: c, top: u, width: h, height: d} = t.getBoundingClientRect();
        if (a || e(),
        !h || !d)
            return;
        const f = ud(u)
          , g = ud(i.clientWidth - (c + h))
          , _ = ud(i.clientHeight - (u + d))
          , m = ud(c)
          , b = {
            rootMargin: -f + "px " + -g + "px " + -_ + "px " + -m + "px",
            threshold: cr(0, vi(1, l)) || 1
        };
        let y = !0;
        function x(E) {
            const w = E[0].intersectionRatio;
            if (w !== l) {
                if (!y)
                    return o();
                w ? o(!1, w) : r = setTimeout( () => {
                    o(!1, 1e-7)
                }
                , 1e3)
            }
            y = !1
        }
        try {
            n = new IntersectionObserver(x,{
                ...b,
                root: i.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(x,b)
        }
        n.observe(t)
    }
    return o(!0),
    s
}
function V4(t, e, n, r) {
    r === void 0 && (r = {});
    const {ancestorScroll: i=!0, ancestorResize: s=!0, elementResize: o=typeof ResizeObserver == "function", layoutShift: a=typeof IntersectionObserver == "function", animationFrame: l=!1} = r
      , c = jy(t)
      , u = i || s ? [...c ? uu(c) : [], ...uu(e)] : [];
    u.forEach(p => {
        i && p.addEventListener("scroll", n, {
            passive: !0
        }),
        s && p.addEventListener("resize", n)
    }
    );
    const h = c && a ? U4(c, n) : null;
    let d = -1
      , f = null;
    o && (f = new ResizeObserver(p => {
        let[b] = p;
        b && b.target === c && f && (f.unobserve(e),
        cancelAnimationFrame(d),
        d = requestAnimationFrame( () => {
            var y;
            (y = f) == null || y.observe(e)
        }
        )),
        n()
    }
    ),
    c && !l && f.observe(c),
    f.observe(e));
    let g, _ = l ? Wo(t) : null;
    l && m();
    function m() {
        const p = Wo(t);
        _ && (p.x !== _.x || p.y !== _.y || p.width !== _.width || p.height !== _.height) && n(),
        _ = p,
        g = requestAnimationFrame(m)
    }
    return n(),
    () => {
        var p;
        u.forEach(b => {
            i && b.removeEventListener("scroll", n),
            s && b.removeEventListener("resize", n)
        }
        ),
        h?.(),
        (p = f) == null || p.disconnect(),
        f = null,
        l && cancelAnimationFrame(g)
    }
}
const $4 = x4
  , z4 = E4
  , W4 = b4
  , G4 = w4
  , q4 = y4
  , zx = _4
  , K4 = S4
  , Y4 = (t, e, n) => {
    const r = new Map
      , i = {
        platform: H4,
        ...n
    }
      , s = {
        ...i.platform,
        _c: r
    };
    return g4(t, e, {
        ...i,
        platform: s
    })
}
;
var uf = typeof document < "u" ? S.useLayoutEffect : S.useEffect;
function Ff(t, e) {
    if (t === e)
        return !0;
    if (typeof t != typeof e)
        return !1;
    if (typeof t == "function" && t.toString() === e.toString())
        return !0;
    let n, r, i;
    if (t && e && typeof t == "object") {
        if (Array.isArray(t)) {
            if (n = t.length,
            n !== e.length)
                return !1;
            for (r = n; r-- !== 0; )
                if (!Ff(t[r], e[r]))
                    return !1;
            return !0
        }
        if (i = Object.keys(t),
        n = i.length,
        n !== Object.keys(e).length)
            return !1;
        for (r = n; r-- !== 0; )
            if (!{}.hasOwnProperty.call(e, i[r]))
                return !1;
        for (r = n; r-- !== 0; ) {
            const s = i[r];
            if (!(s === "_owner" && t.$$typeof) && !Ff(t[s], e[s]))
                return !1
        }
        return !0
    }
    return t !== t && e !== e
}
function Dk(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function Wx(t, e) {
    const n = Dk(t);
    return Math.round(e * n) / n
}
function Gx(t) {
    const e = S.useRef(t);
    return uf( () => {
        e.current = t
    }
    ),
    e
}
function X4(t) {
    t === void 0 && (t = {});
    const {placement: e="bottom", strategy: n="absolute", middleware: r=[], platform: i, elements: {reference: s, floating: o}={}, transform: a=!0, whileElementsMounted: l, open: c} = t
      , [u,h] = S.useState({
        x: 0,
        y: 0,
        strategy: n,
        placement: e,
        middlewareData: {},
        isPositioned: !1
    })
      , [d,f] = S.useState(r);
    Ff(d, r) || f(r);
    const [g,_] = S.useState(null)
      , [m,p] = S.useState(null)
      , b = S.useCallback(Q => {
        Q !== w.current && (w.current = Q,
        _(Q))
    }
    , [])
      , y = S.useCallback(Q => {
        Q !== A.current && (A.current = Q,
        p(Q))
    }
    , [])
      , x = s || g
      , E = o || m
      , w = S.useRef(null)
      , A = S.useRef(null)
      , C = S.useRef(u)
      , k = l != null
      , I = Gx(l)
      , N = Gx(i)
      , O = S.useCallback( () => {
        if (!w.current || !A.current)
            return;
        const Q = {
            placement: e,
            strategy: n,
            middleware: d
        };
        N.current && (Q.platform = N.current),
        Y4(w.current, A.current, Q).then(ee => {
            const D = {
                ...ee,
                isPositioned: !0
            };
            M.current && !Ff(C.current, D) && (C.current = D,
            fa.flushSync( () => {
                h(D)
            }
            ))
        }
        )
    }
    , [d, e, n, N]);
    uf( () => {
        c === !1 && C.current.isPositioned && (C.current.isPositioned = !1,
        h(Q => ({
            ...Q,
            isPositioned: !1
        })))
    }
    , [c]);
    const M = S.useRef(!1);
    uf( () => (M.current = !0,
    () => {
        M.current = !1
    }
    ), []),
    uf( () => {
        if (x && (w.current = x),
        E && (A.current = E),
        x && E) {
            if (I.current)
                return I.current(x, E, O);
            O()
        }
    }
    , [x, E, O, I, k]);
    const H = S.useMemo( () => ({
        reference: w,
        floating: A,
        setReference: b,
        setFloating: y
    }), [b, y])
      , $ = S.useMemo( () => ({
        reference: x,
        floating: E
    }), [x, E])
      , J = S.useMemo( () => {
        const Q = {
            position: n,
            left: 0,
            top: 0
        };
        if (!$.floating)
            return Q;
        const ee = Wx($.floating, u.x)
          , D = Wx($.floating, u.y);
        return a ? {
            ...Q,
            transform: "translate(" + ee + "px, " + D + "px)",
            ...Dk($.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: n,
            left: ee,
            top: D
        }
    }
    , [n, a, $.floating, u.x, u.y]);
    return S.useMemo( () => ({
        ...u,
        update: O,
        refs: H,
        elements: $,
        floatingStyles: J
    }), [u, O, H, $, J])
}
const Q4 = t => {
    function e(n) {
        return {}.hasOwnProperty.call(n, "current")
    }
    return {
        name: "arrow",
        options: t,
        fn(n) {
            const {element: r, padding: i} = typeof t == "function" ? t(n) : t;
            return r && e(r) ? r.current != null ? zx({
                element: r.current,
                padding: i
            }).fn(n) : {} : r ? zx({
                element: r,
                padding: i
            }).fn(n) : {}
        }
    }
}
  , J4 = (t, e) => ({
    ...$4(t),
    options: [t, e]
})
  , Z4 = (t, e) => ({
    ...z4(t),
    options: [t, e]
})
  , e5 = (t, e) => ({
    ...K4(t),
    options: [t, e]
})
  , t5 = (t, e) => ({
    ...W4(t),
    options: [t, e]
})
  , n5 = (t, e) => ({
    ...G4(t),
    options: [t, e]
})
  , r5 = (t, e) => ({
    ...q4(t),
    options: [t, e]
})
  , i5 = (t, e) => ({
    ...Q4(t),
    options: [t, e]
});
var s5 = "Arrow"
  , Lk = S.forwardRef( (t, e) => {
    const {children: n, width: r=10, height: i=5, ...s} = t;
    return v.jsx(We.svg, {
        ...s,
        ref: e,
        width: r,
        height: i,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: t.asChild ? n : v.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
Lk.displayName = s5;
var o5 = Lk;
function Ok(t) {
    const [e,n] = S.useState(void 0);
    return hn( () => {
        if (t) {
            n({
                width: t.offsetWidth,
                height: t.offsetHeight
            });
            const r = new ResizeObserver(i => {
                if (!Array.isArray(i) || !i.length)
                    return;
                const s = i[0];
                let o, a;
                if ("borderBoxSize"in s) {
                    const l = s.borderBoxSize
                      , c = Array.isArray(l) ? l[0] : l;
                    o = c.inlineSize,
                    a = c.blockSize
                } else
                    o = t.offsetWidth,
                    a = t.offsetHeight;
                n({
                    width: o,
                    height: a
                })
            }
            );
            return r.observe(t, {
                box: "border-box"
            }),
            () => r.unobserve(t)
        } else
            n(void 0)
    }
    , [t]),
    e
}
var Hy = "Popper"
  , [Nk,ro] = cs(Hy)
  , [a5,Mk] = Nk(Hy)
  , Bk = t => {
    const {__scopePopper: e, children: n} = t
      , [r,i] = S.useState(null);
    return v.jsx(a5, {
        scope: e,
        anchor: r,
        onAnchorChange: i,
        children: n
    })
}
;
Bk.displayName = Hy;
var Fk = "PopperAnchor"
  , jk = S.forwardRef( (t, e) => {
    const {__scopePopper: n, virtualRef: r, ...i} = t
      , s = Mk(Fk, n)
      , o = S.useRef(null)
      , a = rt(e, o);
    return S.useEffect( () => {
        s.onAnchorChange(r?.current || o.current)
    }
    ),
    r ? null : v.jsx(We.div, {
        ...i,
        ref: a
    })
}
);
jk.displayName = Fk;
var Uy = "PopperContent"
  , [l5,c5] = Nk(Uy)
  , Hk = S.forwardRef( (t, e) => {
    const {__scopePopper: n, side: r="bottom", sideOffset: i=0, align: s="center", alignOffset: o=0, arrowPadding: a=0, avoidCollisions: l=!0, collisionBoundary: c=[], collisionPadding: u=0, sticky: h="partial", hideWhenDetached: d=!1, updatePositionStrategy: f="optimized", onPlaced: g, ..._} = t
      , m = Mk(Uy, n)
      , [p,b] = S.useState(null)
      , y = rt(e, G => b(G))
      , [x,E] = S.useState(null)
      , w = Ok(x)
      , A = w?.width ?? 0
      , C = w?.height ?? 0
      , k = r + (s !== "center" ? "-" + s : "")
      , I = typeof u == "number" ? u : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...u
    }
      , N = Array.isArray(c) ? c : [c]
      , O = N.length > 0
      , M = {
        padding: I,
        boundary: N.filter(h5),
        altBoundary: O
    }
      , {refs: H, floatingStyles: $, placement: J, isPositioned: Q, middlewareData: ee} = X4({
        strategy: "fixed",
        placement: k,
        whileElementsMounted: (...G) => V4(...G, {
            animationFrame: f === "always"
        }),
        elements: {
            reference: m.anchor
        },
        middleware: [J4({
            mainAxis: i + C,
            alignmentAxis: o
        }), l && Z4({
            mainAxis: !0,
            crossAxis: !1,
            limiter: h === "partial" ? e5() : void 0,
            ...M
        }), l && t5({
            ...M
        }), n5({
            ...M,
            apply: ({elements: G, rects: j, availableWidth: oe, availableHeight: le}) => {
                const {width: de, height: ne} = j.reference
                  , pe = G.floating.style;
                pe.setProperty("--radix-popper-available-width", `${oe}px`),
                pe.setProperty("--radix-popper-available-height", `${le}px`),
                pe.setProperty("--radix-popper-anchor-width", `${de}px`),
                pe.setProperty("--radix-popper-anchor-height", `${ne}px`)
            }
        }), x && i5({
            element: x,
            padding: a
        }), d5({
            arrowWidth: A,
            arrowHeight: C
        }), d && r5({
            strategy: "referenceHidden",
            ...M
        })]
    })
      , [D,L] = $k(J)
      , z = vn(g);
    hn( () => {
        Q && z?.()
    }
    , [Q, z]);
    const V = ee.arrow?.x
      , B = ee.arrow?.y
      , Z = ee.arrow?.centerOffset !== 0
      , [se,ae] = S.useState();
    return hn( () => {
        p && ae(window.getComputedStyle(p).zIndex)
    }
    , [p]),
    v.jsx("div", {
        ref: H.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...$,
            transform: Q ? $.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: se,
            "--radix-popper-transform-origin": [ee.transformOrigin?.x, ee.transformOrigin?.y].join(" "),
            ...ee.hide?.referenceHidden && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: t.dir,
        children: v.jsx(l5, {
            scope: n,
            placedSide: D,
            onArrowChange: E,
            arrowX: V,
            arrowY: B,
            shouldHideArrow: Z,
            children: v.jsx(We.div, {
                "data-side": D,
                "data-align": L,
                ..._,
                ref: y,
                style: {
                    ..._.style,
                    animation: Q ? void 0 : "none"
                }
            })
        })
    })
}
);
Hk.displayName = Uy;
var Uk = "PopperArrow"
  , u5 = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , Vk = S.forwardRef(function(e, n) {
    const {__scopePopper: r, ...i} = e
      , s = c5(Uk, r)
      , o = u5[s.placedSide];
    return v.jsx("span", {
        ref: s.onArrowChange,
        style: {
            position: "absolute",
            left: s.arrowX,
            top: s.arrowY,
            [o]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[s.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[s.placedSide],
            visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: v.jsx(o5, {
            ...i,
            ref: n,
            style: {
                ...i.style,
                display: "block"
            }
        })
    })
});
Vk.displayName = Uk;
function h5(t) {
    return t !== null
}
var d5 = t => ({
    name: "transformOrigin",
    options: t,
    fn(e) {
        const {placement: n, rects: r, middlewareData: i} = e
          , o = i.arrow?.centerOffset !== 0
          , a = o ? 0 : t.arrowWidth
          , l = o ? 0 : t.arrowHeight
          , [c,u] = $k(n)
          , h = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[u]
          , d = (i.arrow?.x ?? 0) + a / 2
          , f = (i.arrow?.y ?? 0) + l / 2;
        let g = ""
          , _ = "";
        return c === "bottom" ? (g = o ? h : `${d}px`,
        _ = `${-l}px`) : c === "top" ? (g = o ? h : `${d}px`,
        _ = `${r.floating.height + l}px`) : c === "right" ? (g = `${-l}px`,
        _ = o ? h : `${f}px`) : c === "left" && (g = `${r.floating.width + l}px`,
        _ = o ? h : `${f}px`),
        {
            data: {
                x: g,
                y: _
            }
        }
    }
});
function $k(t) {
    const [e,n="center"] = t.split("-");
    return [e, n]
}
var um = Bk
  , hm = jk
  , dm = Hk
  , fm = Vk
  , f5 = "Portal"
  , Th = S.forwardRef( (t, e) => {
    const {container: n, ...r} = t
      , [i,s] = S.useState(!1);
    hn( () => s(!0), []);
    const o = n || i && globalThis?.document?.body;
    return o ? ck.createPortal(v.jsx(We.div, {
        ...r,
        ref: e
    }), o) : null
}
);
Th.displayName = f5;
function p5(t, e) {
    return S.useReducer( (n, r) => e[n][r] ?? n, t)
}
var Li = t => {
    const {present: e, children: n} = t
      , r = m5(e)
      , i = typeof n == "function" ? n({
        present: r.isPresent
    }) : S.Children.only(n)
      , s = rt(r.ref, g5(i));
    return typeof n == "function" || r.isPresent ? S.cloneElement(i, {
        ref: s
    }) : null
}
;
Li.displayName = "Presence";
function m5(t) {
    const [e,n] = S.useState()
      , r = S.useRef({})
      , i = S.useRef(t)
      , s = S.useRef("none")
      , o = t ? "mounted" : "unmounted"
      , [a,l] = p5(o, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return S.useEffect( () => {
        const c = hd(r.current);
        s.current = a === "mounted" ? c : "none"
    }
    , [a]),
    hn( () => {
        const c = r.current
          , u = i.current;
        if (u !== t) {
            const d = s.current
              , f = hd(c);
            t ? l("MOUNT") : f === "none" || c?.display === "none" ? l("UNMOUNT") : l(u && d !== f ? "ANIMATION_OUT" : "UNMOUNT"),
            i.current = t
        }
    }
    , [t, l]),
    hn( () => {
        if (e) {
            const c = h => {
                const f = hd(r.current).includes(h.animationName);
                h.target === e && f && fa.flushSync( () => l("ANIMATION_END"))
            }
              , u = h => {
                h.target === e && (s.current = hd(r.current))
            }
            ;
            return e.addEventListener("animationstart", u),
            e.addEventListener("animationcancel", c),
            e.addEventListener("animationend", c),
            () => {
                e.removeEventListener("animationstart", u),
                e.removeEventListener("animationcancel", c),
                e.removeEventListener("animationend", c)
            }
        } else
            l("ANIMATION_END")
    }
    , [e, l]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: S.useCallback(c => {
            c && (r.current = getComputedStyle(c)),
            n(c)
        }
        , [])
    }
}
function hd(t) {
    return t?.animationName || "none"
}
function g5(t) {
    let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get
      , n = e && "isReactWarning"in e && e.isReactWarning;
    return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get,
    n = e && "isReactWarning"in e && e.isReactWarning,
    n ? t.props.ref : t.props.ref || t.ref)
}
function Go({prop: t, defaultProp: e, onChange: n= () => {}
}) {
    const [r,i] = _5({
        defaultProp: e,
        onChange: n
    })
      , s = t !== void 0
      , o = s ? t : r
      , a = vn(n)
      , l = S.useCallback(c => {
        if (s) {
            const h = typeof c == "function" ? c(t) : c;
            h !== t && a(h)
        } else
            i(c)
    }
    , [s, t, i, a]);
    return [o, l]
}
function _5({defaultProp: t, onChange: e}) {
    const n = S.useState(t)
      , [r] = n
      , i = S.useRef(r)
      , s = vn(e);
    return S.useEffect( () => {
        i.current !== r && (s(r),
        i.current = r)
    }
    , [r, i, s]),
    n
}
var b5 = "VisuallyHidden"
  , Ah = S.forwardRef( (t, e) => v.jsx(We.span, {
    ...t,
    ref: e,
    style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style
    }
}));
Ah.displayName = b5;
var y5 = Ah
  , [pm,Vye] = cs("Tooltip", [ro])
  , mm = ro()
  , zk = "TooltipProvider"
  , v5 = 700
  , __ = "tooltip.open"
  , [x5,Vy] = pm(zk)
  , Wk = t => {
    const {__scopeTooltip: e, delayDuration: n=v5, skipDelayDuration: r=300, disableHoverableContent: i=!1, children: s} = t
      , [o,a] = S.useState(!0)
      , l = S.useRef(!1)
      , c = S.useRef(0);
    return S.useEffect( () => {
        const u = c.current;
        return () => window.clearTimeout(u)
    }
    , []),
    v.jsx(x5, {
        scope: e,
        isOpenDelayed: o,
        delayDuration: n,
        onOpen: S.useCallback( () => {
            window.clearTimeout(c.current),
            a(!1)
        }
        , []),
        onClose: S.useCallback( () => {
            window.clearTimeout(c.current),
            c.current = window.setTimeout( () => a(!0), r)
        }
        , [r]),
        isPointerInTransitRef: l,
        onPointerInTransitChange: S.useCallback(u => {
            l.current = u
        }
        , []),
        disableHoverableContent: i,
        children: s
    })
}
;
Wk.displayName = zk;
var gm = "Tooltip"
  , [E5,kh] = pm(gm)
  , Gk = t => {
    const {__scopeTooltip: e, children: n, open: r, defaultOpen: i=!1, onOpenChange: s, disableHoverableContent: o, delayDuration: a} = t
      , l = Vy(gm, t.__scopeTooltip)
      , c = mm(e)
      , [u,h] = S.useState(null)
      , d = Ci()
      , f = S.useRef(0)
      , g = o ?? l.disableHoverableContent
      , _ = a ?? l.delayDuration
      , m = S.useRef(!1)
      , [p=!1,b] = Go({
        prop: r,
        defaultProp: i,
        onChange: A => {
            A ? (l.onOpen(),
            document.dispatchEvent(new CustomEvent(__))) : l.onClose(),
            s?.(A)
        }
    })
      , y = S.useMemo( () => p ? m.current ? "delayed-open" : "instant-open" : "closed", [p])
      , x = S.useCallback( () => {
        window.clearTimeout(f.current),
        m.current = !1,
        b(!0)
    }
    , [b])
      , E = S.useCallback( () => {
        window.clearTimeout(f.current),
        b(!1)
    }
    , [b])
      , w = S.useCallback( () => {
        window.clearTimeout(f.current),
        f.current = window.setTimeout( () => {
            m.current = !0,
            b(!0)
        }
        , _)
    }
    , [_, b]);
    return S.useEffect( () => () => window.clearTimeout(f.current), []),
    v.jsx(um, {
        ...c,
        children: v.jsx(E5, {
            scope: e,
            contentId: d,
            open: p,
            stateAttribute: y,
            trigger: u,
            onTriggerChange: h,
            onTriggerEnter: S.useCallback( () => {
                l.isOpenDelayed ? w() : x()
            }
            , [l.isOpenDelayed, w, x]),
            onTriggerLeave: S.useCallback( () => {
                g ? E() : window.clearTimeout(f.current)
            }
            , [E, g]),
            onOpen: x,
            onClose: E,
            disableHoverableContent: g,
            children: n
        })
    })
}
;
Gk.displayName = gm;
var b_ = "TooltipTrigger"
  , qk = S.forwardRef( (t, e) => {
    const {__scopeTooltip: n, ...r} = t
      , i = kh(b_, n)
      , s = Vy(b_, n)
      , o = mm(n)
      , a = S.useRef(null)
      , l = rt(e, a, i.onTriggerChange)
      , c = S.useRef(!1)
      , u = S.useRef(!1)
      , h = S.useCallback( () => c.current = !1, []);
    return S.useEffect( () => () => document.removeEventListener("pointerup", h), [h]),
    v.jsx(hm, {
        asChild: !0,
        ...o,
        children: v.jsx(We.button, {
            "aria-describedby": i.open ? i.contentId : void 0,
            "data-state": i.stateAttribute,
            ...r,
            ref: l,
            onPointerMove: Ee(t.onPointerMove, d => {
                d.pointerType !== "touch" && !u.current && !s.isPointerInTransitRef.current && (i.onTriggerEnter(),
                u.current = !0)
            }
            ),
            onPointerLeave: Ee(t.onPointerLeave, () => {
                i.onTriggerLeave(),
                u.current = !1
            }
            ),
            onPointerDown: Ee(t.onPointerDown, () => {
                c.current = !0,
                document.addEventListener("pointerup", h, {
                    once: !0
                })
            }
            ),
            onFocus: Ee(t.onFocus, () => {
                c.current || i.onOpen()
            }
            ),
            onBlur: Ee(t.onBlur, i.onClose),
            onClick: Ee(t.onClick, i.onClose)
        })
    })
}
);
qk.displayName = b_;
var $y = "TooltipPortal"
  , [S5,w5] = pm($y, {
    forceMount: void 0
})
  , Kk = t => {
    const {__scopeTooltip: e, forceMount: n, children: r, container: i} = t
      , s = kh($y, e);
    return v.jsx(S5, {
        scope: e,
        forceMount: n,
        children: v.jsx(Li, {
            present: n || s.open,
            children: v.jsx(Th, {
                asChild: !0,
                container: i,
                children: r
            })
        })
    })
}
;
Kk.displayName = $y;
var xl = "TooltipContent"
  , Yk = S.forwardRef( (t, e) => {
    const n = w5(xl, t.__scopeTooltip)
      , {forceMount: r=n.forceMount, side: i="top", ...s} = t
      , o = kh(xl, t.__scopeTooltip);
    return v.jsx(Li, {
        present: r || o.open,
        children: o.disableHoverableContent ? v.jsx(Xk, {
            side: i,
            ...s,
            ref: e
        }) : v.jsx(C5, {
            side: i,
            ...s,
            ref: e
        })
    })
}
)
  , C5 = S.forwardRef( (t, e) => {
    const n = kh(xl, t.__scopeTooltip)
      , r = Vy(xl, t.__scopeTooltip)
      , i = S.useRef(null)
      , s = rt(e, i)
      , [o,a] = S.useState(null)
      , {trigger: l, onClose: c} = n
      , u = i.current
      , {onPointerInTransitChange: h} = r
      , d = S.useCallback( () => {
        a(null),
        h(!1)
    }
    , [h])
      , f = S.useCallback( (g, _) => {
        const m = g.currentTarget
          , p = {
            x: g.clientX,
            y: g.clientY
        }
          , b = k5(p, m.getBoundingClientRect())
          , y = R5(p, b)
          , x = I5(_.getBoundingClientRect())
          , E = D5([...y, ...x]);
        a(E),
        h(!0)
    }
    , [h]);
    return S.useEffect( () => () => d(), [d]),
    S.useEffect( () => {
        if (l && u) {
            const g = m => f(m, u)
              , _ = m => f(m, l);
            return l.addEventListener("pointerleave", g),
            u.addEventListener("pointerleave", _),
            () => {
                l.removeEventListener("pointerleave", g),
                u.removeEventListener("pointerleave", _)
            }
        }
    }
    , [l, u, f, d]),
    S.useEffect( () => {
        if (o) {
            const g = _ => {
                const m = _.target
                  , p = {
                    x: _.clientX,
                    y: _.clientY
                }
                  , b = l?.contains(m) || u?.contains(m)
                  , y = !P5(p, o);
                b ? d() : y && (d(),
                c())
            }
            ;
            return document.addEventListener("pointermove", g),
            () => document.removeEventListener("pointermove", g)
        }
    }
    , [l, u, o, c, d]),
    v.jsx(Xk, {
        ...t,
        ref: s
    })
}
)
  , [T5,A5] = pm(gm, {
    isInside: !1
})
  , Xk = S.forwardRef( (t, e) => {
    const {__scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: s, onPointerDownOutside: o, ...a} = t
      , l = kh(xl, n)
      , c = mm(n)
      , {onClose: u} = l;
    return S.useEffect( () => (document.addEventListener(__, u),
    () => document.removeEventListener(__, u)), [u]),
    S.useEffect( () => {
        if (l.trigger) {
            const h = d => {
                d.target?.contains(l.trigger) && u()
            }
            ;
            return window.addEventListener("scroll", h, {
                capture: !0
            }),
            () => window.removeEventListener("scroll", h, {
                capture: !0
            })
        }
    }
    , [l.trigger, u]),
    v.jsx(wh, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        onFocusOutside: h => h.preventDefault(),
        onDismiss: u,
        children: v.jsxs(dm, {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: e,
            style: {
                ...a.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [v.jsx(vk, {
                children: r
            }), v.jsx(T5, {
                scope: n,
                isInside: !0,
                children: v.jsx(y5, {
                    id: l.contentId,
                    role: "tooltip",
                    children: i || r
                })
            })]
        })
    })
}
);
Yk.displayName = xl;
var Qk = "TooltipArrow"
  , Jk = S.forwardRef( (t, e) => {
    const {__scopeTooltip: n, ...r} = t
      , i = mm(n);
    return A5(Qk, n).isInside ? null : v.jsx(fm, {
        ...i,
        ...r,
        ref: e
    })
}
);
Jk.displayName = Qk;
function k5(t, e) {
    const n = Math.abs(e.top - t.y)
      , r = Math.abs(e.bottom - t.y)
      , i = Math.abs(e.right - t.x)
      , s = Math.abs(e.left - t.x);
    switch (Math.min(n, r, i, s)) {
    case s:
        return "left";
    case i:
        return "right";
    case n:
        return "top";
    case r:
        return "bottom";
    default:
        throw new Error("unreachable")
    }
}
function R5(t, e, n=5) {
    const r = [];
    switch (e) {
    case "top":
        r.push({
            x: t.x - n,
            y: t.y + n
        }, {
            x: t.x + n,
            y: t.y + n
        });
        break;
    case "bottom":
        r.push({
            x: t.x - n,
            y: t.y - n
        }, {
            x: t.x + n,
            y: t.y - n
        });
        break;
    case "left":
        r.push({
            x: t.x + n,
            y: t.y - n
        }, {
            x: t.x + n,
            y: t.y + n
        });
        break;
    case "right":
        r.push({
            x: t.x - n,
            y: t.y - n
        }, {
            x: t.x - n,
            y: t.y + n
        });
        break
    }
    return r
}
function I5(t) {
    const {top: e, right: n, bottom: r, left: i} = t;
    return [{
        x: i,
        y: e
    }, {
        x: n,
        y: e
    }, {
        x: n,
        y: r
    }, {
        x: i,
        y: r
    }]
}
function P5(t, e) {
    const {x: n, y: r} = t;
    let i = !1;
    for (let s = 0, o = e.length - 1; s < e.length; o = s++) {
        const a = e[s].x
          , l = e[s].y
          , c = e[o].x
          , u = e[o].y;
        l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (i = !i)
    }
    return i
}
function D5(t) {
    const e = t.slice();
    return e.sort( (n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0),
    L5(e)
}
function L5(t) {
    if (t.length <= 1)
        return t.slice();
    const e = [];
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        for (; e.length >= 2; ) {
            const s = e[e.length - 1]
              , o = e[e.length - 2];
            if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
                e.pop();
            else
                break
        }
        e.push(i)
    }
    e.pop();
    const n = [];
    for (let r = t.length - 1; r >= 0; r--) {
        const i = t[r];
        for (; n.length >= 2; ) {
            const s = n[n.length - 1]
              , o = n[n.length - 2];
            if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
                n.pop();
            else
                break
        }
        n.push(i)
    }
    return n.pop(),
    e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n)
}
var ga = Wk
  , Vs = Gk
  , qo = qk
  , Ko = Kk
  , O5 = Yk
  , Zk = Jk;
const N5 = {
    damping: .7,
    stiffness: .05,
    mass: 1.25
}
  , M5 = 70
  , B5 = 1e3 / 60
  , F5 = 350
  , j5 = (t={}) => {
    const [e,n] = S.useState(!1)
      , [r,i] = S.useState(t.initial !== !1)
      , [s,o] = S.useState(!1)
      , a = S.useRef(null);
    a.current = t;
    const l = S.useCallback(m => {
        u.isAtBottom = m,
        i(m)
    }
    , [])
      , c = S.useCallback(m => {
        u.escapedFromLock = m,
        n(m)
    }
    , [])
      , u = S.useMemo( () => {
        let m;
        return {
            escapedFromLock: e,
            isAtBottom: r,
            resizeDifference: 0,
            accumulated: 0,
            velocity: 0,
            listeners: new Set,
            get scrollTop() {
                return g.current?.scrollTop ?? 0
            },
            set scrollTop(p) {
                g.current && (g.current.scrollTop = p,
                u.ignoreScrollToTop = g.current.scrollTop)
            },
            get targetScrollTop() {
                return !g.current || !_.current ? 0 : g.current.scrollHeight - 1 - g.current.clientHeight
            },
            get calculatedTargetScrollTop() {
                if (!g.current || !_.current)
                    return 0;
                const {targetScrollTop: p} = this;
                if (!t.targetScrollTop)
                    return p;
                if (m?.targetScrollTop === p)
                    return m.calculatedScrollTop;
                const b = Math.max(Math.min(t.targetScrollTop(p, {
                    scrollElement: g.current,
                    contentElement: _.current
                }), p), 0);
                return m = {
                    targetScrollTop: p,
                    calculatedScrollTop: b
                },
                requestAnimationFrame( () => {
                    m = void 0
                }
                ),
                b
            },
            get scrollDifference() {
                return this.calculatedTargetScrollTop - this.scrollTop
            },
            get isNearBottom() {
                return this.scrollDifference <= M5
            }
        }
    }
    , [])
      , h = S.useCallback( (m={}) => {
        typeof m == "string" && (m = {
            animation: m
        }),
        m.preserveScrollPosition || l(!0);
        const p = Date.now() + (Number(m.wait) || 0)
          , b = wg(a.current, m.animation)
          , {ignoreEscapes: y=!1} = m;
        let x, E = u.calculatedTargetScrollTop;
        m.duration instanceof Promise ? m.duration.finally( () => {
            x = Date.now()
        }
        ) : x = p + (m.duration ?? 0);
        const w = async () => {
            const A = new Promise(requestAnimationFrame).then( () => {
                if (!u.isAtBottom)
                    return u.animation = void 0,
                    !1;
                const {scrollTop: C} = u
                  , k = performance.now()
                  , I = (k - (u.lastTick ?? k)) / B5;
                if (u.animation || (u.animation = {
                    behavior: b,
                    promise: A,
                    ignoreEscapes: y
                }),
                u.animation.behavior === b && (u.lastTick = k),
                p > Date.now())
                    return w();
                if (C < Math.min(E, u.calculatedTargetScrollTop)) {
                    if (u.animation?.behavior === b) {
                        if (b === "instant")
                            return u.scrollTop = u.calculatedTargetScrollTop,
                            w();
                        u.velocity = (b.damping * u.velocity + b.stiffness * u.scrollDifference) / b.mass,
                        u.accumulated += u.velocity * I,
                        u.scrollTop += u.accumulated,
                        u.scrollTop !== C && (u.accumulated = 0)
                    }
                    return w()
                }
                return x > Date.now() ? (E = u.calculatedTargetScrollTop,
                w()) : (u.animation = void 0,
                u.scrollTop < u.calculatedTargetScrollTop ? h({
                    animation: wg(a.current, a.current.resize),
                    ignoreEscapes: y,
                    duration: Math.max(0, x - Date.now()) || void 0
                }) : u.isAtBottom)
            }
            );
            return A.then(C => (requestAnimationFrame( () => {
                u.animation || (u.lastTick = void 0,
                u.velocity = 0)
            }
            ),
            C))
        }
        ;
        return m.wait !== !0 && (u.animation = void 0),
        u.animation?.behavior === b ? u.animation.promise : w()
    }
    , [])
      , d = S.useCallback( ({target: m}) => {
        if (m !== g.current)
            return;
        const {scrollTop: p, ignoreScrollToTop: b} = u;
        let {lastScrollTop: y=p} = u;
        u.lastScrollTop = p,
        u.ignoreScrollToTop = void 0,
        b && b > p && (y = b),
        o(u.isNearBottom),
        setTimeout( () => {
            if (u.resizeDifference || p === b)
                return;
            const x = p > y
              , E = p < y;
            if (u.animation?.ignoreEscapes) {
                u.scrollTop = y;
                return
            }
            E && (c(!0),
            l(!1)),
            x && c(!1),
            !u.escapedFromLock && u.isNearBottom && l(!0)
        }
        , 1)
    }
    , [])
      , f = S.useCallback( ({target: m, deltaY: p}) => {
        let b = m;
        for (; !["scroll", "auto"].includes(getComputedStyle(b).overflow); ) {
            if (!b.parentElement)
                return;
            b = b.parentElement
        }
        b === g.current && p < 0 && g.current.scrollHeight > g.current.clientHeight && !u.animation?.ignoreEscapes && (c(!0),
        l(!1))
    }
    , [])
      , g = qx(m => {
        g.current?.removeEventListener("scroll", d),
        g.current?.removeEventListener("wheel", f),
        m?.addEventListener("scroll", d, {
            passive: !0
        }),
        m?.addEventListener("wheel", f)
    }
    , [])
      , _ = qx(m => {
        if (u.resizeObserver?.disconnect(),
        !m)
            return;
        let p;
        u.resizeObserver = new ResizeObserver( ([b]) => {
            const {height: y} = b.contentRect
              , x = y - (p ?? y);
            if (u.resizeDifference = x,
            u.scrollTop > u.targetScrollTop && (u.scrollTop = u.targetScrollTop),
            o(u.isNearBottom),
            x >= 0) {
                const E = wg(a.current, p ? a.current.resize : a.current.initial);
                h({
                    animation: E,
                    wait: !0,
                    preserveScrollPosition: !0,
                    duration: E === "instant" ? void 0 : F5
                })
            } else
                u.isNearBottom && (c(!1),
                l(!0));
            p = y,
            requestAnimationFrame( () => {
                setTimeout( () => {
                    u.resizeDifference === x && (u.resizeDifference = 0)
                }
                , 1)
            }
            )
        }
        ),
        u.resizeObserver?.observe(m)
    }
    , []);
    return {
        contentRef: _,
        scrollRef: g,
        scrollToBottom: h,
        isAtBottom: r || s,
        isNearBottom: s,
        escapedFromLock: e
    }
}
;
function qx(t, e) {
    const n = S.useCallback(r => (n.current = r,
    t(r)), e);
    return n
}
const Sg = new Map;
function wg(...t) {
    const e = {
        ...N5
    };
    let n = !1;
    for (const i of t) {
        if (i === "instant") {
            n = !0;
            continue
        }
        typeof i == "object" && (n = !1,
        e.damping = i.damping ?? e.damping,
        e.stiffness = i.stiffness ?? e.stiffness,
        e.mass = i.mass ?? e.mass)
    }
    const r = JSON.stringify(e);
    return Sg.has(r) || Sg.set(r, Object.freeze(e)),
    n ? "instant" : Sg.get(r)
}
const zy = S.createContext({
    transformPagePoint: t => t,
    isStatic: !1,
    reducedMotion: "never"
})
  , _m = S.createContext({})
  , bm = S.createContext(null)
  , Wy = typeof document < "u"
  , Rh = Wy ? S.useLayoutEffect : S.useEffect
  , eR = S.createContext({
    strict: !1
})
  , Gy = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , H5 = "framerAppearId"
  , tR = "data-" + Gy(H5)
  , U5 = {
    skipAnimations: !1,
    useManualTiming: !1
};
class Kx {
    constructor() {
        this.order = [],
        this.scheduled = new Set
    }
    add(e) {
        if (!this.scheduled.has(e))
            return this.scheduled.add(e),
            this.order.push(e),
            !0
    }
    remove(e) {
        const n = this.order.indexOf(e);
        n !== -1 && (this.order.splice(n, 1),
        this.scheduled.delete(e))
    }
    clear() {
        this.order.length = 0,
        this.scheduled.clear()
    }
}
function V5(t) {
    let e = new Kx
      , n = new Kx
      , r = 0
      , i = !1
      , s = !1;
    const o = new WeakSet
      , a = {
        schedule: (l, c=!1, u=!1) => {
            const h = u && i
              , d = h ? e : n;
            return c && o.add(l),
            d.add(l) && h && i && (r = e.order.length),
            l
        }
        ,
        cancel: l => {
            n.remove(l),
            o.delete(l)
        }
        ,
        process: l => {
            if (i) {
                s = !0;
                return
            }
            if (i = !0,
            [e,n] = [n, e],
            n.clear(),
            r = e.order.length,
            r)
                for (let c = 0; c < r; c++) {
                    const u = e.order[c];
                    o.has(u) && (a.schedule(u),
                    t()),
                    u(l)
                }
            i = !1,
            s && (s = !1,
            a.process(l))
        }
    };
    return a
}
const dd = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , $5 = 40;
function nR(t, e) {
    let n = !1
      , r = !0;
    const i = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , s = dd.reduce( (h, d) => (h[d] = V5( () => n = !0),
    h), {})
      , o = h => {
        s[h].process(i)
    }
      , a = () => {
        const h = performance.now();
        n = !1,
        i.delta = r ? 1e3 / 60 : Math.max(Math.min(h - i.timestamp, $5), 1),
        i.timestamp = h,
        i.isProcessing = !0,
        dd.forEach(o),
        i.isProcessing = !1,
        n && e && (r = !1,
        t(a))
    }
      , l = () => {
        n = !0,
        r = !0,
        i.isProcessing || t(a)
    }
    ;
    return {
        schedule: dd.reduce( (h, d) => {
            const f = s[d];
            return h[d] = (g, _=!1, m=!1) => (n || l(),
            f.schedule(g, _, m)),
            h
        }
        , {}),
        cancel: h => dd.forEach(d => s[d].cancel(h)),
        state: i,
        steps: s
    }
}
const {schedule: qy, cancel: $ye} = nR(queueMicrotask, !1);
function qa(t) {
    return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
}
const rR = S.createContext({});
let Yx = !1;
function z5(t, e, n, r, i) {
    const {visualElement: s} = S.useContext(_m)
      , o = S.useContext(eR)
      , a = S.useContext(bm)
      , l = S.useContext(zy).reducedMotion
      , c = S.useRef();
    r = r || o.renderer,
    !c.current && r && (c.current = r(t, {
        visualState: e,
        parent: s,
        props: n,
        presenceContext: a,
        blockInitialAnimation: a ? a.initial === !1 : !1,
        reducedMotionConfig: l
    }));
    const u = c.current
      , h = S.useContext(rR);
    u && !u.projection && i && (u.type === "html" || u.type === "svg") && G5(c.current, n, i, h),
    S.useInsertionEffect( () => {
        u && u.update(n, a)
    }
    );
    const d = S.useRef(!!(n[tR] && !window.HandoffComplete));
    return Rh( () => {
        u && (u.updateFeatures(),
        qy.render(u.render),
        d.current && u.animationState && u.animationState.animateChanges())
    }
    ),
    S.useEffect( () => {
        u && (!d.current && u.animationState && u.animationState.animateChanges(),
        d.current && (d.current = !1,
        Yx || (Yx = !0,
        queueMicrotask(W5))))
    }
    ),
    u
}
function W5() {
    window.HandoffComplete = !0
}
function G5(t, e, n, r) {
    const {layoutId: i, layout: s, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: c} = e;
    t.projection = new n(t.latestValues,e["data-framer-portal-id"] ? void 0 : iR(t.parent)),
    t.projection.setOptions({
        layoutId: i,
        layout: s,
        alwaysMeasureLayout: !!o || a && qa(a),
        visualElement: t,
        scheduleRender: () => t.scheduleRender(),
        animationType: typeof s == "string" ? s : "both",
        initialPromotionConfig: r,
        layoutScroll: l,
        layoutRoot: c
    })
}
function iR(t) {
    if (t)
        return t.options.allowProjection !== !1 ? t.projection : iR(t.parent)
}
function q5(t, e, n) {
    return S.useCallback(r => {
        r && t.mount && t.mount(r),
        e && (r ? e.mount(r) : e.unmount()),
        n && (typeof n == "function" ? n(r) : qa(n) && (n.current = r))
    }
    , [e])
}
function hu(t) {
    return typeof t == "string" || Array.isArray(t)
}
function ym(t) {
    return t !== null && typeof t == "object" && typeof t.start == "function"
}
const Ky = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , Yy = ["initial", ...Ky];
function vm(t) {
    return ym(t.animate) || Yy.some(e => hu(t[e]))
}
function sR(t) {
    return !!(vm(t) || t.variants)
}
function K5(t, e) {
    if (vm(t)) {
        const {initial: n, animate: r} = t;
        return {
            initial: n === !1 || hu(n) ? n : void 0,
            animate: hu(r) ? r : void 0
        }
    }
    return t.inherit !== !1 ? e : {}
}
function Y5(t) {
    const {initial: e, animate: n} = K5(t, S.useContext(_m));
    return S.useMemo( () => ({
        initial: e,
        animate: n
    }), [Xx(e), Xx(n)])
}
function Xx(t) {
    return Array.isArray(t) ? t.join(" ") : t
}
const Qx = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , El = {};
for (const t in Qx)
    El[t] = {
        isEnabled: e => Qx[t].some(n => !!e[n])
    };
function X5(t) {
    for (const e in t)
        El[e] = {
            ...El[e],
            ...t[e]
        }
}
const Xy = S.createContext({})
  , Q5 = Symbol.for("motionComponentSymbol")
  , Pn = t => t;
let jf = Pn;
function J5({preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: i}) {
    t && X5(t);
    function s(a, l) {
        let c;
        const u = {
            ...S.useContext(zy),
            ...a,
            layoutId: Z5(a)
        }
          , {isStatic: h} = u
          , d = Y5(a)
          , f = r(a, h);
        if (!h && Wy) {
            e8();
            const g = t8(u);
            c = g.MeasureLayout,
            d.visualElement = z5(i, f, u, e, g.ProjectionNode)
        }
        return v.jsxs(_m.Provider, {
            value: d,
            children: [c && d.visualElement ? v.jsx(c, {
                visualElement: d.visualElement,
                ...u
            }) : null, n(i, a, q5(f, d.visualElement, l), f, h, d.visualElement)]
        })
    }
    const o = S.forwardRef(s);
    return o[Q5] = i,
    o
}
function Z5({layoutId: t}) {
    const e = S.useContext(Xy).id;
    return e && t !== void 0 ? e + "-" + t : t
}
function e8(t, e) {
    S.useContext(eR).strict
}
function t8(t) {
    const {drag: e, layout: n} = El;
    if (!e && !n)
        return {};
    const r = {
        ...e,
        ...n
    };
    return {
        MeasureLayout: e?.isEnabled(t) || n?.isEnabled(t) ? r.MeasureLayout : void 0,
        ProjectionNode: r.ProjectionNode
    }
}
function n8(t) {
    function e(r, i={}) {
        return J5(t(r, i))
    }
    if (typeof Proxy > "u")
        return e;
    const n = new Map;
    return new Proxy(e,{
        get: (r, i) => (n.has(i) || n.set(i, e(i)),
        n.get(i))
    })
}
const r8 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function Qy(t) {
    return typeof t != "string" || t.includes("-") ? !1 : !!(r8.indexOf(t) > -1 || /[A-Z]/u.test(t))
}
const Hf = {};
function i8(t) {
    Object.assign(Hf, t)
}
const Ih = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , _a = new Set(Ih);
function oR(t, {layout: e, layoutId: n}) {
    return _a.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Hf[t] || t === "opacity")
}
const un = t => !!(t && t.getVelocity)
  , s8 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , o8 = Ih.length;
function a8(t, {enableHardwareAcceleration: e=!0, allowTransformNone: n=!0}, r, i) {
    let s = "";
    for (let o = 0; o < o8; o++) {
        const a = Ih[o];
        if (t[a] !== void 0) {
            const l = s8[a] || a;
            s += `${l}(${t[a]}) `
        }
    }
    return e && !t.z && (s += "translateZ(0)"),
    s = s.trim(),
    i ? s = i(t, r ? "" : s) : n && r && (s = "none"),
    s
}
const aR = t => e => typeof e == "string" && e.startsWith(t)
  , lR = aR("--")
  , l8 = aR("var(--")
  , Jy = t => l8(t) ? c8.test(t.split("/*")[0].trim()) : !1
  , c8 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , u8 = (t, e) => e && typeof t == "number" ? e.transform(t) : t
  , $s = (t, e, n) => n > e ? e : n < t ? t : n
  , Ul = {
    test: t => typeof t == "number",
    parse: parseFloat,
    transform: t => t
}
  , Fc = {
    ...Ul,
    transform: t => $s(0, 1, t)
}
  , fd = {
    ...Ul,
    default: 1
}
  , jc = t => Math.round(t * 1e5) / 1e5
  , Zy = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
  , h8 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
  , d8 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function Ph(t) {
    return typeof t == "string"
}
const Dh = t => ({
    test: e => Ph(e) && e.endsWith(t) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: e => `${e}${t}`
})
  , gs = Dh("deg")
  , Ti = Dh("%")
  , Ue = Dh("px")
  , f8 = Dh("vh")
  , p8 = Dh("vw")
  , Jx = {
    ...Ti,
    parse: t => Ti.parse(t) / 100,
    transform: t => Ti.transform(t * 100)
}
  , Zx = {
    ...Ul,
    transform: Math.round
}
  , cR = {
    borderWidth: Ue,
    borderTopWidth: Ue,
    borderRightWidth: Ue,
    borderBottomWidth: Ue,
    borderLeftWidth: Ue,
    borderRadius: Ue,
    radius: Ue,
    borderTopLeftRadius: Ue,
    borderTopRightRadius: Ue,
    borderBottomRightRadius: Ue,
    borderBottomLeftRadius: Ue,
    width: Ue,
    maxWidth: Ue,
    height: Ue,
    maxHeight: Ue,
    size: Ue,
    top: Ue,
    right: Ue,
    bottom: Ue,
    left: Ue,
    padding: Ue,
    paddingTop: Ue,
    paddingRight: Ue,
    paddingBottom: Ue,
    paddingLeft: Ue,
    margin: Ue,
    marginTop: Ue,
    marginRight: Ue,
    marginBottom: Ue,
    marginLeft: Ue,
    rotate: gs,
    rotateX: gs,
    rotateY: gs,
    rotateZ: gs,
    scale: fd,
    scaleX: fd,
    scaleY: fd,
    scaleZ: fd,
    skew: gs,
    skewX: gs,
    skewY: gs,
    distance: Ue,
    translateX: Ue,
    translateY: Ue,
    translateZ: Ue,
    x: Ue,
    y: Ue,
    z: Ue,
    perspective: Ue,
    transformPerspective: Ue,
    opacity: Fc,
    originX: Jx,
    originY: Jx,
    originZ: Ue,
    zIndex: Zx,
    backgroundPositionX: Ue,
    backgroundPositionY: Ue,
    fillOpacity: Fc,
    strokeOpacity: Fc,
    numOctaves: Zx
};
function ev(t, e, n, r) {
    const {style: i, vars: s, transform: o, transformOrigin: a} = t;
    let l = !1
      , c = !1
      , u = !0;
    for (const h in e) {
        const d = e[h];
        if (lR(h)) {
            s[h] = d;
            continue
        }
        const f = cR[h]
          , g = u8(d, f);
        if (_a.has(h)) {
            if (l = !0,
            o[h] = g,
            !u)
                continue;
            d !== (f.default || 0) && (u = !1)
        } else
            h.startsWith("origin") ? (c = !0,
            a[h] = g) : i[h] = g
    }
    if (e.transform || (l || r ? i.transform = a8(t.transform, n, u, r) : i.transform && (i.transform = "none")),
    c) {
        const {originX: h="50%", originY: d="50%", originZ: f=0} = a;
        i.transformOrigin = `${h} ${d} ${f}`
    }
}
const tv = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function uR(t, e, n) {
    for (const r in e)
        !un(e[r]) && !oR(r, n) && (t[r] = e[r])
}
function m8({transformTemplate: t}, e, n) {
    return S.useMemo( () => {
        const r = tv();
        return ev(r, e, {
            enableHardwareAcceleration: !n
        }, t),
        Object.assign({}, r.vars, r.style)
    }
    , [e])
}
function g8(t, e, n) {
    const r = t.style || {}
      , i = {};
    return uR(i, r, t),
    Object.assign(i, m8(t, e, n)),
    i
}
function _8(t, e, n) {
    const r = {}
      , i = g8(t, e, n);
    return t.drag && t.dragListener !== !1 && (r.draggable = !1,
    i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none",
    i.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`),
    t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0),
    r.style = i,
    r
}
const b8 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function Uf(t) {
    return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || b8.has(t)
}
let hR = t => !Uf(t);
function y8(t) {
    t && (hR = e => e.startsWith("on") ? !Uf(e) : t(e))
}
try {
    y8(require("@emotion/is-prop-valid").default)
} catch {}
function v8(t, e, n) {
    const r = {};
    for (const i in t)
        i === "values" && typeof t.values == "object" || (hR(i) || n === !0 && Uf(i) || !e && !Uf(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]);
    return r
}
function eE(t, e, n) {
    return typeof t == "string" ? t : Ue.transform(e + n * t)
}
function x8(t, e, n) {
    const r = eE(e, t.x, t.width)
      , i = eE(n, t.y, t.height);
    return `${r} ${i}`
}
const E8 = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , S8 = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function w8(t, e, n=1, r=0, i=!0) {
    t.pathLength = 1;
    const s = i ? E8 : S8;
    t[s.offset] = Ue.transform(-r);
    const o = Ue.transform(e)
      , a = Ue.transform(n);
    t[s.array] = `${o} ${a}`
}
function nv(t, {attrX: e, attrY: n, attrScale: r, originX: i, originY: s, pathLength: o, pathSpacing: a=1, pathOffset: l=0, ...c}, u, h, d) {
    if (ev(t, c, u, d),
    h) {
        t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
        return
    }
    t.attrs = t.style,
    t.style = {};
    const {attrs: f, style: g, dimensions: _} = t;
    f.transform && (_ && (g.transform = f.transform),
    delete f.transform),
    _ && (i !== void 0 || s !== void 0 || g.transform) && (g.transformOrigin = x8(_, i !== void 0 ? i : .5, s !== void 0 ? s : .5)),
    e !== void 0 && (f.x = e),
    n !== void 0 && (f.y = n),
    r !== void 0 && (f.scale = r),
    o !== void 0 && w8(f, o, a, l, !1)
}
const dR = () => ({
    ...tv(),
    attrs: {}
})
  , rv = t => typeof t == "string" && t.toLowerCase() === "svg";
function C8(t, e, n, r) {
    const i = S.useMemo( () => {
        const s = dR();
        return nv(s, e, {
            enableHardwareAcceleration: !1
        }, rv(r), t.transformTemplate),
        {
            ...s.attrs,
            style: {
                ...s.style
            }
        }
    }
    , [e]);
    if (t.style) {
        const s = {};
        uR(s, t.style, t),
        i.style = {
            ...s,
            ...i.style
        }
    }
    return i
}
function T8(t=!1) {
    return (n, r, i, {latestValues: s}, o) => {
        const l = (Qy(n) ? C8 : _8)(r, s, o, n)
          , c = v8(r, typeof n == "string", t)
          , u = n !== S.Fragment ? {
            ...c,
            ...l,
            ref: i
        } : {}
          , {children: h} = r
          , d = S.useMemo( () => un(h) ? h.get() : h, [h]);
        return S.createElement(n, {
            ...u,
            children: d
        })
    }
}
function fR(t, {style: e, vars: n}, r, i) {
    Object.assign(t.style, e, i && i.getProjectionStyles(r));
    for (const s in n)
        t.style.setProperty(s, n[s])
}
const pR = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function mR(t, e, n, r) {
    fR(t, e, void 0, r);
    for (const i in e.attrs)
        t.setAttribute(pR.has(i) ? i : Gy(i), e.attrs[i])
}
function iv(t, e, n) {
    var r;
    const {style: i} = t
      , s = {};
    for (const o in i)
        (un(i[o]) || e.style && un(e.style[o]) || oR(o, t) || ((r = n?.getValue(o)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (s[o] = i[o]);
    return s
}
function gR(t, e, n) {
    const r = iv(t, e, n);
    for (const i in t)
        if (un(t[i]) || un(e[i])) {
            const s = Ih.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            r[s] = t[i]
        }
    return r
}
function tE(t) {
    const e = [{}, {}];
    return t?.values.forEach( (n, r) => {
        e[0][r] = n.get(),
        e[1][r] = n.getVelocity()
    }
    ),
    e
}
function sv(t, e, n, r) {
    if (typeof e == "function") {
        const [i,s] = tE(r);
        e = e(n !== void 0 ? n : t.custom, i, s)
    }
    if (typeof e == "string" && (e = t.variants && t.variants[e]),
    typeof e == "function") {
        const [i,s] = tE(r);
        e = e(n !== void 0 ? n : t.custom, i, s)
    }
    return e
}
function du(t) {
    const e = S.useRef(null);
    return e.current === null && (e.current = t()),
    e.current
}
const y_ = t => Array.isArray(t)
  , A8 = t => !!(t && typeof t == "object" && t.mix && t.toValue)
  , k8 = t => y_(t) ? t[t.length - 1] || 0 : t;
function hf(t) {
    const e = un(t) ? t.get() : t;
    return A8(e) ? e.toValue() : e
}
function R8({scrapeMotionValuesFromProps: t, createRenderState: e, onMount: n}, r, i, s) {
    const o = {
        latestValues: I8(r, i, s, t),
        renderState: e()
    };
    return n && (o.mount = a => n(r, a, o)),
    o
}
const _R = t => (e, n) => {
    const r = S.useContext(_m)
      , i = S.useContext(bm)
      , s = () => R8(t, e, r, i);
    return n ? s() : du(s)
}
;
function I8(t, e, n, r) {
    const i = {}
      , s = r(t, {});
    for (const d in s)
        i[d] = hf(s[d]);
    let {initial: o, animate: a} = t;
    const l = vm(t)
      , c = sR(t);
    e && c && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial),
    a === void 0 && (a = e.animate));
    let u = n ? n.initial === !1 : !1;
    u = u || o === !1;
    const h = u ? a : o;
    return h && typeof h != "boolean" && !ym(h) && (Array.isArray(h) ? h : [h]).forEach(f => {
        const g = sv(t, f);
        if (!g)
            return;
        const {transitionEnd: _, transition: m, ...p} = g;
        for (const b in p) {
            let y = p[b];
            if (Array.isArray(y)) {
                const x = u ? y.length - 1 : 0;
                y = y[x]
            }
            y !== null && (i[b] = y)
        }
        for (const b in _)
            i[b] = _[b]
    }
    ),
    i
}
const {schedule: vt, cancel: rs, state: fn, steps: Cg} = nR(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Pn, !0)
  , P8 = {
    useVisualState: _R({
        scrapeMotionValuesFromProps: gR,
        createRenderState: dR,
        onMount: (t, e, {renderState: n, latestValues: r}) => {
            vt.read( () => {
                try {
                    n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
                } catch {
                    n.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            vt.render( () => {
                nv(n, r, {
                    enableHardwareAcceleration: !1
                }, rv(e.tagName), t.transformTemplate),
                mR(e, n)
            }
            )
        }
    })
}
  , D8 = {
    useVisualState: _R({
        scrapeMotionValuesFromProps: iv,
        createRenderState: tv
    })
};
function L8(t, {forwardMotionProps: e=!1}, n, r) {
    return {
        ...Qy(t) ? P8 : D8,
        preloadedFeatures: n,
        useRender: T8(e),
        createVisualElement: r,
        Component: t
    }
}
function Wi(t, e, n, r={
    passive: !0
}) {
    return t.addEventListener(e, n, r),
    () => t.removeEventListener(e, n)
}
const bR = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function xm(t, e="page") {
    return {
        point: {
            x: t[`${e}X`],
            y: t[`${e}Y`]
        }
    }
}
const O8 = t => e => bR(e) && t(e, xm(e));
function Ki(t, e, n, r) {
    return Wi(t, e, O8(n), r)
}
const N8 = (t, e) => n => e(t(n))
  , Yi = (...t) => t.reduce(N8);
function yR(t) {
    let e = null;
    return () => {
        const n = () => {
            e = null
        }
        ;
        return e === null ? (e = t,
        n) : !1
    }
}
const nE = yR("dragHorizontal")
  , rE = yR("dragVertical");
function vR(t) {
    let e = !1;
    if (t === "y")
        e = rE();
    else if (t === "x")
        e = nE();
    else {
        const n = nE()
          , r = rE();
        n && r ? e = () => {
            n(),
            r()
        }
        : (n && n(),
        r && r())
    }
    return e
}
function xR() {
    const t = vR(!0);
    return t ? (t(),
    !1) : !0
}
class io {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
function iE(t, e) {
    const n = e ? "pointerenter" : "pointerleave"
      , r = e ? "onHoverStart" : "onHoverEnd"
      , i = (s, o) => {
        if (s.pointerType === "touch" || xR())
            return;
        const a = t.getProps();
        t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
        const l = a[r];
        l && vt.postRender( () => l(s, o))
    }
    ;
    return Ki(t.current, n, i, {
        passive: !t.getProps()[r]
    })
}
class M8 extends io {
    mount() {
        this.unmount = Yi(iE(this.node, !0), iE(this.node, !1))
    }
    unmount() {}
}
class B8 extends io {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = Yi(Wi(this.node.current, "focus", () => this.onFocus()), Wi(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
const ER = (t, e) => e ? t === e ? !0 : ER(t, e.parentElement) : !1;
function Tg(t, e) {
    if (!e)
        return;
    const n = new PointerEvent("pointer" + t);
    e(n, xm(n))
}
class F8 extends io {
    constructor() {
        super(...arguments),
        this.removeStartListeners = Pn,
        this.removeEndListeners = Pn,
        this.removeAccessibleListeners = Pn,
        this.startPointerPress = (e, n) => {
            if (this.isPressing)
                return;
            this.removeEndListeners();
            const r = this.node.getProps()
              , s = Ki(window, "pointerup", (a, l) => {
                if (!this.checkPressEnd())
                    return;
                const {onTap: c, onTapCancel: u, globalTapTarget: h} = this.node.getProps()
                  , d = !h && !ER(this.node.current, a.target) ? u : c;
                d && vt.update( () => d(a, l))
            }
            , {
                passive: !(r.onTap || r.onPointerUp)
            })
              , o = Ki(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
                passive: !(r.onTapCancel || r.onPointerCancel)
            });
            this.removeEndListeners = Yi(s, o),
            this.startPress(e, n)
        }
        ,
        this.startAccessiblePress = () => {
            const e = s => {
                if (s.key !== "Enter" || this.isPressing)
                    return;
                const o = a => {
                    a.key !== "Enter" || !this.checkPressEnd() || Tg("up", (l, c) => {
                        const {onTap: u} = this.node.getProps();
                        u && vt.postRender( () => u(l, c))
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = Wi(this.node.current, "keyup", o),
                Tg("down", (a, l) => {
                    this.startPress(a, l)
                }
                )
            }
              , n = Wi(this.node.current, "keydown", e)
              , r = () => {
                this.isPressing && Tg("cancel", (s, o) => this.cancelPress(s, o))
            }
              , i = Wi(this.node.current, "blur", r);
            this.removeAccessibleListeners = Yi(n, i)
        }
    }
    startPress(e, n) {
        this.isPressing = !0;
        const {onTapStart: r, whileTap: i} = this.node.getProps();
        i && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        r && vt.postRender( () => r(e, n))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !xR()
    }
    cancelPress(e, n) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: r} = this.node.getProps();
        r && vt.postRender( () => r(e, n))
    }
    mount() {
        const e = this.node.getProps()
          , n = Ki(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(e.onTapStart || e.onPointerStart)
        })
          , r = Wi(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Yi(n, r)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const v_ = new WeakMap
  , Ag = new WeakMap
  , j8 = t => {
    const e = v_.get(t.target);
    e && e(t)
}
  , H8 = t => {
    t.forEach(j8)
}
;
function U8({root: t, ...e}) {
    const n = t || document;
    Ag.has(n) || Ag.set(n, {});
    const r = Ag.get(n)
      , i = JSON.stringify(e);
    return r[i] || (r[i] = new IntersectionObserver(H8,{
        root: t,
        ...e
    })),
    r[i]
}
function V8(t, e, n) {
    const r = U8(e);
    return v_.set(t, n),
    r.observe(t),
    () => {
        v_.delete(t),
        r.unobserve(t)
    }
}
const $8 = {
    some: 0,
    all: 1
};
class z8 extends io {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: e={}} = this.node.getProps()
          , {root: n, margin: r, amount: i="some", once: s} = e
          , o = {
            root: n ? n.current : void 0,
            rootMargin: r,
            threshold: typeof i == "number" ? i : $8[i]
        }
          , a = l => {
            const {isIntersecting: c} = l;
            if (this.isInView === c || (this.isInView = c,
            s && !c && this.hasEnteredView))
                return;
            c && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", c);
            const {onViewportEnter: u, onViewportLeave: h} = this.node.getProps()
              , d = c ? u : h;
            d && d(l)
        }
        ;
        return V8(this.node.current, o, a)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: e, prevProps: n} = this.node;
        ["amount", "margin", "root"].some(W8(e, n)) && this.startObserver()
    }
    unmount() {}
}
function W8({viewport: t={}}, {viewport: e={}}={}) {
    return n => t[n] !== e[n]
}
const G8 = {
    inView: {
        Feature: z8
    },
    tap: {
        Feature: F8
    },
    focus: {
        Feature: B8
    },
    hover: {
        Feature: M8
    }
};
function SR(t, e) {
    if (!Array.isArray(e))
        return !1;
    const n = e.length;
    if (n !== t.length)
        return !1;
    for (let r = 0; r < n; r++)
        if (e[r] !== t[r])
            return !1;
    return !0
}
function Em(t, e, n) {
    const r = t.getProps();
    return sv(r, e, n !== void 0 ? n : r.custom, t)
}
const Xi = t => t * 1e3
  , Ai = t => t / 1e3
  , q8 = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , K8 = t => ({
    type: "spring",
    stiffness: 550,
    damping: t === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , Y8 = {
    type: "keyframes",
    duration: .8
}
  , X8 = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , Q8 = (t, {keyframes: e}) => e.length > 2 ? Y8 : _a.has(t) ? t.startsWith("scale") ? K8(e[1]) : q8 : X8;
function J8({when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u}) {
    return !!Object.keys(u).length
}
function ov(t, e) {
    return t[e] || t.default || t
}
const Z8 = t => t !== null;
function Sm(t, {repeat: e, repeatType: n="loop"}, r) {
    const i = t.filter(Z8)
      , s = e && n !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
    return !s || r === void 0 ? i[s] : r
}
let df;
function ej() {
    df = void 0
}
const Ds = {
    now: () => (df === void 0 && Ds.set(fn.isProcessing || U5.useManualTiming ? fn.timestamp : performance.now()),
    df),
    set: t => {
        df = t,
        queueMicrotask(ej)
    }
}
  , wR = t => /^0[^.\s]+$/u.test(t);
function tj(t) {
    return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || wR(t) : !0
}
const CR = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t)
  , nj = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function rj(t) {
    const e = nj.exec(t);
    if (!e)
        return [, ];
    const [,n,r,i] = e;
    return [`--${n ?? r}`, i]
}
function TR(t, e, n=1) {
    const [r,i] = rj(t);
    if (!r)
        return;
    const s = window.getComputedStyle(e).getPropertyValue(r);
    if (s) {
        const o = s.trim();
        return CR(o) ? parseFloat(o) : o
    }
    return Jy(i) ? TR(i, e, n + 1) : i
}
const ij = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , sE = t => t === Ul || t === Ue
  , oE = (t, e) => parseFloat(t.split(", ")[e])
  , aE = (t, e) => (n, {transform: r}) => {
    if (r === "none" || !r)
        return 0;
    const i = r.match(/^matrix3d\((.+)\)$/u);
    if (i)
        return oE(i[1], e);
    {
        const s = r.match(/^matrix\((.+)\)$/u);
        return s ? oE(s[1], t) : 0
    }
}
  , sj = new Set(["x", "y", "z"])
  , oj = Ih.filter(t => !sj.has(t));
function aj(t) {
    const e = [];
    return oj.forEach(n => {
        const r = t.getValue(n);
        r !== void 0 && (e.push([n, r.get()]),
        r.set(n.startsWith("scale") ? 1 : 0))
    }
    ),
    e
}
const Sl = {
    width: ({x: t}, {paddingLeft: e="0", paddingRight: n="0"}) => t.max - t.min - parseFloat(e) - parseFloat(n),
    height: ({y: t}, {paddingTop: e="0", paddingBottom: n="0"}) => t.max - t.min - parseFloat(e) - parseFloat(n),
    top: (t, {top: e}) => parseFloat(e),
    left: (t, {left: e}) => parseFloat(e),
    bottom: ({y: t}, {top: e}) => parseFloat(e) + (t.max - t.min),
    right: ({x: t}, {left: e}) => parseFloat(e) + (t.max - t.min),
    x: aE(4, 13),
    y: aE(5, 14)
};
Sl.translateX = Sl.x;
Sl.translateY = Sl.y;
const AR = t => e => e.test(t)
  , lj = {
    test: t => t === "auto",
    parse: t => t
}
  , kR = [Ul, Ue, Ti, gs, p8, f8, lj]
  , lE = t => kR.find(AR(t))
  , Bo = new Set;
let x_ = !1
  , E_ = !1;
function RR() {
    if (E_) {
        const t = Array.from(Bo).filter(r => r.needsMeasurement)
          , e = new Set(t.map(r => r.element))
          , n = new Map;
        e.forEach(r => {
            const i = aj(r);
            i.length && (n.set(r, i),
            r.render())
        }
        ),
        t.forEach(r => r.measureInitialState()),
        e.forEach(r => {
            r.render();
            const i = n.get(r);
            i && i.forEach( ([s,o]) => {
                var a;
                (a = r.getValue(s)) === null || a === void 0 || a.set(o)
            }
            )
        }
        ),
        t.forEach(r => r.measureEndState()),
        t.forEach(r => {
            r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
        }
        )
    }
    E_ = !1,
    x_ = !1,
    Bo.forEach(t => t.complete()),
    Bo.clear()
}
function IR() {
    Bo.forEach(t => {
        t.readKeyframes(),
        t.needsMeasurement && (E_ = !0)
    }
    )
}
function cj() {
    IR(),
    RR()
}
class av {
    constructor(e, n, r, i, s, o=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...e],
        this.onComplete = n,
        this.name = r,
        this.motionValue = i,
        this.element = s,
        this.isAsync = o
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (Bo.add(this),
        x_ || (x_ = !0,
        vt.read(IR),
        vt.resolveKeyframes(RR))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, name: n, element: r, motionValue: i} = this;
        for (let s = 0; s < e.length; s++)
            if (e[s] === null)
                if (s === 0) {
                    const o = i?.get()
                      , a = e[e.length - 1];
                    if (o !== void 0)
                        e[0] = o;
                    else if (r && n) {
                        const l = r.readValue(n, a);
                        l != null && (e[0] = l)
                    }
                    e[0] === void 0 && (e[0] = a),
                    i && o === void 0 && i.set(e[0])
                } else
                    e[s] = e[s - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        Bo.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        Bo.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const lv = (t, e) => n => !!(Ph(n) && d8.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e))
  , PR = (t, e, n) => r => {
    if (!Ph(r))
        return r;
    const [i,s,o,a] = r.match(Zy);
    return {
        [t]: parseFloat(i),
        [e]: parseFloat(s),
        [n]: parseFloat(o),
        alpha: a !== void 0 ? parseFloat(a) : 1
    }
}
  , uj = t => $s(0, 255, t)
  , kg = {
    ...Ul,
    transform: t => Math.round(uj(t))
}
  , To = {
    test: lv("rgb", "red"),
    parse: PR("red", "green", "blue"),
    transform: ({red: t, green: e, blue: n, alpha: r=1}) => "rgba(" + kg.transform(t) + ", " + kg.transform(e) + ", " + kg.transform(n) + ", " + jc(Fc.transform(r)) + ")"
};
function hj(t) {
    let e = ""
      , n = ""
      , r = ""
      , i = "";
    return t.length > 5 ? (e = t.substring(1, 3),
    n = t.substring(3, 5),
    r = t.substring(5, 7),
    i = t.substring(7, 9)) : (e = t.substring(1, 2),
    n = t.substring(2, 3),
    r = t.substring(3, 4),
    i = t.substring(4, 5),
    e += e,
    n += n,
    r += r,
    i += i),
    {
        red: parseInt(e, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
const S_ = {
    test: lv("#"),
    parse: hj,
    transform: To.transform
}
  , Ka = {
    test: lv("hsl", "hue"),
    parse: PR("hue", "saturation", "lightness"),
    transform: ({hue: t, saturation: e, lightness: n, alpha: r=1}) => "hsla(" + Math.round(t) + ", " + Ti.transform(jc(e)) + ", " + Ti.transform(jc(n)) + ", " + jc(Fc.transform(r)) + ")"
}
  , Cn = {
    test: t => To.test(t) || S_.test(t) || Ka.test(t),
    parse: t => To.test(t) ? To.parse(t) : Ka.test(t) ? Ka.parse(t) : S_.parse(t),
    transform: t => Ph(t) ? t : t.hasOwnProperty("red") ? To.transform(t) : Ka.transform(t)
};
function dj(t) {
    var e, n;
    return isNaN(t) && Ph(t) && (((e = t.match(Zy)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(h8)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
const DR = "number"
  , LR = "color"
  , fj = "var"
  , pj = "var("
  , cE = "${}"
  , mj = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function fu(t) {
    const e = t.toString()
      , n = []
      , r = {
        color: [],
        number: [],
        var: []
    }
      , i = [];
    let s = 0;
    const a = e.replace(mj, l => (Cn.test(l) ? (r.color.push(s),
    i.push(LR),
    n.push(Cn.parse(l))) : l.startsWith(pj) ? (r.var.push(s),
    i.push(fj),
    n.push(l)) : (r.number.push(s),
    i.push(DR),
    n.push(parseFloat(l))),
    ++s,
    cE)).split(cE);
    return {
        values: n,
        split: a,
        indexes: r,
        types: i
    }
}
function OR(t) {
    return fu(t).values
}
function NR(t) {
    const {split: e, types: n} = fu(t)
      , r = e.length;
    return i => {
        let s = "";
        for (let o = 0; o < r; o++)
            if (s += e[o],
            i[o] !== void 0) {
                const a = n[o];
                a === DR ? s += jc(i[o]) : a === LR ? s += Cn.transform(i[o]) : s += i[o]
            }
        return s
    }
}
const gj = t => typeof t == "number" ? 0 : t;
function _j(t) {
    const e = OR(t);
    return NR(t)(e.map(gj))
}
const zs = {
    test: dj,
    parse: OR,
    createTransformer: NR,
    getAnimatableNone: _j
}
  , bj = new Set(["brightness", "contrast", "saturate", "opacity"]);
function yj(t) {
    const [e,n] = t.slice(0, -1).split("(");
    if (e === "drop-shadow")
        return t;
    const [r] = n.match(Zy) || [];
    if (!r)
        return t;
    const i = n.replace(r, "");
    let s = bj.has(e) ? 1 : 0;
    return r !== n && (s *= 100),
    e + "(" + s + i + ")"
}
const vj = /\b([a-z-]*)\(.*?\)/gu
  , w_ = {
    ...zs,
    getAnimatableNone: t => {
        const e = t.match(vj);
        return e ? e.map(yj).join(" ") : t
    }
}
  , xj = {
    ...cR,
    color: Cn,
    backgroundColor: Cn,
    outlineColor: Cn,
    fill: Cn,
    stroke: Cn,
    borderColor: Cn,
    borderTopColor: Cn,
    borderRightColor: Cn,
    borderBottomColor: Cn,
    borderLeftColor: Cn,
    filter: w_,
    WebkitFilter: w_
}
  , cv = t => xj[t];
function MR(t, e) {
    let n = cv(t);
    return n !== w_ && (n = zs),
    n.getAnimatableNone ? n.getAnimatableNone(e) : void 0
}
const Ej = new Set(["auto", "none", "0"]);
function Sj(t, e, n) {
    let r = 0, i;
    for (; r < t.length && !i; ) {
        const s = t[r];
        typeof s == "string" && !Ej.has(s) && fu(s).values.length && (i = t[r]),
        r++
    }
    if (i && n)
        for (const s of e)
            t[s] = MR(n, i)
}
class BR extends av {
    constructor(e, n, r, i) {
        super(e, n, r, i, i?.owner, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, element: n, name: r} = this;
        if (!n.current)
            return;
        super.readKeyframes();
        for (let l = 0; l < e.length; l++) {
            let c = e[l];
            if (typeof c == "string" && (c = c.trim(),
            Jy(c))) {
                const u = TR(c, n.current);
                u !== void 0 && (e[l] = u),
                l === e.length - 1 && (this.finalKeyframe = c)
            }
        }
        if (this.resolveNoneKeyframes(),
        !ij.has(r) || e.length !== 2)
            return;
        const [i,s] = e
          , o = lE(i)
          , a = lE(s);
        if (o !== a)
            if (sE(o) && sE(a))
                for (let l = 0; l < e.length; l++) {
                    const c = e[l];
                    typeof c == "string" && (e[l] = parseFloat(c))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: e, name: n} = this
          , r = [];
        for (let i = 0; i < e.length; i++)
            tj(e[i]) && r.push(i);
        r.length && Sj(e, r, n)
    }
    measureInitialState() {
        const {element: e, unresolvedKeyframes: n, name: r} = this;
        if (!e.current)
            return;
        r === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = Sl[r](e.measureViewportBox(), window.getComputedStyle(e.current)),
        n[0] = this.measuredOrigin;
        const i = n[n.length - 1];
        i !== void 0 && e.getValue(r, i).jump(i, !1)
    }
    measureEndState() {
        var e;
        const {element: n, name: r, unresolvedKeyframes: i} = this;
        if (!n.current)
            return;
        const s = n.getValue(r);
        s && s.jump(this.measuredOrigin, !1);
        const o = i.length - 1
          , a = i[o];
        i[o] = Sl[r](n.measureViewportBox(), window.getComputedStyle(n.current)),
        a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a),
        !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach( ([l,c]) => {
            n.getValue(l).set(c)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function FR(t) {
    let e;
    return () => (e === void 0 && (e = t()),
    e)
}
const uE = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (zs.test(t) || t === "0") && !t.startsWith("url("));
function wj(t) {
    const e = t[0];
    if (t.length === 1)
        return !0;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e)
            return !0
}
function Cj(t, e, n, r) {
    const i = t[0];
    if (i === null)
        return !1;
    if (e === "display" || e === "visibility")
        return !0;
    const s = t[t.length - 1]
      , o = uE(i, e)
      , a = uE(s, e);
    return !o || !a ? !1 : wj(t) || n === "spring" && r
}
class jR {
    constructor({autoplay: e=!0, delay: n=0, type: r="keyframes", repeat: i=0, repeatDelay: s=0, repeatType: o="loop", ...a}) {
        this.isStopped = !1,
        this.hasAttemptedResolve = !1,
        this.options = {
            autoplay: e,
            delay: n,
            type: r,
            repeat: i,
            repeatDelay: s,
            repeatType: o,
            ...a
        },
        this.updateFinishedPromise()
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && cj(),
        this._resolved
    }
    onKeyframesResolved(e, n) {
        this.hasAttemptedResolve = !0;
        const {name: r, type: i, velocity: s, delay: o, onComplete: a, onUpdate: l, isGenerator: c} = this.options;
        if (!c && !Cj(e, r, i, s))
            if (o)
                this.options.duration = 0;
            else {
                l?.(Sm(e, this.options, n)),
                a?.(),
                this.resolveFinishedPromise();
                return
            }
        const u = this.initPlayback(e, n);
        u !== !1 && (this._resolved = {
            keyframes: e,
            finalKeyframe: n,
            ...u
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(e, n) {
        return this.currentFinishedPromise.then(e, n)
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(e => {
            this.resolveFinishedPromise = e
        }
        )
    }
}
function HR(t, e) {
    return e ? t * (1e3 / e) : 0
}
const Tj = 5;
function UR(t, e, n) {
    const r = Math.max(e - Tj, 0);
    return HR(n - t(r), e - r)
}
const Rg = .001
  , Aj = .01
  , kj = 10
  , Rj = .05
  , Ij = 1;
function Pj({duration: t=800, bounce: e=.25, velocity: n=0, mass: r=1}) {
    let i, s, o = 1 - e;
    o = $s(Rj, Ij, o),
    t = $s(Aj, kj, Ai(t)),
    o < 1 ? (i = c => {
        const u = c * o
          , h = u * t
          , d = u - n
          , f = C_(c, o)
          , g = Math.exp(-h);
        return Rg - d / f * g
    }
    ,
    s = c => {
        const h = c * o * t
          , d = h * n + n
          , f = Math.pow(o, 2) * Math.pow(c, 2) * t
          , g = Math.exp(-h)
          , _ = C_(Math.pow(c, 2), o);
        return (-i(c) + Rg > 0 ? -1 : 1) * ((d - f) * g) / _
    }
    ) : (i = c => {
        const u = Math.exp(-c * t)
          , h = (c - n) * t + 1;
        return -Rg + u * h
    }
    ,
    s = c => {
        const u = Math.exp(-c * t)
          , h = (n - c) * (t * t);
        return u * h
    }
    );
    const a = 5 / t
      , l = Lj(i, s, a);
    if (t = Xi(t),
    isNaN(l))
        return {
            stiffness: 100,
            damping: 10,
            duration: t
        };
    {
        const c = Math.pow(l, 2) * r;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(r * c),
            duration: t
        }
    }
}
const Dj = 12;
function Lj(t, e, n) {
    let r = n;
    for (let i = 1; i < Dj; i++)
        r = r - t(r) / e(r);
    return r
}
function C_(t, e) {
    return t * Math.sqrt(1 - e * e)
}
const Oj = ["duration", "bounce"]
  , Nj = ["stiffness", "damping", "mass"];
function hE(t, e) {
    return e.some(n => t[n] !== void 0)
}
function Mj(t) {
    let e = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...t
    };
    if (!hE(t, Nj) && hE(t, Oj)) {
        const n = Pj(t);
        e = {
            ...e,
            ...n,
            mass: 1
        },
        e.isResolvedFromDuration = !0
    }
    return e
}
function uv({keyframes: t, restDelta: e, restSpeed: n, ...r}) {
    const i = t[0]
      , s = t[t.length - 1]
      , o = {
        done: !1,
        value: i
    }
      , {stiffness: a, damping: l, mass: c, duration: u, velocity: h, isResolvedFromDuration: d} = Mj({
        ...r,
        velocity: -Ai(r.velocity || 0)
    })
      , f = h || 0
      , g = l / (2 * Math.sqrt(a * c))
      , _ = s - i
      , m = Ai(Math.sqrt(a / c))
      , p = Math.abs(_) < 5;
    n || (n = p ? .01 : 2),
    e || (e = p ? .005 : .5);
    let b;
    if (g < 1) {
        const y = C_(m, g);
        b = x => {
            const E = Math.exp(-g * m * x);
            return s - E * ((f + g * m * _) / y * Math.sin(y * x) + _ * Math.cos(y * x))
        }
    } else if (g === 1)
        b = y => s - Math.exp(-m * y) * (_ + (f + m * _) * y);
    else {
        const y = m * Math.sqrt(g * g - 1);
        b = x => {
            const E = Math.exp(-g * m * x)
              , w = Math.min(y * x, 300);
            return s - E * ((f + g * m * _) * Math.sinh(w) + y * _ * Math.cosh(w)) / y
        }
    }
    return {
        calculatedDuration: d && u || null,
        next: y => {
            const x = b(y);
            if (d)
                o.done = y >= u;
            else {
                let E = f;
                y !== 0 && (g < 1 ? E = UR(b, y, x) : E = 0);
                const w = Math.abs(E) <= n
                  , A = Math.abs(s - x) <= e;
                o.done = w && A
            }
            return o.value = o.done ? s : x,
            o
        }
    }
}
function dE({keyframes: t, velocity: e=0, power: n=.8, timeConstant: r=325, bounceDamping: i=10, bounceStiffness: s=500, modifyTarget: o, min: a, max: l, restDelta: c=.5, restSpeed: u}) {
    const h = t[0]
      , d = {
        done: !1,
        value: h
    }
      , f = C => a !== void 0 && C < a || l !== void 0 && C > l
      , g = C => a === void 0 ? l : l === void 0 || Math.abs(a - C) < Math.abs(l - C) ? a : l;
    let _ = n * e;
    const m = h + _
      , p = o === void 0 ? m : o(m);
    p !== m && (_ = p - h);
    const b = C => -_ * Math.exp(-C / r)
      , y = C => p + b(C)
      , x = C => {
        const k = b(C)
          , I = y(C);
        d.done = Math.abs(k) <= c,
        d.value = d.done ? p : I
    }
    ;
    let E, w;
    const A = C => {
        f(d.value) && (E = C,
        w = uv({
            keyframes: [d.value, g(d.value)],
            velocity: UR(y, C, d.value),
            damping: i,
            stiffness: s,
            restDelta: c,
            restSpeed: u
        }))
    }
    ;
    return A(0),
    {
        calculatedDuration: null,
        next: C => {
            let k = !1;
            return !w && E === void 0 && (k = !0,
            x(C),
            A(C)),
            E !== void 0 && C >= E ? w.next(C - E) : (!k && x(C),
            d)
        }
    }
}
const VR = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t
  , Bj = 1e-7
  , Fj = 12;
function jj(t, e, n, r, i) {
    let s, o, a = 0;
    do
        o = e + (n - e) / 2,
        s = VR(o, r, i) - t,
        s > 0 ? n = o : e = o;
    while (Math.abs(s) > Bj && ++a < Fj);
    return o
}
function ba(t, e, n, r) {
    if (t === e && n === r)
        return Pn;
    const i = s => jj(s, 0, 1, t, n);
    return s => s === 0 || s === 1 ? s : VR(i(s), e, r)
}
const Hj = ba(.42, 0, 1, 1)
  , Uj = ba(0, 0, .58, 1)
  , hv = ba(.42, 0, .58, 1)
  , $R = t => Array.isArray(t) && typeof t[0] != "number"
  , zR = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2
  , WR = t => e => 1 - t(1 - e)
  , dv = t => 1 - Math.sin(Math.acos(t))
  , GR = WR(dv)
  , Vj = zR(dv)
  , qR = ba(.33, 1.53, .69, .99)
  , fv = WR(qR)
  , $j = zR(fv)
  , zj = t => (t *= 2) < 1 ? .5 * fv(t) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
  , fE = {
    linear: Pn,
    easeIn: Hj,
    easeInOut: hv,
    easeOut: Uj,
    circIn: dv,
    circInOut: Vj,
    circOut: GR,
    backIn: fv,
    backInOut: $j,
    backOut: qR,
    anticipate: zj
}
  , pE = t => {
    if (Array.isArray(t)) {
        jf(t.length === 4);
        const [e,n,r,i] = t;
        return ba(e, n, r, i)
    } else if (typeof t == "string")
        return jf(fE[t] !== void 0),
        fE[t];
    return t
}
  , wl = (t, e, n) => {
    const r = e - t;
    return r === 0 ? 1 : (n - t) / r
}
  , Ot = (t, e, n) => t + (e - t) * n;
function Ig(t, e, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}
function Wj({hue: t, saturation: e, lightness: n, alpha: r}) {
    t /= 360,
    e /= 100,
    n /= 100;
    let i = 0
      , s = 0
      , o = 0;
    if (!e)
        i = s = o = n;
    else {
        const a = n < .5 ? n * (1 + e) : n + e - n * e
          , l = 2 * n - a;
        i = Ig(l, a, t + 1 / 3),
        s = Ig(l, a, t),
        o = Ig(l, a, t - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: r
    }
}
function Vf(t, e) {
    return n => n > 0 ? e : t
}
const Pg = (t, e, n) => {
    const r = t * t
      , i = n * (e * e - r) + r;
    return i < 0 ? 0 : Math.sqrt(i)
}
  , Gj = [S_, To, Ka]
  , qj = t => Gj.find(e => e.test(t));
function mE(t) {
    const e = qj(t);
    if (!e)
        return !1;
    let n = e.parse(t);
    return e === Ka && (n = Wj(n)),
    n
}
const gE = (t, e) => {
    const n = mE(t)
      , r = mE(e);
    if (!n || !r)
        return Vf(t, e);
    const i = {
        ...n
    };
    return s => (i.red = Pg(n.red, r.red, s),
    i.green = Pg(n.green, r.green, s),
    i.blue = Pg(n.blue, r.blue, s),
    i.alpha = Ot(n.alpha, r.alpha, s),
    To.transform(i))
}
  , T_ = new Set(["none", "hidden"]);
function Kj(t, e) {
    return T_.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t
}
function Yj(t, e) {
    return n => Ot(t, e, n)
}
function pv(t) {
    return typeof t == "number" ? Yj : typeof t == "string" ? Jy(t) ? Vf : Cn.test(t) ? gE : Jj : Array.isArray(t) ? KR : typeof t == "object" ? Cn.test(t) ? gE : Xj : Vf
}
function KR(t, e) {
    const n = [...t]
      , r = n.length
      , i = t.map( (s, o) => pv(s)(s, e[o]));
    return s => {
        for (let o = 0; o < r; o++)
            n[o] = i[o](s);
        return n
    }
}
function Xj(t, e) {
    const n = {
        ...t,
        ...e
    }
      , r = {};
    for (const i in n)
        t[i] !== void 0 && e[i] !== void 0 && (r[i] = pv(t[i])(t[i], e[i]));
    return i => {
        for (const s in r)
            n[s] = r[s](i);
        return n
    }
}
function Qj(t, e) {
    var n;
    const r = []
      , i = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let s = 0; s < e.values.length; s++) {
        const o = e.types[s]
          , a = t.indexes[o][i[o]]
          , l = (n = t.values[a]) !== null && n !== void 0 ? n : 0;
        r[s] = l,
        i[o]++
    }
    return r
}
const Jj = (t, e) => {
    const n = zs.createTransformer(e)
      , r = fu(t)
      , i = fu(e);
    return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? T_.has(t) && !i.values.length || T_.has(e) && !r.values.length ? Kj(t, e) : Yi(KR(Qj(r, i), i.values), n) : Vf(t, e)
}
;
function YR(t, e, n) {
    return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Ot(t, e, n) : pv(t)(t, e)
}
function Zj(t, e, n) {
    const r = []
      , i = n || YR
      , s = t.length - 1;
    for (let o = 0; o < s; o++) {
        let a = i(t[o], t[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] || Pn : e;
            a = Yi(l, a)
        }
        r.push(a)
    }
    return r
}
function eH(t, e, {clamp: n=!0, ease: r, mixer: i}={}) {
    const s = t.length;
    if (jf(s === e.length),
    s === 1)
        return () => e[0];
    if (s === 2 && t[0] === t[1])
        return () => e[1];
    t[0] > t[s - 1] && (t = [...t].reverse(),
    e = [...e].reverse());
    const o = Zj(e, r, i)
      , a = o.length
      , l = c => {
        let u = 0;
        if (a > 1)
            for (; u < t.length - 2 && !(c < t[u + 1]); u++)
                ;
        const h = wl(t[u], t[u + 1], c);
        return o[u](h)
    }
    ;
    return n ? c => l($s(t[0], t[s - 1], c)) : l
}
function XR(t, e) {
    const n = t[t.length - 1];
    for (let r = 1; r <= e; r++) {
        const i = wl(0, e, r);
        t.push(Ot(n, 1, i))
    }
}
function QR(t) {
    const e = [0];
    return XR(e, t.length - 1),
    e
}
function tH(t, e) {
    return t.map(n => n * e)
}
function nH(t, e) {
    return t.map( () => e || hv).splice(0, t.length - 1)
}
function $f({duration: t=300, keyframes: e, times: n, ease: r="easeInOut"}) {
    const i = $R(r) ? r.map(pE) : pE(r)
      , s = {
        done: !1,
        value: e[0]
    }
      , o = tH(n && n.length === e.length ? n : QR(e), t)
      , a = eH(o, e, {
        ease: Array.isArray(i) ? i : nH(e, i)
    });
    return {
        calculatedDuration: t,
        next: l => (s.value = a(l),
        s.done = l >= t,
        s)
    }
}
const A_ = 2e4;
function JR(t) {
    let e = 0;
    const n = 50;
    let r = t.next(e);
    for (; !r.done && e < A_; )
        e += n,
        r = t.next(e);
    return e >= A_ ? 1 / 0 : e
}
const rH = t => {
    const e = ({timestamp: n}) => t(n);
    return {
        start: () => vt.update(e, !0),
        stop: () => rs(e),
        now: () => fn.isProcessing ? fn.timestamp : Ds.now()
    }
}
  , iH = {
    decay: dE,
    inertia: dE,
    tween: $f,
    keyframes: $f,
    spring: uv
}
  , sH = t => t / 100;
class mv extends jR {
    constructor({KeyframeResolver: e=av, ...n}) {
        super(n),
        this.holdTime = null,
        this.startTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.state = "idle",
        this.stop = () => {
            if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
                return;
            this.teardown();
            const {onStop: a} = this.options;
            a && a()
        }
        ;
        const {name: r, motionValue: i, keyframes: s} = this.options
          , o = (a, l) => this.onKeyframesResolved(a, l);
        r && i && i.owner ? this.resolver = i.owner.resolveKeyframes(s, o, r, i) : this.resolver = new e(s,o,r,i),
        this.resolver.scheduleResolve()
    }
    initPlayback(e) {
        const {type: n="keyframes", repeat: r=0, repeatDelay: i=0, repeatType: s, velocity: o=0} = this.options
          , a = iH[n] || $f;
        let l, c;
        a !== $f && typeof e[0] != "number" && (l = Yi(sH, YR(e[0], e[1])),
        e = [0, 100]);
        const u = a({
            ...this.options,
            keyframes: e
        });
        s === "mirror" && (c = a({
            ...this.options,
            keyframes: [...e].reverse(),
            velocity: -o
        })),
        u.calculatedDuration === null && (u.calculatedDuration = JR(u));
        const {calculatedDuration: h} = u
          , d = h + i
          , f = d * (r + 1) - i;
        return {
            generator: u,
            mirroredGenerator: c,
            mapPercentToKeyframes: l,
            calculatedDuration: h,
            resolvedDuration: d,
            totalDuration: f
        }
    }
    onPostResolved() {
        const {autoplay: e=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState
    }
    tick(e, n=!1) {
        const {resolved: r} = this;
        if (!r) {
            const {keyframes: C} = this.options;
            return {
                done: !0,
                value: C[C.length - 1]
            }
        }
        const {finalKeyframe: i, generator: s, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: c, totalDuration: u, resolvedDuration: h} = r;
        if (this.startTime === null)
            return s.next(0);
        const {delay: d, repeat: f, repeatType: g, repeatDelay: _, onUpdate: m} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - u / this.speed, this.startTime)),
        n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
        const p = this.currentTime - d * (this.speed >= 0 ? 1 : -1)
          , b = this.speed >= 0 ? p < 0 : p > u;
        this.currentTime = Math.max(p, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = u);
        let y = this.currentTime
          , x = s;
        if (f) {
            const C = Math.min(this.currentTime, u) / h;
            let k = Math.floor(C)
              , I = C % 1;
            !I && C >= 1 && (I = 1),
            I === 1 && k--,
            k = Math.min(k, f + 1),
            !!(k % 2) && (g === "reverse" ? (I = 1 - I,
            _ && (I -= _ / h)) : g === "mirror" && (x = o)),
            y = $s(0, 1, I) * h
        }
        const E = b ? {
            done: !1,
            value: l[0]
        } : x.next(y);
        a && (E.value = a(E.value));
        let {done: w} = E;
        !b && c !== null && (w = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
        const A = this.holdTime === null && (this.state === "finished" || this.state === "running" && w);
        return A && i !== void 0 && (E.value = Sm(l, this.options, i)),
        m && m(E.value),
        A && this.finish(),
        E
    }
    get duration() {
        const {resolved: e} = this;
        return e ? Ai(e.calculatedDuration) : 0
    }
    get time() {
        return Ai(this.currentTime)
    }
    set time(e) {
        e = Xi(e),
        this.currentTime = e,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        const n = this.playbackSpeed !== e;
        this.playbackSpeed = e,
        n && (this.time = Ai(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: e=rH, onPlay: n} = this.options;
        this.driver || (this.driver = e(i => this.tick(i))),
        n && n();
        const r = this.driver.now();
        this.holdTime !== null ? this.startTime = r - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = r),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var e;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        const {onComplete: e} = this.options;
        e && e()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0,
        this.tick(e, !0)
    }
}
const ZR = t => Array.isArray(t) && typeof t[0] == "number";
function e2(t) {
    return !!(!t || typeof t == "string" && t in gv || ZR(t) || Array.isArray(t) && t.every(e2))
}
const xc = ([t,e,n,r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`
  , gv = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: xc([0, .65, .55, 1]),
    circOut: xc([.55, 0, 1, .45]),
    backIn: xc([.31, .01, .66, -.59]),
    backOut: xc([.33, 1.53, .69, .99])
};
function oH(t) {
    return t2(t) || gv.easeOut
}
function t2(t) {
    if (t)
        return ZR(t) ? xc(t) : Array.isArray(t) ? t.map(oH) : gv[t]
}
function aH(t, e, n, {delay: r=0, duration: i=300, repeat: s=0, repeatType: o="loop", ease: a, times: l}={}) {
    const c = {
        [e]: n
    };
    l && (c.offset = l);
    const u = t2(a);
    return Array.isArray(u) && (c.easing = u),
    t.animate(c, {
        delay: r,
        duration: i,
        easing: Array.isArray(u) ? "linear" : u,
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}
const lH = FR( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
  , cH = new Set(["opacity", "clipPath", "filter", "transform"])
  , zf = 10
  , uH = 2e4;
function hH(t) {
    return t.type === "spring" || t.name === "backgroundColor" || !e2(t.ease)
}
function dH(t, e) {
    const n = new mv({
        ...e,
        keyframes: t,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let r = {
        done: !1,
        value: t[0]
    };
    const i = [];
    let s = 0;
    for (; !r.done && s < uH; )
        r = n.sample(s),
        i.push(r.value),
        s += zf;
    return {
        times: void 0,
        keyframes: i,
        duration: s - zf,
        ease: "linear"
    }
}
class _E extends jR {
    constructor(e) {
        super(e);
        const {name: n, motionValue: r, keyframes: i} = this.options;
        this.resolver = new BR(i, (s, o) => this.onKeyframesResolved(s, o),n,r),
        this.resolver.scheduleResolve()
    }
    initPlayback(e, n) {
        var r;
        let {duration: i=300, times: s, ease: o, type: a, motionValue: l, name: c} = this.options;
        if (!(!((r = l.owner) === null || r === void 0) && r.current))
            return !1;
        if (hH(this.options)) {
            const {onComplete: h, onUpdate: d, motionValue: f, ...g} = this.options
              , _ = dH(e, g);
            e = _.keyframes,
            e.length === 1 && (e[1] = e[0]),
            i = _.duration,
            s = _.times,
            o = _.ease,
            a = "keyframes"
        }
        const u = aH(l.owner.current, c, e, {
            ...this.options,
            duration: i,
            times: s,
            ease: o
        });
        return u.startTime = Ds.now(),
        this.pendingTimeline ? (u.timeline = this.pendingTimeline,
        this.pendingTimeline = void 0) : u.onfinish = () => {
            const {onComplete: h} = this.options;
            l.set(Sm(e, this.options, n)),
            h && h(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: u,
            duration: i,
            times: s,
            type: a,
            ease: o,
            keyframes: e
        }
    }
    get duration() {
        const {resolved: e} = this;
        if (!e)
            return 0;
        const {duration: n} = e;
        return Ai(n)
    }
    get time() {
        const {resolved: e} = this;
        if (!e)
            return 0;
        const {animation: n} = e;
        return Ai(n.currentTime || 0)
    }
    set time(e) {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: r} = n;
        r.currentTime = Xi(e)
    }
    get speed() {
        const {resolved: e} = this;
        if (!e)
            return 1;
        const {animation: n} = e;
        return n.playbackRate
    }
    set speed(e) {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: r} = n;
        r.playbackRate = e
    }
    get state() {
        const {resolved: e} = this;
        if (!e)
            return "idle";
        const {animation: n} = e;
        return n.playState
    }
    attachTimeline(e) {
        if (!this._resolved)
            this.pendingTimeline = e;
        else {
            const {resolved: n} = this;
            if (!n)
                return Pn;
            const {animation: r} = n;
            r.timeline = e,
            r.onfinish = null
        }
        return Pn
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: e} = this;
        if (!e)
            return;
        const {animation: n} = e;
        n.playState === "finished" && this.updateFinishedPromise(),
        n.play()
    }
    pause() {
        const {resolved: e} = this;
        if (!e)
            return;
        const {animation: n} = e;
        n.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        const {resolved: e} = this;
        if (!e)
            return;
        const {animation: n, keyframes: r, duration: i, type: s, ease: o, times: a} = e;
        if (!(n.playState === "idle" || n.playState === "finished")) {
            if (this.time) {
                const {motionValue: l, onUpdate: c, onComplete: u, ...h} = this.options
                  , d = new mv({
                    ...h,
                    keyframes: r,
                    duration: i,
                    type: s,
                    ease: o,
                    times: a,
                    isGenerator: !0
                })
                  , f = Xi(this.time);
                l.setWithVelocity(d.sample(f - zf).value, d.sample(f).value, zf)
            }
            this.cancel()
        }
    }
    complete() {
        const {resolved: e} = this;
        e && e.animation.finish()
    }
    cancel() {
        const {resolved: e} = this;
        e && e.animation.cancel()
    }
    static supports(e) {
        const {motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: o, type: a} = e;
        return lH() && r && cH.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia"
    }
}
function fH(t, e) {
    let n;
    const r = () => {
        const {currentTime: i} = e
          , o = (i === null ? 0 : i.value) / 100;
        n !== o && t(o),
        n = o
    }
    ;
    return vt.update(r, !0),
    () => rs(r)
}
const pH = FR( () => window.ScrollTimeline !== void 0);
class _v {
    constructor(e) {
        this.stop = () => this.runAll("stop"),
        this.animations = e.filter(Boolean)
    }
    then(e, n) {
        return Promise.all(this.animations).then(e).catch(n)
    }
    getAll(e) {
        return this.animations[0][e]
    }
    setAll(e, n) {
        for (let r = 0; r < this.animations.length; r++)
            this.animations[r][e] = n
    }
    attachTimeline(e) {
        const n = this.animations.map(r => {
            if (pH() && r.attachTimeline)
                r.attachTimeline(e);
            else
                return r.pause(),
                fH(i => {
                    r.time = r.duration * i
                }
                , e)
        }
        );
        return () => {
            n.forEach( (r, i) => {
                r && r(),
                this.animations[i].stop()
            }
            )
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(e) {
        this.setAll("time", e)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(e) {
        this.setAll("speed", e)
    }
    get duration() {
        let e = 0;
        for (let n = 0; n < this.animations.length; n++)
            e = Math.max(e, this.animations[n].duration);
        return e
    }
    runAll(e) {
        this.animations.forEach(n => n[e]())
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
const bv = (t, e, n, r={}, i, s) => o => {
    const a = ov(r, t) || {}
      , l = a.delay || r.delay || 0;
    let {elapsed: c=0} = r;
    c = c - Xi(l);
    let u = {
        keyframes: Array.isArray(n) ? n : [null, n],
        ease: "easeOut",
        velocity: e.getVelocity(),
        ...a,
        delay: -c,
        onUpdate: d => {
            e.set(d),
            a.onUpdate && a.onUpdate(d)
        }
        ,
        onComplete: () => {
            o(),
            a.onComplete && a.onComplete()
        }
        ,
        name: t,
        motionValue: e,
        element: s ? void 0 : i
    };
    J8(a) || (u = {
        ...u,
        ...Q8(t, u)
    }),
    u.duration && (u.duration = Xi(u.duration)),
    u.repeatDelay && (u.repeatDelay = Xi(u.repeatDelay)),
    u.from !== void 0 && (u.keyframes[0] = u.from);
    let h = !1;
    if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0,
    u.delay === 0 && (h = !0)),
    h && !s && e.get() !== void 0) {
        const d = Sm(u.keyframes, a);
        if (d !== void 0)
            return vt.update( () => {
                u.onUpdate(d),
                u.onComplete()
            }
            ),
            new _v([])
    }
    return !s && _E.supports(u) ? new _E(u) : new mv(u)
}
;
function Wf(t) {
    return !!(un(t) && t.add)
}
function yv(t, e) {
    t.indexOf(e) === -1 && t.push(e)
}
function wm(t, e) {
    const n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}
class vv {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return yv(this.subscriptions, e),
        () => wm(this.subscriptions, e)
    }
    notify(e, n, r) {
        const i = this.subscriptions.length;
        if (i)
            if (i === 1)
                this.subscriptions[0](e, n, r);
            else
                for (let s = 0; s < i; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, n, r)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const bE = 30
  , mH = t => !isNaN(parseFloat(t));
class gH {
    constructor(e, n={}) {
        this.version = "11.2.12",
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = (r, i=!0) => {
            const s = Ds.now();
            this.updatedAt !== s && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(r),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            i && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(e),
        this.owner = n.owner
    }
    setCurrent(e) {
        this.current = e,
        this.updatedAt = Ds.now(),
        this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = mH(this.current))
    }
    setPrevFrameValue(e=this.current) {
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, n) {
        this.events[e] || (this.events[e] = new vv);
        const r = this.events[e].add(n);
        return e === "change" ? () => {
            r(),
            vt.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : r
    }
    clearListeners() {
        for (const e in this.events)
            this.events[e].clear()
    }
    attach(e, n) {
        this.passiveEffect = e,
        this.stopPassiveEffect = n
    }
    set(e, n=!0) {
        !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, n, r) {
        this.set(n),
        this.prev = void 0,
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt - r
    }
    jump(e, n=!0) {
        this.updateAndNotify(e),
        this.prev = e,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        n && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const e = Ds.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > bE)
            return 0;
        const n = Math.min(this.updatedAt - this.prevUpdatedAt, bE);
        return HR(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(e) {
        return this.stop(),
        new Promise(n => {
            this.hasAnimated = !0,
            this.animation = e(n),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function pu(t, e) {
    return new gH(t,e)
}
function _H(t, e, n) {
    t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, pu(n))
}
function xv(t, e) {
    const n = Em(t, e);
    let {transitionEnd: r={}, transition: i={}, ...s} = n || {};
    s = {
        ...s,
        ...r
    };
    for (const o in s) {
        const a = k8(s[o]);
        _H(t, o, a)
    }
}
function n2(t) {
    return t.getProps()[tR]
}
function bH({protectedKeys: t, needsAnimating: e}, n) {
    const r = t.hasOwnProperty(n) && e[n] !== !0;
    return e[n] = !1,
    r
}
function Ev(t, e, {delay: n=0, transitionOverride: r, type: i}={}) {
    var s;
    let {transition: o=t.getDefaultTransition(), transitionEnd: a, ...l} = e;
    const c = t.getValue("willChange");
    r && (o = r);
    const u = []
      , h = i && t.animationState && t.animationState.getState()[i];
    for (const d in l) {
        const f = t.getValue(d, (s = t.latestValues[d]) !== null && s !== void 0 ? s : null)
          , g = l[d];
        if (g === void 0 || h && bH(h, d))
            continue;
        const _ = {
            delay: n,
            elapsed: 0,
            ...ov(o || {}, d)
        };
        let m = !1;
        if (window.HandoffAppearAnimations) {
            const b = n2(t);
            if (b) {
                const y = window.HandoffAppearAnimations(b, d, f, vt);
                y !== null && (_.elapsed = y,
                m = !0)
            }
        }
        f.start(bv(d, f, g, t.shouldReduceMotion && _a.has(d) ? {
            type: !1
        } : _, t, m));
        const p = f.animation;
        p && (Wf(c) && (c.add(d),
        p.then( () => c.remove(d))),
        u.push(p))
    }
    return a && Promise.all(u).then( () => {
        vt.update( () => {
            a && xv(t, a)
        }
        )
    }
    ),
    u
}
function k_(t, e, n={}) {
    var r;
    const i = Em(t, e, n.type === "exit" ? (r = t.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
    let {transition: s=t.getDefaultTransition() || {}} = i || {};
    n.transitionOverride && (s = n.transitionOverride);
    const o = i ? () => Promise.all(Ev(t, i, n)) : () => Promise.resolve()
      , a = t.variantChildren && t.variantChildren.size ? (c=0) => {
        const {delayChildren: u=0, staggerChildren: h, staggerDirection: d} = s;
        return yH(t, e, u + c, h, d, n)
    }
    : () => Promise.resolve()
      , {when: l} = s;
    if (l) {
        const [c,u] = l === "beforeChildren" ? [o, a] : [a, o];
        return c().then( () => u())
    } else
        return Promise.all([o(), a(n.delay)])
}
function yH(t, e, n=0, r=0, i=1, s) {
    const o = []
      , a = (t.variantChildren.size - 1) * r
      , l = i === 1 ? (c=0) => c * r : (c=0) => a - c * r;
    return Array.from(t.variantChildren).sort(vH).forEach( (c, u) => {
        c.notify("AnimationStart", e),
        o.push(k_(c, e, {
            ...s,
            delay: n + l(u)
        }).then( () => c.notify("AnimationComplete", e)))
    }
    ),
    Promise.all(o)
}
function vH(t, e) {
    return t.sortNodePosition(e)
}
function r2(t, e, n={}) {
    t.notify("AnimationStart", e);
    let r;
    if (Array.isArray(e)) {
        const i = e.map(s => k_(t, s, n));
        r = Promise.all(i)
    } else if (typeof e == "string")
        r = k_(t, e, n);
    else {
        const i = typeof e == "function" ? Em(t, e, n.custom) : e;
        r = Promise.all(Ev(t, i, n))
    }
    return r.then( () => {
        vt.postRender( () => {
            t.notify("AnimationComplete", e)
        }
        )
    }
    )
}
const xH = [...Ky].reverse()
  , EH = Ky.length;
function SH(t) {
    return e => Promise.all(e.map( ({animation: n, options: r}) => r2(t, n, r)))
}
function wH(t) {
    let e = SH(t)
      , n = yE()
      , r = !0;
    const i = l => (c, u) => {
        var h;
        const d = Em(t, u, l === "exit" ? (h = t.presenceContext) === null || h === void 0 ? void 0 : h.custom : void 0);
        if (d) {
            const {transition: f, transitionEnd: g, ..._} = d;
            c = {
                ...c,
                ..._,
                ...g
            }
        }
        return c
    }
    ;
    function s(l) {
        e = l(t)
    }
    function o(l) {
        const c = t.getProps()
          , u = t.getVariantContext(!0) || {}
          , h = []
          , d = new Set;
        let f = {}
          , g = 1 / 0;
        for (let m = 0; m < EH; m++) {
            const p = xH[m]
              , b = n[p]
              , y = c[p] !== void 0 ? c[p] : u[p]
              , x = hu(y)
              , E = p === l ? b.isActive : null;
            E === !1 && (g = m);
            let w = y === u[p] && y !== c[p] && x;
            if (w && r && t.manuallyAnimateOnMount && (w = !1),
            b.protectedKeys = {
                ...f
            },
            !b.isActive && E === null || !y && !b.prevProp || ym(y) || typeof y == "boolean")
                continue;
            let C = CH(b.prevProp, y) || p === l && b.isActive && !w && x || m > g && x
              , k = !1;
            const I = Array.isArray(y) ? y : [y];
            let N = I.reduce(i(p), {});
            E === !1 && (N = {});
            const {prevResolvedValues: O={}} = b
              , M = {
                ...O,
                ...N
            }
              , H = $ => {
                C = !0,
                d.has($) && (k = !0,
                d.delete($)),
                b.needsAnimating[$] = !0;
                const J = t.getValue($);
                J && (J.liveStyle = !1)
            }
            ;
            for (const $ in M) {
                const J = N[$]
                  , Q = O[$];
                if (f.hasOwnProperty($))
                    continue;
                let ee = !1;
                y_(J) && y_(Q) ? ee = !SR(J, Q) : ee = J !== Q,
                ee ? J != null ? H($) : d.add($) : J !== void 0 && d.has($) ? H($) : b.protectedKeys[$] = !0
            }
            b.prevProp = y,
            b.prevResolvedValues = N,
            b.isActive && (f = {
                ...f,
                ...N
            }),
            r && t.blockInitialAnimation && (C = !1),
            C && (!w || k) && h.push(...I.map($ => ({
                animation: $,
                options: {
                    type: p
                }
            })))
        }
        if (d.size) {
            const m = {};
            d.forEach(p => {
                const b = t.getBaseTarget(p)
                  , y = t.getValue(p);
                y && (y.liveStyle = !0),
                m[p] = b ?? null
            }
            ),
            h.push({
                animation: m
            })
        }
        let _ = !!h.length;
        return r && (c.initial === !1 || c.initial === c.animate) && !t.manuallyAnimateOnMount && (_ = !1),
        r = !1,
        _ ? e(h) : Promise.resolve()
    }
    function a(l, c) {
        var u;
        if (n[l].isActive === c)
            return Promise.resolve();
        (u = t.variantChildren) === null || u === void 0 || u.forEach(d => {
            var f;
            return (f = d.animationState) === null || f === void 0 ? void 0 : f.setActive(l, c)
        }
        ),
        n[l].isActive = c;
        const h = o(l);
        for (const d in n)
            n[d].protectedKeys = {};
        return h
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: () => n,
        reset: () => {
            n = yE(),
            r = !0
        }
    }
}
function CH(t, e) {
    return typeof e == "string" ? e !== t : Array.isArray(e) ? !SR(e, t) : !1
}
function po(t=!1) {
    return {
        isActive: t,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function yE() {
    return {
        animate: po(!0),
        whileInView: po(),
        whileHover: po(),
        whileTap: po(),
        whileDrag: po(),
        whileFocus: po(),
        exit: po()
    }
}
class TH extends io {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = wH(e))
    }
    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        ym(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: e} = this.node.getProps()
          , {animate: n} = this.node.prevProps || {};
        e !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(),
        (e = this.unmountControls) === null || e === void 0 || e.call(this)
    }
}
let AH = 0;
class kH extends io {
    constructor() {
        super(...arguments),
        this.id = AH++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: e, onExitComplete: n} = this.node.presenceContext
          , {isPresent: r} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === r)
            return;
        const i = this.node.animationState.setActive("exit", !e);
        n && !e && i.then( () => n(this.id))
    }
    mount() {
        const {register: e} = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const RH = {
    animation: {
        Feature: TH
    },
    exit: {
        Feature: kH
    }
}
  , vE = (t, e) => Math.abs(t - e);
function IH(t, e) {
    const n = vE(t.x, e.x)
      , r = vE(t.y, e.y);
    return Math.sqrt(n ** 2 + r ** 2)
}
class i2 {
    constructor(e, n, {transformPagePoint: r, contextWindow: i, dragSnapToOrigin: s=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const h = Lg(this.lastMoveEventInfo, this.history)
              , d = this.startEvent !== null
              , f = IH(h.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!d && !f)
                return;
            const {point: g} = h
              , {timestamp: _} = fn;
            this.history.push({
                ...g,
                timestamp: _
            });
            const {onStart: m, onMove: p} = this.handlers;
            d || (m && m(this.lastMoveEvent, h),
            this.startEvent = this.lastMoveEvent),
            p && p(this.lastMoveEvent, h)
        }
        ,
        this.handlePointerMove = (h, d) => {
            this.lastMoveEvent = h,
            this.lastMoveEventInfo = Dg(d, this.transformPagePoint),
            vt.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (h, d) => {
            this.end();
            const {onEnd: f, onSessionEnd: g, resumeAnimation: _} = this.handlers;
            if (this.dragSnapToOrigin && _ && _(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const m = Lg(h.type === "pointercancel" ? this.lastMoveEventInfo : Dg(d, this.transformPagePoint), this.history);
            this.startEvent && f && f(h, m),
            g && g(h, m)
        }
        ,
        !bR(e))
            return;
        this.dragSnapToOrigin = s,
        this.handlers = n,
        this.transformPagePoint = r,
        this.contextWindow = i || window;
        const o = xm(e)
          , a = Dg(o, this.transformPagePoint)
          , {point: l} = a
          , {timestamp: c} = fn;
        this.history = [{
            ...l,
            timestamp: c
        }];
        const {onSessionStart: u} = n;
        u && u(e, Lg(a, this.history)),
        this.removeListeners = Yi(Ki(this.contextWindow, "pointermove", this.handlePointerMove), Ki(this.contextWindow, "pointerup", this.handlePointerUp), Ki(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        rs(this.updatePoint)
    }
}
function Dg(t, e) {
    return e ? {
        point: e(t.point)
    } : t
}
function xE(t, e) {
    return {
        x: t.x - e.x,
        y: t.y - e.y
    }
}
function Lg({point: t}, e) {
    return {
        point: t,
        delta: xE(t, s2(e)),
        offset: xE(t, PH(e)),
        velocity: DH(e, .1)
    }
}
function PH(t) {
    return t[0]
}
function s2(t) {
    return t[t.length - 1]
}
function DH(t, e) {
    if (t.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = t.length - 1
      , r = null;
    const i = s2(t);
    for (; n >= 0 && (r = t[n],
    !(i.timestamp - r.timestamp > Xi(e))); )
        n--;
    if (!r)
        return {
            x: 0,
            y: 0
        };
    const s = Ai(i.timestamp - r.timestamp);
    if (s === 0)
        return {
            x: 0,
            y: 0
        };
    const o = {
        x: (i.x - r.x) / s,
        y: (i.y - r.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0),
    o.y === 1 / 0 && (o.y = 0),
    o
}
function gr(t) {
    return t.max - t.min
}
function R_(t, e=0, n=.01) {
    return Math.abs(t - e) <= n
}
function EE(t, e, n, r=.5) {
    t.origin = r,
    t.originPoint = Ot(e.min, e.max, t.origin),
    t.scale = gr(n) / gr(e),
    (R_(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1),
    t.translate = Ot(n.min, n.max, t.origin) - t.originPoint,
    (R_(t.translate) || isNaN(t.translate)) && (t.translate = 0)
}
function Hc(t, e, n, r) {
    EE(t.x, e.x, n.x, r ? r.originX : void 0),
    EE(t.y, e.y, n.y, r ? r.originY : void 0)
}
function SE(t, e, n) {
    t.min = n.min + e.min,
    t.max = t.min + gr(e)
}
function LH(t, e, n) {
    SE(t.x, e.x, n.x),
    SE(t.y, e.y, n.y)
}
function wE(t, e, n) {
    t.min = e.min - n.min,
    t.max = t.min + gr(e)
}
function Uc(t, e, n) {
    wE(t.x, e.x, n.x),
    wE(t.y, e.y, n.y)
}
function OH(t, {min: e, max: n}, r) {
    return e !== void 0 && t < e ? t = r ? Ot(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Ot(n, t, r.max) : Math.min(t, n)),
    t
}
function CE(t, e, n) {
    return {
        min: e !== void 0 ? t.min + e : void 0,
        max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
    }
}
function NH(t, {top: e, left: n, bottom: r, right: i}) {
    return {
        x: CE(t.x, n, i),
        y: CE(t.y, e, r)
    }
}
function TE(t, e) {
    let n = e.min - t.min
      , r = e.max - t.max;
    return e.max - e.min < t.max - t.min && ([n,r] = [r, n]),
    {
        min: n,
        max: r
    }
}
function MH(t, e) {
    return {
        x: TE(t.x, e.x),
        y: TE(t.y, e.y)
    }
}
function BH(t, e) {
    let n = .5;
    const r = gr(t)
      , i = gr(e);
    return i > r ? n = wl(e.min, e.max - r, t.min) : r > i && (n = wl(t.min, t.max - i, e.min)),
    $s(0, 1, n)
}
function FH(t, e) {
    const n = {};
    return e.min !== void 0 && (n.min = e.min - t.min),
    e.max !== void 0 && (n.max = e.max - t.min),
    n
}
const I_ = .35;
function jH(t=I_) {
    return t === !1 ? t = 0 : t === !0 && (t = I_),
    {
        x: AE(t, "left", "right"),
        y: AE(t, "top", "bottom")
    }
}
function AE(t, e, n) {
    return {
        min: kE(t, e),
        max: kE(t, n)
    }
}
function kE(t, e) {
    return typeof t == "number" ? t : t[e] || 0
}
const RE = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , Ya = () => ({
    x: RE(),
    y: RE()
})
  , IE = () => ({
    min: 0,
    max: 0
})
  , Ht = () => ({
    x: IE(),
    y: IE()
});
function xr(t) {
    return [t("x"), t("y")]
}
function o2({top: t, left: e, right: n, bottom: r}) {
    return {
        x: {
            min: e,
            max: n
        },
        y: {
            min: t,
            max: r
        }
    }
}
function HH({x: t, y: e}) {
    return {
        top: e.min,
        right: t.max,
        bottom: e.max,
        left: t.min
    }
}
function UH(t, e) {
    if (!e)
        return t;
    const n = e({
        x: t.left,
        y: t.top
    })
      , r = e({
        x: t.right,
        y: t.bottom
    });
    return {
        top: n.y,
        left: n.x,
        bottom: r.y,
        right: r.x
    }
}
function Og(t) {
    return t === void 0 || t === 1
}
function P_({scale: t, scaleX: e, scaleY: n}) {
    return !Og(t) || !Og(e) || !Og(n)
}
function yo(t) {
    return P_(t) || a2(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
}
function a2(t) {
    return PE(t.x) || PE(t.y)
}
function PE(t) {
    return t && t !== "0%"
}
function Gf(t, e, n) {
    const r = t - n
      , i = e * r;
    return n + i
}
function DE(t, e, n, r, i) {
    return i !== void 0 && (t = Gf(t, i, r)),
    Gf(t, n, r) + e
}
function D_(t, e=0, n=1, r, i) {
    t.min = DE(t.min, e, n, r, i),
    t.max = DE(t.max, e, n, r, i)
}
function l2(t, {x: e, y: n}) {
    D_(t.x, e.translate, e.scale, e.originPoint),
    D_(t.y, n.translate, n.scale, n.originPoint)
}
function VH(t, e, n, r=!1) {
    const i = n.length;
    if (!i)
        return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < i; a++) {
        s = n[a],
        o = s.projectionDelta;
        const l = s.instance;
        l && l.style && l.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && Xa(t, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }),
        o && (e.x *= o.x.scale,
        e.y *= o.y.scale,
        l2(t, o)),
        r && yo(s.latestValues) && Xa(t, s.latestValues))
    }
    e.x = LE(e.x),
    e.y = LE(e.y)
}
function LE(t) {
    return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1
}
function xs(t, e) {
    t.min = t.min + e,
    t.max = t.max + e
}
function OE(t, e, [n,r,i]) {
    const s = e[i] !== void 0 ? e[i] : .5
      , o = Ot(t.min, t.max, s);
    D_(t, e[n], e[r], o, e.scale)
}
const $H = ["x", "scaleX", "originX"]
  , zH = ["y", "scaleY", "originY"];
function Xa(t, e) {
    OE(t.x, e, $H),
    OE(t.y, e, zH)
}
function c2(t, e) {
    return o2(UH(t.getBoundingClientRect(), e))
}
function WH(t, e, n) {
    const r = c2(t, n)
      , {scroll: i} = e;
    return i && (xs(r.x, i.offset.x),
    xs(r.y, i.offset.y)),
    r
}
const u2 = ({current: t}) => t ? t.ownerDocument.defaultView : null
  , GH = new WeakMap;
class qH {
    constructor(e) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = Ht(),
        this.visualElement = e
    }
    start(e, {snapToCursor: n=!1}={}) {
        const {presenceContext: r} = this.visualElement;
        if (r && r.isPresent === !1)
            return;
        const i = u => {
            const {dragSnapToOrigin: h} = this.getProps();
            h ? this.pauseAnimation() : this.stopAnimation(),
            n && this.snapToCursor(xm(u, "page").point)
        }
          , s = (u, h) => {
            const {drag: d, dragPropagation: f, onDragStart: g} = this.getProps();
            if (d && !f && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = vR(d),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            xr(m => {
                let p = this.getAxisMotionValue(m).get() || 0;
                if (Ti.test(p)) {
                    const {projection: b} = this.visualElement;
                    if (b && b.layout) {
                        const y = b.layout.layoutBox[m];
                        y && (p = gr(y) * (parseFloat(p) / 100))
                    }
                }
                this.originPoint[m] = p
            }
            ),
            g && vt.postRender( () => g(u, h));
            const {animationState: _} = this.visualElement;
            _ && _.setActive("whileDrag", !0)
        }
          , o = (u, h) => {
            const {dragPropagation: d, dragDirectionLock: f, onDirectionLock: g, onDrag: _} = this.getProps();
            if (!d && !this.openGlobalLock)
                return;
            const {offset: m} = h;
            if (f && this.currentDirection === null) {
                this.currentDirection = KH(m),
                this.currentDirection !== null && g && g(this.currentDirection);
                return
            }
            this.updateAxis("x", h.point, m),
            this.updateAxis("y", h.point, m),
            this.visualElement.render(),
            _ && _(u, h)
        }
          , a = (u, h) => this.stop(u, h)
          , l = () => xr(u => {
            var h;
            return this.getAnimationState(u) === "paused" && ((h = this.getAxisMotionValue(u).animation) === null || h === void 0 ? void 0 : h.play())
        }
        )
          , {dragSnapToOrigin: c} = this.getProps();
        this.panSession = new i2(e,{
            onSessionStart: i,
            onStart: s,
            onMove: o,
            onSessionEnd: a,
            resumeAnimation: l
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: c,
            contextWindow: u2(this.visualElement)
        })
    }
    stop(e, n) {
        const r = this.isDragging;
        if (this.cancel(),
        !r)
            return;
        const {velocity: i} = n;
        this.startAnimation(i);
        const {onDragEnd: s} = this.getProps();
        s && vt.postRender( () => s(e, n))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: n} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: r} = this.getProps();
        !r && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        n && n.setActive("whileDrag", !1)
    }
    updateAxis(e, n, r) {
        const {drag: i} = this.getProps();
        if (!r || !pd(e, i, this.currentDirection))
            return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + r[e];
        this.constraints && this.constraints[e] && (o = OH(o, this.constraints[e], this.elastic[e])),
        s.set(o)
    }
    resolveConstraints() {
        var e;
        const {dragConstraints: n, dragElastic: r} = this.getProps()
          , i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout
          , s = this.constraints;
        n && qa(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = NH(i.layoutBox, n) : this.constraints = !1,
        this.elastic = jH(r),
        s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && xr(o => {
            this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = FH(i.layoutBox[o], this.constraints[o]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: n} = this.getProps();
        if (!e || !qa(e))
            return !1;
        const r = e.current
          , {projection: i} = this.visualElement;
        if (!i || !i.layout)
            return !1;
        const s = WH(r, i.root, this.visualElement.getTransformPagePoint());
        let o = MH(i.layout.layoutBox, s);
        if (n) {
            const a = n(HH(o));
            this.hasMutatedConstraints = !!a,
            a && (o = o2(a))
        }
        return o
    }
    startAnimation(e) {
        const {drag: n, dragMomentum: r, dragElastic: i, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a} = this.getProps()
          , l = this.constraints || {}
          , c = xr(u => {
            if (!pd(u, n, this.currentDirection))
                return;
            let h = l && l[u] || {};
            o && (h = {
                min: 0,
                max: 0
            });
            const d = i ? 200 : 1e6
              , f = i ? 40 : 1e7
              , g = {
                type: "inertia",
                velocity: r ? e[u] : 0,
                bounceStiffness: d,
                bounceDamping: f,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...s,
                ...h
            };
            return this.startAxisValueAnimation(u, g)
        }
        );
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, n) {
        const r = this.getAxisMotionValue(e);
        return r.start(bv(e, r, 0, n, this.visualElement))
    }
    stopAnimation() {
        xr(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        xr(e => {
            var n;
            return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause()
        }
        )
    }
    getAnimationState(e) {
        var n;
        return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state
    }
    getAxisMotionValue(e) {
        const n = `_drag${e.toUpperCase()}`
          , r = this.visualElement.getProps()
          , i = r[n];
        return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        xr(n => {
            const {drag: r} = this.getProps();
            if (!pd(n, r, this.currentDirection))
                return;
            const {projection: i} = this.visualElement
              , s = this.getAxisMotionValue(n);
            if (i && i.layout) {
                const {min: o, max: a} = i.layout.layoutBox[n];
                s.set(e[n] - Ot(o, a, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: e, dragConstraints: n} = this.getProps()
          , {projection: r} = this.visualElement;
        if (!qa(n) || !r || !this.constraints)
            return;
        this.stopAnimation();
        const i = {
            x: 0,
            y: 0
        };
        xr(o => {
            const a = this.getAxisMotionValue(o);
            if (a && this.constraints !== !1) {
                const l = a.get();
                i[o] = BH({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        }
        );
        const {transformTemplate: s} = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none",
        r.root && r.root.updateScroll(),
        r.updateLayout(),
        this.resolveConstraints(),
        xr(o => {
            if (!pd(o, e, null))
                return;
            const a = this.getAxisMotionValue(o)
              , {min: l, max: c} = this.constraints[o];
            a.set(Ot(l, c, i[o]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        GH.set(this.visualElement, this);
        const e = this.visualElement.current
          , n = Ki(e, "pointerdown", l => {
            const {drag: c, dragListener: u=!0} = this.getProps();
            c && u && this.start(l)
        }
        )
          , r = () => {
            const {dragConstraints: l} = this.getProps();
            qa(l) && l.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: i} = this.visualElement
          , s = i.addEventListener("measure", r);
        i && !i.layout && (i.root && i.root.updateScroll(),
        i.updateLayout()),
        vt.read(r);
        const o = Wi(window, "resize", () => this.scalePositionWithinConstraints())
          , a = i.addEventListener("didUpdate", ({delta: l, hasLayoutChanged: c}) => {
            this.isDragging && c && (xr(u => {
                const h = this.getAxisMotionValue(u);
                h && (this.originPoint[u] += l[u].translate,
                h.set(h.get() + l[u].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            o(),
            n(),
            s(),
            a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps()
          , {drag: n=!1, dragDirectionLock: r=!1, dragPropagation: i=!1, dragConstraints: s=!1, dragElastic: o=I_, dragMomentum: a=!0} = e;
        return {
            ...e,
            drag: n,
            dragDirectionLock: r,
            dragPropagation: i,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}
function pd(t, e, n) {
    return (e === !0 || e === t) && (n === null || n === t)
}
function KH(t, e=10) {
    let n = null;
    return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"),
    n
}
class YH extends io {
    constructor(e) {
        super(e),
        this.removeGroupControls = Pn,
        this.removeListeners = Pn,
        this.controls = new qH(e)
    }
    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || Pn
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const NE = t => (e, n) => {
    t && vt.postRender( () => t(e, n))
}
;
class XH extends io {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = Pn
    }
    onPointerDown(e) {
        this.session = new i2(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: u2(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: i} = this.node.getProps();
        return {
            onSessionStart: NE(e),
            onStart: NE(n),
            onMove: r,
            onEnd: (s, o) => {
                delete this.session,
                i && vt.postRender( () => i(s, o))
            }
        }
    }
    mount() {
        this.removePointerDownListener = Ki(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function QH() {
    const t = S.useContext(bm);
    if (t === null)
        return [!0, null];
    const {isPresent: e, onExitComplete: n, register: r} = t
      , i = S.useId();
    return S.useEffect( () => r(i), []),
    !e && n ? [!1, () => n && n(i)] : [!0]
}
const ff = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function ME(t, e) {
    return e.max === e.min ? 0 : t / (e.max - e.min) * 100
}
const tc = {
    correct: (t, e) => {
        if (!e.target)
            return t;
        if (typeof t == "string")
            if (Ue.test(t))
                t = parseFloat(t);
            else
                return t;
        const n = ME(t, e.target.x)
          , r = ME(t, e.target.y);
        return `${n}% ${r}%`
    }
}
  , JH = {
    correct: (t, {treeScale: e, projectionDelta: n}) => {
        const r = t
          , i = zs.parse(t);
        if (i.length > 5)
            return r;
        const s = zs.createTransformer(t)
          , o = typeof i[0] != "number" ? 1 : 0
          , a = n.x.scale * e.x
          , l = n.y.scale * e.y;
        i[0 + o] /= a,
        i[1 + o] /= l;
        const c = Ot(a, l, .5);
        return typeof i[2 + o] == "number" && (i[2 + o] /= c),
        typeof i[3 + o] == "number" && (i[3 + o] /= c),
        s(i)
    }
};
class ZH extends S.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: i} = this.props
          , {projection: s} = e;
        i8(e9),
        s && (n.group && n.group.add(s),
        r && r.register && i && r.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        s.setOptions({
            ...s.options,
            onExitComplete: () => this.safeToRemove()
        })),
        ff.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: n, visualElement: r, drag: i, isPresent: s} = this.props
          , o = r.projection;
        return o && (o.isPresent = s,
        i || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(),
        e.isPresent !== s && (s ? o.promote() : o.relegate() || vt.postRender( () => {
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        qy.postRender( () => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: e, layoutGroup: n, switchLayoutGroup: r} = this.props
          , {projection: i} = e;
        i && (i.scheduleCheckAfterUnmount(),
        n && n.group && n.group.remove(i),
        r && r.deregister && r.deregister(i))
    }
    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
function h2(t) {
    const [e,n] = QH()
      , r = S.useContext(Xy);
    return v.jsx(ZH, {
        ...t,
        layoutGroup: r,
        switchLayoutGroup: S.useContext(rR),
        isPresent: e,
        safeToRemove: n
    })
}
const e9 = {
    borderRadius: {
        ...tc,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: tc,
    borderTopRightRadius: tc,
    borderBottomLeftRadius: tc,
    borderBottomRightRadius: tc,
    boxShadow: JH
}
  , d2 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , t9 = d2.length
  , BE = t => typeof t == "string" ? parseFloat(t) : t
  , FE = t => typeof t == "number" || Ue.test(t);
function n9(t, e, n, r, i, s) {
    i ? (t.opacity = Ot(0, n.opacity !== void 0 ? n.opacity : 1, r9(r)),
    t.opacityExit = Ot(e.opacity !== void 0 ? e.opacity : 1, 0, i9(r))) : s && (t.opacity = Ot(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
    for (let o = 0; o < t9; o++) {
        const a = `border${d2[o]}Radius`;
        let l = jE(e, a)
          , c = jE(n, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
        c || (c = 0),
        l === 0 || c === 0 || FE(l) === FE(c) ? (t[a] = Math.max(Ot(BE(l), BE(c), r), 0),
        (Ti.test(c) || Ti.test(l)) && (t[a] += "%")) : t[a] = c
    }
    (e.rotate || n.rotate) && (t.rotate = Ot(e.rotate || 0, n.rotate || 0, r))
}
function jE(t, e) {
    return t[e] !== void 0 ? t[e] : t.borderRadius
}
const r9 = f2(0, .5, GR)
  , i9 = f2(.5, .95, Pn);
function f2(t, e, n) {
    return r => r < t ? 0 : r > e ? 1 : n(wl(t, e, r))
}
function HE(t, e) {
    t.min = e.min,
    t.max = e.max
}
function yr(t, e) {
    HE(t.x, e.x),
    HE(t.y, e.y)
}
function UE(t, e, n, r, i) {
    return t -= e,
    t = Gf(t, 1 / n, r),
    i !== void 0 && (t = Gf(t, 1 / i, r)),
    t
}
function s9(t, e=0, n=1, r=.5, i, s=t, o=t) {
    if (Ti.test(e) && (e = parseFloat(e),
    e = Ot(o.min, o.max, e / 100) - o.min),
    typeof e != "number")
        return;
    let a = Ot(s.min, s.max, r);
    t === s && (a -= e),
    t.min = UE(t.min, e, n, a, i),
    t.max = UE(t.max, e, n, a, i)
}
function VE(t, e, [n,r,i], s, o) {
    s9(t, e[n], e[r], e[i], e.scale, s, o)
}
const o9 = ["x", "scaleX", "originX"]
  , a9 = ["y", "scaleY", "originY"];
function $E(t, e, n, r) {
    VE(t.x, e, o9, n ? n.x : void 0, r ? r.x : void 0),
    VE(t.y, e, a9, n ? n.y : void 0, r ? r.y : void 0)
}
function zE(t) {
    return t.translate === 0 && t.scale === 1
}
function p2(t) {
    return zE(t.x) && zE(t.y)
}
function l9(t, e) {
    return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max
}
function m2(t, e) {
    return Math.round(t.x.min) === Math.round(e.x.min) && Math.round(t.x.max) === Math.round(e.x.max) && Math.round(t.y.min) === Math.round(e.y.min) && Math.round(t.y.max) === Math.round(e.y.max)
}
function WE(t) {
    return gr(t.x) / gr(t.y)
}
class c9 {
    constructor() {
        this.members = []
    }
    add(e) {
        yv(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (wm(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(e) {
        const n = this.members.findIndex(i => e === i);
        if (n === 0)
            return !1;
        let r;
        for (let i = n; i >= 0; i--) {
            const s = this.members[i];
            if (s.isPresent !== !1) {
                r = s;
                break
            }
        }
        return r ? (this.promote(r),
        !0) : !1
    }
    promote(e, n) {
        const r = this.lead;
        if (e !== r && (this.prevLead = r,
        this.lead = e,
        e.show(),
        r)) {
            r.instance && r.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = r,
            n && (e.resumeFrom.preserveOpacity = !0),
            r.snapshot && (e.snapshot = r.snapshot,
            e.snapshot.latestValues = r.animationValues || r.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: i} = e.options;
            i === !1 && r.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {options: n, resumingFrom: r} = e;
            n.onExitComplete && n.onExitComplete(),
            r && r.options.onExitComplete && r.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function GE(t, e, n) {
    let r = "";
    const i = t.x.translate / e.x
      , s = t.y.translate / e.y
      , o = n?.z || 0;
    if ((i || s || o) && (r = `translate3d(${i}px, ${s}px, ${o}px) `),
    (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `),
    n) {
        const {transformPerspective: c, rotate: u, rotateX: h, rotateY: d, skewX: f, skewY: g} = n;
        c && (r = `perspective(${c}px) ${r}`),
        u && (r += `rotate(${u}deg) `),
        h && (r += `rotateX(${h}deg) `),
        d && (r += `rotateY(${d}deg) `),
        f && (r += `skewX(${f}deg) `),
        g && (r += `skewY(${g}deg) `)
    }
    const a = t.x.scale * e.x
      , l = t.y.scale * e.y;
    return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`),
    r || "none"
}
const u9 = (t, e) => t.depth - e.depth;
class h9 {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        yv(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        wm(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(u9),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
function d9(t, e) {
    const n = Ds.now()
      , r = ({timestamp: i}) => {
        const s = i - n;
        s >= e && (rs(r),
        t(s - e))
    }
    ;
    return vt.read(r, !0),
    () => rs(r)
}
function f9(t) {
    window.MotionDebug && window.MotionDebug.record(t)
}
function g2(t) {
    return t instanceof SVGElement && t.tagName !== "svg"
}
function Sv(t, e, n) {
    const r = un(t) ? t : pu(t);
    return r.start(bv("", r, e, n)),
    r.animation
}
const Ng = ["", "X", "Y", "Z"]
  , p9 = {
    visibility: "hidden"
}
  , qE = 1e3;
let m9 = 0;
const vo = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function Mg(t, e, n, r) {
    const {latestValues: i} = e;
    i[t] && (n[t] = i[t],
    e.setStaticValue(t, 0),
    r && (r[t] = 0))
}
function _2(t) {
    if (t.hasCheckedOptimisedAppear = !0,
    t.root === t)
        return !1;
    const {visualElement: e} = t.options;
    return e ? n2(e) ? !0 : t.parent && !t.parent.hasCheckedOptimisedAppear ? _2(t.parent) : !1 : !1
}
function b2({attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: i}) {
    return class {
        constructor(o={}, a=e?.()) {
            this.id = m9++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                vo.totalNodes = vo.resolvedTargetDeltas = vo.recalculatedProjection = 0,
                this.nodes.forEach(b9),
                this.nodes.forEach(S9),
                this.nodes.forEach(w9),
                this.nodes.forEach(y9),
                f9(vo)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = o,
            this.root = a ? a.root || a : this,
            this.path = a ? [...a.path, a] : [],
            this.parent = a,
            this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++)
                this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new h9)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new vv),
            this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        mount(o, a=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = g2(o),
            this.instance = o;
            const {layoutId: l, layout: c, visualElement: u} = this.options;
            if (u && !u.current && u.mount(o),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            a && (c || l) && (this.isLayoutDirty = !0),
            t) {
                let h;
                const d = () => this.root.updateBlockedByResize = !1;
                t(o, () => {
                    this.root.updateBlockedByResize = !0,
                    h && h(),
                    h = d9(d, 250),
                    ff.hasAnimatedSinceResize && (ff.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(YE))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
            this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({delta: h, hasLayoutChanged: d, hasRelativeTargetChanged: f, layout: g}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const _ = this.options.transition || u.getDefaultTransition() || R9
                  , {onLayoutAnimationStart: m, onLayoutAnimationComplete: p} = u.getProps()
                  , b = !this.targetLayout || !m2(this.targetLayout, g) || f
                  , y = !d && f;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || y || d && (b || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(h, y);
                    const x = {
                        ...ov(_, "layout"),
                        onPlay: m,
                        onComplete: p
                    };
                    (u.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0,
                    x.type = !1),
                    this.startAnimation(x)
                } else
                    d || YE(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = g
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            rs(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(C9),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: o} = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.HandoffCancelAllAnimations && _2(this) && window.HandoffCancelAllAnimations(),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let u = 0; u < this.path.length; u++) {
                const h = this.path[u];
                h.shouldResetTransform = !0,
                h.updateScroll("snapshot"),
                h.options.layoutRoot && h.willUpdate(!1)
            }
            const {layoutId: a, layout: l} = this.options;
            if (a === void 0 && !l)
                return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            o && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(KE);
                return
            }
            this.isUpdating || this.nodes.forEach(x9),
            this.isUpdating = !1,
            this.nodes.forEach(E9),
            this.nodes.forEach(g9),
            this.nodes.forEach(_9),
            this.clearAllSnapshots();
            const a = Ds.now();
            fn.delta = $s(0, 1e3 / 60, a - fn.timestamp),
            fn.timestamp = a,
            fn.isProcessing = !0,
            Cg.update.process(fn),
            Cg.preRender.process(fn),
            Cg.render.process(fn),
            fn.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            qy.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(v9),
            this.sharedNodes.forEach(T9)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            vt.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            vt.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = Ht(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: a} = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o="measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1),
            a && (this.scroll = {
                animationId: this.root.animationId,
                phase: o,
                isRoot: r(this.instance),
                offset: n(this.instance)
            })
        }
        resetTransform() {
            if (!i)
                return;
            const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , a = this.projectionDelta && !p2(this.projectionDelta)
              , l = this.getTransformTemplate()
              , c = l ? l(this.latestValues, "") : void 0
              , u = c !== this.prevTransformTemplateValue;
            o && (a || yo(this.latestValues) || u) && (i(this.instance, c),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(o=!0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)),
            I9(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: o} = this.options;
            if (!o)
                return Ht();
            const a = o.measureViewportBox()
              , {scroll: l} = this.root;
            return l && (xs(a.x, l.offset.x),
            xs(a.y, l.offset.y)),
            a
        }
        removeElementScroll(o) {
            const a = Ht();
            yr(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l]
                  , {scroll: u, options: h} = c;
                if (c !== this.root && u && h.layoutScroll) {
                    if (u.isRoot) {
                        yr(a, o);
                        const {scroll: d} = this.root;
                        d && (xs(a.x, -d.offset.x),
                        xs(a.y, -d.offset.y))
                    }
                    xs(a.x, u.offset.x),
                    xs(a.y, u.offset.y)
                }
            }
            return a
        }
        applyTransform(o, a=!1) {
            const l = Ht();
            yr(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const u = this.path[c];
                !a && u.options.layoutScroll && u.scroll && u !== u.root && Xa(l, {
                    x: -u.scroll.offset.x,
                    y: -u.scroll.offset.y
                }),
                yo(u.latestValues) && Xa(l, u.latestValues)
            }
            return yo(this.latestValues) && Xa(l, this.latestValues),
            l
        }
        removeTransform(o) {
            const a = Ht();
            yr(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !yo(c.latestValues))
                    continue;
                P_(c.latestValues) && c.updateSnapshot();
                const u = Ht()
                  , h = c.measurePageBox();
                yr(u, h),
                $E(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
            }
            return yo(this.latestValues) && $E(a, this.latestValues),
            a
        }
        setTargetDelta(o) {
            this.targetDelta = o,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = {
                ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== fn.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(o=!1) {
            var a;
            const l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const c = !!this.resumingFrom || this !== l;
            if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: h, layoutId: d} = this.options;
            if (!(!this.layout || !(h || d))) {
                if (this.resolvedRelativeTargetAt = fn.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const f = this.getClosestProjectingParent();
                    f && f.layout && this.animationProgress !== 1 ? (this.relativeParent = f,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = Ht(),
                    this.relativeTargetOrigin = Ht(),
                    Uc(this.relativeTargetOrigin, this.layout.layoutBox, f.layout.layoutBox),
                    yr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = Ht(),
                    this.targetWithTransforms = Ht()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    LH(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : yr(this.target, this.layout.layoutBox),
                    l2(this.target, this.targetDelta)) : yr(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const f = this.getClosestProjectingParent();
                        f && !!f.resumingFrom == !!this.resumingFrom && !f.options.layoutScroll && f.target && this.animationProgress !== 1 ? (this.relativeParent = f,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = Ht(),
                        this.relativeTargetOrigin = Ht(),
                        Uc(this.relativeTargetOrigin, this.target, f.target),
                        yr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    vo.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || P_(this.parent.latestValues) || a2(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead()
              , l = !!this.resumingFrom || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1),
            l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1),
            this.resolvedRelativeTargetAt === fn.timestamp && (c = !1),
            c)
                return;
            const {layout: u, layoutId: h} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(u || h))
                return;
            yr(this.layoutCorrected, this.layout.layoutBox);
            const d = this.treeScale.x
              , f = this.treeScale.y;
            VH(this.layoutCorrected, this.treeScale, this.path, l),
            a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox,
            a.targetWithTransforms = Ht());
            const {target: g} = a;
            if (!g) {
                this.projectionTransform && (this.projectionDelta = Ya(),
                this.projectionTransform = "none",
                this.scheduleRender());
                return
            }
            this.projectionDelta || (this.projectionDelta = Ya(),
            this.projectionDeltaWithTransform = Ya());
            const _ = this.projectionTransform;
            Hc(this.projectionDelta, this.layoutCorrected, g, this.latestValues),
            this.projectionTransform = GE(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== _ || this.treeScale.x !== d || this.treeScale.y !== f) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", g)),
            vo.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            o) {
                const a = this.getStack();
                a && a.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(o, a=!1) {
            const l = this.snapshot
              , c = l ? l.latestValues : {}
              , u = {
                ...this.latestValues
            }
              , h = Ya();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !a;
            const d = Ht()
              , f = l ? l.source : void 0
              , g = this.layout ? this.layout.source : void 0
              , _ = f !== g
              , m = this.getStack()
              , p = !m || m.members.length <= 1
              , b = !!(_ && !p && this.options.crossfade === !0 && !this.path.some(k9));
            this.animationProgress = 0;
            let y;
            this.mixTargetDelta = x => {
                const E = x / 1e3;
                XE(h.x, o.x, E),
                XE(h.y, o.y, E),
                this.setTargetDelta(h),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Uc(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                A9(this.relativeTarget, this.relativeTargetOrigin, d, E),
                y && l9(this.relativeTarget, y) && (this.isProjectionDirty = !1),
                y || (y = Ht()),
                yr(y, this.relativeTarget)),
                _ && (this.animationValues = u,
                n9(u, c, this.latestValues, E, b, p)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = E
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (rs(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = vt.update( () => {
                ff.hasAnimatedSinceResize = !0,
                this.currentAnimation = Sv(0, qE, {
                    ...o,
                    onUpdate: a => {
                        this.mixTargetDelta(a),
                        o.onUpdate && o.onUpdate(a)
                    }
                    ,
                    onComplete: () => {
                        o.onComplete && o.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(qE),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {targetWithTransforms: a, target: l, layout: c, latestValues: u} = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && y2(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || Ht();
                    const h = gr(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min,
                    l.x.max = l.x.min + h;
                    const d = gr(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min,
                    l.y.max = l.y.min + d
                }
                yr(a, l),
                Xa(a, u),
                Hc(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new c9),
            this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {layoutId: o} = this.options;
            if (o)
                return this.root.sharedNodes.get(o)
        }
        promote({needsReset: o, transition: a, preserveFollowOpacity: l}={}) {
            const c = this.getStack();
            c && c.promote(this, l),
            o && (this.projectionDelta = void 0,
            this.needsReset = !0),
            a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: o} = this.options;
            if (!o)
                return;
            let a = !1;
            const {latestValues: l} = o;
            if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0),
            !a)
                return;
            const c = {};
            l.z && Mg("z", o, c, this.animationValues);
            for (let u = 0; u < Ng.length; u++)
                Mg(`rotate${Ng[u]}`, o, c, this.animationValues),
                Mg(`skew${Ng[u]}`, o, c, this.animationValues);
            o.render();
            for (const u in c)
                o.setStaticValue(u, c[u]),
                this.animationValues && (this.animationValues[u] = c[u]);
            o.scheduleRender()
        }
        getProjectionStyles(o) {
            var a, l;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return p9;
            const c = {
                visibility: ""
            }
              , u = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                c.opacity = "",
                c.pointerEvents = hf(o?.pointerEvents) || "",
                c.transform = u ? u(this.latestValues, "") : "none",
                c;
            const h = this.getLead();
            if (!this.projectionDelta || !this.layout || !h.target) {
                const _ = {};
                return this.options.layoutId && (_.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                _.pointerEvents = hf(o?.pointerEvents) || ""),
                this.hasProjected && !yo(this.latestValues) && (_.transform = u ? u({}, "") : "none",
                this.hasProjected = !1),
                _
            }
            const d = h.animationValues || h.latestValues;
            this.applyTransformsToTarget(),
            c.transform = GE(this.projectionDeltaWithTransform, this.treeScale, d),
            u && (c.transform = u(d, c.transform));
            const {x: f, y: g} = this.projectionDelta;
            c.transformOrigin = `${f.origin * 100}% ${g.origin * 100}% 0`,
            h.animationValues ? c.opacity = h === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = h === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (const _ in Hf) {
                if (d[_] === void 0)
                    continue;
                const {correct: m, applyTo: p} = Hf[_]
                  , b = c.transform === "none" ? d[_] : m(d[_], h);
                if (p) {
                    const y = p.length;
                    for (let x = 0; x < y; x++)
                        c[p[x]] = b
                } else
                    c[_] = b
            }
            return this.options.layoutId && (c.pointerEvents = h === this ? hf(o?.pointerEvents) || "" : "none"),
            c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o => {
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }
            ),
            this.root.nodes.forEach(KE),
            this.root.sharedNodes.clear()
        }
    }
}
function g9(t) {
    t.updateLayout()
}
function _9(t) {
    var e;
    const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
    if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
        const {layoutBox: r, measuredBox: i} = t.layout
          , {animationType: s} = t.options
          , o = n.source !== t.layout.source;
        s === "size" ? xr(h => {
            const d = o ? n.measuredBox[h] : n.layoutBox[h]
              , f = gr(d);
            d.min = r[h].min,
            d.max = d.min + f
        }
        ) : y2(s, n.layoutBox, r) && xr(h => {
            const d = o ? n.measuredBox[h] : n.layoutBox[h]
              , f = gr(r[h]);
            d.max = d.min + f,
            t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0,
            t.relativeTarget[h].max = t.relativeTarget[h].min + f)
        }
        );
        const a = Ya();
        Hc(a, r, n.layoutBox);
        const l = Ya();
        o ? Hc(l, t.applyTransform(i, !0), n.measuredBox) : Hc(l, r, n.layoutBox);
        const c = !p2(a);
        let u = !1;
        if (!t.resumeFrom) {
            const h = t.getClosestProjectingParent();
            if (h && !h.resumeFrom) {
                const {snapshot: d, layout: f} = h;
                if (d && f) {
                    const g = Ht();
                    Uc(g, n.layoutBox, d.layoutBox);
                    const _ = Ht();
                    Uc(_, r, f.layoutBox),
                    m2(g, _) || (u = !0),
                    h.options.layoutRoot && (t.relativeTarget = _,
                    t.relativeTargetOrigin = g,
                    t.relativeParent = h)
                }
            }
        }
        t.notifyListeners("didUpdate", {
            layout: r,
            snapshot: n,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: u
        })
    } else if (t.isLead()) {
        const {onExitComplete: r} = t.options;
        r && r()
    }
    t.options.transition = void 0
}
function b9(t) {
    vo.totalNodes++,
    t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty),
    t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)),
    t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
}
function y9(t) {
    t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}
function v9(t) {
    t.clearSnapshot()
}
function KE(t) {
    t.clearMeasurements()
}
function x9(t) {
    t.isLayoutDirty = !1
}
function E9(t) {
    const {visualElement: e} = t.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    t.resetTransform()
}
function YE(t) {
    t.finishAnimation(),
    t.targetDelta = t.relativeTarget = t.target = void 0,
    t.isProjectionDirty = !0
}
function S9(t) {
    t.resolveTargetDelta()
}
function w9(t) {
    t.calcProjection()
}
function C9(t) {
    t.resetSkewAndRotation()
}
function T9(t) {
    t.removeLeadSnapshot()
}
function XE(t, e, n) {
    t.translate = Ot(e.translate, 0, n),
    t.scale = Ot(e.scale, 1, n),
    t.origin = e.origin,
    t.originPoint = e.originPoint
}
function QE(t, e, n, r) {
    t.min = Ot(e.min, n.min, r),
    t.max = Ot(e.max, n.max, r)
}
function A9(t, e, n, r) {
    QE(t.x, e.x, n.x, r),
    QE(t.y, e.y, n.y, r)
}
function k9(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0
}
const R9 = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , JE = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t)
  , ZE = JE("applewebkit/") && !JE("chrome/") ? Math.round : Pn;
function eS(t) {
    t.min = ZE(t.min),
    t.max = ZE(t.max)
}
function I9(t) {
    eS(t.x),
    eS(t.y)
}
function y2(t, e, n) {
    return t === "position" || t === "preserve-aspect" && !R_(WE(e), WE(n), .2)
}
const P9 = b2({
    attachResizeListener: (t, e) => Wi(t, "resize", e),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , Bg = {
    current: void 0
}
  , v2 = b2({
    measureScroll: t => ({
        x: t.scrollLeft,
        y: t.scrollTop
    }),
    defaultParent: () => {
        if (!Bg.current) {
            const t = new P9({});
            t.mount(window),
            t.setOptions({
                layoutScroll: !0
            }),
            Bg.current = t
        }
        return Bg.current
    }
    ,
    resetTransform: (t, e) => {
        t.style.transform = e !== void 0 ? e : "none"
    }
    ,
    checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed"
})
  , D9 = {
    pan: {
        Feature: XH
    },
    drag: {
        Feature: YH,
        ProjectionNode: v2,
        MeasureLayout: h2
    }
}
  , L_ = {
    current: null
}
  , x2 = {
    current: !1
};
function L9() {
    if (x2.current = !0,
    !!Wy)
        if (window.matchMedia) {
            const t = window.matchMedia("(prefers-reduced-motion)")
              , e = () => L_.current = t.matches;
            t.addListener(e),
            e()
        } else
            L_.current = !1
}
function O9(t, e, n) {
    const {willChange: r} = e;
    for (const i in e) {
        const s = e[i]
          , o = n[i];
        if (un(s))
            t.addValue(i, s),
            Wf(r) && r.add(i);
        else if (un(o))
            t.addValue(i, pu(s, {
                owner: t
            })),
            Wf(r) && r.remove(i);
        else if (o !== s)
            if (t.hasValue(i)) {
                const a = t.getValue(i);
                a.liveStyle === !0 ? a.jump(s) : a.hasAnimated || a.set(s)
            } else {
                const a = t.getStaticValue(i);
                t.addValue(i, pu(a !== void 0 ? a : s, {
                    owner: t
                }))
            }
    }
    for (const i in n)
        e[i] === void 0 && t.removeValue(i);
    return e
}
const mu = new WeakMap
  , N9 = [...kR, Cn, zs]
  , M9 = t => N9.find(AR(t))
  , tS = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , B9 = Yy.length;
class F9 {
    scrapeMotionValuesFromProps(e, n, r) {
        return {}
    }
    constructor({parent: e, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: o}, a={}) {
        this.resolveKeyframes = (d, f, g, _) => new this.KeyframeResolver(d,f,g,_,this),
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = av,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = () => vt.render(this.render, !1, !0);
        const {latestValues: l, renderState: c} = o;
        this.latestValues = l,
        this.baseTarget = {
            ...l
        },
        this.initialValues = n.initial ? {
            ...l
        } : {},
        this.renderState = c,
        this.parent = e,
        this.props = n,
        this.presenceContext = r,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = i,
        this.options = a,
        this.blockInitialAnimation = !!s,
        this.isControllingVariants = vm(n),
        this.isVariantNode = sR(n),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(e && e.current);
        const {willChange: u, ...h} = this.scrapeMotionValuesFromProps(n, {}, this);
        for (const d in h) {
            const f = h[d];
            l[d] !== void 0 && un(f) && (f.set(l[d], !1),
            Wf(u) && u.add(d))
        }
    }
    mount(e) {
        this.current = e,
        mu.set(e, this),
        this.projection && !this.projection.instance && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (n, r) => this.bindToMotionValue(r, n)),
        x2.current || L9(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : L_.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        mu.delete(this.current),
        this.projection && this.projection.unmount(),
        rs(this.notifyUpdate),
        rs(this.render),
        this.valueSubscriptions.forEach(e => e()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const e in this.events)
            this.events[e].clear();
        for (const e in this.features) {
            const n = this.features[e];
            n && (n.unmount(),
            n.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(e, n) {
        const r = _a.has(e)
          , i = n.on("change", o => {
            this.latestValues[e] = o,
            this.props.onUpdate && vt.preRender(this.notifyUpdate),
            r && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , s = n.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(e, () => {
            i(),
            s(),
            n.owner && n.stop()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in El) {
            const n = El[e];
            if (!n)
                continue;
            const {isEnabled: r, Feature: i} = n;
            if (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)),
            this.features[e]) {
                const s = this.features[e];
                s.isMounted ? s.update() : (s.mount(),
                s.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ht()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, n) {
        this.latestValues[e] = n
    }
    update(e, n) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = n;
        for (let r = 0; r < tS.length; r++) {
            const i = tS[r];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](),
            delete this.propEventSubscriptions[i]);
            const s = "on" + i
              , o = e[s];
            o && (this.propEventSubscriptions[i] = this.on(i, o))
        }
        this.prevMotionValues = O9(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(e=!1) {
        if (e)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const r = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (r.initial = this.props.initial),
            r
        }
        const n = {};
        for (let r = 0; r < B9; r++) {
            const i = Yy[r]
              , s = this.props[i];
            (hu(s) || s === !1) && (n[i] = s)
        }
        return n
    }
    addVariantChild(e) {
        const n = this.getClosestVariantNode();
        if (n)
            return n.variantChildren && n.variantChildren.add(e),
            () => n.variantChildren.delete(e)
    }
    addValue(e, n) {
        const r = this.values.get(e);
        n !== r && (r && this.removeValue(e),
        this.bindToMotionValue(e, n),
        this.values.set(e, n),
        this.latestValues[e] = n.get())
    }
    removeValue(e) {
        this.values.delete(e);
        const n = this.valueSubscriptions.get(e);
        n && (n(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, n) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let r = this.values.get(e);
        return r === void 0 && n !== void 0 && (r = pu(n === null ? void 0 : n, {
            owner: this
        }),
        this.addValue(e, r)),
        r
    }
    readValue(e, n) {
        var r;
        let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options);
        return i != null && (typeof i == "string" && (CR(i) || wR(i)) ? i = parseFloat(i) : !M9(i) && zs.test(n) && (i = MR(e, n)),
        this.setBaseTarget(e, un(i) ? i.get() : i)),
        un(i) ? i.get() : i
    }
    setBaseTarget(e, n) {
        this.baseTarget[e] = n
    }
    getBaseTarget(e) {
        var n;
        const {initial: r} = this.props;
        let i;
        if (typeof r == "string" || typeof r == "object") {
            const o = sv(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
            o && (i = o[e])
        }
        if (r && i !== void 0)
            return i;
        const s = this.getBaseTargetFromProps(this.props, e);
        return s !== void 0 && !un(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, n) {
        return this.events[e] || (this.events[e] = new vv),
        this.events[e].add(n)
    }
    notify(e, ...n) {
        this.events[e] && this.events[e].notify(...n)
    }
}
class E2 extends F9 {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = BR
    }
    sortInstanceNodePosition(e, n) {
        return e.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, n) {
        return e.style ? e.style[n] : void 0
    }
    removeValueFromRenderState(e, {vars: n, style: r}) {
        delete n[e],
        delete r[e]
    }
}
function j9(t) {
    return window.getComputedStyle(t)
}
class S2 extends E2 {
    constructor() {
        super(...arguments),
        this.type = "html"
    }
    readValueFromInstance(e, n) {
        if (_a.has(n)) {
            const r = cv(n);
            return r && r.default || 0
        } else {
            const r = j9(e)
              , i = (lR(n) ? r.getPropertyValue(n) : r[n]) || 0;
            return typeof i == "string" ? i.trim() : i
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: n}) {
        return c2(e, n)
    }
    build(e, n, r, i) {
        ev(e, n, r, i.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, n, r) {
        return iv(e, n, r)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: e} = this.props;
        un(e) && (this.childSubscription = e.on("change", n => {
            this.current && (this.current.textContent = `${n}`)
        }
        ))
    }
    renderInstance(e, n, r, i) {
        fR(e, n, r, i)
    }
}
class w2 extends E2 {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(e, n) {
        return e[n]
    }
    readValueFromInstance(e, n) {
        if (_a.has(n)) {
            const r = cv(n);
            return r && r.default || 0
        }
        return n = pR.has(n) ? n : Gy(n),
        e.getAttribute(n)
    }
    measureInstanceViewportBox() {
        return Ht()
    }
    scrapeMotionValuesFromProps(e, n, r) {
        return gR(e, n, r)
    }
    build(e, n, r, i) {
        nv(e, n, r, this.isSVGTag, i.transformTemplate)
    }
    renderInstance(e, n, r, i) {
        mR(e, n, r, i)
    }
    mount(e) {
        this.isSVGTag = rv(e.tagName),
        super.mount(e)
    }
}
const H9 = (t, e) => Qy(t) ? new w2(e,{
    enableHardwareAcceleration: !1
}) : new S2(e,{
    allowProjection: t !== S.Fragment,
    enableHardwareAcceleration: !0
})
  , U9 = {
    layout: {
        ProjectionNode: v2,
        MeasureLayout: h2
    }
}
  , V9 = {
    ...RH,
    ...G8,
    ...D9,
    ...U9
}
  , It = n8( (t, e) => L8(t, e, V9, H9));
function C2() {
    const t = S.useRef(!1);
    return Rh( () => (t.current = !0,
    () => {
        t.current = !1
    }
    ), []),
    t
}
function $9() {
    const t = C2()
      , [e,n] = S.useState(0)
      , r = S.useCallback( () => {
        t.current && n(e + 1)
    }
    , [e]);
    return [S.useCallback( () => vt.postRender(r), [r]), e]
}
class z9 extends S.Component {
    getSnapshotBeforeUpdate(e) {
        const n = this.props.childRef.current;
        if (n && e.isPresent && !this.props.isPresent) {
            const r = this.props.sizeRef.current;
            r.height = n.offsetHeight || 0,
            r.width = n.offsetWidth || 0,
            r.top = n.offsetTop,
            r.left = n.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function W9({children: t, isPresent: e}) {
    const n = S.useId()
      , r = S.useRef(null)
      , i = S.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0
    })
      , {nonce: s} = S.useContext(zy);
    return S.useInsertionEffect( () => {
        const {width: o, height: a, top: l, left: c} = i.current;
        if (e || !r.current || !o || !a)
            return;
        r.current.dataset.motionPopId = n;
        const u = document.createElement("style");
        return s && (u.nonce = s),
        document.head.appendChild(u),
        u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `),
        () => {
            document.head.removeChild(u)
        }
    }
    , [e]),
    v.jsx(z9, {
        isPresent: e,
        childRef: r,
        sizeRef: i,
        children: S.cloneElement(t, {
            ref: r
        })
    })
}
const Fg = ({children: t, initial: e, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: s, mode: o}) => {
    const a = du(G9)
      , l = S.useId()
      , c = S.useMemo( () => ({
        id: l,
        initial: e,
        isPresent: n,
        custom: i,
        onExitComplete: u => {
            a.set(u, !0);
            for (const h of a.values())
                if (!h)
                    return;
            r && r()
        }
        ,
        register: u => (a.set(u, !1),
        () => a.delete(u))
    }), s ? [Math.random()] : [n]);
    return S.useMemo( () => {
        a.forEach( (u, h) => a.set(h, !1))
    }
    , [n]),
    S.useEffect( () => {
        !n && !a.size && r && r()
    }
    , [n]),
    o === "popLayout" && (t = v.jsx(W9, {
        isPresent: n,
        children: t
    })),
    v.jsx(bm.Provider, {
        value: c,
        children: t
    })
}
;
function G9() {
    return new Map
}
function T2(t) {
    return S.useEffect( () => () => t(), [])
}
const xo = t => t.key || "";
function q9(t, e) {
    t.forEach(n => {
        const r = xo(n);
        e.set(r, n)
    }
    )
}
function K9(t) {
    const e = [];
    return S.Children.forEach(t, n => {
        S.isValidElement(n) && e.push(n)
    }
    ),
    e
}
const hs = ({children: t, custom: e, initial: n=!0, onExitComplete: r, exitBeforeEnter: i, presenceAffectsLayout: s=!0, mode: o="sync"}) => {
    const a = S.useContext(Xy).forceRender || $9()[0]
      , l = C2()
      , c = K9(t);
    let u = c;
    const h = S.useRef(new Map).current
      , d = S.useRef(u)
      , f = S.useRef(new Map).current
      , g = S.useRef(!0);
    if (Rh( () => {
        g.current = !1,
        q9(c, f),
        d.current = u
    }
    ),
    T2( () => {
        g.current = !0,
        f.clear(),
        h.clear()
    }
    ),
    g.current)
        return v.jsx(v.Fragment, {
            children: u.map(b => v.jsx(Fg, {
                isPresent: !0,
                initial: n ? void 0 : !1,
                presenceAffectsLayout: s,
                mode: o,
                children: b
            }, xo(b)))
        });
    u = [...u];
    const _ = d.current.map(xo)
      , m = c.map(xo)
      , p = _.length;
    for (let b = 0; b < p; b++) {
        const y = _[b];
        m.indexOf(y) === -1 && !h.has(y) && h.set(y, void 0)
    }
    return o === "wait" && h.size && (u = []),
    h.forEach( (b, y) => {
        if (m.indexOf(y) !== -1)
            return;
        const x = f.get(y);
        if (!x)
            return;
        const E = _.indexOf(y);
        let w = b;
        if (!w) {
            const A = () => {
                h.delete(y);
                const C = Array.from(f.keys()).filter(k => !m.includes(k));
                if (C.forEach(k => f.delete(k)),
                d.current = c.filter(k => {
                    const I = xo(k);
                    return I === y || C.includes(I)
                }
                ),
                !h.size) {
                    if (l.current === !1)
                        return;
                    a(),
                    r && r()
                }
            }
            ;
            w = v.jsx(Fg, {
                isPresent: !1,
                onExitComplete: A,
                custom: e,
                presenceAffectsLayout: s,
                mode: o,
                children: x
            }, xo(x)),
            h.set(y, w)
        }
        u.splice(E, 0, w)
    }
    ),
    u = u.map(b => {
        const y = b.key;
        return h.has(y) ? b : v.jsx(Fg, {
            isPresent: !0,
            presenceAffectsLayout: s,
            mode: o,
            children: b
        }, xo(b))
    }
    ),
    v.jsx(v.Fragment, {
        children: h.size ? u : u.map(b => S.cloneElement(b))
    })
}
;
function A2(t, e, n) {
    var r;
    if (typeof t == "string") {
        let i = document;
        e && (jf(!!e.current),
        i = e.current),
        n ? ((r = n[t]) !== null && r !== void 0 || (n[t] = i.querySelectorAll(t)),
        t = n[t]) : t = i.querySelectorAll(t)
    } else
        t instanceof Element && (t = [t]);
    return Array.from(t || [])
}
function Y9(t) {
    t.values.forEach(e => e.stop())
}
function O_(t, e) {
    [...e].reverse().forEach(r => {
        const i = t.getVariant(r);
        i && xv(t, i),
        t.variantChildren && t.variantChildren.forEach(s => {
            O_(s, e)
        }
        )
    }
    )
}
function X9(t, e) {
    if (Array.isArray(e))
        return O_(t, e);
    if (typeof e == "string")
        return O_(t, [e]);
    xv(t, e)
}
function Q9() {
    const t = new Set
      , e = {
        subscribe(n) {
            return t.add(n),
            () => void t.delete(n)
        },
        start(n, r) {
            const i = [];
            return t.forEach(s => {
                i.push(r2(s, n, {
                    transitionOverride: r
                }))
            }
            ),
            Promise.all(i)
        },
        set(n) {
            return t.forEach(r => {
                X9(r, n)
            }
            )
        },
        stop() {
            t.forEach(n => {
                Y9(n)
            }
            )
        },
        mount() {
            return () => {
                e.stop()
            }
        }
    };
    return e
}
function J9(t) {
    return typeof t == "object" && !Array.isArray(t)
}
function Z9(t) {
    const e = {
        presenceContext: null,
        props: {},
        visualState: {
            renderState: {
                transform: {},
                transformOrigin: {},
                style: {},
                vars: {},
                attrs: {}
            },
            latestValues: {}
        }
    }
      , n = g2(t) ? new w2(e,{
        enableHardwareAcceleration: !1
    }) : new S2(e,{
        enableHardwareAcceleration: !0
    });
    n.mount(t),
    mu.set(t, n)
}
function eU(t, e=100) {
    const n = uv({
        keyframes: [0, e],
        ...t
    })
      , r = Math.min(JR(n), A_);
    return {
        type: "keyframes",
        ease: i => n.next(r * i).value / e,
        duration: Ai(r)
    }
}
function nS(t, e, n, r) {
    var i;
    return typeof e == "number" ? e : e.startsWith("-") || e.startsWith("+") ? Math.max(0, t + parseFloat(e)) : e === "<" ? n : (i = r.get(e)) !== null && i !== void 0 ? i : t
}
const tU = (t, e, n) => {
    const r = e - t;
    return ((n - t) % r + r) % r + t
}
;
function nU(t, e) {
    return $R(t) ? t[tU(0, t.length, e)] : t
}
function rU(t, e, n) {
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        i.at > e && i.at < n && (wm(t, i),
        r--)
    }
}
function iU(t, e, n, r, i, s) {
    rU(t, i, s);
    for (let o = 0; o < e.length; o++)
        t.push({
            value: e[o],
            at: Ot(i, s, r[o]),
            easing: nU(n, o)
        })
}
function sU(t, e) {
    return t.at === e.at ? t.value === null ? 1 : e.value === null ? -1 : 0 : t.at - e.at
}
const oU = "easeInOut";
function aU(t, {defaultTransition: e={}, ...n}={}, r) {
    const i = e.duration || .3
      , s = new Map
      , o = new Map
      , a = {}
      , l = new Map;
    let c = 0
      , u = 0
      , h = 0;
    for (let d = 0; d < t.length; d++) {
        const f = t[d];
        if (typeof f == "string") {
            l.set(f, u);
            continue
        } else if (!Array.isArray(f)) {
            l.set(f.name, nS(u, f.at, c, l));
            continue
        }
        let[g,_,m={}] = f;
        m.at !== void 0 && (u = nS(u, m.at, c, l));
        let p = 0;
        const b = (y, x, E, w=0, A=0) => {
            const C = lU(y)
              , {delay: k=0, times: I=QR(C), type: N="keyframes", ...O} = x;
            let {ease: M=e.ease || "easeOut", duration: H} = x;
            const $ = typeof k == "function" ? k(w, A) : k
              , J = C.length;
            if (J <= 2 && N === "spring") {
                let L = 100;
                if (J === 2 && hU(C)) {
                    const B = C[1] - C[0];
                    L = Math.abs(B)
                }
                const z = {
                    ...O
                };
                H !== void 0 && (z.duration = Xi(H));
                const V = eU(z, L);
                M = V.ease,
                H = V.duration
            }
            H ?? (H = i);
            const Q = u + $
              , ee = Q + H;
            I.length === 1 && I[0] === 0 && (I[1] = 1);
            const D = I.length - C.length;
            D > 0 && XR(I, D),
            C.length === 1 && C.unshift(null),
            iU(E, C, M, I, Q, ee),
            p = Math.max($ + H, p),
            h = Math.max(ee, h)
        }
        ;
        if (un(g)) {
            const y = rS(g, o);
            b(_, m, iS("default", y))
        } else {
            const y = A2(g, r, a)
              , x = y.length;
            for (let E = 0; E < x; E++) {
                _ = _,
                m = m;
                const w = y[E]
                  , A = rS(w, o);
                for (const C in _)
                    b(_[C], cU(m, C), iS(C, A), E, x)
            }
        }
        c = u,
        u += p
    }
    return o.forEach( (d, f) => {
        for (const g in d) {
            const _ = d[g];
            _.sort(sU);
            const m = []
              , p = []
              , b = [];
            for (let x = 0; x < _.length; x++) {
                const {at: E, value: w, easing: A} = _[x];
                m.push(w),
                p.push(wl(0, h, E)),
                b.push(A || "easeOut")
            }
            p[0] !== 0 && (p.unshift(0),
            m.unshift(m[0]),
            b.unshift(oU)),
            p[p.length - 1] !== 1 && (p.push(1),
            m.push(null)),
            s.has(f) || s.set(f, {
                keyframes: {},
                transition: {}
            });
            const y = s.get(f);
            y.keyframes[g] = m,
            y.transition[g] = {
                ...e,
                duration: h,
                ease: b,
                times: p,
                ...n
            }
        }
    }
    ),
    s
}
function rS(t, e) {
    return !e.has(t) && e.set(t, {}),
    e.get(t)
}
function iS(t, e) {
    return e[t] || (e[t] = []),
    e[t]
}
function lU(t) {
    return Array.isArray(t) ? t : [t]
}
function cU(t, e) {
    return t[e] ? {
        ...t,
        ...t[e]
    } : {
        ...t
    }
}
const uU = t => typeof t == "number"
  , hU = t => t.every(uU);
function k2(t, e, n, r) {
    const i = A2(t, r)
      , s = i.length
      , o = [];
    for (let a = 0; a < s; a++) {
        const l = i[a];
        mu.has(l) || Z9(l);
        const c = mu.get(l)
          , u = {
            ...n
        };
        typeof u.delay == "function" && (u.delay = u.delay(a, s)),
        o.push(...Ev(c, {
            ...e,
            transition: u
        }, {}))
    }
    return new _v(o)
}
const dU = t => Array.isArray(t) && Array.isArray(t[0]);
function fU(t, e, n) {
    const r = [];
    return aU(t, e, n).forEach( ({keyframes: s, transition: o}, a) => {
        let l;
        un(a) ? l = Sv(a, s.default, o.default) : l = k2(a, s, o),
        r.push(l)
    }
    ),
    new _v(r)
}
const pU = t => {
    function e(n, r, i) {
        let s;
        return dU(n) ? s = fU(n, r, t) : J9(r) ? s = k2(n, r, i, t) : s = Sv(n, r, i),
        t && t.animations.push(s),
        s
    }
    return e
}
;
function mU() {
    const t = du( () => ({
        current: null,
        animations: []
    }))
      , e = du( () => pU(t));
    return T2( () => {
        t.animations.forEach(n => n.stop())
    }
    ),
    [t, e]
}
function gU() {
    const t = du(Q9);
    return Rh(t.mount, []),
    t
}
const _U = "_Shadow_11hxj_1"
  , bU = {
    Shadow: _U
}
  , yU = {
    visible: {
        marginBottom: "-2.5rem",
        height: "2.5rem",
        opacity: 1
    },
    hidden: {
        marginBottom: 0,
        height: 0,
        opacity: 0
    }
};
function sS({spin: t, style: e}) {
    const n = t !== !1;
    return v.jsx(It.div, {
        className: be(bU.Shadow, {
            "grow-1": n
        }, "sticky w-full"),
        variants: yU,
        transition: {
            duration: .1
        },
        style: e,
        animate: n ? "visible" : "hidden",
        children: n && v.jsx("div", {
            className: "text-center w-full text-bolt-elements-textSecondary i-svg-spinners:3-dots-fade text-4xl origin-center shr h-10"
        })
    })
}
function oS(t) {
    const e = []
      , n = String(t || "");
    let r = n.indexOf(",")
      , i = 0
      , s = !1;
    for (; !s; ) {
        r === -1 && (r = n.length,
        s = !0);
        const o = n.slice(i, r).trim();
        (o || !s) && e.push(o),
        i = r + 1,
        r = n.indexOf(",", i)
    }
    return e
}
function R2(t, e) {
    const n = {};
    return (t[t.length - 1] === "" ? [...t, ""] : t).join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")).trim()
}
const vU = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u
  , xU = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u
  , EU = {};
function aS(t, e) {
    return (EU.jsx ? xU : vU).test(t)
}
const SU = /[ \t\n\f\r]/g;
function wU(t) {
    return typeof t == "object" ? t.type === "text" ? lS(t.value) : !1 : lS(t)
}
function lS(t) {
    return t.replace(SU, "") === ""
}
let Lh = class {
    constructor(e, n, r) {
        this.property = e,
        this.normal = n,
        r && (this.space = r)
    }
}
;
Lh.prototype.property = {};
Lh.prototype.normal = {};
Lh.prototype.space = null;
function I2(t, e) {
    const n = {}
      , r = {};
    let i = -1;
    for (; ++i < t.length; )
        Object.assign(n, t[i].property),
        Object.assign(r, t[i].normal);
    return new Lh(n,r,e)
}
function gu(t) {
    return t.toLowerCase()
}
let Br = class {
    constructor(e, n) {
        this.property = e,
        this.attribute = n
    }
}
;
Br.prototype.space = null;
Br.prototype.boolean = !1;
Br.prototype.booleanish = !1;
Br.prototype.overloadedBoolean = !1;
Br.prototype.number = !1;
Br.prototype.commaSeparated = !1;
Br.prototype.spaceSeparated = !1;
Br.prototype.commaOrSpaceSeparated = !1;
Br.prototype.mustUseProperty = !1;
Br.prototype.defined = !1;
let CU = 0;
const Ye = ya()
  , Wt = ya()
  , P2 = ya()
  , ve = ya()
  , kt = ya()
  , al = ya()
  , sr = ya();
function ya() {
    return 2 ** ++CU
}
const N_ = Object.freeze(Object.defineProperty({
    __proto__: null,
    boolean: Ye,
    booleanish: Wt,
    commaOrSpaceSeparated: sr,
    commaSeparated: al,
    number: ve,
    overloadedBoolean: P2,
    spaceSeparated: kt
}, Symbol.toStringTag, {
    value: "Module"
}))
  , jg = Object.keys(N_);
let wv = class extends Br {
    constructor(e, n, r, i) {
        let s = -1;
        if (super(e, n),
        cS(this, "space", i),
        typeof r == "number")
            for (; ++s < jg.length; ) {
                const o = jg[s];
                cS(this, jg[s], (r & N_[o]) === N_[o])
            }
    }
}
;
wv.prototype.defined = !0;
function cS(t, e, n) {
    n && (t[e] = n)
}
const TU = {}.hasOwnProperty;
function Vl(t) {
    const e = {}
      , n = {};
    let r;
    for (r in t.properties)
        if (TU.call(t.properties, r)) {
            const i = t.properties[r]
              , s = new wv(r,t.transform(t.attributes || {}, r),i,t.space);
            t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0),
            e[r] = s,
            n[gu(r)] = r,
            n[gu(s.attribute)] = r
        }
    return new Lh(e,n,t.space)
}
const D2 = Vl({
    space: "xlink",
    transform(t, e) {
        return "xlink:" + e.slice(5).toLowerCase()
    },
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
})
  , L2 = Vl({
    space: "xml",
    transform(t, e) {
        return "xml:" + e.slice(3).toLowerCase()
    },
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function O2(t, e) {
    return e in t ? t[e] : e
}
function N2(t, e) {
    return O2(t, e.toLowerCase())
}
const M2 = Vl({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: N2,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
})
  , B2 = Vl({
    transform(t, e) {
        return e === "role" ? e : "aria-" + e.slice(4).toLowerCase()
    },
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: Wt,
        ariaAutoComplete: null,
        ariaBusy: Wt,
        ariaChecked: Wt,
        ariaColCount: ve,
        ariaColIndex: ve,
        ariaColSpan: ve,
        ariaControls: kt,
        ariaCurrent: null,
        ariaDescribedBy: kt,
        ariaDetails: null,
        ariaDisabled: Wt,
        ariaDropEffect: kt,
        ariaErrorMessage: null,
        ariaExpanded: Wt,
        ariaFlowTo: kt,
        ariaGrabbed: Wt,
        ariaHasPopup: null,
        ariaHidden: Wt,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: kt,
        ariaLevel: ve,
        ariaLive: null,
        ariaModal: Wt,
        ariaMultiLine: Wt,
        ariaMultiSelectable: Wt,
        ariaOrientation: null,
        ariaOwns: kt,
        ariaPlaceholder: null,
        ariaPosInSet: ve,
        ariaPressed: Wt,
        ariaReadOnly: Wt,
        ariaRelevant: null,
        ariaRequired: Wt,
        ariaRoleDescription: kt,
        ariaRowCount: ve,
        ariaRowIndex: ve,
        ariaRowSpan: ve,
        ariaSelected: Wt,
        ariaSetSize: ve,
        ariaSort: null,
        ariaValueMax: ve,
        ariaValueMin: ve,
        ariaValueNow: ve,
        ariaValueText: null,
        role: null
    }
})
  , AU = Vl({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: N2,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
        abbr: null,
        accept: al,
        acceptCharset: kt,
        accessKey: kt,
        action: null,
        allow: null,
        allowFullScreen: Ye,
        allowPaymentRequest: Ye,
        allowUserMedia: Ye,
        alt: null,
        as: null,
        async: Ye,
        autoCapitalize: null,
        autoComplete: kt,
        autoFocus: Ye,
        autoPlay: Ye,
        blocking: kt,
        capture: null,
        charSet: null,
        checked: Ye,
        cite: null,
        className: kt,
        cols: ve,
        colSpan: null,
        content: null,
        contentEditable: Wt,
        controls: Ye,
        controlsList: kt,
        coords: ve | al,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: Ye,
        defer: Ye,
        dir: null,
        dirName: null,
        disabled: Ye,
        download: P2,
        draggable: Wt,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: Ye,
        formTarget: null,
        headers: kt,
        height: ve,
        hidden: Ye,
        high: ve,
        href: null,
        hrefLang: null,
        htmlFor: kt,
        httpEquiv: kt,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: Ye,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: Ye,
        itemId: null,
        itemProp: kt,
        itemRef: kt,
        itemScope: Ye,
        itemType: kt,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: Ye,
        low: ve,
        manifest: null,
        max: null,
        maxLength: ve,
        media: null,
        method: null,
        min: null,
        minLength: ve,
        multiple: Ye,
        muted: Ye,
        name: null,
        nonce: null,
        noModule: Ye,
        noValidate: Ye,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: Ye,
        optimum: ve,
        pattern: null,
        ping: kt,
        placeholder: null,
        playsInline: Ye,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: Ye,
        referrerPolicy: null,
        rel: kt,
        required: Ye,
        reversed: Ye,
        rows: ve,
        rowSpan: ve,
        sandbox: kt,
        scope: null,
        scoped: Ye,
        seamless: Ye,
        selected: Ye,
        shadowRootClonable: Ye,
        shadowRootDelegatesFocus: Ye,
        shadowRootMode: null,
        shape: null,
        size: ve,
        sizes: null,
        slot: null,
        span: ve,
        spellCheck: Wt,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: ve,
        step: null,
        style: null,
        tabIndex: ve,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: Ye,
        useMap: null,
        value: Wt,
        width: ve,
        wrap: null,
        writingSuggestions: null,
        align: null,
        aLink: null,
        archive: kt,
        axis: null,
        background: null,
        bgColor: null,
        border: ve,
        borderColor: null,
        bottomMargin: ve,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: Ye,
        declare: Ye,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: ve,
        leftMargin: ve,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: ve,
        marginWidth: ve,
        noResize: Ye,
        noHref: Ye,
        noShade: Ye,
        noWrap: Ye,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: ve,
        rules: null,
        scheme: null,
        scrolling: Wt,
        standby: null,
        summary: null,
        text: null,
        topMargin: ve,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: ve,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: Ye,
        disableRemotePlayback: Ye,
        prefix: null,
        property: null,
        results: ve,
        security: null,
        unselectable: null
    }
})
  , kU = Vl({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: O2,
    properties: {
        about: sr,
        accentHeight: ve,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: ve,
        amplitude: ve,
        arabicForm: null,
        ascent: ve,
        attributeName: null,
        attributeType: null,
        azimuth: ve,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: ve,
        by: null,
        calcMode: null,
        capHeight: ve,
        className: kt,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: ve,
        diffuseConstant: ve,
        direction: null,
        display: null,
        dur: null,
        divisor: ve,
        dominantBaseline: null,
        download: Ye,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: ve,
        enableBackground: null,
        end: null,
        event: null,
        exponent: ve,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: ve,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: al,
        g2: al,
        glyphName: al,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: ve,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: ve,
        horizOriginX: ve,
        horizOriginY: ve,
        id: null,
        ideographic: ve,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: ve,
        k: ve,
        k1: ve,
        k2: ve,
        k3: ve,
        k4: ve,
        kernelMatrix: sr,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: ve,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: ve,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: ve,
        overlineThickness: ve,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: ve,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: kt,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: ve,
        pointsAtY: ve,
        pointsAtZ: ve,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: sr,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: sr,
        rev: sr,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: sr,
        requiredFeatures: sr,
        requiredFonts: sr,
        requiredFormats: sr,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: ve,
        specularExponent: ve,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: ve,
        strikethroughThickness: ve,
        string: null,
        stroke: null,
        strokeDashArray: sr,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: ve,
        strokeOpacity: ve,
        strokeWidth: null,
        style: null,
        surfaceScale: ve,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: sr,
        tabIndex: ve,
        tableValues: null,
        target: null,
        targetX: ve,
        targetY: ve,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: sr,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: ve,
        underlineThickness: ve,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: ve,
        values: null,
        vAlphabetic: ve,
        vMathematical: ve,
        vectorEffect: null,
        vHanging: ve,
        vIdeographic: ve,
        version: null,
        vertAdvY: ve,
        vertOriginX: ve,
        vertOriginY: ve,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: ve,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
})
  , RU = /^data[-\w.:]+$/i
  , uS = /-[a-z]/g
  , IU = /[A-Z]/g;
function Cm(t, e) {
    const n = gu(e);
    let r = e
      , i = Br;
    if (n in t.normal)
        return t.property[t.normal[n]];
    if (n.length > 4 && n.slice(0, 4) === "data" && RU.test(e)) {
        if (e.charAt(4) === "-") {
            const s = e.slice(5).replace(uS, DU);
            r = "data" + s.charAt(0).toUpperCase() + s.slice(1)
        } else {
            const s = e.slice(4);
            if (!uS.test(s)) {
                let o = s.replace(IU, PU);
                o.charAt(0) !== "-" && (o = "-" + o),
                e = "data" + o
            }
        }
        i = wv
    }
    return new i(r,e)
}
function PU(t) {
    return "-" + t.toLowerCase()
}
function DU(t) {
    return t.charAt(1).toUpperCase()
}
const LU = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
}
  , Oh = I2([L2, D2, M2, B2, AU], "html")
  , so = I2([L2, D2, M2, B2, kU], "svg");
function hS(t) {
    const e = String(t || "").trim();
    return e ? e.split(/[ \t\n\r\f]+/g) : []
}
function F2(t) {
    return t.join(" ").trim()
}
var j2 = {}
  , dS = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
  , OU = /\n/g
  , NU = /^\s*/
  , MU = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
  , BU = /^:\s*/
  , FU = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/
  , jU = /^[;\s]*/
  , HU = /^\s+|\s+$/g
  , UU = `
`
  , fS = "/"
  , pS = "*"
  , So = ""
  , VU = "comment"
  , $U = "declaration"
  , zU = function(t, e) {
    if (typeof t != "string")
        throw new TypeError("First argument must be a string");
    if (!t)
        return [];
    e = e || {};
    var n = 1
      , r = 1;
    function i(g) {
        var _ = g.match(OU);
        _ && (n += _.length);
        var m = g.lastIndexOf(UU);
        r = ~m ? g.length - m : r + g.length
    }
    function s() {
        var g = {
            line: n,
            column: r
        };
        return function(_) {
            return _.position = new o(g),
            c(),
            _
        }
    }
    function o(g) {
        this.start = g,
        this.end = {
            line: n,
            column: r
        },
        this.source = e.source
    }
    o.prototype.content = t;
    function a(g) {
        var _ = new Error(e.source + ":" + n + ":" + r + ": " + g);
        if (_.reason = g,
        _.filename = e.source,
        _.line = n,
        _.column = r,
        _.source = t,
        !e.silent)
            throw _
    }
    function l(g) {
        var _ = g.exec(t);
        if (_) {
            var m = _[0];
            return i(m),
            t = t.slice(m.length),
            _
        }
    }
    function c() {
        l(NU)
    }
    function u(g) {
        var _;
        for (g = g || []; _ = h(); )
            _ !== !1 && g.push(_);
        return g
    }
    function h() {
        var g = s();
        if (!(fS != t.charAt(0) || pS != t.charAt(1))) {
            for (var _ = 2; So != t.charAt(_) && (pS != t.charAt(_) || fS != t.charAt(_ + 1)); )
                ++_;
            if (_ += 2,
            So === t.charAt(_ - 1))
                return a("End of comment missing");
            var m = t.slice(2, _ - 2);
            return r += 2,
            i(m),
            t = t.slice(_),
            r += 2,
            g({
                type: VU,
                comment: m
            })
        }
    }
    function d() {
        var g = s()
          , _ = l(MU);
        if (_) {
            if (h(),
            !l(BU))
                return a("property missing ':'");
            var m = l(FU)
              , p = g({
                type: $U,
                property: mS(_[0].replace(dS, So)),
                value: m ? mS(m[0].replace(dS, So)) : So
            });
            return l(jU),
            p
        }
    }
    function f() {
        var g = [];
        u(g);
        for (var _; _ = d(); )
            _ !== !1 && (g.push(_),
            u(g));
        return g
    }
    return c(),
    f()
};
function mS(t) {
    return t ? t.replace(HU, So) : So
}
var WU = Cx && Cx.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(j2, "__esModule", {
    value: !0
});
var GU = WU(zU);
function qU(t, e) {
    var n = null;
    if (!t || typeof t != "string")
        return n;
    var r = (0,
    GU.default)(t)
      , i = typeof e == "function";
    return r.forEach(function(s) {
        if (s.type === "declaration") {
            var o = s.property
              , a = s.value;
            i ? e(o, a, s) : a && (n = n || {},
            n[o] = a)
        }
    }),
    n
}
var gS = j2.default = qU;
const KU = gS.default || gS
  , Tm = H2("end")
  , Oi = H2("start");
function H2(t) {
    return e;
    function e(n) {
        const r = n && n.position && n.position[t] || {};
        if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
            return {
                line: r.line,
                column: r.column,
                offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
            }
    }
}
function U2(t) {
    const e = Oi(t)
      , n = Tm(t);
    if (e && n)
        return {
            start: e,
            end: n
        }
}
function Vc(t) {
    return !t || typeof t != "object" ? "" : "position"in t || "type"in t ? _S(t.position) : "start"in t || "end"in t ? _S(t) : "line"in t || "column"in t ? M_(t) : ""
}
function M_(t) {
    return bS(t && t.line) + ":" + bS(t && t.column)
}
function _S(t) {
    return M_(t && t.start) + "-" + M_(t && t.end)
}
function bS(t) {
    return t && typeof t == "number" ? t : 1
}
class On extends Error {
    constructor(e, n, r) {
        super(),
        typeof n == "string" && (r = n,
        n = void 0);
        let i = ""
          , s = {}
          , o = !1;
        if (n && ("line"in n && "column"in n ? s = {
            place: n
        } : "start"in n && "end"in n ? s = {
            place: n
        } : "type"in n ? s = {
            ancestors: [n],
            place: n.position
        } : s = {
            ...n
        }),
        typeof e == "string" ? i = e : !s.cause && e && (o = !0,
        i = e.message,
        s.cause = e),
        !s.ruleId && !s.source && typeof r == "string") {
            const l = r.indexOf(":");
            l === -1 ? s.ruleId = r : (s.source = r.slice(0, l),
            s.ruleId = r.slice(l + 1))
        }
        if (!s.place && s.ancestors && s.ancestors) {
            const l = s.ancestors[s.ancestors.length - 1];
            l && (s.place = l.position)
        }
        const a = s.place && "start"in s.place ? s.place.start : s.place;
        this.ancestors = s.ancestors || void 0,
        this.cause = s.cause || void 0,
        this.column = a ? a.column : void 0,
        this.fatal = void 0,
        this.file,
        this.message = i,
        this.line = a ? a.line : void 0,
        this.name = Vc(s.place) || "1:1",
        this.place = s.place || void 0,
        this.reason = this.message,
        this.ruleId = s.ruleId || void 0,
        this.source = s.source || void 0,
        this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "",
        this.actual,
        this.expected,
        this.note,
        this.url
    }
}
On.prototype.file = "";
On.prototype.name = "";
On.prototype.reason = "";
On.prototype.message = "";
On.prototype.stack = "";
On.prototype.column = void 0;
On.prototype.line = void 0;
On.prototype.ancestors = void 0;
On.prototype.cause = void 0;
On.prototype.fatal = void 0;
On.prototype.place = void 0;
On.prototype.ruleId = void 0;
On.prototype.source = void 0;
const Cv = {}.hasOwnProperty
  , YU = new Map
  , XU = /[A-Z]/g
  , QU = /-([a-z])/g
  , JU = new Set(["table", "tbody", "thead", "tfoot", "tr"])
  , ZU = new Set(["td", "th"])
  , V2 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function e7(t, e) {
    if (!e || e.Fragment === void 0)
        throw new TypeError("Expected `Fragment` in options");
    const n = e.filePath || void 0;
    let r;
    if (e.development) {
        if (typeof e.jsxDEV != "function")
            throw new TypeError("Expected `jsxDEV` in options when `development: true`");
        r = l7(n, e.jsxDEV)
    } else {
        if (typeof e.jsx != "function")
            throw new TypeError("Expected `jsx` in production options");
        if (typeof e.jsxs != "function")
            throw new TypeError("Expected `jsxs` in production options");
        r = a7(n, e.jsx, e.jsxs)
    }
    const i = {
        Fragment: e.Fragment,
        ancestors: [],
        components: e.components || {},
        create: r,
        elementAttributeNameCase: e.elementAttributeNameCase || "react",
        evaluater: e.createEvaluater ? e.createEvaluater() : void 0,
        filePath: n,
        ignoreInvalidStyle: e.ignoreInvalidStyle || !1,
        passKeys: e.passKeys !== !1,
        passNode: e.passNode || !1,
        schema: e.space === "svg" ? so : Oh,
        stylePropertyNameCase: e.stylePropertyNameCase || "dom",
        tableCellAlignToStyle: e.tableCellAlignToStyle !== !1
    }
      , s = $2(i, t, void 0);
    return s && typeof s != "string" ? s : i.create(t, i.Fragment, {
        children: s || void 0
    }, void 0)
}
function $2(t, e, n) {
    if (e.type === "element")
        return t7(t, e, n);
    if (e.type === "mdxFlowExpression" || e.type === "mdxTextExpression")
        return n7(t, e);
    if (e.type === "mdxJsxFlowElement" || e.type === "mdxJsxTextElement")
        return i7(t, e, n);
    if (e.type === "mdxjsEsm")
        return r7(t, e);
    if (e.type === "root")
        return s7(t, e, n);
    if (e.type === "text")
        return o7(t, e)
}
function t7(t, e, n) {
    const r = t.schema;
    let i = r;
    e.tagName.toLowerCase() === "svg" && r.space === "html" && (i = so,
    t.schema = i),
    t.ancestors.push(e);
    const s = W2(t, e.tagName, !1)
      , o = c7(t, e);
    let a = Av(t, e);
    return JU.has(e.tagName) && (a = a.filter(function(l) {
        return typeof l == "string" ? !wU(l) : !0
    })),
    z2(t, o, s, e),
    Tv(o, a),
    t.ancestors.pop(),
    t.schema = r,
    t.create(e, s, o, n)
}
function n7(t, e) {
    if (e.data && e.data.estree && t.evaluater) {
        const r = e.data.estree.body[0];
        return r.type,
        t.evaluater.evaluateExpression(r.expression)
    }
    _u(t, e.position)
}
function r7(t, e) {
    if (e.data && e.data.estree && t.evaluater)
        return t.evaluater.evaluateProgram(e.data.estree);
    _u(t, e.position)
}
function i7(t, e, n) {
    const r = t.schema;
    let i = r;
    e.name === "svg" && r.space === "html" && (i = so,
    t.schema = i),
    t.ancestors.push(e);
    const s = e.name === null ? t.Fragment : W2(t, e.name, !0)
      , o = u7(t, e)
      , a = Av(t, e);
    return z2(t, o, s, e),
    Tv(o, a),
    t.ancestors.pop(),
    t.schema = r,
    t.create(e, s, o, n)
}
function s7(t, e, n) {
    const r = {};
    return Tv(r, Av(t, e)),
    t.create(e, t.Fragment, r, n)
}
function o7(t, e) {
    return e.value
}
function z2(t, e, n, r) {
    typeof n != "string" && n !== t.Fragment && t.passNode && (e.node = r)
}
function Tv(t, e) {
    if (e.length > 0) {
        const n = e.length > 1 ? e : e[0];
        n && (t.children = n)
    }
}
function a7(t, e, n) {
    return r;
    function r(i, s, o, a) {
        const c = Array.isArray(o.children) ? n : e;
        return a ? c(s, o, a) : c(s, o)
    }
}
function l7(t, e) {
    return n;
    function n(r, i, s, o) {
        const a = Array.isArray(s.children)
          , l = Oi(r);
        return e(i, s, o, a, {
            columnNumber: l ? l.column - 1 : void 0,
            fileName: t,
            lineNumber: l ? l.line : void 0
        }, void 0)
    }
}
function c7(t, e) {
    const n = {};
    let r, i;
    for (i in e.properties)
        if (i !== "children" && Cv.call(e.properties, i)) {
            const s = h7(t, i, e.properties[i]);
            if (s) {
                const [o,a] = s;
                t.tableCellAlignToStyle && o === "align" && typeof a == "string" && ZU.has(e.tagName) ? r = a : n[o] = a
            }
        }
    if (r) {
        const s = n.style || (n.style = {});
        s[t.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r
    }
    return n
}
function u7(t, e) {
    const n = {};
    for (const r of e.attributes)
        if (r.type === "mdxJsxExpressionAttribute")
            if (r.data && r.data.estree && t.evaluater) {
                const s = r.data.estree.body[0];
                s.type;
                const o = s.expression;
                o.type;
                const a = o.properties[0];
                a.type,
                Object.assign(n, t.evaluater.evaluateExpression(a.argument))
            } else
                _u(t, e.position);
        else {
            const i = r.name;
            let s;
            if (r.value && typeof r.value == "object")
                if (r.value.data && r.value.data.estree && t.evaluater) {
                    const a = r.value.data.estree.body[0];
                    a.type,
                    s = t.evaluater.evaluateExpression(a.expression)
                } else
                    _u(t, e.position);
            else
                s = r.value === null ? !0 : r.value;
            n[i] = s
        }
    return n
}
function Av(t, e) {
    const n = [];
    let r = -1;
    const i = t.passKeys ? new Map : YU;
    for (; ++r < e.children.length; ) {
        const s = e.children[r];
        let o;
        if (t.passKeys) {
            const l = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0;
            if (l) {
                const c = i.get(l) || 0;
                o = l + "-" + c,
                i.set(l, c + 1)
            }
        }
        const a = $2(t, s, o);
        a !== void 0 && n.push(a)
    }
    return n
}
function h7(t, e, n) {
    const r = Cm(t.schema, e);
    if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
        if (Array.isArray(n) && (n = r.commaSeparated ? R2(n) : F2(n)),
        r.property === "style") {
            let i = typeof n == "object" ? n : d7(t, String(n));
            return t.stylePropertyNameCase === "css" && (i = f7(i)),
            ["style", i]
        }
        return [t.elementAttributeNameCase === "react" && r.space ? LU[r.property] || r.property : r.attribute, n]
    }
}
function d7(t, e) {
    const n = {};
    try {
        KU(e, r)
    } catch (i) {
        if (!t.ignoreInvalidStyle) {
            const s = i
              , o = new On("Cannot parse `style` attribute",{
                ancestors: t.ancestors,
                cause: s,
                ruleId: "style",
                source: "hast-util-to-jsx-runtime"
            });
            throw o.file = t.filePath || void 0,
            o.url = V2 + "#cannot-parse-style-attribute",
            o
        }
    }
    return n;
    function r(i, s) {
        let o = i;
        o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)),
        o = o.replace(QU, m7)),
        n[o] = s
    }
}
function W2(t, e, n) {
    let r;
    if (!n)
        r = {
            type: "Literal",
            value: e
        };
    else if (e.includes(".")) {
        const i = e.split(".");
        let s = -1, o;
        for (; ++s < i.length; ) {
            const a = aS(i[s]) ? {
                type: "Identifier",
                name: i[s]
            } : {
                type: "Literal",
                value: i[s]
            };
            o = o ? {
                type: "MemberExpression",
                object: o,
                property: a,
                computed: !!(s && a.type === "Literal"),
                optional: !1
            } : a
        }
        r = o
    } else
        r = aS(e) && !/^[a-z]/.test(e) ? {
            type: "Identifier",
            name: e
        } : {
            type: "Literal",
            value: e
        };
    if (r.type === "Literal") {
        const i = r.value;
        return Cv.call(t.components, i) ? t.components[i] : i
    }
    if (t.evaluater)
        return t.evaluater.evaluateExpression(r);
    _u(t)
}
function _u(t, e) {
    const n = new On("Cannot handle MDX estrees without `createEvaluater`",{
        ancestors: t.ancestors,
        place: e,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
    });
    throw n.file = t.filePath || void 0,
    n.url = V2 + "#cannot-handle-mdx-estrees-without-createevaluater",
    n
}
function f7(t) {
    const e = {};
    let n;
    for (n in t)
        Cv.call(t, n) && (e[p7(n)] = t[n]);
    return e
}
function p7(t) {
    let e = t.replace(XU, g7);
    return e.slice(0, 3) === "ms-" && (e = "-" + e),
    e
}
function m7(t, e) {
    return e.toUpperCase()
}
function g7(t) {
    return "-" + t.toLowerCase()
}
const Hg = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"]
}
  , _7 = {};
function kv(t, e) {
    const n = _7
      , r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0
      , i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
    return G2(t, r, i)
}
function G2(t, e, n) {
    if (b7(t)) {
        if ("value"in t)
            return t.type === "html" && !n ? "" : t.value;
        if (e && "alt"in t && t.alt)
            return t.alt;
        if ("children"in t)
            return yS(t.children, e, n)
    }
    return Array.isArray(t) ? yS(t, e, n) : ""
}
function yS(t, e, n) {
    const r = [];
    let i = -1;
    for (; ++i < t.length; )
        r[i] = G2(t[i], e, n);
    return r.join("")
}
function b7(t) {
    return !!(t && typeof t == "object")
}
const vS = document.createElement("i");
function Rv(t) {
    const e = "&" + t + ";";
    vS.innerHTML = e;
    const n = vS.textContent;
    return n.charCodeAt(n.length - 1) === 59 && t !== "semi" || n === e ? !1 : n
}
function Pr(t, e, n, r) {
    const i = t.length;
    let s = 0, o;
    if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e,
    n = n > 0 ? n : 0,
    r.length < 1e4)
        o = Array.from(r),
        o.unshift(e, n),
        t.splice(...o);
    else
        for (n && t.splice(e, n); s < r.length; )
            o = r.slice(s, s + 1e4),
            o.unshift(e, 0),
            t.splice(...o),
            s += 1e4,
            e += 1e4
}
function Tr(t, e) {
    return t.length > 0 ? (Pr(t, t.length, 0, e),
    t) : e
}
const xS = {}.hasOwnProperty;
function q2(t) {
    const e = {};
    let n = -1;
    for (; ++n < t.length; )
        y7(e, t[n]);
    return e
}
function y7(t, e) {
    let n;
    for (n in e) {
        const i = (xS.call(t, n) ? t[n] : void 0) || (t[n] = {})
          , s = e[n];
        let o;
        if (s)
            for (o in s) {
                xS.call(i, o) || (i[o] = []);
                const a = s[o];
                v7(i[o], Array.isArray(a) ? a : a ? [a] : [])
            }
    }
}
function v7(t, e) {
    let n = -1;
    const r = [];
    for (; ++n < e.length; )
        (e[n].add === "after" ? t : r).push(e[n]);
    Pr(t, 0, 0, r)
}
function K2(t, e) {
    const n = Number.parseInt(t, e);
    return n < 9 || n === 11 || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || n > 1114111 ? "" : String.fromCodePoint(n)
}
function Xr(t) {
    return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase()
}
const jn = oo(/[A-Za-z]/)
  , In = oo(/[\dA-Za-z]/)
  , x7 = oo(/[#-'*+\--9=?A-Z^-~]/);
function qf(t) {
    return t !== null && (t < 32 || t === 127)
}
const B_ = oo(/\d/)
  , E7 = oo(/[\dA-Fa-f]/)
  , S7 = oo(/[!-/:-@[-`{-~]/);
function je(t) {
    return t !== null && t < -2
}
function At(t) {
    return t !== null && (t < 0 || t === 32)
}
function st(t) {
    return t === -2 || t === -1 || t === 32
}
const Am = oo(/\p{P}|\p{S}/u)
  , Yo = oo(/\s/);
function oo(t) {
    return e;
    function e(n) {
        return n !== null && n > -1 && t.test(String.fromCharCode(n))
    }
}
function $l(t) {
    const e = [];
    let n = -1
      , r = 0
      , i = 0;
    for (; ++n < t.length; ) {
        const s = t.charCodeAt(n);
        let o = "";
        if (s === 37 && In(t.charCodeAt(n + 1)) && In(t.charCodeAt(n + 2)))
            i = 2;
        else if (s < 128)
            /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (o = String.fromCharCode(s));
        else if (s > 55295 && s < 57344) {
            const a = t.charCodeAt(n + 1);
            s < 56320 && a > 56319 && a < 57344 ? (o = String.fromCharCode(s, a),
            i = 1) : o = ""
        } else
            o = String.fromCharCode(s);
        o && (e.push(t.slice(r, n), encodeURIComponent(o)),
        r = n + i + 1,
        o = ""),
        i && (n += i,
        i = 0)
    }
    return e.join("") + t.slice(r)
}
function ht(t, e, n, r) {
    const i = r ? r - 1 : Number.POSITIVE_INFINITY;
    let s = 0;
    return o;
    function o(l) {
        return st(l) ? (t.enter(n),
        a(l)) : e(l)
    }
    function a(l) {
        return st(l) && s++ < i ? (t.consume(l),
        a) : (t.exit(n),
        e(l))
    }
}
const w7 = {
    tokenize: C7
};
function C7(t) {
    const e = t.attempt(this.parser.constructs.contentInitial, r, i);
    let n;
    return e;
    function r(a) {
        if (a === null) {
            t.consume(a);
            return
        }
        return t.enter("lineEnding"),
        t.consume(a),
        t.exit("lineEnding"),
        ht(t, e, "linePrefix")
    }
    function i(a) {
        return t.enter("paragraph"),
        s(a)
    }
    function s(a) {
        const l = t.enter("chunkText", {
            contentType: "text",
            previous: n
        });
        return n && (n.next = l),
        n = l,
        o(a)
    }
    function o(a) {
        if (a === null) {
            t.exit("chunkText"),
            t.exit("paragraph"),
            t.consume(a);
            return
        }
        return je(a) ? (t.consume(a),
        t.exit("chunkText"),
        s) : (t.consume(a),
        o)
    }
}
const T7 = {
    tokenize: A7
}
  , ES = {
    tokenize: k7
};
function A7(t) {
    const e = this
      , n = [];
    let r = 0, i, s, o;
    return a;
    function a(y) {
        if (r < n.length) {
            const x = n[r];
            return e.containerState = x[1],
            t.attempt(x[0].continuation, l, c)(y)
        }
        return c(y)
    }
    function l(y) {
        if (r++,
        e.containerState._closeFlow) {
            e.containerState._closeFlow = void 0,
            i && b();
            const x = e.events.length;
            let E = x, w;
            for (; E--; )
                if (e.events[E][0] === "exit" && e.events[E][1].type === "chunkFlow") {
                    w = e.events[E][1].end;
                    break
                }
            p(r);
            let A = x;
            for (; A < e.events.length; )
                e.events[A][1].end = Object.assign({}, w),
                A++;
            return Pr(e.events, E + 1, 0, e.events.slice(x)),
            e.events.length = A,
            c(y)
        }
        return a(y)
    }
    function c(y) {
        if (r === n.length) {
            if (!i)
                return d(y);
            if (i.currentConstruct && i.currentConstruct.concrete)
                return g(y);
            e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack)
        }
        return e.containerState = {},
        t.check(ES, u, h)(y)
    }
    function u(y) {
        return i && b(),
        p(r),
        d(y)
    }
    function h(y) {
        return e.parser.lazy[e.now().line] = r !== n.length,
        o = e.now().offset,
        g(y)
    }
    function d(y) {
        return e.containerState = {},
        t.attempt(ES, f, g)(y)
    }
    function f(y) {
        return r++,
        n.push([e.currentConstruct, e.containerState]),
        d(y)
    }
    function g(y) {
        if (y === null) {
            i && b(),
            p(0),
            t.consume(y);
            return
        }
        return i = i || e.parser.flow(e.now()),
        t.enter("chunkFlow", {
            contentType: "flow",
            previous: s,
            _tokenizer: i
        }),
        _(y)
    }
    function _(y) {
        if (y === null) {
            m(t.exit("chunkFlow"), !0),
            p(0),
            t.consume(y);
            return
        }
        return je(y) ? (t.consume(y),
        m(t.exit("chunkFlow")),
        r = 0,
        e.interrupt = void 0,
        a) : (t.consume(y),
        _)
    }
    function m(y, x) {
        const E = e.sliceStream(y);
        if (x && E.push(null),
        y.previous = s,
        s && (s.next = y),
        s = y,
        i.defineSkip(y.start),
        i.write(E),
        e.parser.lazy[y.start.line]) {
            let w = i.events.length;
            for (; w--; )
                if (i.events[w][1].start.offset < o && (!i.events[w][1].end || i.events[w][1].end.offset > o))
                    return;
            const A = e.events.length;
            let C = A, k, I;
            for (; C--; )
                if (e.events[C][0] === "exit" && e.events[C][1].type === "chunkFlow") {
                    if (k) {
                        I = e.events[C][1].end;
                        break
                    }
                    k = !0
                }
            for (p(r),
            w = A; w < e.events.length; )
                e.events[w][1].end = Object.assign({}, I),
                w++;
            Pr(e.events, C + 1, 0, e.events.slice(A)),
            e.events.length = w
        }
    }
    function p(y) {
        let x = n.length;
        for (; x-- > y; ) {
            const E = n[x];
            e.containerState = E[1],
            E[0].exit.call(e, t)
        }
        n.length = y
    }
    function b() {
        i.write([null]),
        s = void 0,
        i = void 0,
        e.containerState._closeFlow = void 0
    }
}
function k7(t, e, n) {
    return ht(t, t.attempt(this.parser.constructs.document, e, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
}
function Kf(t) {
    if (t === null || At(t) || Yo(t))
        return 1;
    if (Am(t))
        return 2
}
function km(t, e, n) {
    const r = [];
    let i = -1;
    for (; ++i < t.length; ) {
        const s = t[i].resolveAll;
        s && !r.includes(s) && (e = s(e, n),
        r.push(s))
    }
    return e
}
const F_ = {
    name: "attention",
    tokenize: I7,
    resolveAll: R7
};
function R7(t, e) {
    let n = -1, r, i, s, o, a, l, c, u;
    for (; ++n < t.length; )
        if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
            for (r = n; r--; )
                if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) {
                    if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3))
                        continue;
                    l = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
                    const h = Object.assign({}, t[r][1].end)
                      , d = Object.assign({}, t[n][1].start);
                    SS(h, -l),
                    SS(d, l),
                    o = {
                        type: l > 1 ? "strongSequence" : "emphasisSequence",
                        start: h,
                        end: Object.assign({}, t[r][1].end)
                    },
                    a = {
                        type: l > 1 ? "strongSequence" : "emphasisSequence",
                        start: Object.assign({}, t[n][1].start),
                        end: d
                    },
                    s = {
                        type: l > 1 ? "strongText" : "emphasisText",
                        start: Object.assign({}, t[r][1].end),
                        end: Object.assign({}, t[n][1].start)
                    },
                    i = {
                        type: l > 1 ? "strong" : "emphasis",
                        start: Object.assign({}, o.start),
                        end: Object.assign({}, a.end)
                    },
                    t[r][1].end = Object.assign({}, o.start),
                    t[n][1].start = Object.assign({}, a.end),
                    c = [],
                    t[r][1].end.offset - t[r][1].start.offset && (c = Tr(c, [["enter", t[r][1], e], ["exit", t[r][1], e]])),
                    c = Tr(c, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["enter", s, e]]),
                    c = Tr(c, km(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e)),
                    c = Tr(c, [["exit", s, e], ["enter", a, e], ["exit", a, e], ["exit", i, e]]),
                    t[n][1].end.offset - t[n][1].start.offset ? (u = 2,
                    c = Tr(c, [["enter", t[n][1], e], ["exit", t[n][1], e]])) : u = 0,
                    Pr(t, r - 1, n - r + 3, c),
                    n = r + c.length - u - 2;
                    break
                }
        }
    for (n = -1; ++n < t.length; )
        t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
    return t
}
function I7(t, e) {
    const n = this.parser.constructs.attentionMarkers.null
      , r = this.previous
      , i = Kf(r);
    let s;
    return o;
    function o(l) {
        return s = l,
        t.enter("attentionSequence"),
        a(l)
    }
    function a(l) {
        if (l === s)
            return t.consume(l),
            a;
        const c = t.exit("attentionSequence")
          , u = Kf(l)
          , h = !u || u === 2 && i || n.includes(l)
          , d = !i || i === 2 && u || n.includes(r);
        return c._open = !!(s === 42 ? h : h && (i || !d)),
        c._close = !!(s === 42 ? d : d && (u || !h)),
        e(l)
    }
}
function SS(t, e) {
    t.column += e,
    t.offset += e,
    t._bufferIndex += e
}
const P7 = {
    name: "autolink",
    tokenize: D7
};
function D7(t, e, n) {
    let r = 0;
    return i;
    function i(f) {
        return t.enter("autolink"),
        t.enter("autolinkMarker"),
        t.consume(f),
        t.exit("autolinkMarker"),
        t.enter("autolinkProtocol"),
        s
    }
    function s(f) {
        return jn(f) ? (t.consume(f),
        o) : f === 64 ? n(f) : c(f)
    }
    function o(f) {
        return f === 43 || f === 45 || f === 46 || In(f) ? (r = 1,
        a(f)) : c(f)
    }
    function a(f) {
        return f === 58 ? (t.consume(f),
        r = 0,
        l) : (f === 43 || f === 45 || f === 46 || In(f)) && r++ < 32 ? (t.consume(f),
        a) : (r = 0,
        c(f))
    }
    function l(f) {
        return f === 62 ? (t.exit("autolinkProtocol"),
        t.enter("autolinkMarker"),
        t.consume(f),
        t.exit("autolinkMarker"),
        t.exit("autolink"),
        e) : f === null || f === 32 || f === 60 || qf(f) ? n(f) : (t.consume(f),
        l)
    }
    function c(f) {
        return f === 64 ? (t.consume(f),
        u) : x7(f) ? (t.consume(f),
        c) : n(f)
    }
    function u(f) {
        return In(f) ? h(f) : n(f)
    }
    function h(f) {
        return f === 46 ? (t.consume(f),
        r = 0,
        u) : f === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail",
        t.enter("autolinkMarker"),
        t.consume(f),
        t.exit("autolinkMarker"),
        t.exit("autolink"),
        e) : d(f)
    }
    function d(f) {
        if ((f === 45 || In(f)) && r++ < 63) {
            const g = f === 45 ? d : h;
            return t.consume(f),
            g
        }
        return n(f)
    }
}
const Nh = {
    tokenize: L7,
    partial: !0
};
function L7(t, e, n) {
    return r;
    function r(s) {
        return st(s) ? ht(t, i, "linePrefix")(s) : i(s)
    }
    function i(s) {
        return s === null || je(s) ? e(s) : n(s)
    }
}
const Y2 = {
    name: "blockQuote",
    tokenize: O7,
    continuation: {
        tokenize: N7
    },
    exit: M7
};
function O7(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        if (o === 62) {
            const a = r.containerState;
            return a.open || (t.enter("blockQuote", {
                _container: !0
            }),
            a.open = !0),
            t.enter("blockQuotePrefix"),
            t.enter("blockQuoteMarker"),
            t.consume(o),
            t.exit("blockQuoteMarker"),
            s
        }
        return n(o)
    }
    function s(o) {
        return st(o) ? (t.enter("blockQuotePrefixWhitespace"),
        t.consume(o),
        t.exit("blockQuotePrefixWhitespace"),
        t.exit("blockQuotePrefix"),
        e) : (t.exit("blockQuotePrefix"),
        e(o))
    }
}
function N7(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return st(o) ? ht(t, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o)
    }
    function s(o) {
        return t.attempt(Y2, e, n)(o)
    }
}
function M7(t) {
    t.exit("blockQuote")
}
const X2 = {
    name: "characterEscape",
    tokenize: B7
};
function B7(t, e, n) {
    return r;
    function r(s) {
        return t.enter("characterEscape"),
        t.enter("escapeMarker"),
        t.consume(s),
        t.exit("escapeMarker"),
        i
    }
    function i(s) {
        return S7(s) ? (t.enter("characterEscapeValue"),
        t.consume(s),
        t.exit("characterEscapeValue"),
        t.exit("characterEscape"),
        e) : n(s)
    }
}
const Q2 = {
    name: "characterReference",
    tokenize: F7
};
function F7(t, e, n) {
    const r = this;
    let i = 0, s, o;
    return a;
    function a(h) {
        return t.enter("characterReference"),
        t.enter("characterReferenceMarker"),
        t.consume(h),
        t.exit("characterReferenceMarker"),
        l
    }
    function l(h) {
        return h === 35 ? (t.enter("characterReferenceMarkerNumeric"),
        t.consume(h),
        t.exit("characterReferenceMarkerNumeric"),
        c) : (t.enter("characterReferenceValue"),
        s = 31,
        o = In,
        u(h))
    }
    function c(h) {
        return h === 88 || h === 120 ? (t.enter("characterReferenceMarkerHexadecimal"),
        t.consume(h),
        t.exit("characterReferenceMarkerHexadecimal"),
        t.enter("characterReferenceValue"),
        s = 6,
        o = E7,
        u) : (t.enter("characterReferenceValue"),
        s = 7,
        o = B_,
        u(h))
    }
    function u(h) {
        if (h === 59 && i) {
            const d = t.exit("characterReferenceValue");
            return o === In && !Rv(r.sliceSerialize(d)) ? n(h) : (t.enter("characterReferenceMarker"),
            t.consume(h),
            t.exit("characterReferenceMarker"),
            t.exit("characterReference"),
            e)
        }
        return o(h) && i++ < s ? (t.consume(h),
        u) : n(h)
    }
}
const wS = {
    tokenize: H7,
    partial: !0
}
  , CS = {
    name: "codeFenced",
    tokenize: j7,
    concrete: !0
};
function j7(t, e, n) {
    const r = this
      , i = {
        tokenize: E,
        partial: !0
    };
    let s = 0, o = 0, a;
    return l;
    function l(w) {
        return c(w)
    }
    function c(w) {
        const A = r.events[r.events.length - 1];
        return s = A && A[1].type === "linePrefix" ? A[2].sliceSerialize(A[1], !0).length : 0,
        a = w,
        t.enter("codeFenced"),
        t.enter("codeFencedFence"),
        t.enter("codeFencedFenceSequence"),
        u(w)
    }
    function u(w) {
        return w === a ? (o++,
        t.consume(w),
        u) : o < 3 ? n(w) : (t.exit("codeFencedFenceSequence"),
        st(w) ? ht(t, h, "whitespace")(w) : h(w))
    }
    function h(w) {
        return w === null || je(w) ? (t.exit("codeFencedFence"),
        r.interrupt ? e(w) : t.check(wS, _, x)(w)) : (t.enter("codeFencedFenceInfo"),
        t.enter("chunkString", {
            contentType: "string"
        }),
        d(w))
    }
    function d(w) {
        return w === null || je(w) ? (t.exit("chunkString"),
        t.exit("codeFencedFenceInfo"),
        h(w)) : st(w) ? (t.exit("chunkString"),
        t.exit("codeFencedFenceInfo"),
        ht(t, f, "whitespace")(w)) : w === 96 && w === a ? n(w) : (t.consume(w),
        d)
    }
    function f(w) {
        return w === null || je(w) ? h(w) : (t.enter("codeFencedFenceMeta"),
        t.enter("chunkString", {
            contentType: "string"
        }),
        g(w))
    }
    function g(w) {
        return w === null || je(w) ? (t.exit("chunkString"),
        t.exit("codeFencedFenceMeta"),
        h(w)) : w === 96 && w === a ? n(w) : (t.consume(w),
        g)
    }
    function _(w) {
        return t.attempt(i, x, m)(w)
    }
    function m(w) {
        return t.enter("lineEnding"),
        t.consume(w),
        t.exit("lineEnding"),
        p
    }
    function p(w) {
        return s > 0 && st(w) ? ht(t, b, "linePrefix", s + 1)(w) : b(w)
    }
    function b(w) {
        return w === null || je(w) ? t.check(wS, _, x)(w) : (t.enter("codeFlowValue"),
        y(w))
    }
    function y(w) {
        return w === null || je(w) ? (t.exit("codeFlowValue"),
        b(w)) : (t.consume(w),
        y)
    }
    function x(w) {
        return t.exit("codeFenced"),
        e(w)
    }
    function E(w, A, C) {
        let k = 0;
        return I;
        function I($) {
            return w.enter("lineEnding"),
            w.consume($),
            w.exit("lineEnding"),
            N
        }
        function N($) {
            return w.enter("codeFencedFence"),
            st($) ? ht(w, O, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)($) : O($)
        }
        function O($) {
            return $ === a ? (w.enter("codeFencedFenceSequence"),
            M($)) : C($)
        }
        function M($) {
            return $ === a ? (k++,
            w.consume($),
            M) : k >= o ? (w.exit("codeFencedFenceSequence"),
            st($) ? ht(w, H, "whitespace")($) : H($)) : C($)
        }
        function H($) {
            return $ === null || je($) ? (w.exit("codeFencedFence"),
            A($)) : C($)
        }
    }
}
function H7(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return o === null ? n(o) : (t.enter("lineEnding"),
        t.consume(o),
        t.exit("lineEnding"),
        s)
    }
    function s(o) {
        return r.parser.lazy[r.now().line] ? n(o) : e(o)
    }
}
const Ug = {
    name: "codeIndented",
    tokenize: V7
}
  , U7 = {
    tokenize: $7,
    partial: !0
};
function V7(t, e, n) {
    const r = this;
    return i;
    function i(c) {
        return t.enter("codeIndented"),
        ht(t, s, "linePrefix", 5)(c)
    }
    function s(c) {
        const u = r.events[r.events.length - 1];
        return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : n(c)
    }
    function o(c) {
        return c === null ? l(c) : je(c) ? t.attempt(U7, o, l)(c) : (t.enter("codeFlowValue"),
        a(c))
    }
    function a(c) {
        return c === null || je(c) ? (t.exit("codeFlowValue"),
        o(c)) : (t.consume(c),
        a)
    }
    function l(c) {
        return t.exit("codeIndented"),
        e(c)
    }
}
function $7(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return r.parser.lazy[r.now().line] ? n(o) : je(o) ? (t.enter("lineEnding"),
        t.consume(o),
        t.exit("lineEnding"),
        i) : ht(t, s, "linePrefix", 5)(o)
    }
    function s(o) {
        const a = r.events[r.events.length - 1];
        return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : je(o) ? i(o) : n(o)
    }
}
const z7 = {
    name: "codeText",
    tokenize: q7,
    resolve: W7,
    previous: G7
};
function W7(t) {
    let e = t.length - 4, n = 3, r, i;
    if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
        for (r = n; ++r < e; )
            if (t[r][1].type === "codeTextData") {
                t[n][1].type = "codeTextPadding",
                t[e][1].type = "codeTextPadding",
                n += 2,
                e -= 2;
                break
            }
    }
    for (r = n - 1,
    e++; ++r <= e; )
        i === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (i = r) : (r === e || t[r][1].type === "lineEnding") && (t[i][1].type = "codeTextData",
        r !== i + 2 && (t[i][1].end = t[r - 1][1].end,
        t.splice(i + 2, r - i - 2),
        e -= r - i - 2,
        r = i + 2),
        i = void 0);
    return t
}
function G7(t) {
    return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape"
}
function q7(t, e, n) {
    let r = 0, i, s;
    return o;
    function o(h) {
        return t.enter("codeText"),
        t.enter("codeTextSequence"),
        a(h)
    }
    function a(h) {
        return h === 96 ? (t.consume(h),
        r++,
        a) : (t.exit("codeTextSequence"),
        l(h))
    }
    function l(h) {
        return h === null ? n(h) : h === 32 ? (t.enter("space"),
        t.consume(h),
        t.exit("space"),
        l) : h === 96 ? (s = t.enter("codeTextSequence"),
        i = 0,
        u(h)) : je(h) ? (t.enter("lineEnding"),
        t.consume(h),
        t.exit("lineEnding"),
        l) : (t.enter("codeTextData"),
        c(h))
    }
    function c(h) {
        return h === null || h === 32 || h === 96 || je(h) ? (t.exit("codeTextData"),
        l(h)) : (t.consume(h),
        c)
    }
    function u(h) {
        return h === 96 ? (t.consume(h),
        i++,
        u) : i === r ? (t.exit("codeTextSequence"),
        t.exit("codeText"),
        e(h)) : (s.type = "codeTextData",
        c(h))
    }
}
class K7 {
    constructor(e) {
        this.left = e ? [...e] : [],
        this.right = []
    }
    get(e) {
        if (e < 0 || e >= this.left.length + this.right.length)
            throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
        return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1]
    }
    get length() {
        return this.left.length + this.right.length
    }
    shift() {
        return this.setCursor(0),
        this.right.pop()
    }
    slice(e, n) {
        const r = n ?? Number.POSITIVE_INFINITY;
        return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse())
    }
    splice(e, n, r) {
        const i = n || 0;
        this.setCursor(Math.trunc(e));
        const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
        return r && nc(this.left, r),
        s.reverse()
    }
    pop() {
        return this.setCursor(Number.POSITIVE_INFINITY),
        this.left.pop()
    }
    push(e) {
        this.setCursor(Number.POSITIVE_INFINITY),
        this.left.push(e)
    }
    pushMany(e) {
        this.setCursor(Number.POSITIVE_INFINITY),
        nc(this.left, e)
    }
    unshift(e) {
        this.setCursor(0),
        this.right.push(e)
    }
    unshiftMany(e) {
        this.setCursor(0),
        nc(this.right, e.reverse())
    }
    setCursor(e) {
        if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
            if (e < this.left.length) {
                const n = this.left.splice(e, Number.POSITIVE_INFINITY);
                nc(this.right, n.reverse())
            } else {
                const n = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
                nc(this.left, n.reverse())
            }
    }
}
function nc(t, e) {
    let n = 0;
    if (e.length < 1e4)
        t.push(...e);
    else
        for (; n < e.length; )
            t.push(...e.slice(n, n + 1e4)),
            n += 1e4
}
function J2(t) {
    const e = {};
    let n = -1, r, i, s, o, a, l, c;
    const u = new K7(t);
    for (; ++n < u.length; ) {
        for (; n in e; )
            n = e[n];
        if (r = u.get(n),
        n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events,
        s = 0,
        s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2),
        s < l.length && l[s][1].type === "content"))
            for (; ++s < l.length && l[s][1].type !== "content"; )
                l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0,
                s++);
        if (r[0] === "enter")
            r[1].contentType && (Object.assign(e, Y7(u, n)),
            n = e[n],
            c = !0);
        else if (r[1]._container) {
            for (s = n,
            i = void 0; s-- && (o = u.get(s),
            o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
                o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"),
                o[1].type = "lineEnding",
                i = s);
            i && (r[1].end = Object.assign({}, u.get(i)[1].start),
            a = u.slice(i, n),
            a.unshift(r),
            u.splice(i, n - i + 1, a))
        }
    }
    return Pr(t, 0, Number.POSITIVE_INFINITY, u.slice(0)),
    !c
}
function Y7(t, e) {
    const n = t.get(e)[1]
      , r = t.get(e)[2];
    let i = e - 1;
    const s = []
      , o = n._tokenizer || r.parser[n.contentType](n.start)
      , a = o.events
      , l = []
      , c = {};
    let u, h, d = -1, f = n, g = 0, _ = 0;
    const m = [_];
    for (; f; ) {
        for (; t.get(++i)[1] !== f; )
            ;
        s.push(i),
        f._tokenizer || (u = r.sliceStream(f),
        f.next || u.push(null),
        h && o.defineSkip(f.start),
        f._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0),
        o.write(u),
        f._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)),
        h = f,
        f = f.next
    }
    for (f = n; ++d < a.length; )
        a[d][0] === "exit" && a[d - 1][0] === "enter" && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (_ = d + 1,
        m.push(_),
        f._tokenizer = void 0,
        f.previous = void 0,
        f = f.next);
    for (o.events = [],
    f ? (f._tokenizer = void 0,
    f.previous = void 0) : m.pop(),
    d = m.length; d--; ) {
        const p = a.slice(m[d], m[d + 1])
          , b = s.pop();
        l.push([b, b + p.length - 1]),
        t.splice(b, 2, p)
    }
    for (l.reverse(),
    d = -1; ++d < l.length; )
        c[g + l[d][0]] = g + l[d][1],
        g += l[d][1] - l[d][0] - 1;
    return c
}
const X7 = {
    tokenize: Z7,
    resolve: J7
}
  , Q7 = {
    tokenize: eV,
    partial: !0
};
function J7(t) {
    return J2(t),
    t
}
function Z7(t, e) {
    let n;
    return r;
    function r(a) {
        return t.enter("content"),
        n = t.enter("chunkContent", {
            contentType: "content"
        }),
        i(a)
    }
    function i(a) {
        return a === null ? s(a) : je(a) ? t.check(Q7, o, s)(a) : (t.consume(a),
        i)
    }
    function s(a) {
        return t.exit("chunkContent"),
        t.exit("content"),
        e(a)
    }
    function o(a) {
        return t.consume(a),
        t.exit("chunkContent"),
        n.next = t.enter("chunkContent", {
            contentType: "content",
            previous: n
        }),
        n = n.next,
        i
    }
}
function eV(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return t.exit("chunkContent"),
        t.enter("lineEnding"),
        t.consume(o),
        t.exit("lineEnding"),
        ht(t, s, "linePrefix")
    }
    function s(o) {
        if (o === null || je(o))
            return n(o);
        const a = r.events[r.events.length - 1];
        return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : t.interrupt(r.parser.constructs.flow, n, e)(o)
    }
}
function Z2(t, e, n, r, i, s, o, a, l) {
    const c = l || Number.POSITIVE_INFINITY;
    let u = 0;
    return h;
    function h(p) {
        return p === 60 ? (t.enter(r),
        t.enter(i),
        t.enter(s),
        t.consume(p),
        t.exit(s),
        d) : p === null || p === 32 || p === 41 || qf(p) ? n(p) : (t.enter(r),
        t.enter(o),
        t.enter(a),
        t.enter("chunkString", {
            contentType: "string"
        }),
        _(p))
    }
    function d(p) {
        return p === 62 ? (t.enter(s),
        t.consume(p),
        t.exit(s),
        t.exit(i),
        t.exit(r),
        e) : (t.enter(a),
        t.enter("chunkString", {
            contentType: "string"
        }),
        f(p))
    }
    function f(p) {
        return p === 62 ? (t.exit("chunkString"),
        t.exit(a),
        d(p)) : p === null || p === 60 || je(p) ? n(p) : (t.consume(p),
        p === 92 ? g : f)
    }
    function g(p) {
        return p === 60 || p === 62 || p === 92 ? (t.consume(p),
        f) : f(p)
    }
    function _(p) {
        return !u && (p === null || p === 41 || At(p)) ? (t.exit("chunkString"),
        t.exit(a),
        t.exit(o),
        t.exit(r),
        e(p)) : u < c && p === 40 ? (t.consume(p),
        u++,
        _) : p === 41 ? (t.consume(p),
        u--,
        _) : p === null || p === 32 || p === 40 || qf(p) ? n(p) : (t.consume(p),
        p === 92 ? m : _)
    }
    function m(p) {
        return p === 40 || p === 41 || p === 92 ? (t.consume(p),
        _) : _(p)
    }
}
function eI(t, e, n, r, i, s) {
    const o = this;
    let a = 0, l;
    return c;
    function c(f) {
        return t.enter(r),
        t.enter(i),
        t.consume(f),
        t.exit(i),
        t.enter(s),
        u
    }
    function u(f) {
        return a > 999 || f === null || f === 91 || f === 93 && !l || f === 94 && !a && "_hiddenFootnoteSupport"in o.parser.constructs ? n(f) : f === 93 ? (t.exit(s),
        t.enter(i),
        t.consume(f),
        t.exit(i),
        t.exit(r),
        e) : je(f) ? (t.enter("lineEnding"),
        t.consume(f),
        t.exit("lineEnding"),
        u) : (t.enter("chunkString", {
            contentType: "string"
        }),
        h(f))
    }
    function h(f) {
        return f === null || f === 91 || f === 93 || je(f) || a++ > 999 ? (t.exit("chunkString"),
        u(f)) : (t.consume(f),
        l || (l = !st(f)),
        f === 92 ? d : h)
    }
    function d(f) {
        return f === 91 || f === 92 || f === 93 ? (t.consume(f),
        a++,
        h) : h(f)
    }
}
function tI(t, e, n, r, i, s) {
    let o;
    return a;
    function a(d) {
        return d === 34 || d === 39 || d === 40 ? (t.enter(r),
        t.enter(i),
        t.consume(d),
        t.exit(i),
        o = d === 40 ? 41 : d,
        l) : n(d)
    }
    function l(d) {
        return d === o ? (t.enter(i),
        t.consume(d),
        t.exit(i),
        t.exit(r),
        e) : (t.enter(s),
        c(d))
    }
    function c(d) {
        return d === o ? (t.exit(s),
        l(o)) : d === null ? n(d) : je(d) ? (t.enter("lineEnding"),
        t.consume(d),
        t.exit("lineEnding"),
        ht(t, c, "linePrefix")) : (t.enter("chunkString", {
            contentType: "string"
        }),
        u(d))
    }
    function u(d) {
        return d === o || d === null || je(d) ? (t.exit("chunkString"),
        c(d)) : (t.consume(d),
        d === 92 ? h : u)
    }
    function h(d) {
        return d === o || d === 92 ? (t.consume(d),
        u) : u(d)
    }
}
function $c(t, e) {
    let n;
    return r;
    function r(i) {
        return je(i) ? (t.enter("lineEnding"),
        t.consume(i),
        t.exit("lineEnding"),
        n = !0,
        r) : st(i) ? ht(t, r, n ? "linePrefix" : "lineSuffix")(i) : e(i)
    }
}
const tV = {
    name: "definition",
    tokenize: rV
}
  , nV = {
    tokenize: iV,
    partial: !0
};
function rV(t, e, n) {
    const r = this;
    let i;
    return s;
    function s(f) {
        return t.enter("definition"),
        o(f)
    }
    function o(f) {
        return eI.call(r, t, a, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(f)
    }
    function a(f) {
        return i = Xr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)),
        f === 58 ? (t.enter("definitionMarker"),
        t.consume(f),
        t.exit("definitionMarker"),
        l) : n(f)
    }
    function l(f) {
        return At(f) ? $c(t, c)(f) : c(f)
    }
    function c(f) {
        return Z2(t, u, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(f)
    }
    function u(f) {
        return t.attempt(nV, h, h)(f)
    }
    function h(f) {
        return st(f) ? ht(t, d, "whitespace")(f) : d(f)
    }
    function d(f) {
        return f === null || je(f) ? (t.exit("definition"),
        r.parser.defined.push(i),
        e(f)) : n(f)
    }
}
function iV(t, e, n) {
    return r;
    function r(a) {
        return At(a) ? $c(t, i)(a) : n(a)
    }
    function i(a) {
        return tI(t, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a)
    }
    function s(a) {
        return st(a) ? ht(t, o, "whitespace")(a) : o(a)
    }
    function o(a) {
        return a === null || je(a) ? e(a) : n(a)
    }
}
const sV = {
    name: "hardBreakEscape",
    tokenize: oV
};
function oV(t, e, n) {
    return r;
    function r(s) {
        return t.enter("hardBreakEscape"),
        t.consume(s),
        i
    }
    function i(s) {
        return je(s) ? (t.exit("hardBreakEscape"),
        e(s)) : n(s)
    }
}
const aV = {
    name: "headingAtx",
    tokenize: cV,
    resolve: lV
};
function lV(t, e) {
    let n = t.length - 2, r = 3, i, s;
    return t[r][1].type === "whitespace" && (r += 2),
    n - 2 > r && t[n][1].type === "whitespace" && (n -= 2),
    t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4),
    n > r && (i = {
        type: "atxHeadingText",
        start: t[r][1].start,
        end: t[n][1].end
    },
    s = {
        type: "chunkText",
        start: t[r][1].start,
        end: t[n][1].end,
        contentType: "text"
    },
    Pr(t, r, n - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])),
    t
}
function cV(t, e, n) {
    let r = 0;
    return i;
    function i(u) {
        return t.enter("atxHeading"),
        s(u)
    }
    function s(u) {
        return t.enter("atxHeadingSequence"),
        o(u)
    }
    function o(u) {
        return u === 35 && r++ < 6 ? (t.consume(u),
        o) : u === null || At(u) ? (t.exit("atxHeadingSequence"),
        a(u)) : n(u)
    }
    function a(u) {
        return u === 35 ? (t.enter("atxHeadingSequence"),
        l(u)) : u === null || je(u) ? (t.exit("atxHeading"),
        e(u)) : st(u) ? ht(t, a, "whitespace")(u) : (t.enter("atxHeadingText"),
        c(u))
    }
    function l(u) {
        return u === 35 ? (t.consume(u),
        l) : (t.exit("atxHeadingSequence"),
        a(u))
    }
    function c(u) {
        return u === null || u === 35 || At(u) ? (t.exit("atxHeadingText"),
        a(u)) : (t.consume(u),
        c)
    }
}
const uV = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
  , TS = ["pre", "script", "style", "textarea"]
  , hV = {
    name: "htmlFlow",
    tokenize: mV,
    resolveTo: pV,
    concrete: !0
}
  , dV = {
    tokenize: _V,
    partial: !0
}
  , fV = {
    tokenize: gV,
    partial: !0
};
function pV(t) {
    let e = t.length;
    for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); )
        ;
    return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start,
    t[e + 1][1].start = t[e - 2][1].start,
    t.splice(e - 2, 2)),
    t
}
function mV(t, e, n) {
    const r = this;
    let i, s, o, a, l;
    return c;
    function c(B) {
        return u(B)
    }
    function u(B) {
        return t.enter("htmlFlow"),
        t.enter("htmlFlowData"),
        t.consume(B),
        h
    }
    function h(B) {
        return B === 33 ? (t.consume(B),
        d) : B === 47 ? (t.consume(B),
        s = !0,
        _) : B === 63 ? (t.consume(B),
        i = 3,
        r.interrupt ? e : L) : jn(B) ? (t.consume(B),
        o = String.fromCharCode(B),
        m) : n(B)
    }
    function d(B) {
        return B === 45 ? (t.consume(B),
        i = 2,
        f) : B === 91 ? (t.consume(B),
        i = 5,
        a = 0,
        g) : jn(B) ? (t.consume(B),
        i = 4,
        r.interrupt ? e : L) : n(B)
    }
    function f(B) {
        return B === 45 ? (t.consume(B),
        r.interrupt ? e : L) : n(B)
    }
    function g(B) {
        const Z = "CDATA[";
        return B === Z.charCodeAt(a++) ? (t.consume(B),
        a === Z.length ? r.interrupt ? e : O : g) : n(B)
    }
    function _(B) {
        return jn(B) ? (t.consume(B),
        o = String.fromCharCode(B),
        m) : n(B)
    }
    function m(B) {
        if (B === null || B === 47 || B === 62 || At(B)) {
            const Z = B === 47
              , se = o.toLowerCase();
            return !Z && !s && TS.includes(se) ? (i = 1,
            r.interrupt ? e(B) : O(B)) : uV.includes(o.toLowerCase()) ? (i = 6,
            Z ? (t.consume(B),
            p) : r.interrupt ? e(B) : O(B)) : (i = 7,
            r.interrupt && !r.parser.lazy[r.now().line] ? n(B) : s ? b(B) : y(B))
        }
        return B === 45 || In(B) ? (t.consume(B),
        o += String.fromCharCode(B),
        m) : n(B)
    }
    function p(B) {
        return B === 62 ? (t.consume(B),
        r.interrupt ? e : O) : n(B)
    }
    function b(B) {
        return st(B) ? (t.consume(B),
        b) : I(B)
    }
    function y(B) {
        return B === 47 ? (t.consume(B),
        I) : B === 58 || B === 95 || jn(B) ? (t.consume(B),
        x) : st(B) ? (t.consume(B),
        y) : I(B)
    }
    function x(B) {
        return B === 45 || B === 46 || B === 58 || B === 95 || In(B) ? (t.consume(B),
        x) : E(B)
    }
    function E(B) {
        return B === 61 ? (t.consume(B),
        w) : st(B) ? (t.consume(B),
        E) : y(B)
    }
    function w(B) {
        return B === null || B === 60 || B === 61 || B === 62 || B === 96 ? n(B) : B === 34 || B === 39 ? (t.consume(B),
        l = B,
        A) : st(B) ? (t.consume(B),
        w) : C(B)
    }
    function A(B) {
        return B === l ? (t.consume(B),
        l = null,
        k) : B === null || je(B) ? n(B) : (t.consume(B),
        A)
    }
    function C(B) {
        return B === null || B === 34 || B === 39 || B === 47 || B === 60 || B === 61 || B === 62 || B === 96 || At(B) ? E(B) : (t.consume(B),
        C)
    }
    function k(B) {
        return B === 47 || B === 62 || st(B) ? y(B) : n(B)
    }
    function I(B) {
        return B === 62 ? (t.consume(B),
        N) : n(B)
    }
    function N(B) {
        return B === null || je(B) ? O(B) : st(B) ? (t.consume(B),
        N) : n(B)
    }
    function O(B) {
        return B === 45 && i === 2 ? (t.consume(B),
        J) : B === 60 && i === 1 ? (t.consume(B),
        Q) : B === 62 && i === 4 ? (t.consume(B),
        z) : B === 63 && i === 3 ? (t.consume(B),
        L) : B === 93 && i === 5 ? (t.consume(B),
        D) : je(B) && (i === 6 || i === 7) ? (t.exit("htmlFlowData"),
        t.check(dV, V, M)(B)) : B === null || je(B) ? (t.exit("htmlFlowData"),
        M(B)) : (t.consume(B),
        O)
    }
    function M(B) {
        return t.check(fV, H, V)(B)
    }
    function H(B) {
        return t.enter("lineEnding"),
        t.consume(B),
        t.exit("lineEnding"),
        $
    }
    function $(B) {
        return B === null || je(B) ? M(B) : (t.enter("htmlFlowData"),
        O(B))
    }
    function J(B) {
        return B === 45 ? (t.consume(B),
        L) : O(B)
    }
    function Q(B) {
        return B === 47 ? (t.consume(B),
        o = "",
        ee) : O(B)
    }
    function ee(B) {
        if (B === 62) {
            const Z = o.toLowerCase();
            return TS.includes(Z) ? (t.consume(B),
            z) : O(B)
        }
        return jn(B) && o.length < 8 ? (t.consume(B),
        o += String.fromCharCode(B),
        ee) : O(B)
    }
    function D(B) {
        return B === 93 ? (t.consume(B),
        L) : O(B)
    }
    function L(B) {
        return B === 62 ? (t.consume(B),
        z) : B === 45 && i === 2 ? (t.consume(B),
        L) : O(B)
    }
    function z(B) {
        return B === null || je(B) ? (t.exit("htmlFlowData"),
        V(B)) : (t.consume(B),
        z)
    }
    function V(B) {
        return t.exit("htmlFlow"),
        e(B)
    }
}
function gV(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return je(o) ? (t.enter("lineEnding"),
        t.consume(o),
        t.exit("lineEnding"),
        s) : n(o)
    }
    function s(o) {
        return r.parser.lazy[r.now().line] ? n(o) : e(o)
    }
}
function _V(t, e, n) {
    return r;
    function r(i) {
        return t.enter("lineEnding"),
        t.consume(i),
        t.exit("lineEnding"),
        t.attempt(Nh, e, n)
    }
}
const bV = {
    name: "htmlText",
    tokenize: yV
};
function yV(t, e, n) {
    const r = this;
    let i, s, o;
    return a;
    function a(L) {
        return t.enter("htmlText"),
        t.enter("htmlTextData"),
        t.consume(L),
        l
    }
    function l(L) {
        return L === 33 ? (t.consume(L),
        c) : L === 47 ? (t.consume(L),
        E) : L === 63 ? (t.consume(L),
        y) : jn(L) ? (t.consume(L),
        C) : n(L)
    }
    function c(L) {
        return L === 45 ? (t.consume(L),
        u) : L === 91 ? (t.consume(L),
        s = 0,
        g) : jn(L) ? (t.consume(L),
        b) : n(L)
    }
    function u(L) {
        return L === 45 ? (t.consume(L),
        f) : n(L)
    }
    function h(L) {
        return L === null ? n(L) : L === 45 ? (t.consume(L),
        d) : je(L) ? (o = h,
        Q(L)) : (t.consume(L),
        h)
    }
    function d(L) {
        return L === 45 ? (t.consume(L),
        f) : h(L)
    }
    function f(L) {
        return L === 62 ? J(L) : L === 45 ? d(L) : h(L)
    }
    function g(L) {
        const z = "CDATA[";
        return L === z.charCodeAt(s++) ? (t.consume(L),
        s === z.length ? _ : g) : n(L)
    }
    function _(L) {
        return L === null ? n(L) : L === 93 ? (t.consume(L),
        m) : je(L) ? (o = _,
        Q(L)) : (t.consume(L),
        _)
    }
    function m(L) {
        return L === 93 ? (t.consume(L),
        p) : _(L)
    }
    function p(L) {
        return L === 62 ? J(L) : L === 93 ? (t.consume(L),
        p) : _(L)
    }
    function b(L) {
        return L === null || L === 62 ? J(L) : je(L) ? (o = b,
        Q(L)) : (t.consume(L),
        b)
    }
    function y(L) {
        return L === null ? n(L) : L === 63 ? (t.consume(L),
        x) : je(L) ? (o = y,
        Q(L)) : (t.consume(L),
        y)
    }
    function x(L) {
        return L === 62 ? J(L) : y(L)
    }
    function E(L) {
        return jn(L) ? (t.consume(L),
        w) : n(L)
    }
    function w(L) {
        return L === 45 || In(L) ? (t.consume(L),
        w) : A(L)
    }
    function A(L) {
        return je(L) ? (o = A,
        Q(L)) : st(L) ? (t.consume(L),
        A) : J(L)
    }
    function C(L) {
        return L === 45 || In(L) ? (t.consume(L),
        C) : L === 47 || L === 62 || At(L) ? k(L) : n(L)
    }
    function k(L) {
        return L === 47 ? (t.consume(L),
        J) : L === 58 || L === 95 || jn(L) ? (t.consume(L),
        I) : je(L) ? (o = k,
        Q(L)) : st(L) ? (t.consume(L),
        k) : J(L)
    }
    function I(L) {
        return L === 45 || L === 46 || L === 58 || L === 95 || In(L) ? (t.consume(L),
        I) : N(L)
    }
    function N(L) {
        return L === 61 ? (t.consume(L),
        O) : je(L) ? (o = N,
        Q(L)) : st(L) ? (t.consume(L),
        N) : k(L)
    }
    function O(L) {
        return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? n(L) : L === 34 || L === 39 ? (t.consume(L),
        i = L,
        M) : je(L) ? (o = O,
        Q(L)) : st(L) ? (t.consume(L),
        O) : (t.consume(L),
        H)
    }
    function M(L) {
        return L === i ? (t.consume(L),
        i = void 0,
        $) : L === null ? n(L) : je(L) ? (o = M,
        Q(L)) : (t.consume(L),
        M)
    }
    function H(L) {
        return L === null || L === 34 || L === 39 || L === 60 || L === 61 || L === 96 ? n(L) : L === 47 || L === 62 || At(L) ? k(L) : (t.consume(L),
        H)
    }
    function $(L) {
        return L === 47 || L === 62 || At(L) ? k(L) : n(L)
    }
    function J(L) {
        return L === 62 ? (t.consume(L),
        t.exit("htmlTextData"),
        t.exit("htmlText"),
        e) : n(L)
    }
    function Q(L) {
        return t.exit("htmlTextData"),
        t.enter("lineEnding"),
        t.consume(L),
        t.exit("lineEnding"),
        ee
    }
    function ee(L) {
        return st(L) ? ht(t, D, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(L) : D(L)
    }
    function D(L) {
        return t.enter("htmlTextData"),
        o(L)
    }
}
const Iv = {
    name: "labelEnd",
    tokenize: CV,
    resolveTo: wV,
    resolveAll: SV
}
  , vV = {
    tokenize: TV
}
  , xV = {
    tokenize: AV
}
  , EV = {
    tokenize: kV
};
function SV(t) {
    let e = -1;
    for (; ++e < t.length; ) {
        const n = t[e][1];
        (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (t.splice(e + 1, n.type === "labelImage" ? 4 : 2),
        n.type = "data",
        e++)
    }
    return t
}
function wV(t, e) {
    let n = t.length, r = 0, i, s, o, a;
    for (; n--; )
        if (i = t[n][1],
        s) {
            if (i.type === "link" || i.type === "labelLink" && i._inactive)
                break;
            t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0)
        } else if (o) {
            if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = n,
            i.type !== "labelLink")) {
                r = 2;
                break
            }
        } else
            i.type === "labelEnd" && (o = n);
    const l = {
        type: t[s][1].type === "labelLink" ? "link" : "image",
        start: Object.assign({}, t[s][1].start),
        end: Object.assign({}, t[t.length - 1][1].end)
    }
      , c = {
        type: "label",
        start: Object.assign({}, t[s][1].start),
        end: Object.assign({}, t[o][1].end)
    }
      , u = {
        type: "labelText",
        start: Object.assign({}, t[s + r + 2][1].end),
        end: Object.assign({}, t[o - 2][1].start)
    };
    return a = [["enter", l, e], ["enter", c, e]],
    a = Tr(a, t.slice(s + 1, s + r + 3)),
    a = Tr(a, [["enter", u, e]]),
    a = Tr(a, km(e.parser.constructs.insideSpan.null, t.slice(s + r + 4, o - 3), e)),
    a = Tr(a, [["exit", u, e], t[o - 2], t[o - 1], ["exit", c, e]]),
    a = Tr(a, t.slice(o + 1)),
    a = Tr(a, [["exit", l, e]]),
    Pr(t, s, t.length, a),
    t
}
function CV(t, e, n) {
    const r = this;
    let i = r.events.length, s, o;
    for (; i--; )
        if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
            s = r.events[i][1];
            break
        }
    return a;
    function a(d) {
        return s ? s._inactive ? h(d) : (o = r.parser.defined.includes(Xr(r.sliceSerialize({
            start: s.end,
            end: r.now()
        }))),
        t.enter("labelEnd"),
        t.enter("labelMarker"),
        t.consume(d),
        t.exit("labelMarker"),
        t.exit("labelEnd"),
        l) : n(d)
    }
    function l(d) {
        return d === 40 ? t.attempt(vV, u, o ? u : h)(d) : d === 91 ? t.attempt(xV, u, o ? c : h)(d) : o ? u(d) : h(d)
    }
    function c(d) {
        return t.attempt(EV, u, h)(d)
    }
    function u(d) {
        return e(d)
    }
    function h(d) {
        return s._balanced = !0,
        n(d)
    }
}
function TV(t, e, n) {
    return r;
    function r(h) {
        return t.enter("resource"),
        t.enter("resourceMarker"),
        t.consume(h),
        t.exit("resourceMarker"),
        i
    }
    function i(h) {
        return At(h) ? $c(t, s)(h) : s(h)
    }
    function s(h) {
        return h === 41 ? u(h) : Z2(t, o, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h)
    }
    function o(h) {
        return At(h) ? $c(t, l)(h) : u(h)
    }
    function a(h) {
        return n(h)
    }
    function l(h) {
        return h === 34 || h === 39 || h === 40 ? tI(t, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h)
    }
    function c(h) {
        return At(h) ? $c(t, u)(h) : u(h)
    }
    function u(h) {
        return h === 41 ? (t.enter("resourceMarker"),
        t.consume(h),
        t.exit("resourceMarker"),
        t.exit("resource"),
        e) : n(h)
    }
}
function AV(t, e, n) {
    const r = this;
    return i;
    function i(a) {
        return eI.call(r, t, s, o, "reference", "referenceMarker", "referenceString")(a)
    }
    function s(a) {
        return r.parser.defined.includes(Xr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(a) : n(a)
    }
    function o(a) {
        return n(a)
    }
}
function kV(t, e, n) {
    return r;
    function r(s) {
        return t.enter("reference"),
        t.enter("referenceMarker"),
        t.consume(s),
        t.exit("referenceMarker"),
        i
    }
    function i(s) {
        return s === 93 ? (t.enter("referenceMarker"),
        t.consume(s),
        t.exit("referenceMarker"),
        t.exit("reference"),
        e) : n(s)
    }
}
const RV = {
    name: "labelStartImage",
    tokenize: IV,
    resolveAll: Iv.resolveAll
};
function IV(t, e, n) {
    const r = this;
    return i;
    function i(a) {
        return t.enter("labelImage"),
        t.enter("labelImageMarker"),
        t.consume(a),
        t.exit("labelImageMarker"),
        s
    }
    function s(a) {
        return a === 91 ? (t.enter("labelMarker"),
        t.consume(a),
        t.exit("labelMarker"),
        t.exit("labelImage"),
        o) : n(a)
    }
    function o(a) {
        return a === 94 && "_hiddenFootnoteSupport"in r.parser.constructs ? n(a) : e(a)
    }
}
const PV = {
    name: "labelStartLink",
    tokenize: DV,
    resolveAll: Iv.resolveAll
};
function DV(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return t.enter("labelLink"),
        t.enter("labelMarker"),
        t.consume(o),
        t.exit("labelMarker"),
        t.exit("labelLink"),
        s
    }
    function s(o) {
        return o === 94 && "_hiddenFootnoteSupport"in r.parser.constructs ? n(o) : e(o)
    }
}
const Vg = {
    name: "lineEnding",
    tokenize: LV
};
function LV(t, e) {
    return n;
    function n(r) {
        return t.enter("lineEnding"),
        t.consume(r),
        t.exit("lineEnding"),
        ht(t, e, "linePrefix")
    }
}
const pf = {
    name: "thematicBreak",
    tokenize: OV
};
function OV(t, e, n) {
    let r = 0, i;
    return s;
    function s(c) {
        return t.enter("thematicBreak"),
        o(c)
    }
    function o(c) {
        return i = c,
        a(c)
    }
    function a(c) {
        return c === i ? (t.enter("thematicBreakSequence"),
        l(c)) : r >= 3 && (c === null || je(c)) ? (t.exit("thematicBreak"),
        e(c)) : n(c)
    }
    function l(c) {
        return c === i ? (t.consume(c),
        r++,
        l) : (t.exit("thematicBreakSequence"),
        st(c) ? ht(t, a, "whitespace")(c) : a(c))
    }
}
const Kn = {
    name: "list",
    tokenize: BV,
    continuation: {
        tokenize: FV
    },
    exit: HV
}
  , NV = {
    tokenize: UV,
    partial: !0
}
  , MV = {
    tokenize: jV,
    partial: !0
};
function BV(t, e, n) {
    const r = this
      , i = r.events[r.events.length - 1];
    let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0
      , o = 0;
    return a;
    function a(f) {
        const g = r.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
        if (g === "listUnordered" ? !r.containerState.marker || f === r.containerState.marker : B_(f)) {
            if (r.containerState.type || (r.containerState.type = g,
            t.enter(g, {
                _container: !0
            })),
            g === "listUnordered")
                return t.enter("listItemPrefix"),
                f === 42 || f === 45 ? t.check(pf, n, c)(f) : c(f);
            if (!r.interrupt || f === 49)
                return t.enter("listItemPrefix"),
                t.enter("listItemValue"),
                l(f)
        }
        return n(f)
    }
    function l(f) {
        return B_(f) && ++o < 10 ? (t.consume(f),
        l) : (!r.interrupt || o < 2) && (r.containerState.marker ? f === r.containerState.marker : f === 41 || f === 46) ? (t.exit("listItemValue"),
        c(f)) : n(f)
    }
    function c(f) {
        return t.enter("listItemMarker"),
        t.consume(f),
        t.exit("listItemMarker"),
        r.containerState.marker = r.containerState.marker || f,
        t.check(Nh, r.interrupt ? n : u, t.attempt(NV, d, h))
    }
    function u(f) {
        return r.containerState.initialBlankLine = !0,
        s++,
        d(f)
    }
    function h(f) {
        return st(f) ? (t.enter("listItemPrefixWhitespace"),
        t.consume(f),
        t.exit("listItemPrefixWhitespace"),
        d) : n(f)
    }
    function d(f) {
        return r.containerState.size = s + r.sliceSerialize(t.exit("listItemPrefix"), !0).length,
        e(f)
    }
}
function FV(t, e, n) {
    const r = this;
    return r.containerState._closeFlow = void 0,
    t.check(Nh, i, s);
    function i(a) {
        return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine,
        ht(t, e, "listItemIndent", r.containerState.size + 1)(a)
    }
    function s(a) {
        return r.containerState.furtherBlankLines || !st(a) ? (r.containerState.furtherBlankLines = void 0,
        r.containerState.initialBlankLine = void 0,
        o(a)) : (r.containerState.furtherBlankLines = void 0,
        r.containerState.initialBlankLine = void 0,
        t.attempt(MV, e, o)(a))
    }
    function o(a) {
        return r.containerState._closeFlow = !0,
        r.interrupt = void 0,
        ht(t, t.attempt(Kn, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a)
    }
}
function jV(t, e, n) {
    const r = this;
    return ht(t, i, "listItemIndent", r.containerState.size + 1);
    function i(s) {
        const o = r.events[r.events.length - 1];
        return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : n(s)
    }
}
function HV(t) {
    t.exit(this.containerState.type)
}
function UV(t, e, n) {
    const r = this;
    return ht(t, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
    function i(s) {
        const o = r.events[r.events.length - 1];
        return !st(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : n(s)
    }
}
const AS = {
    name: "setextUnderline",
    tokenize: $V,
    resolveTo: VV
};
function VV(t, e) {
    let n = t.length, r, i, s;
    for (; n--; )
        if (t[n][0] === "enter") {
            if (t[n][1].type === "content") {
                r = n;
                break
            }
            t[n][1].type === "paragraph" && (i = n)
        } else
            t[n][1].type === "content" && t.splice(n, 1),
            !s && t[n][1].type === "definition" && (s = n);
    const o = {
        type: "setextHeading",
        start: Object.assign({}, t[i][1].start),
        end: Object.assign({}, t[t.length - 1][1].end)
    };
    return t[i][1].type = "setextHeadingText",
    s ? (t.splice(i, 0, ["enter", o, e]),
    t.splice(s + 1, 0, ["exit", t[r][1], e]),
    t[r][1].end = Object.assign({}, t[s][1].end)) : t[r][1] = o,
    t.push(["exit", o, e]),
    t
}
function $V(t, e, n) {
    const r = this;
    let i;
    return s;
    function s(c) {
        let u = r.events.length, h;
        for (; u--; )
            if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
                h = r.events[u][1].type === "paragraph";
                break
            }
        return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (t.enter("setextHeadingLine"),
        i = c,
        o(c)) : n(c)
    }
    function o(c) {
        return t.enter("setextHeadingLineSequence"),
        a(c)
    }
    function a(c) {
        return c === i ? (t.consume(c),
        a) : (t.exit("setextHeadingLineSequence"),
        st(c) ? ht(t, l, "lineSuffix")(c) : l(c))
    }
    function l(c) {
        return c === null || je(c) ? (t.exit("setextHeadingLine"),
        e(c)) : n(c)
    }
}
const zV = {
    tokenize: WV
};
function WV(t) {
    const e = this
      , n = t.attempt(Nh, r, t.attempt(this.parser.constructs.flowInitial, i, ht(t, t.attempt(this.parser.constructs.flow, i, t.attempt(X7, i)), "linePrefix")));
    return n;
    function r(s) {
        if (s === null) {
            t.consume(s);
            return
        }
        return t.enter("lineEndingBlank"),
        t.consume(s),
        t.exit("lineEndingBlank"),
        e.currentConstruct = void 0,
        n
    }
    function i(s) {
        if (s === null) {
            t.consume(s);
            return
        }
        return t.enter("lineEnding"),
        t.consume(s),
        t.exit("lineEnding"),
        e.currentConstruct = void 0,
        n
    }
}
const GV = {
    resolveAll: rI()
}
  , qV = nI("string")
  , KV = nI("text");
function nI(t) {
    return {
        tokenize: e,
        resolveAll: rI(t === "text" ? YV : void 0)
    };
    function e(n) {
        const r = this
          , i = this.parser.constructs[t]
          , s = n.attempt(i, o, a);
        return o;
        function o(u) {
            return c(u) ? s(u) : a(u)
        }
        function a(u) {
            if (u === null) {
                n.consume(u);
                return
            }
            return n.enter("data"),
            n.consume(u),
            l
        }
        function l(u) {
            return c(u) ? (n.exit("data"),
            s(u)) : (n.consume(u),
            l)
        }
        function c(u) {
            if (u === null)
                return !0;
            const h = i[u];
            let d = -1;
            if (h)
                for (; ++d < h.length; ) {
                    const f = h[d];
                    if (!f.previous || f.previous.call(r, r.previous))
                        return !0
                }
            return !1
        }
    }
}
function rI(t) {
    return e;
    function e(n, r) {
        let i = -1, s;
        for (; ++i <= n.length; )
            s === void 0 ? n[i] && n[i][1].type === "data" && (s = i,
            i++) : (!n[i] || n[i][1].type !== "data") && (i !== s + 2 && (n[s][1].end = n[i - 1][1].end,
            n.splice(s + 2, i - s - 2),
            i = s + 2),
            s = void 0);
        return t ? t(n, r) : n
    }
}
function YV(t, e) {
    let n = 0;
    for (; ++n <= t.length; )
        if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
            const r = t[n - 1][1]
              , i = e.sliceStream(r);
            let s = i.length, o = -1, a = 0, l;
            for (; s--; ) {
                const c = i[s];
                if (typeof c == "string") {
                    for (o = c.length; c.charCodeAt(o - 1) === 32; )
                        a++,
                        o--;
                    if (o)
                        break;
                    o = -1
                } else if (c === -2)
                    l = !0,
                    a++;
                else if (c !== -1) {
                    s++;
                    break
                }
            }
            if (a) {
                const c = {
                    type: n === t.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
                    start: {
                        line: r.end.line,
                        column: r.end.column - a,
                        offset: r.end.offset - a,
                        _index: r.start._index + s,
                        _bufferIndex: s ? o : r.start._bufferIndex + o
                    },
                    end: Object.assign({}, r.end)
                };
                r.end = Object.assign({}, c.start),
                r.start.offset === r.end.offset ? Object.assign(r, c) : (t.splice(n, 0, ["enter", c, e], ["exit", c, e]),
                n += 2)
            }
            n++
        }
    return t
}
function XV(t, e, n) {
    let r = Object.assign(n ? Object.assign({}, n) : {
        line: 1,
        column: 1,
        offset: 0
    }, {
        _index: 0,
        _bufferIndex: -1
    });
    const i = {}
      , s = [];
    let o = []
      , a = [];
    const l = {
        consume: b,
        enter: y,
        exit: x,
        attempt: A(E),
        check: A(w),
        interrupt: A(w, {
            interrupt: !0
        })
    }
      , c = {
        previous: null,
        code: null,
        containerState: {},
        events: [],
        parser: t,
        sliceStream: f,
        sliceSerialize: d,
        now: g,
        defineSkip: _,
        write: h
    };
    let u = e.tokenize.call(c, l);
    return e.resolveAll && s.push(e),
    c;
    function h(N) {
        return o = Tr(o, N),
        m(),
        o[o.length - 1] !== null ? [] : (C(e, 0),
        c.events = km(s, c.events, c),
        c.events)
    }
    function d(N, O) {
        return JV(f(N), O)
    }
    function f(N) {
        return QV(o, N)
    }
    function g() {
        const {line: N, column: O, offset: M, _index: H, _bufferIndex: $} = r;
        return {
            line: N,
            column: O,
            offset: M,
            _index: H,
            _bufferIndex: $
        }
    }
    function _(N) {
        i[N.line] = N.column,
        I()
    }
    function m() {
        let N;
        for (; r._index < o.length; ) {
            const O = o[r._index];
            if (typeof O == "string")
                for (N = r._index,
                r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === N && r._bufferIndex < O.length; )
                    p(O.charCodeAt(r._bufferIndex));
            else
                p(O)
        }
    }
    function p(N) {
        u = u(N)
    }
    function b(N) {
        je(N) ? (r.line++,
        r.column = 1,
        r.offset += N === -3 ? 2 : 1,
        I()) : N !== -1 && (r.column++,
        r.offset++),
        r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++,
        r._bufferIndex === o[r._index].length && (r._bufferIndex = -1,
        r._index++)),
        c.previous = N
    }
    function y(N, O) {
        const M = O || {};
        return M.type = N,
        M.start = g(),
        c.events.push(["enter", M, c]),
        a.push(M),
        M
    }
    function x(N) {
        const O = a.pop();
        return O.end = g(),
        c.events.push(["exit", O, c]),
        O
    }
    function E(N, O) {
        C(N, O.from)
    }
    function w(N, O) {
        O.restore()
    }
    function A(N, O) {
        return M;
        function M(H, $, J) {
            let Q, ee, D, L;
            return Array.isArray(H) ? V(H) : "tokenize"in H ? V([H]) : z(H);
            function z(ae) {
                return G;
                function G(j) {
                    const oe = j !== null && ae[j]
                      , le = j !== null && ae.null
                      , de = [...Array.isArray(oe) ? oe : oe ? [oe] : [], ...Array.isArray(le) ? le : le ? [le] : []];
                    return V(de)(j)
                }
            }
            function V(ae) {
                return Q = ae,
                ee = 0,
                ae.length === 0 ? J : B(ae[ee])
            }
            function B(ae) {
                return G;
                function G(j) {
                    return L = k(),
                    D = ae,
                    ae.partial || (c.currentConstruct = ae),
                    ae.name && c.parser.constructs.disable.null.includes(ae.name) ? se() : ae.tokenize.call(O ? Object.assign(Object.create(c), O) : c, l, Z, se)(j)
                }
            }
            function Z(ae) {
                return N(D, L),
                $
            }
            function se(ae) {
                return L.restore(),
                ++ee < Q.length ? B(Q[ee]) : J
            }
        }
    }
    function C(N, O) {
        N.resolveAll && !s.includes(N) && s.push(N),
        N.resolve && Pr(c.events, O, c.events.length - O, N.resolve(c.events.slice(O), c)),
        N.resolveTo && (c.events = N.resolveTo(c.events, c))
    }
    function k() {
        const N = g()
          , O = c.previous
          , M = c.currentConstruct
          , H = c.events.length
          , $ = Array.from(a);
        return {
            restore: J,
            from: H
        };
        function J() {
            r = N,
            c.previous = O,
            c.currentConstruct = M,
            c.events.length = H,
            a = $,
            I()
        }
    }
    function I() {
        r.line in i && r.column < 2 && (r.column = i[r.line],
        r.offset += i[r.line] - 1)
    }
}
function QV(t, e) {
    const n = e.start._index
      , r = e.start._bufferIndex
      , i = e.end._index
      , s = e.end._bufferIndex;
    let o;
    if (n === i)
        o = [t[n].slice(r, s)];
    else {
        if (o = t.slice(n, i),
        r > -1) {
            const a = o[0];
            typeof a == "string" ? o[0] = a.slice(r) : o.shift()
        }
        s > 0 && o.push(t[i].slice(0, s))
    }
    return o
}
function JV(t, e) {
    let n = -1;
    const r = [];
    let i;
    for (; ++n < t.length; ) {
        const s = t[n];
        let o;
        if (typeof s == "string")
            o = s;
        else
            switch (s) {
            case -5:
                {
                    o = "\r";
                    break
                }
            case -4:
                {
                    o = `
`;
                    break
                }
            case -3:
                {
                    o = `\r
`;
                    break
                }
            case -2:
                {
                    o = e ? " " : "	";
                    break
                }
            case -1:
                {
                    if (!e && i)
                        continue;
                    o = " ";
                    break
                }
            default:
                o = String.fromCharCode(s)
            }
        i = s === -2,
        r.push(o)
    }
    return r.join("")
}
const ZV = {
    42: Kn,
    43: Kn,
    45: Kn,
    48: Kn,
    49: Kn,
    50: Kn,
    51: Kn,
    52: Kn,
    53: Kn,
    54: Kn,
    55: Kn,
    56: Kn,
    57: Kn,
    62: Y2
}
  , e$ = {
    91: tV
}
  , t$ = {
    [-2]: Ug,
    [-1]: Ug,
    32: Ug
}
  , n$ = {
    35: aV,
    42: pf,
    45: [AS, pf],
    60: hV,
    61: AS,
    95: pf,
    96: CS,
    126: CS
}
  , r$ = {
    38: Q2,
    92: X2
}
  , i$ = {
    [-5]: Vg,
    [-4]: Vg,
    [-3]: Vg,
    33: RV,
    38: Q2,
    42: F_,
    60: [P7, bV],
    91: PV,
    92: [sV, X2],
    93: Iv,
    95: F_,
    96: z7
}
  , s$ = {
    null: [F_, GV]
}
  , o$ = {
    null: [42, 95]
}
  , a$ = {
    null: []
}
  , l$ = Object.freeze(Object.defineProperty({
    __proto__: null,
    attentionMarkers: o$,
    contentInitial: e$,
    disable: a$,
    document: ZV,
    flow: n$,
    flowInitial: t$,
    insideSpan: s$,
    string: r$,
    text: i$
}, Symbol.toStringTag, {
    value: "Module"
}));
function c$(t) {
    const n = q2([l$, ...(t || {}).extensions || []])
      , r = {
        defined: [],
        lazy: {},
        constructs: n,
        content: i(w7),
        document: i(T7),
        flow: i(zV),
        string: i(qV),
        text: i(KV)
    };
    return r;
    function i(s) {
        return o;
        function o(a) {
            return XV(r, s, a)
        }
    }
}
function u$(t) {
    for (; !J2(t); )
        ;
    return t
}
const kS = /[\0\t\n\r]/g;
function h$() {
    let t = 1, e = "", n = !0, r;
    return i;
    function i(s, o, a) {
        const l = [];
        let c, u, h, d, f;
        for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)),
        h = 0,
        e = "",
        n && (s.charCodeAt(0) === 65279 && h++,
        n = void 0); h < s.length; ) {
            if (kS.lastIndex = h,
            c = kS.exec(s),
            d = c && c.index !== void 0 ? c.index : s.length,
            f = s.charCodeAt(d),
            !c) {
                e = s.slice(h);
                break
            }
            if (f === 10 && h === d && r)
                l.push(-3),
                r = void 0;
            else
                switch (r && (l.push(-5),
                r = void 0),
                h < d && (l.push(s.slice(h, d)),
                t += d - h),
                f) {
                case 0:
                    {
                        l.push(65533),
                        t++;
                        break
                    }
                case 9:
                    {
                        for (u = Math.ceil(t / 4) * 4,
                        l.push(-2); t++ < u; )
                            l.push(-1);
                        break
                    }
                case 10:
                    {
                        l.push(-4),
                        t = 1;
                        break
                    }
                default:
                    r = !0,
                    t = 1
                }
            h = d + 1
        }
        return a && (r && l.push(-5),
        e && l.push(e),
        l.push(null)),
        l
    }
}
const d$ = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function f$(t) {
    return t.replace(d$, p$)
}
function p$(t, e, n) {
    if (e)
        return e;
    if (n.charCodeAt(0) === 35) {
        const i = n.charCodeAt(1)
          , s = i === 120 || i === 88;
        return K2(n.slice(s ? 2 : 1), s ? 16 : 10)
    }
    return Rv(n) || t
}
const iI = {}.hasOwnProperty;
function m$(t, e, n) {
    return typeof e != "string" && (n = e,
    e = void 0),
    g$(n)(u$(c$(n).document().write(h$()(t, e, !0))))
}
function g$(t) {
    const e = {
        transforms: [],
        canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
        enter: {
            autolink: s(qe),
            autolinkProtocol: k,
            autolinkEmail: k,
            atxHeading: s(Ce),
            blockQuote: s(le),
            characterEscape: k,
            characterReference: k,
            codeFenced: s(de),
            codeFencedFenceInfo: o,
            codeFencedFenceMeta: o,
            codeIndented: s(de, o),
            codeText: s(ne, o),
            codeTextData: k,
            data: k,
            codeFlowValue: k,
            definition: s(pe),
            definitionDestinationString: o,
            definitionLabelString: o,
            definitionTitleString: o,
            emphasis: s(Te),
            hardBreakEscape: s(Re),
            hardBreakTrailing: s(Re),
            htmlFlow: s(we, o),
            htmlFlowData: k,
            htmlText: s(we, o),
            htmlTextData: k,
            image: s(ze),
            label: o,
            link: s(qe),
            listItem: s($t),
            listItemValue: d,
            listOrdered: s(et, h),
            listUnordered: s(et),
            paragraph: s(Jt),
            reference: B,
            referenceString: o,
            resourceDestinationString: o,
            resourceTitleString: o,
            setextHeading: s(Ce),
            strong: s(_t),
            thematicBreak: s(it)
        },
        exit: {
            atxHeading: l(),
            atxHeadingSequence: E,
            autolink: l(),
            autolinkEmail: oe,
            autolinkProtocol: j,
            blockQuote: l(),
            characterEscapeValue: I,
            characterReferenceMarkerHexadecimal: se,
            characterReferenceMarkerNumeric: se,
            characterReferenceValue: ae,
            characterReference: G,
            codeFenced: l(m),
            codeFencedFence: _,
            codeFencedFenceInfo: f,
            codeFencedFenceMeta: g,
            codeFlowValue: I,
            codeIndented: l(p),
            codeText: l($),
            codeTextData: I,
            data: I,
            definition: l(),
            definitionDestinationString: x,
            definitionLabelString: b,
            definitionTitleString: y,
            emphasis: l(),
            hardBreakEscape: l(O),
            hardBreakTrailing: l(O),
            htmlFlow: l(M),
            htmlFlowData: I,
            htmlText: l(H),
            htmlTextData: I,
            image: l(Q),
            label: D,
            labelText: ee,
            lineEnding: N,
            link: l(J),
            listItem: l(),
            listOrdered: l(),
            listUnordered: l(),
            paragraph: l(),
            referenceString: Z,
            resourceDestinationString: L,
            resourceTitleString: z,
            resource: V,
            setextHeading: l(C),
            setextHeadingLineSequence: A,
            setextHeadingText: w,
            strong: l(),
            thematicBreak: l()
        }
    };
    sI(e, (t || {}).mdastExtensions || []);
    const n = {};
    return r;
    function r(he) {
        let Se = {
            type: "root",
            children: []
        };
        const De = {
            stack: [Se],
            tokenStack: [],
            config: e,
            enter: a,
            exit: c,
            buffer: o,
            resume: u,
            data: n
        }
          , Ge = [];
        let F = -1;
        for (; ++F < he.length; )
            if (he[F][1].type === "listOrdered" || he[F][1].type === "listUnordered")
                if (he[F][0] === "enter")
                    Ge.push(F);
                else {
                    const R = Ge.pop();
                    F = i(he, R, F)
                }
        for (F = -1; ++F < he.length; ) {
            const R = e[he[F][0]];
            iI.call(R, he[F][1].type) && R[he[F][1].type].call(Object.assign({
                sliceSerialize: he[F][2].sliceSerialize
            }, De), he[F][1])
        }
        if (De.tokenStack.length > 0) {
            const R = De.tokenStack[De.tokenStack.length - 1];
            (R[1] || RS).call(De, void 0, R[0])
        }
        for (Se.position = {
            start: ps(he.length > 0 ? he[0][1].start : {
                line: 1,
                column: 1,
                offset: 0
            }),
            end: ps(he.length > 0 ? he[he.length - 2][1].end : {
                line: 1,
                column: 1,
                offset: 0
            })
        },
        F = -1; ++F < e.transforms.length; )
            Se = e.transforms[F](Se) || Se;
        return Se
    }
    function i(he, Se, De) {
        let Ge = Se - 1, F = -1, R = !1, P, q, Y, re;
        for (; ++Ge <= De; ) {
            const ce = he[Ge];
            switch (ce[1].type) {
            case "listUnordered":
            case "listOrdered":
            case "blockQuote":
                {
                    ce[0] === "enter" ? F++ : F--,
                    re = void 0;
                    break
                }
            case "lineEndingBlank":
                {
                    ce[0] === "enter" && (P && !re && !F && !Y && (Y = Ge),
                    re = void 0);
                    break
                }
            case "linePrefix":
            case "listItemValue":
            case "listItemMarker":
            case "listItemPrefix":
            case "listItemPrefixWhitespace":
                break;
            default:
                re = void 0
            }
            if (!F && ce[0] === "enter" && ce[1].type === "listItemPrefix" || F === -1 && ce[0] === "exit" && (ce[1].type === "listUnordered" || ce[1].type === "listOrdered")) {
                if (P) {
                    let Be = Ge;
                    for (q = void 0; Be--; ) {
                        const Ke = he[Be];
                        if (Ke[1].type === "lineEnding" || Ke[1].type === "lineEndingBlank") {
                            if (Ke[0] === "exit")
                                continue;
                            q && (he[q][1].type = "lineEndingBlank",
                            R = !0),
                            Ke[1].type = "lineEnding",
                            q = Be
                        } else if (!(Ke[1].type === "linePrefix" || Ke[1].type === "blockQuotePrefix" || Ke[1].type === "blockQuotePrefixWhitespace" || Ke[1].type === "blockQuoteMarker" || Ke[1].type === "listItemIndent"))
                            break
                    }
                    Y && (!q || Y < q) && (P._spread = !0),
                    P.end = Object.assign({}, q ? he[q][1].start : ce[1].end),
                    he.splice(q || Ge, 0, ["exit", P, ce[2]]),
                    Ge++,
                    De++
                }
                if (ce[1].type === "listItemPrefix") {
                    const Be = {
                        type: "listItem",
                        _spread: !1,
                        start: Object.assign({}, ce[1].start),
                        end: void 0
                    };
                    P = Be,
                    he.splice(Ge, 0, ["enter", Be, ce[2]]),
                    Ge++,
                    De++,
                    Y = void 0,
                    re = !0
                }
            }
        }
        return he[Se][1]._spread = R,
        De
    }
    function s(he, Se) {
        return De;
        function De(Ge) {
            a.call(this, he(Ge), Ge),
            Se && Se.call(this, Ge)
        }
    }
    function o() {
        this.stack.push({
            type: "fragment",
            children: []
        })
    }
    function a(he, Se, De) {
        this.stack[this.stack.length - 1].children.push(he),
        this.stack.push(he),
        this.tokenStack.push([Se, De]),
        he.position = {
            start: ps(Se.start),
            end: void 0
        }
    }
    function l(he) {
        return Se;
        function Se(De) {
            he && he.call(this, De),
            c.call(this, De)
        }
    }
    function c(he, Se) {
        const De = this.stack.pop()
          , Ge = this.tokenStack.pop();
        if (Ge)
            Ge[0].type !== he.type && (Se ? Se.call(this, he, Ge[0]) : (Ge[1] || RS).call(this, he, Ge[0]));
        else
            throw new Error("Cannot close `" + he.type + "` (" + Vc({
                start: he.start,
                end: he.end
            }) + "): its not open");
        De.position.end = ps(he.end)
    }
    function u() {
        return kv(this.stack.pop())
    }
    function h() {
        this.data.expectingFirstListItemValue = !0
    }
    function d(he) {
        if (this.data.expectingFirstListItemValue) {
            const Se = this.stack[this.stack.length - 2];
            Se.start = Number.parseInt(this.sliceSerialize(he), 10),
            this.data.expectingFirstListItemValue = void 0
        }
    }
    function f() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.lang = he
    }
    function g() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.meta = he
    }
    function _() {
        this.data.flowCodeInside || (this.buffer(),
        this.data.flowCodeInside = !0)
    }
    function m() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.value = he.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""),
        this.data.flowCodeInside = void 0
    }
    function p() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.value = he.replace(/(\r?\n|\r)$/g, "")
    }
    function b(he) {
        const Se = this.resume()
          , De = this.stack[this.stack.length - 1];
        De.label = Se,
        De.identifier = Xr(this.sliceSerialize(he)).toLowerCase()
    }
    function y() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.title = he
    }
    function x() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.url = he
    }
    function E(he) {
        const Se = this.stack[this.stack.length - 1];
        if (!Se.depth) {
            const De = this.sliceSerialize(he).length;
            Se.depth = De
        }
    }
    function w() {
        this.data.setextHeadingSlurpLineEnding = !0
    }
    function A(he) {
        const Se = this.stack[this.stack.length - 1];
        Se.depth = this.sliceSerialize(he).codePointAt(0) === 61 ? 1 : 2
    }
    function C() {
        this.data.setextHeadingSlurpLineEnding = void 0
    }
    function k(he) {
        const De = this.stack[this.stack.length - 1].children;
        let Ge = De[De.length - 1];
        (!Ge || Ge.type !== "text") && (Ge = St(),
        Ge.position = {
            start: ps(he.start),
            end: void 0
        },
        De.push(Ge)),
        this.stack.push(Ge)
    }
    function I(he) {
        const Se = this.stack.pop();
        Se.value += this.sliceSerialize(he),
        Se.position.end = ps(he.end)
    }
    function N(he) {
        const Se = this.stack[this.stack.length - 1];
        if (this.data.atHardBreak) {
            const De = Se.children[Se.children.length - 1];
            De.position.end = ps(he.end),
            this.data.atHardBreak = void 0;
            return
        }
        !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(Se.type) && (k.call(this, he),
        I.call(this, he))
    }
    function O() {
        this.data.atHardBreak = !0
    }
    function M() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.value = he
    }
    function H() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.value = he
    }
    function $() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.value = he
    }
    function J() {
        const he = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
            const Se = this.data.referenceType || "shortcut";
            he.type += "Reference",
            he.referenceType = Se,
            delete he.url,
            delete he.title
        } else
            delete he.identifier,
            delete he.label;
        this.data.referenceType = void 0
    }
    function Q() {
        const he = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
            const Se = this.data.referenceType || "shortcut";
            he.type += "Reference",
            he.referenceType = Se,
            delete he.url,
            delete he.title
        } else
            delete he.identifier,
            delete he.label;
        this.data.referenceType = void 0
    }
    function ee(he) {
        const Se = this.sliceSerialize(he)
          , De = this.stack[this.stack.length - 2];
        De.label = f$(Se),
        De.identifier = Xr(Se).toLowerCase()
    }
    function D() {
        const he = this.stack[this.stack.length - 1]
          , Se = this.resume()
          , De = this.stack[this.stack.length - 1];
        if (this.data.inReference = !0,
        De.type === "link") {
            const Ge = he.children;
            De.children = Ge
        } else
            De.alt = Se
    }
    function L() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.url = he
    }
    function z() {
        const he = this.resume()
          , Se = this.stack[this.stack.length - 1];
        Se.title = he
    }
    function V() {
        this.data.inReference = void 0
    }
    function B() {
        this.data.referenceType = "collapsed"
    }
    function Z(he) {
        const Se = this.resume()
          , De = this.stack[this.stack.length - 1];
        De.label = Se,
        De.identifier = Xr(this.sliceSerialize(he)).toLowerCase(),
        this.data.referenceType = "full"
    }
    function se(he) {
        this.data.characterReferenceType = he.type
    }
    function ae(he) {
        const Se = this.sliceSerialize(he)
          , De = this.data.characterReferenceType;
        let Ge;
        De ? (Ge = K2(Se, De === "characterReferenceMarkerNumeric" ? 10 : 16),
        this.data.characterReferenceType = void 0) : Ge = Rv(Se);
        const F = this.stack[this.stack.length - 1];
        F.value += Ge
    }
    function G(he) {
        const Se = this.stack.pop();
        Se.position.end = ps(he.end)
    }
    function j(he) {
        I.call(this, he);
        const Se = this.stack[this.stack.length - 1];
        Se.url = this.sliceSerialize(he)
    }
    function oe(he) {
        I.call(this, he);
        const Se = this.stack[this.stack.length - 1];
        Se.url = "mailto:" + this.sliceSerialize(he)
    }
    function le() {
        return {
            type: "blockquote",
            children: []
        }
    }
    function de() {
        return {
            type: "code",
            lang: null,
            meta: null,
            value: ""
        }
    }
    function ne() {
        return {
            type: "inlineCode",
            value: ""
        }
    }
    function pe() {
        return {
            type: "definition",
            identifier: "",
            label: null,
            title: null,
            url: ""
        }
    }
    function Te() {
        return {
            type: "emphasis",
            children: []
        }
    }
    function Ce() {
        return {
            type: "heading",
            depth: 0,
            children: []
        }
    }
    function Re() {
        return {
            type: "break"
        }
    }
    function we() {
        return {
            type: "html",
            value: ""
        }
    }
    function ze() {
        return {
            type: "image",
            title: null,
            url: "",
            alt: null
        }
    }
    function qe() {
        return {
            type: "link",
            title: null,
            url: "",
            children: []
        }
    }
    function et(he) {
        return {
            type: "list",
            ordered: he.type === "listOrdered",
            start: null,
            spread: he._spread,
            children: []
        }
    }
    function $t(he) {
        return {
            type: "listItem",
            spread: he._spread,
            checked: null,
            children: []
        }
    }
    function Jt() {
        return {
            type: "paragraph",
            children: []
        }
    }
    function _t() {
        return {
            type: "strong",
            children: []
        }
    }
    function St() {
        return {
            type: "text",
            value: ""
        }
    }
    function it() {
        return {
            type: "thematicBreak"
        }
    }
}
function ps(t) {
    return {
        line: t.line,
        column: t.column,
        offset: t.offset
    }
}
function sI(t, e) {
    let n = -1;
    for (; ++n < e.length; ) {
        const r = e[n];
        Array.isArray(r) ? sI(t, r) : _$(t, r)
    }
}
function _$(t, e) {
    let n;
    for (n in e)
        if (iI.call(e, n))
            switch (n) {
            case "canContainEols":
                {
                    const r = e[n];
                    r && t[n].push(...r);
                    break
                }
            case "transforms":
                {
                    const r = e[n];
                    r && t[n].push(...r);
                    break
                }
            case "enter":
            case "exit":
                {
                    const r = e[n];
                    r && Object.assign(t[n], r);
                    break
                }
            }
}
function RS(t, e) {
    throw t ? new Error("Cannot close `" + t.type + "` (" + Vc({
        start: t.start,
        end: t.end
    }) + "): a different token (`" + e.type + "`, " + Vc({
        start: e.start,
        end: e.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Vc({
        start: e.start,
        end: e.end
    }) + ") is still open")
}
function b$(t) {
    const e = this;
    e.parser = n;
    function n(r) {
        return m$(r, {
            ...e.data("settings"),
            ...t,
            extensions: e.data("micromarkExtensions") || [],
            mdastExtensions: e.data("fromMarkdownExtensions") || []
        })
    }
}
function y$(t, e) {
    const n = {
        type: "element",
        tagName: "blockquote",
        properties: {},
        children: t.wrap(t.all(e), !0)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function v$(t, e) {
    const n = {
        type: "element",
        tagName: "br",
        properties: {},
        children: []
    };
    return t.patch(e, n),
    [t.applyData(e, n), {
        type: "text",
        value: `
`
    }]
}
function x$(t, e) {
    const n = e.value ? e.value + `
` : ""
      , r = {};
    e.lang && (r.className = ["language-" + e.lang]);
    let i = {
        type: "element",
        tagName: "code",
        properties: r,
        children: [{
            type: "text",
            value: n
        }]
    };
    return e.meta && (i.data = {
        meta: e.meta
    }),
    t.patch(e, i),
    i = t.applyData(e, i),
    i = {
        type: "element",
        tagName: "pre",
        properties: {},
        children: [i]
    },
    t.patch(e, i),
    i
}
function E$(t, e) {
    const n = {
        type: "element",
        tagName: "del",
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function S$(t, e) {
    const n = {
        type: "element",
        tagName: "em",
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function w$(t, e) {
    const n = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-"
      , r = String(e.identifier).toUpperCase()
      , i = $l(r.toLowerCase())
      , s = t.footnoteOrder.indexOf(r);
    let o, a = t.footnoteCounts.get(r);
    a === void 0 ? (a = 0,
    t.footnoteOrder.push(r),
    o = t.footnoteOrder.length) : o = s + 1,
    a += 1,
    t.footnoteCounts.set(r, a);
    const l = {
        type: "element",
        tagName: "a",
        properties: {
            href: "#" + n + "fn-" + i,
            id: n + "fnref-" + i + (a > 1 ? "-" + a : ""),
            dataFootnoteRef: !0,
            ariaDescribedBy: ["footnote-label"]
        },
        children: [{
            type: "text",
            value: String(o)
        }]
    };
    t.patch(e, l);
    const c = {
        type: "element",
        tagName: "sup",
        properties: {},
        children: [l]
    };
    return t.patch(e, c),
    t.applyData(e, c)
}
function C$(t, e) {
    const n = {
        type: "element",
        tagName: "h" + e.depth,
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function T$(t, e) {
    if (t.options.allowDangerousHtml) {
        const n = {
            type: "raw",
            value: e.value
        };
        return t.patch(e, n),
        t.applyData(e, n)
    }
}
function oI(t, e) {
    const n = e.referenceType;
    let r = "]";
    if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"),
    e.type === "imageReference")
        return [{
            type: "text",
            value: "![" + e.alt + r
        }];
    const i = t.all(e)
      , s = i[0];
    s && s.type === "text" ? s.value = "[" + s.value : i.unshift({
        type: "text",
        value: "["
    });
    const o = i[i.length - 1];
    return o && o.type === "text" ? o.value += r : i.push({
        type: "text",
        value: r
    }),
    i
}
function A$(t, e) {
    const n = String(e.identifier).toUpperCase()
      , r = t.definitionById.get(n);
    if (!r)
        return oI(t, e);
    const i = {
        src: $l(r.url || ""),
        alt: e.alt
    };
    r.title !== null && r.title !== void 0 && (i.title = r.title);
    const s = {
        type: "element",
        tagName: "img",
        properties: i,
        children: []
    };
    return t.patch(e, s),
    t.applyData(e, s)
}
function k$(t, e) {
    const n = {
        src: $l(e.url)
    };
    e.alt !== null && e.alt !== void 0 && (n.alt = e.alt),
    e.title !== null && e.title !== void 0 && (n.title = e.title);
    const r = {
        type: "element",
        tagName: "img",
        properties: n,
        children: []
    };
    return t.patch(e, r),
    t.applyData(e, r)
}
function R$(t, e) {
    const n = {
        type: "text",
        value: e.value.replace(/\r?\n|\r/g, " ")
    };
    t.patch(e, n);
    const r = {
        type: "element",
        tagName: "code",
        properties: {},
        children: [n]
    };
    return t.patch(e, r),
    t.applyData(e, r)
}
function I$(t, e) {
    const n = String(e.identifier).toUpperCase()
      , r = t.definitionById.get(n);
    if (!r)
        return oI(t, e);
    const i = {
        href: $l(r.url || "")
    };
    r.title !== null && r.title !== void 0 && (i.title = r.title);
    const s = {
        type: "element",
        tagName: "a",
        properties: i,
        children: t.all(e)
    };
    return t.patch(e, s),
    t.applyData(e, s)
}
function P$(t, e) {
    const n = {
        href: $l(e.url)
    };
    e.title !== null && e.title !== void 0 && (n.title = e.title);
    const r = {
        type: "element",
        tagName: "a",
        properties: n,
        children: t.all(e)
    };
    return t.patch(e, r),
    t.applyData(e, r)
}
function D$(t, e, n) {
    const r = t.all(e)
      , i = n ? L$(n) : aI(e)
      , s = {}
      , o = [];
    if (typeof e.checked == "boolean") {
        const u = r[0];
        let h;
        u && u.type === "element" && u.tagName === "p" ? h = u : (h = {
            type: "element",
            tagName: "p",
            properties: {},
            children: []
        },
        r.unshift(h)),
        h.children.length > 0 && h.children.unshift({
            type: "text",
            value: " "
        }),
        h.children.unshift({
            type: "element",
            tagName: "input",
            properties: {
                type: "checkbox",
                checked: e.checked,
                disabled: !0
            },
            children: []
        }),
        s.className = ["task-list-item"]
    }
    let a = -1;
    for (; ++a < r.length; ) {
        const u = r[a];
        (i || a !== 0 || u.type !== "element" || u.tagName !== "p") && o.push({
            type: "text",
            value: `
`
        }),
        u.type === "element" && u.tagName === "p" && !i ? o.push(...u.children) : o.push(u)
    }
    const l = r[r.length - 1];
    l && (i || l.type !== "element" || l.tagName !== "p") && o.push({
        type: "text",
        value: `
`
    });
    const c = {
        type: "element",
        tagName: "li",
        properties: s,
        children: o
    };
    return t.patch(e, c),
    t.applyData(e, c)
}
function L$(t) {
    let e = !1;
    if (t.type === "list") {
        e = t.spread || !1;
        const n = t.children;
        let r = -1;
        for (; !e && ++r < n.length; )
            e = aI(n[r])
    }
    return e
}
function aI(t) {
    const e = t.spread;
    return e ?? t.children.length > 1
}
function O$(t, e) {
    const n = {}
      , r = t.all(e);
    let i = -1;
    for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++i < r.length; ) {
        const o = r[i];
        if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
            n.className = ["contains-task-list"];
            break
        }
    }
    const s = {
        type: "element",
        tagName: e.ordered ? "ol" : "ul",
        properties: n,
        children: t.wrap(r, !0)
    };
    return t.patch(e, s),
    t.applyData(e, s)
}
function N$(t, e) {
    const n = {
        type: "element",
        tagName: "p",
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function M$(t, e) {
    const n = {
        type: "root",
        children: t.wrap(t.all(e))
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function B$(t, e) {
    const n = {
        type: "element",
        tagName: "strong",
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function F$(t, e) {
    const n = t.all(e)
      , r = n.shift()
      , i = [];
    if (r) {
        const o = {
            type: "element",
            tagName: "thead",
            properties: {},
            children: t.wrap([r], !0)
        };
        t.patch(e.children[0], o),
        i.push(o)
    }
    if (n.length > 0) {
        const o = {
            type: "element",
            tagName: "tbody",
            properties: {},
            children: t.wrap(n, !0)
        }
          , a = Oi(e.children[1])
          , l = Tm(e.children[e.children.length - 1]);
        a && l && (o.position = {
            start: a,
            end: l
        }),
        i.push(o)
    }
    const s = {
        type: "element",
        tagName: "table",
        properties: {},
        children: t.wrap(i, !0)
    };
    return t.patch(e, s),
    t.applyData(e, s)
}
function j$(t, e, n) {
    const r = n ? n.children : void 0
      , s = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td"
      , o = n && n.type === "table" ? n.align : void 0
      , a = o ? o.length : e.children.length;
    let l = -1;
    const c = [];
    for (; ++l < a; ) {
        const h = e.children[l]
          , d = {}
          , f = o ? o[l] : void 0;
        f && (d.align = f);
        let g = {
            type: "element",
            tagName: s,
            properties: d,
            children: []
        };
        h && (g.children = t.all(h),
        t.patch(h, g),
        g = t.applyData(h, g)),
        c.push(g)
    }
    const u = {
        type: "element",
        tagName: "tr",
        properties: {},
        children: t.wrap(c, !0)
    };
    return t.patch(e, u),
    t.applyData(e, u)
}
function H$(t, e) {
    const n = {
        type: "element",
        tagName: "td",
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
const IS = 9
  , PS = 32;
function U$(t) {
    const e = String(t)
      , n = /\r?\n|\r/g;
    let r = n.exec(e)
      , i = 0;
    const s = [];
    for (; r; )
        s.push(DS(e.slice(i, r.index), i > 0, !0), r[0]),
        i = r.index + r[0].length,
        r = n.exec(e);
    return s.push(DS(e.slice(i), i > 0, !1)),
    s.join("")
}
function DS(t, e, n) {
    let r = 0
      , i = t.length;
    if (e) {
        let s = t.codePointAt(r);
        for (; s === IS || s === PS; )
            r++,
            s = t.codePointAt(r)
    }
    if (n) {
        let s = t.codePointAt(i - 1);
        for (; s === IS || s === PS; )
            i--,
            s = t.codePointAt(i - 1)
    }
    return i > r ? t.slice(r, i) : ""
}
function V$(t, e) {
    const n = {
        type: "text",
        value: U$(String(e.value))
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
function $$(t, e) {
    const n = {
        type: "element",
        tagName: "hr",
        properties: {},
        children: []
    };
    return t.patch(e, n),
    t.applyData(e, n)
}
const z$ = {
    blockquote: y$,
    break: v$,
    code: x$,
    delete: E$,
    emphasis: S$,
    footnoteReference: w$,
    heading: C$,
    html: T$,
    imageReference: A$,
    image: k$,
    inlineCode: R$,
    linkReference: I$,
    link: P$,
    listItem: D$,
    list: O$,
    paragraph: N$,
    root: M$,
    strong: B$,
    table: F$,
    tableCell: H$,
    tableRow: j$,
    text: V$,
    thematicBreak: $$,
    toml: md,
    yaml: md,
    definition: md,
    footnoteDefinition: md
};
function md() {}
const lI = -1
  , Rm = 0
  , Yf = 1
  , Xf = 2
  , Pv = 3
  , Dv = 4
  , Lv = 5
  , Ov = 6
  , cI = 7
  , uI = 8
  , LS = typeof self == "object" ? self : globalThis
  , W$ = (t, e) => {
    const n = (i, s) => (t.set(s, i),
    i)
      , r = i => {
        if (t.has(i))
            return t.get(i);
        const [s,o] = e[i];
        switch (s) {
        case Rm:
        case lI:
            return n(o, i);
        case Yf:
            {
                const a = n([], i);
                for (const l of o)
                    a.push(r(l));
                return a
            }
        case Xf:
            {
                const a = n({}, i);
                for (const [l,c] of o)
                    a[r(l)] = r(c);
                return a
            }
        case Pv:
            return n(new Date(o), i);
        case Dv:
            {
                const {source: a, flags: l} = o;
                return n(new RegExp(a,l), i)
            }
        case Lv:
            {
                const a = n(new Map, i);
                for (const [l,c] of o)
                    a.set(r(l), r(c));
                return a
            }
        case Ov:
            {
                const a = n(new Set, i);
                for (const l of o)
                    a.add(r(l));
                return a
            }
        case cI:
            {
                const {name: a, message: l} = o;
                return n(new LS[a](l), i)
            }
        case uI:
            return n(BigInt(o), i);
        case "BigInt":
            return n(Object(BigInt(o)), i)
        }
        return n(new LS[s](o), i)
    }
    ;
    return r
}
  , OS = t => W$(new Map, t)(0)
  , Ra = ""
  , {toString: G$} = {}
  , {keys: q$} = Object
  , rc = t => {
    const e = typeof t;
    if (e !== "object" || !t)
        return [Rm, e];
    const n = G$.call(t).slice(8, -1);
    switch (n) {
    case "Array":
        return [Yf, Ra];
    case "Object":
        return [Xf, Ra];
    case "Date":
        return [Pv, Ra];
    case "RegExp":
        return [Dv, Ra];
    case "Map":
        return [Lv, Ra];
    case "Set":
        return [Ov, Ra]
    }
    return n.includes("Array") ? [Yf, n] : n.includes("Error") ? [cI, n] : [Xf, n]
}
  , gd = ([t,e]) => t === Rm && (e === "function" || e === "symbol")
  , K$ = (t, e, n, r) => {
    const i = (o, a) => {
        const l = r.push(o) - 1;
        return n.set(a, l),
        l
    }
      , s = o => {
        if (n.has(o))
            return n.get(o);
        let[a,l] = rc(o);
        switch (a) {
        case Rm:
            {
                let u = o;
                switch (l) {
                case "bigint":
                    a = uI,
                    u = o.toString();
                    break;
                case "function":
                case "symbol":
                    if (t)
                        throw new TypeError("unable to serialize " + l);
                    u = null;
                    break;
                case "undefined":
                    return i([lI], o)
                }
                return i([a, u], o)
            }
        case Yf:
            {
                if (l)
                    return i([l, [...o]], o);
                const u = []
                  , h = i([a, u], o);
                for (const d of o)
                    u.push(s(d));
                return h
            }
        case Xf:
            {
                if (l)
                    switch (l) {
                    case "BigInt":
                        return i([l, o.toString()], o);
                    case "Boolean":
                    case "Number":
                    case "String":
                        return i([l, o.valueOf()], o)
                    }
                if (e && "toJSON"in o)
                    return s(o.toJSON());
                const u = []
                  , h = i([a, u], o);
                for (const d of q$(o))
                    (t || !gd(rc(o[d]))) && u.push([s(d), s(o[d])]);
                return h
            }
        case Pv:
            return i([a, o.toISOString()], o);
        case Dv:
            {
                const {source: u, flags: h} = o;
                return i([a, {
                    source: u,
                    flags: h
                }], o)
            }
        case Lv:
            {
                const u = []
                  , h = i([a, u], o);
                for (const [d,f] of o)
                    (t || !(gd(rc(d)) || gd(rc(f)))) && u.push([s(d), s(f)]);
                return h
            }
        case Ov:
            {
                const u = []
                  , h = i([a, u], o);
                for (const d of o)
                    (t || !gd(rc(d))) && u.push(s(d));
                return h
            }
        }
        const {message: c} = o;
        return i([a, {
            name: l,
            message: c
        }], o)
    }
    ;
    return s
}
  , NS = (t, {json: e, lossy: n}={}) => {
    const r = [];
    return K$(!(e || n), !!e, new Map, r)(t),
    r
}
  , Xo = typeof structuredClone == "function" ? (t, e) => e && ("json"in e || "lossy"in e) ? OS(NS(t, e)) : structuredClone(t) : (t, e) => OS(NS(t, e));
function Y$(t, e) {
    const n = [{
        type: "text",
        value: ""
    }];
    return e > 1 && n.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{
            type: "text",
            value: String(e)
        }]
    }),
    n
}
function X$(t, e) {
    return "Back to reference " + (t + 1) + (e > 1 ? "-" + e : "")
}
function Q$(t) {
    const e = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-"
      , n = t.options.footnoteBackContent || Y$
      , r = t.options.footnoteBackLabel || X$
      , i = t.options.footnoteLabel || "Footnotes"
      , s = t.options.footnoteLabelTagName || "h2"
      , o = t.options.footnoteLabelProperties || {
        className: ["sr-only"]
    }
      , a = [];
    let l = -1;
    for (; ++l < t.footnoteOrder.length; ) {
        const c = t.footnoteById.get(t.footnoteOrder[l]);
        if (!c)
            continue;
        const u = t.all(c)
          , h = String(c.identifier).toUpperCase()
          , d = $l(h.toLowerCase());
        let f = 0;
        const g = []
          , _ = t.footnoteCounts.get(h);
        for (; _ !== void 0 && ++f <= _; ) {
            g.length > 0 && g.push({
                type: "text",
                value: " "
            });
            let b = typeof n == "string" ? n : n(l, f);
            typeof b == "string" && (b = {
                type: "text",
                value: b
            }),
            g.push({
                type: "element",
                tagName: "a",
                properties: {
                    href: "#" + e + "fnref-" + d + (f > 1 ? "-" + f : ""),
                    dataFootnoteBackref: "",
                    ariaLabel: typeof r == "string" ? r : r(l, f),
                    className: ["data-footnote-backref"]
                },
                children: Array.isArray(b) ? b : [b]
            })
        }
        const m = u[u.length - 1];
        if (m && m.type === "element" && m.tagName === "p") {
            const b = m.children[m.children.length - 1];
            b && b.type === "text" ? b.value += " " : m.children.push({
                type: "text",
                value: " "
            }),
            m.children.push(...g)
        } else
            u.push(...g);
        const p = {
            type: "element",
            tagName: "li",
            properties: {
                id: e + "fn-" + d
            },
            children: t.wrap(u, !0)
        };
        t.patch(c, p),
        a.push(p)
    }
    if (a.length !== 0)
        return {
            type: "element",
            tagName: "section",
            properties: {
                dataFootnotes: !0,
                className: ["footnotes"]
            },
            children: [{
                type: "element",
                tagName: s,
                properties: {
                    ...Xo(o),
                    id: "footnote-label"
                },
                children: [{
                    type: "text",
                    value: i
                }]
            }, {
                type: "text",
                value: `
`
            }, {
                type: "element",
                tagName: "ol",
                properties: {},
                children: t.wrap(a, !0)
            }, {
                type: "text",
                value: `
`
            }]
        }
}
const Im = function(t) {
    if (t == null)
        return tz;
    if (typeof t == "function")
        return Pm(t);
    if (typeof t == "object")
        return Array.isArray(t) ? J$(t) : Z$(t);
    if (typeof t == "string")
        return ez(t);
    throw new Error("Expected function, string, or object as test")
};
function J$(t) {
    const e = [];
    let n = -1;
    for (; ++n < t.length; )
        e[n] = Im(t[n]);
    return Pm(r);
    function r(...i) {
        let s = -1;
        for (; ++s < e.length; )
            if (e[s].apply(this, i))
                return !0;
        return !1
    }
}
function Z$(t) {
    const e = t;
    return Pm(n);
    function n(r) {
        const i = r;
        let s;
        for (s in t)
            if (i[s] !== e[s])
                return !1;
        return !0
    }
}
function ez(t) {
    return Pm(e);
    function e(n) {
        return n && n.type === t
    }
}
function Pm(t) {
    return e;
    function e(n, r, i) {
        return !!(nz(n) && t.call(this, n, typeof r == "number" ? r : void 0, i || void 0))
    }
}
function tz() {
    return !0
}
function nz(t) {
    return t !== null && typeof t == "object" && "type"in t
}
const hI = []
  , rz = !0
  , j_ = !1
  , dI = "skip";
function fI(t, e, n, r) {
    let i;
    typeof e == "function" && typeof n != "function" ? (r = n,
    n = e) : i = e;
    const s = Im(i)
      , o = r ? -1 : 1;
    a(t, void 0, [])();
    function a(l, c, u) {
        const h = l && typeof l == "object" ? l : {};
        if (typeof h.type == "string") {
            const f = typeof h.tagName == "string" ? h.tagName : typeof h.name == "string" ? h.name : void 0;
            Object.defineProperty(d, "name", {
                value: "node (" + (l.type + (f ? "<" + f + ">" : "")) + ")"
            })
        }
        return d;
        function d() {
            let f = hI, g, _, m;
            if ((!e || s(l, c, u[u.length - 1] || void 0)) && (f = iz(n(l, u)),
            f[0] === j_))
                return f;
            if ("children"in l && l.children) {
                const p = l;
                if (p.children && f[0] !== dI)
                    for (_ = (r ? p.children.length : -1) + o,
                    m = u.concat(p); _ > -1 && _ < p.children.length; ) {
                        const b = p.children[_];
                        if (g = a(b, _, m)(),
                        g[0] === j_)
                            return g;
                        _ = typeof g[1] == "number" ? g[1] : _ + o
                    }
            }
            return f
        }
    }
}
function iz(t) {
    return Array.isArray(t) ? t : typeof t == "number" ? [rz, t] : t == null ? hI : [t]
}
function Mh(t, e, n, r) {
    let i, s, o;
    typeof e == "function" && typeof n != "function" ? (s = void 0,
    o = e,
    i = n) : (s = e,
    o = n,
    i = r),
    fI(t, s, a, i);
    function a(l, c) {
        const u = c[c.length - 1]
          , h = u ? u.children.indexOf(l) : void 0;
        return o(l, h, u)
    }
}
const H_ = {}.hasOwnProperty
  , sz = {};
function oz(t, e) {
    const n = e || sz
      , r = new Map
      , i = new Map
      , s = new Map
      , o = {
        ...z$,
        ...n.handlers
    }
      , a = {
        all: c,
        applyData: lz,
        definitionById: r,
        footnoteById: i,
        footnoteCounts: s,
        footnoteOrder: [],
        handlers: o,
        one: l,
        options: n,
        patch: az,
        wrap: uz
    };
    return Mh(t, function(u) {
        if (u.type === "definition" || u.type === "footnoteDefinition") {
            const h = u.type === "definition" ? r : i
              , d = String(u.identifier).toUpperCase();
            h.has(d) || h.set(d, u)
        }
    }),
    a;
    function l(u, h) {
        const d = u.type
          , f = a.handlers[d];
        if (H_.call(a.handlers, d) && f)
            return f(a, u, h);
        if (a.options.passThrough && a.options.passThrough.includes(d)) {
            if ("children"in u) {
                const {children: _, ...m} = u
                  , p = Xo(m);
                return p.children = a.all(u),
                p
            }
            return Xo(u)
        }
        return (a.options.unknownHandler || cz)(a, u, h)
    }
    function c(u) {
        const h = [];
        if ("children"in u) {
            const d = u.children;
            let f = -1;
            for (; ++f < d.length; ) {
                const g = a.one(d[f], u);
                if (g) {
                    if (f && d[f - 1].type === "break" && (!Array.isArray(g) && g.type === "text" && (g.value = MS(g.value)),
                    !Array.isArray(g) && g.type === "element")) {
                        const _ = g.children[0];
                        _ && _.type === "text" && (_.value = MS(_.value))
                    }
                    Array.isArray(g) ? h.push(...g) : h.push(g)
                }
            }
        }
        return h
    }
}
function az(t, e) {
    t.position && (e.position = U2(t))
}
function lz(t, e) {
    let n = e;
    if (t && t.data) {
        const r = t.data.hName
          , i = t.data.hChildren
          , s = t.data.hProperties;
        if (typeof r == "string")
            if (n.type === "element")
                n.tagName = r;
            else {
                const o = "children"in n ? n.children : [n];
                n = {
                    type: "element",
                    tagName: r,
                    properties: {},
                    children: o
                }
            }
        n.type === "element" && s && Object.assign(n.properties, Xo(s)),
        "children"in n && n.children && i !== null && i !== void 0 && (n.children = i)
    }
    return n
}
function cz(t, e) {
    const n = e.data || {}
      , r = "value"in e && !(H_.call(n, "hProperties") || H_.call(n, "hChildren")) ? {
        type: "text",
        value: e.value
    } : {
        type: "element",
        tagName: "div",
        properties: {},
        children: t.all(e)
    };
    return t.patch(e, r),
    t.applyData(e, r)
}
function uz(t, e) {
    const n = [];
    let r = -1;
    for (e && n.push({
        type: "text",
        value: `
`
    }); ++r < t.length; )
        r && n.push({
            type: "text",
            value: `
`
        }),
        n.push(t[r]);
    return e && t.length > 0 && n.push({
        type: "text",
        value: `
`
    }),
    n
}
function MS(t) {
    let e = 0
      , n = t.charCodeAt(e);
    for (; n === 9 || n === 32; )
        e++,
        n = t.charCodeAt(e);
    return t.slice(e)
}
function BS(t, e) {
    const n = oz(t, e)
      , r = n.one(t, void 0)
      , i = Q$(n)
      , s = Array.isArray(r) ? {
        type: "root",
        children: r
    } : r || {
        type: "root",
        children: []
    };
    return i && s.children.push({
        type: "text",
        value: `
`
    }, i),
    s
}
function hz(t, e) {
    return t && "run"in t ? async function(n, r) {
        const i = BS(n, {
            file: r,
            ...e
        });
        await t.run(i, r)
    }
    : function(n, r) {
        return BS(n, {
            file: r,
            ...e || t
        })
    }
}
function FS(t) {
    if (t)
        throw t
}
var mf = Object.prototype.hasOwnProperty
  , pI = Object.prototype.toString
  , jS = Object.defineProperty
  , HS = Object.getOwnPropertyDescriptor
  , US = function(e) {
    return typeof Array.isArray == "function" ? Array.isArray(e) : pI.call(e) === "[object Array]"
}
  , VS = function(e) {
    if (!e || pI.call(e) !== "[object Object]")
        return !1;
    var n = mf.call(e, "constructor")
      , r = e.constructor && e.constructor.prototype && mf.call(e.constructor.prototype, "isPrototypeOf");
    if (e.constructor && !n && !r)
        return !1;
    var i;
    for (i in e)
        ;
    return typeof i > "u" || mf.call(e, i)
}
  , $S = function(e, n) {
    jS && n.name === "__proto__" ? jS(e, n.name, {
        enumerable: !0,
        configurable: !0,
        value: n.newValue,
        writable: !0
    }) : e[n.name] = n.newValue
}
  , zS = function(e, n) {
    if (n === "__proto__")
        if (mf.call(e, n)) {
            if (HS)
                return HS(e, n).value
        } else
            return;
    return e[n]
}
  , dz = function t() {
    var e, n, r, i, s, o, a = arguments[0], l = 1, c = arguments.length, u = !1;
    for (typeof a == "boolean" && (u = a,
    a = arguments[1] || {},
    l = 2),
    (a == null || typeof a != "object" && typeof a != "function") && (a = {}); l < c; ++l)
        if (e = arguments[l],
        e != null)
            for (n in e)
                r = zS(a, n),
                i = zS(e, n),
                a !== i && (u && i && (VS(i) || (s = US(i))) ? (s ? (s = !1,
                o = r && US(r) ? r : []) : o = r && VS(r) ? r : {},
                $S(a, {
                    name: n,
                    newValue: t(u, o, i)
                })) : typeof i < "u" && $S(a, {
                    name: n,
                    newValue: i
                }));
    return a
};
const $g = Eh(dz);
function U_(t) {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
function fz() {
    const t = []
      , e = {
        run: n,
        use: r
    };
    return e;
    function n(...i) {
        let s = -1;
        const o = i.pop();
        if (typeof o != "function")
            throw new TypeError("Expected function as last argument, not " + o);
        a(null, ...i);
        function a(l, ...c) {
            const u = t[++s];
            let h = -1;
            if (l) {
                o(l);
                return
            }
            for (; ++h < i.length; )
                (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
            i = c,
            u ? pz(u, a)(...c) : o(null, ...c)
        }
    }
    function r(i) {
        if (typeof i != "function")
            throw new TypeError("Expected `middelware` to be a function, not " + i);
        return t.push(i),
        e
    }
}
function pz(t, e) {
    let n;
    return r;
    function r(...o) {
        const a = t.length > o.length;
        let l;
        a && o.push(i);
        try {
            l = t.apply(this, o)
        } catch (c) {
            const u = c;
            if (a && n)
                throw u;
            return i(u)
        }
        a || (l && l.then && typeof l.then == "function" ? l.then(s, i) : l instanceof Error ? i(l) : s(l))
    }
    function i(o, ...a) {
        n || (n = !0,
        e(o, ...a))
    }
    function s(o) {
        i(null, o)
    }
}
const fi = {
    basename: mz,
    dirname: gz,
    extname: _z,
    join: bz,
    sep: "/"
};
function mz(t, e) {
    if (e !== void 0 && typeof e != "string")
        throw new TypeError('"ext" argument must be a string');
    Bh(t);
    let n = 0, r = -1, i = t.length, s;
    if (e === void 0 || e.length === 0 || e.length > t.length) {
        for (; i--; )
            if (t.codePointAt(i) === 47) {
                if (s) {
                    n = i + 1;
                    break
                }
            } else
                r < 0 && (s = !0,
                r = i + 1);
        return r < 0 ? "" : t.slice(n, r)
    }
    if (e === t)
        return "";
    let o = -1
      , a = e.length - 1;
    for (; i--; )
        if (t.codePointAt(i) === 47) {
            if (s) {
                n = i + 1;
                break
            }
        } else
            o < 0 && (s = !0,
            o = i + 1),
            a > -1 && (t.codePointAt(i) === e.codePointAt(a--) ? a < 0 && (r = i) : (a = -1,
            r = o));
    return n === r ? r = o : r < 0 && (r = t.length),
    t.slice(n, r)
}
function gz(t) {
    if (Bh(t),
    t.length === 0)
        return ".";
    let e = -1, n = t.length, r;
    for (; --n; )
        if (t.codePointAt(n) === 47) {
            if (r) {
                e = n;
                break
            }
        } else
            r || (r = !0);
    return e < 0 ? t.codePointAt(0) === 47 ? "/" : "." : e === 1 && t.codePointAt(0) === 47 ? "//" : t.slice(0, e)
}
function _z(t) {
    Bh(t);
    let e = t.length, n = -1, r = 0, i = -1, s = 0, o;
    for (; e--; ) {
        const a = t.codePointAt(e);
        if (a === 47) {
            if (o) {
                r = e + 1;
                break
            }
            continue
        }
        n < 0 && (o = !0,
        n = e + 1),
        a === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1)
    }
    return i < 0 || n < 0 || s === 0 || s === 1 && i === n - 1 && i === r + 1 ? "" : t.slice(i, n)
}
function bz(...t) {
    let e = -1, n;
    for (; ++e < t.length; )
        Bh(t[e]),
        t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
    return n === void 0 ? "." : yz(n)
}
function yz(t) {
    Bh(t);
    const e = t.codePointAt(0) === 47;
    let n = vz(t, !e);
    return n.length === 0 && !e && (n = "."),
    n.length > 0 && t.codePointAt(t.length - 1) === 47 && (n += "/"),
    e ? "/" + n : n
}
function vz(t, e) {
    let n = "", r = 0, i = -1, s = 0, o = -1, a, l;
    for (; ++o <= t.length; ) {
        if (o < t.length)
            a = t.codePointAt(o);
        else {
            if (a === 47)
                break;
            a = 47
        }
        if (a === 47) {
            if (!(i === o - 1 || s === 1))
                if (i !== o - 1 && s === 2) {
                    if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
                        if (n.length > 2) {
                            if (l = n.lastIndexOf("/"),
                            l !== n.length - 1) {
                                l < 0 ? (n = "",
                                r = 0) : (n = n.slice(0, l),
                                r = n.length - 1 - n.lastIndexOf("/")),
                                i = o,
                                s = 0;
                                continue
                            }
                        } else if (n.length > 0) {
                            n = "",
                            r = 0,
                            i = o,
                            s = 0;
                            continue
                        }
                    }
                    e && (n = n.length > 0 ? n + "/.." : "..",
                    r = 2)
                } else
                    n.length > 0 ? n += "/" + t.slice(i + 1, o) : n = t.slice(i + 1, o),
                    r = o - i - 1;
            i = o,
            s = 0
        } else
            a === 46 && s > -1 ? s++ : s = -1
    }
    return n
}
function Bh(t) {
    if (typeof t != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(t))
}
const xz = {
    cwd: Ez
};
function Ez() {
    return "/"
}
function V_(t) {
    return !!(t !== null && typeof t == "object" && "href"in t && t.href && "protocol"in t && t.protocol && t.auth === void 0)
}
function Sz(t) {
    if (typeof t == "string")
        t = new URL(t);
    else if (!V_(t)) {
        const e = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + t + "`");
        throw e.code = "ERR_INVALID_ARG_TYPE",
        e
    }
    if (t.protocol !== "file:") {
        const e = new TypeError("The URL must be of scheme file");
        throw e.code = "ERR_INVALID_URL_SCHEME",
        e
    }
    return wz(t)
}
function wz(t) {
    if (t.hostname !== "") {
        const r = new TypeError('File URL host must be "localhost" or empty on darwin');
        throw r.code = "ERR_INVALID_FILE_URL_HOST",
        r
    }
    const e = t.pathname;
    let n = -1;
    for (; ++n < e.length; )
        if (e.codePointAt(n) === 37 && e.codePointAt(n + 1) === 50) {
            const r = e.codePointAt(n + 2);
            if (r === 70 || r === 102) {
                const i = new TypeError("File URL path must not include encoded / characters");
                throw i.code = "ERR_INVALID_FILE_URL_PATH",
                i
            }
        }
    return decodeURIComponent(e)
}
const zg = ["history", "path", "basename", "stem", "extname", "dirname"];
class mI {
    constructor(e) {
        let n;
        e ? V_(e) ? n = {
            path: e
        } : typeof e == "string" || Cz(e) ? n = {
            value: e
        } : n = e : n = {},
        this.cwd = xz.cwd(),
        this.data = {},
        this.history = [],
        this.messages = [],
        this.value,
        this.map,
        this.result,
        this.stored;
        let r = -1;
        for (; ++r < zg.length; ) {
            const s = zg[r];
            s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s])
        }
        let i;
        for (i in n)
            zg.includes(i) || (this[i] = n[i])
    }
    get basename() {
        return typeof this.path == "string" ? fi.basename(this.path) : void 0
    }
    set basename(e) {
        Gg(e, "basename"),
        Wg(e, "basename"),
        this.path = fi.join(this.dirname || "", e)
    }
    get dirname() {
        return typeof this.path == "string" ? fi.dirname(this.path) : void 0
    }
    set dirname(e) {
        WS(this.basename, "dirname"),
        this.path = fi.join(e || "", this.basename)
    }
    get extname() {
        return typeof this.path == "string" ? fi.extname(this.path) : void 0
    }
    set extname(e) {
        if (Wg(e, "extname"),
        WS(this.dirname, "extname"),
        e) {
            if (e.codePointAt(0) !== 46)
                throw new Error("`extname` must start with `.`");
            if (e.includes(".", 1))
                throw new Error("`extname` cannot contain multiple dots")
        }
        this.path = fi.join(this.dirname, this.stem + (e || ""))
    }
    get path() {
        return this.history[this.history.length - 1]
    }
    set path(e) {
        V_(e) && (e = Sz(e)),
        Gg(e, "path"),
        this.path !== e && this.history.push(e)
    }
    get stem() {
        return typeof this.path == "string" ? fi.basename(this.path, this.extname) : void 0
    }
    set stem(e) {
        Gg(e, "stem"),
        Wg(e, "stem"),
        this.path = fi.join(this.dirname || "", e + (this.extname || ""))
    }
    fail(e, n, r) {
        const i = this.message(e, n, r);
        throw i.fatal = !0,
        i
    }
    info(e, n, r) {
        const i = this.message(e, n, r);
        return i.fatal = void 0,
        i
    }
    message(e, n, r) {
        const i = new On(e,n,r);
        return this.path && (i.name = this.path + ":" + i.name,
        i.file = this.path),
        i.fatal = !1,
        this.messages.push(i),
        i
    }
    toString(e) {
        return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value)
    }
}
function Wg(t, e) {
    if (t && t.includes(fi.sep))
        throw new Error("`" + e + "` cannot be a path: did not expect `" + fi.sep + "`")
}
function Gg(t, e) {
    if (!t)
        throw new Error("`" + e + "` cannot be empty")
}
function WS(t, e) {
    if (!t)
        throw new Error("Setting `" + e + "` requires `path` to be set too")
}
function Cz(t) {
    return !!(t && typeof t == "object" && "byteLength"in t && "byteOffset"in t)
}
const Tz = function(t) {
    const r = this.constructor.prototype
      , i = r[t]
      , s = function() {
        return i.apply(s, arguments)
    };
    return Object.setPrototypeOf(s, r),
    s
}
  , Az = {}.hasOwnProperty;
class Nv extends Tz {
    constructor() {
        super("copy"),
        this.Compiler = void 0,
        this.Parser = void 0,
        this.attachers = [],
        this.compiler = void 0,
        this.freezeIndex = -1,
        this.frozen = void 0,
        this.namespace = {},
        this.parser = void 0,
        this.transformers = fz()
    }
    copy() {
        const e = new Nv;
        let n = -1;
        for (; ++n < this.attachers.length; ) {
            const r = this.attachers[n];
            e.use(...r)
        }
        return e.data($g(!0, {}, this.namespace)),
        e
    }
    data(e, n) {
        return typeof e == "string" ? arguments.length === 2 ? (Yg("data", this.frozen),
        this.namespace[e] = n,
        this) : Az.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Yg("data", this.frozen),
        this.namespace = e,
        this) : this.namespace
    }
    freeze() {
        if (this.frozen)
            return this;
        const e = this;
        for (; ++this.freezeIndex < this.attachers.length; ) {
            const [n,...r] = this.attachers[this.freezeIndex];
            if (r[0] === !1)
                continue;
            r[0] === !0 && (r[0] = void 0);
            const i = n.call(e, ...r);
            typeof i == "function" && this.transformers.use(i)
        }
        return this.frozen = !0,
        this.freezeIndex = Number.POSITIVE_INFINITY,
        this
    }
    parse(e) {
        this.freeze();
        const n = _d(e)
          , r = this.parser || this.Parser;
        return qg("parse", r),
        r(String(n), n)
    }
    process(e, n) {
        const r = this;
        return this.freeze(),
        qg("process", this.parser || this.Parser),
        Kg("process", this.compiler || this.Compiler),
        n ? i(void 0, n) : new Promise(i);
        function i(s, o) {
            const a = _d(e)
              , l = r.parse(a);
            r.run(l, a, function(u, h, d) {
                if (u || !h || !d)
                    return c(u);
                const f = h
                  , g = r.stringify(f, d);
                Iz(g) ? d.value = g : d.result = g,
                c(u, d)
            });
            function c(u, h) {
                u || !h ? o(u) : s ? s(h) : n(void 0, h)
            }
        }
    }
    processSync(e) {
        let n = !1, r;
        return this.freeze(),
        qg("processSync", this.parser || this.Parser),
        Kg("processSync", this.compiler || this.Compiler),
        this.process(e, i),
        qS("processSync", "process", n),
        r;
        function i(s, o) {
            n = !0,
            FS(s),
            r = o
        }
    }
    run(e, n, r) {
        GS(e),
        this.freeze();
        const i = this.transformers;
        return !r && typeof n == "function" && (r = n,
        n = void 0),
        r ? s(void 0, r) : new Promise(s);
        function s(o, a) {
            const l = _d(n);
            i.run(e, l, c);
            function c(u, h, d) {
                const f = h || e;
                u ? a(u) : o ? o(f) : r(void 0, f, d)
            }
        }
    }
    runSync(e, n) {
        let r = !1, i;
        return this.run(e, n, s),
        qS("runSync", "run", r),
        i;
        function s(o, a) {
            FS(o),
            i = a,
            r = !0
        }
    }
    stringify(e, n) {
        this.freeze();
        const r = _d(n)
          , i = this.compiler || this.Compiler;
        return Kg("stringify", i),
        GS(e),
        i(e, r)
    }
    use(e, ...n) {
        const r = this.attachers
          , i = this.namespace;
        if (Yg("use", this.frozen),
        e != null)
            if (typeof e == "function")
                l(e, n);
            else if (typeof e == "object")
                Array.isArray(e) ? a(e) : o(e);
            else
                throw new TypeError("Expected usable value, not `" + e + "`");
        return this;
        function s(c) {
            if (typeof c == "function")
                l(c, []);
            else if (typeof c == "object")
                if (Array.isArray(c)) {
                    const [u,...h] = c;
                    l(u, h)
                } else
                    o(c);
            else
                throw new TypeError("Expected usable value, not `" + c + "`")
        }
        function o(c) {
            if (!("plugins"in c) && !("settings"in c))
                throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
            a(c.plugins),
            c.settings && (i.settings = $g(!0, i.settings, c.settings))
        }
        function a(c) {
            let u = -1;
            if (c != null)
                if (Array.isArray(c))
                    for (; ++u < c.length; ) {
                        const h = c[u];
                        s(h)
                    }
                else
                    throw new TypeError("Expected a list of plugins, not `" + c + "`")
        }
        function l(c, u) {
            let h = -1
              , d = -1;
            for (; ++h < r.length; )
                if (r[h][0] === c) {
                    d = h;
                    break
                }
            if (d === -1)
                r.push([c, ...u]);
            else if (u.length > 0) {
                let[f,...g] = u;
                const _ = r[d][1];
                U_(_) && U_(f) && (f = $g(!0, _, f)),
                r[d] = [c, f, ...g]
            }
        }
    }
}
const kz = new Nv().freeze();
function qg(t, e) {
    if (typeof e != "function")
        throw new TypeError("Cannot `" + t + "` without `parser`")
}
function Kg(t, e) {
    if (typeof e != "function")
        throw new TypeError("Cannot `" + t + "` without `compiler`")
}
function Yg(t, e) {
    if (e)
        throw new Error("Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")
}
function GS(t) {
    if (!U_(t) || typeof t.type != "string")
        throw new TypeError("Expected node, got `" + t + "`")
}
function qS(t, e, n) {
    if (!n)
        throw new Error("`" + t + "` finished async. Use `" + e + "` instead")
}
function _d(t) {
    return Rz(t) ? t : new mI(t)
}
function Rz(t) {
    return !!(t && typeof t == "object" && "message"in t && "messages"in t)
}
function Iz(t) {
    return typeof t == "string" || Pz(t)
}
function Pz(t) {
    return !!(t && typeof t == "object" && "byteLength"in t && "byteOffset"in t)
}
const Dz = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md"
  , KS = []
  , YS = {
    allowDangerousHtml: !0
}
  , Lz = /^(https?|ircs?|mailto|xmpp)$/i
  , Oz = [{
    from: "astPlugins",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "allowDangerousHtml",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
}, {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
}, {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
}, {
    from: "escapeHtml",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "includeElementIndex",
    id: "#remove-includeelementindex"
}, {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
}, {
    from: "linkTarget",
    id: "remove-linktarget"
}, {
    from: "plugins",
    id: "change-plugins-to-remarkplugins",
    to: "remarkPlugins"
}, {
    from: "rawSourcePos",
    id: "#remove-rawsourcepos"
}, {
    from: "renderers",
    id: "change-renderers-to-components",
    to: "components"
}, {
    from: "source",
    id: "change-source-to-children",
    to: "children"
}, {
    from: "sourcePos",
    id: "#remove-sourcepos"
}, {
    from: "transformImageUri",
    id: "#add-urltransform",
    to: "urlTransform"
}, {
    from: "transformLinkUri",
    id: "#add-urltransform",
    to: "urlTransform"
}];
function Nz(t) {
    const e = t.allowedElements
      , n = t.allowElement
      , r = t.children || ""
      , i = t.className
      , s = t.components
      , o = t.disallowedElements
      , a = t.rehypePlugins || KS
      , l = t.remarkPlugins || KS
      , c = t.remarkRehypeOptions ? {
        ...t.remarkRehypeOptions,
        ...YS
    } : YS
      , u = t.skipHtml
      , h = t.unwrapDisallowed
      , d = t.urlTransform || Mz
      , f = kz().use(b$).use(l).use(hz, c).use(a)
      , g = new mI;
    typeof r == "string" && (g.value = r);
    for (const b of Oz)
        Object.hasOwn(t, b.from) && ("" + b.from + (b.to ? "use `" + b.to + "` instead" : "remove it") + Dz + b.id,
        void 0);
    const _ = f.parse(g);
    let m = f.runSync(_, g);
    return i && (m = {
        type: "element",
        tagName: "div",
        properties: {
            className: i
        },
        children: m.type === "root" ? m.children : [m]
    }),
    Mh(m, p),
    e7(m, {
        Fragment: v.Fragment,
        components: s,
        ignoreInvalidStyle: !0,
        jsx: v.jsx,
        jsxs: v.jsxs,
        passKeys: !0,
        passNode: !0
    });
    function p(b, y, x) {
        if (b.type === "raw" && x && typeof y == "number")
            return u ? x.children.splice(y, 1) : x.children[y] = {
                type: "text",
                value: b.value
            },
            y;
        if (b.type === "element") {
            let E;
            for (E in Hg)
                if (Object.hasOwn(Hg, E) && Object.hasOwn(b.properties, E)) {
                    const w = b.properties[E]
                      , A = Hg[E];
                    (A === null || A.includes(b.tagName)) && (b.properties[E] = d(String(w || ""), E, b))
                }
        }
        if (b.type === "element") {
            let E = e ? !e.includes(b.tagName) : o ? o.includes(b.tagName) : !1;
            if (!E && n && typeof y == "number" && (E = !n(b, y, x)),
            E && x && typeof y == "number")
                return h && b.children ? x.children.splice(y, 1, ...b.children) : x.children.splice(y, 1),
                y
        }
    }
}
function Mz(t) {
    const e = t.indexOf(":")
      , n = t.indexOf("?")
      , r = t.indexOf("#")
      , i = t.indexOf("/");
    return e < 0 || i > -1 && e > i || n > -1 && e > n || r > -1 && e > r || Lz.test(t.slice(0, e)) ? t : ""
}
const tn = S.memo(S.forwardRef( ({icon: t, size: e="xl", className: n, iconClassName: r, disabledClassName: i, disabled: s=!1, title: o, onClick: a, children: l}, c) => v.jsx("button", {
    ref: c,
    className: be("flex items-center text-bolt-elements-item-contentDefault bg-transparent enabled:hover:text-bolt-elements-item-contentActive rounded-md enabled:hover:bg-bolt-elements-item-backgroundActive disabled:cursor-not-allowed", Fz(e), {
        [be("opacity-30", i)]: s
    }, n),
    title: o,
    disabled: s,
    onClick: u => {
        s || a?.(u)
    }
    ,
    children: l || v.jsx("div", {
        className: be(t, Bz(e), r)
    })
})));
function Bz(t) {
    return t === "xs" ? "text-xs" : t === "sm" ? "text-sm" : t === "md" ? "text-md" : t === "lg" ? "text-lg" : t === "xl" ? "text-xl" : "text-2xl"
}
function Fz(t) {
    return t === "xs" ? "p-0.5" : "p-1"
}
const Ft = ba(.4, 0, .2, 1)
  , jz = {
    closed: {
        height: 0,
        visibility: "hidden"
    },
    open: {
        height: "auto",
        visibility: "visible"
    }
}
  , Hz = {
    duration: .2,
    ease: Ft
};
function Dm(t) {
    const {title: e, open: n, titleClassName: r, children: i, toggleButton: s="large", onClick: o, onToggle: a, className: l, scrollToBottom: c, ...u} = t
      , h = S.useRef(!0);
    if (S.useEffect( () => {
        if (h.current) {
            h.current = !1;
            return
        }
        n && c?.({
            animation: {
                mass: .9
            },
            duration: 200,
            preserveScrollPosition: !0
        })
    }
    , [n]),
    n == null)
        return v.jsx(Uz, {
            ...t
        });
    const d = o ? "button" : "div";
    return v.jsxs("div", {
        className: be("collapsible flex flex-col border border-bolt-elements-borderColor overflow-hidden rounded-lg w-full transition-border duration-150", l),
        ...u,
        children: [v.jsxs("div", {
            className: "flex relative",
            children: [v.jsx(d, {
                className: be("flex text-left items-stretch w-full overflow-hidden", r),
                onClick: o,
                children: e
            }), s === "large" && v.jsx("div", {
                className: "bg-bolt-elements-artifacts-borderColor w-[1px]"
            }), s === "large" ? v.jsx("button", {
                className: be("p-2 hover:text-bolt-elements-item-contentActive hover:bg-bolt-elements-item-backgroundActive p-4", r),
                onClick: () => a?.(!n),
                children: v.jsx("div", {
                    className: n ? "i-ph:caret-up-bold" : "i-ph:caret-down-bold"
                })
            }) : s === "small" ? v.jsx(tn, {
                icon: n ? "i-ph:caret-up" : "i-ph:caret-down",
                size: "lg",
                onClick: () => a?.(!n),
                className: be("absolute right-4 top-[50%] translate-y-[-50%]", r)
            }) : null]
        }), v.jsxs(It.div, {
            initial: "closed",
            animate: n ? "open" : "closed",
            exit: "closed",
            variants: jz,
            transition: Hz,
            children: [v.jsx("div", {
                className: "bg-bolt-elements-artifacts-borderColor h-[1px]"
            }), i]
        })]
    })
}
function Uz({defaultOpen: t=!1, onToggle: e, ...n}) {
    const [r,i] = S.useState( () => t)
      , s = S.useCallback(o => {
        i(o),
        e?.(o)
    }
    , [e]);
    return v.jsx(Dm, {
        ...n,
        open: r,
        onToggle: s
    })
}
const gI = [{
    id: "abap",
    name: "ABAP",
    import: () => K( () => import("./abap-DXFkqnOI.js"), [])
}, {
    id: "actionscript-3",
    name: "ActionScript",
    import: () => K( () => import("./actionscript-3-BigF1UXR.js"), [])
}, {
    id: "ada",
    name: "Ada",
    import: () => K( () => import("./ada-CowR2XfX.js"), [])
}, {
    id: "angular-html",
    name: "Angular HTML",
    import: () => K( () => import("./angular-html-DZQ5UQWW.js").then(t => t.e), __vite__mapDeps([0, 1, 2, 3]))
}, {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: () => K( () => import("./angular-ts-DOuPvTiZ.js"), __vite__mapDeps([4, 0, 1, 2, 3, 5]))
}, {
    id: "apache",
    name: "Apache Conf",
    import: () => K( () => import("./apache-rS0jd3Ly.js"), [])
}, {
    id: "apex",
    name: "Apex",
    import: () => K( () => import("./apex-Sfo2eW0G.js"), [])
}, {
    id: "apl",
    name: "APL",
    import: () => K( () => import("./apl-D9TNySCV.js"), __vite__mapDeps([6, 1, 2, 3, 7, 8, 9]))
}, {
    id: "applescript",
    name: "AppleScript",
    import: () => K( () => import("./applescript-B4yE-MfL.js"), [])
}, {
    id: "ara",
    name: "Ara",
    import: () => K( () => import("./ara-CG4fK2Nq.js"), [])
}, {
    id: "asciidoc",
    name: "AsciiDoc",
    aliases: ["adoc"],
    import: () => K( () => import("./asciidoc-CF5eOCvB.js"), __vite__mapDeps([10, 1, 2, 3, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 8, 9, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 7, 38, 39, 40, 41, 42, 43, 5, 44, 45, 46]))
}, {
    id: "asm",
    name: "Assembly",
    import: () => K( () => import("./asm-PWN5J14X.js"), [])
}, {
    id: "astro",
    name: "Astro",
    import: () => K( () => import("./astro-U9VgAVQT.js"), __vite__mapDeps([47, 9, 2, 46, 48, 42, 3, 5, 33, 49, 50]))
}, {
    id: "awk",
    name: "AWK",
    import: () => K( () => import("./awk-i0IPvypD.js"), [])
}, {
    id: "ballerina",
    name: "Ballerina",
    import: () => K( () => import("./ballerina-T9ysyp6P.js"), [])
}, {
    id: "bat",
    name: "Batch File",
    aliases: ["batch"],
    import: () => K( () => import("./bat-BPiaQZfK.js"), [])
}, {
    id: "beancount",
    name: "Beancount",
    import: () => K( () => import("./beancount-Urb1RsFe.js"), [])
}, {
    id: "berry",
    name: "Berry",
    aliases: ["be"],
    import: () => K( () => import("./berry-CxrokwfH.js"), [])
}, {
    id: "bibtex",
    name: "BibTeX",
    import: () => K( () => import("./bibtex-BaedD2tq.js"), [])
}, {
    id: "bicep",
    name: "Bicep",
    import: () => K( () => import("./bicep-3ghuYFLd.js"), [])
}, {
    id: "blade",
    name: "Blade",
    import: () => K( () => import("./blade-HiqCVk8k.js"), __vite__mapDeps([51, 1, 2, 3, 7, 8, 18, 9]))
}, {
    id: "c",
    name: "C",
    import: () => K( () => import("./c-RCJZWN-0.js"), [])
}, {
    id: "cadence",
    name: "Cadence",
    aliases: ["cdc"],
    import: () => K( () => import("./cadence-Bgpqy2XC.js"), [])
}, {
    id: "clarity",
    name: "Clarity",
    import: () => K( () => import("./clarity-CIekO_uJ.js"), [])
}, {
    id: "clojure",
    name: "Clojure",
    aliases: ["clj"],
    import: () => K( () => import("./clojure-BF6G6X0H.js"), [])
}, {
    id: "cmake",
    name: "CMake",
    import: () => K( () => import("./cmake-DXZpi2gR.js"), [])
}, {
    id: "cobol",
    name: "COBOL",
    import: () => K( () => import("./cobol-DgBJixdi.js"), __vite__mapDeps([52, 18, 1, 2, 3, 8]))
}, {
    id: "codeowners",
    name: "CODEOWNERS",
    import: () => K( () => import("./codeowners-CGmujMTu.js"), [])
}, {
    id: "codeql",
    name: "CodeQL",
    aliases: ["ql"],
    import: () => K( () => import("./codeql-BOpLLL-w.js"), [])
}, {
    id: "coffee",
    name: "CoffeeScript",
    aliases: ["coffeescript"],
    import: () => K( () => import("./coffee-B4DZ7swD.js"), __vite__mapDeps([15, 2]))
}, {
    id: "common-lisp",
    name: "Common Lisp",
    aliases: ["lisp"],
    import: () => K( () => import("./common-lisp-C3qUB5O8.js"), [])
}, {
    id: "cpp",
    name: "C++",
    aliases: ["c++"],
    import: () => K( () => import("./cpp-B9__le0e.js"), __vite__mapDeps([16, 17, 13, 18]))
}, {
    id: "crystal",
    name: "Crystal",
    import: () => K( () => import("./crystal-DwllXkRF.js"), __vite__mapDeps([53, 1, 2, 3, 18, 13, 39]))
}, {
    id: "csharp",
    name: "C#",
    aliases: ["c#", "cs"],
    import: () => K( () => import("./csharp-DISxKEhY.js"), [])
}, {
    id: "css",
    name: "CSS",
    import: () => K( () => import("./css-CbYhyuC0.js"), [])
}, {
    id: "csv",
    name: "CSV",
    import: () => K( () => import("./csv-B2DkETJQ.js"), [])
}, {
    id: "cue",
    name: "CUE",
    import: () => K( () => import("./cue-C6Aznpr-.js"), [])
}, {
    id: "cypher",
    name: "Cypher",
    aliases: ["cql"],
    import: () => K( () => import("./cypher-ByMv4Xf1.js"), [])
}, {
    id: "d",
    name: "D",
    import: () => K( () => import("./d-PifQWv0n.js"), [])
}, {
    id: "dart",
    name: "Dart",
    import: () => K( () => import("./dart-DZLoTQm4.js"), [])
}, {
    id: "dax",
    name: "DAX",
    import: () => K( () => import("./dax-DsfXcHUZ.js"), [])
}, {
    id: "desktop",
    name: "Desktop",
    import: () => K( () => import("./desktop-D71BffLY.js"), [])
}, {
    id: "diff",
    name: "Diff",
    import: () => K( () => import("./diff-DvyTQcux.js"), [])
}, {
    id: "docker",
    name: "Dockerfile",
    aliases: ["dockerfile"],
    import: () => K( () => import("./docker-DNR26wTC.js"), [])
}, {
    id: "dream-maker",
    name: "Dream Maker",
    import: () => K( () => import("./dream-maker-Eh5U-gDp.js"), [])
}, {
    id: "elixir",
    name: "Elixir",
    import: () => K( () => import("./elixir-DjCTzIqv.js"), __vite__mapDeps([22, 1, 2, 3]))
}, {
    id: "elm",
    name: "Elm",
    import: () => K( () => import("./elm-CTSLo1i4.js"), __vite__mapDeps([23, 17, 13]))
}, {
    id: "emacs-lisp",
    name: "Emacs Lisp",
    aliases: ["elisp"],
    import: () => K( () => import("./emacs-lisp-BEjL32p1.js"), [])
}, {
    id: "erb",
    name: "ERB",
    import: () => K( () => import("./erb-C4FIxXpw.js"), __vite__mapDeps([54, 1, 2, 3, 38, 7, 8, 18, 13, 39, 40]))
}, {
    id: "erlang",
    name: "Erlang",
    aliases: ["erl"],
    import: () => K( () => import("./erlang-DS9ZWoKD.js"), [])
}, {
    id: "fennel",
    name: "Fennel",
    import: () => K( () => import("./fennel-C6XIsc4F.js"), [])
}, {
    id: "fish",
    name: "Fish",
    import: () => K( () => import("./fish-DfeQjIbs.js"), [])
}, {
    id: "fluent",
    name: "Fluent",
    aliases: ["ftl"],
    import: () => K( () => import("./fluent-KPqz0Sb3.js"), [])
}, {
    id: "fortran-fixed-form",
    name: "Fortran (Fixed Form)",
    aliases: ["f", "for", "f77"],
    import: () => K( () => import("./fortran-fixed-form-CdVjoHtb.js"), __vite__mapDeps([55, 56]))
}, {
    id: "fortran-free-form",
    name: "Fortran (Free Form)",
    aliases: ["f90", "f95", "f03", "f08", "f18"],
    import: () => K( () => import("./fortran-free-form-D6pmzCqS.js"), [])
}, {
    id: "fsharp",
    name: "F#",
    aliases: ["f#", "fs"],
    import: () => K( () => import("./fsharp-C-VjhQSu.js"), __vite__mapDeps([57, 58]))
}, {
    id: "gdresource",
    name: "GDResource",
    import: () => K( () => import("./gdresource-nSffpn2A.js"), __vite__mapDeps([59, 60, 61]))
}, {
    id: "gdscript",
    name: "GDScript",
    import: () => K( () => import("./gdscript-B474tPdy.js"), [])
}, {
    id: "gdshader",
    name: "GDShader",
    import: () => K( () => import("./gdshader-B_SUYfiV.js"), [])
}, {
    id: "genie",
    name: "Genie",
    import: () => K( () => import("./genie-DAfrLhwG.js"), [])
}, {
    id: "gherkin",
    name: "Gherkin",
    import: () => K( () => import("./gherkin-DjTlIhuc.js"), [])
}, {
    id: "git-commit",
    name: "Git Commit Message",
    import: () => K( () => import("./git-commit-BleTlbuD.js"), __vite__mapDeps([62, 20]))
}, {
    id: "git-rebase",
    name: "Git Rebase Message",
    import: () => K( () => import("./git-rebase-CtmYztAk.js"), __vite__mapDeps([63, 39]))
}, {
    id: "gleam",
    name: "Gleam",
    import: () => K( () => import("./gleam-Dd6f7Z5P.js"), [])
}, {
    id: "glimmer-js",
    name: "Glimmer JS",
    aliases: ["gjs"],
    import: () => K( () => import("./glimmer-js-Bhx_sfM5.js"), __vite__mapDeps([64, 2, 46, 3, 1]))
}, {
    id: "glimmer-ts",
    name: "Glimmer TS",
    aliases: ["gts"],
    import: () => K( () => import("./glimmer-ts-61dai_V5.js"), __vite__mapDeps([65, 46, 3, 2, 1]))
}, {
    id: "glsl",
    name: "GLSL",
    import: () => K( () => import("./glsl-DNg5e6rY.js"), __vite__mapDeps([17, 13]))
}, {
    id: "gnuplot",
    name: "Gnuplot",
    import: () => K( () => import("./gnuplot-nclm9rTJ.js"), [])
}, {
    id: "go",
    name: "Go",
    import: () => K( () => import("./go-BJn7Ek5W.js"), [])
}, {
    id: "graphql",
    name: "GraphQL",
    aliases: ["gql"],
    import: () => K( () => import("./graphql-Cac5VMXA.js"), __vite__mapDeps([66, 2, 46, 28, 50]))
}, {
    id: "groovy",
    name: "Groovy",
    import: () => K( () => import("./groovy-wChcbJ1V.js"), [])
}, {
    id: "hack",
    name: "Hack",
    import: () => K( () => import("./hack-OhUXFOZr.js"), __vite__mapDeps([67, 1, 2, 3, 18]))
}, {
    id: "haml",
    name: "Ruby Haml",
    import: () => K( () => import("./haml-BsKmeTIz.js"), __vite__mapDeps([68, 38, 1, 2, 3, 7, 8, 18, 13, 39, 40, 42, 15, 58]))
}, {
    id: "handlebars",
    name: "Handlebars",
    aliases: ["hbs"],
    import: () => K( () => import("./handlebars-C0vBBVRa.js"), __vite__mapDeps([69, 1, 2, 3, 11]))
}, {
    id: "haskell",
    name: "Haskell",
    aliases: ["hs"],
    import: () => K( () => import("./haskell-DAGYewaG.js"), [])
}, {
    id: "haxe",
    name: "Haxe",
    import: () => K( () => import("./haxe-Dit6kIrv.js"), [])
}, {
    id: "hcl",
    name: "HashiCorp HCL",
    import: () => K( () => import("./hcl-CpAANOdC.js"), [])
}, {
    id: "hjson",
    name: "Hjson",
    import: () => K( () => import("./hjson-DZqG9GXz.js"), [])
}, {
    id: "hlsl",
    name: "HLSL",
    import: () => K( () => import("./hlsl-DmDrTTlz.js"), [])
}, {
    id: "html",
    name: "HTML",
    import: () => K( () => import("./html-CqhC7HHo.js"), __vite__mapDeps([1, 2, 3]))
}, {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: () => K( () => import("./html-derivative-CvQVKW9i.js"), __vite__mapDeps([70, 1, 2, 3]))
}, {
    id: "http",
    name: "HTTP",
    import: () => K( () => import("./http-mWhOz2-8.js"), __vite__mapDeps([71, 39, 9, 7, 8, 66, 2, 46, 28, 50]))
}, {
    id: "hxml",
    name: "HXML",
    import: () => K( () => import("./hxml-C5imjkyf.js"), __vite__mapDeps([72, 73]))
}, {
    id: "hy",
    name: "Hy",
    import: () => K( () => import("./hy-C3qJFuQy.js"), [])
}, {
    id: "imba",
    name: "Imba",
    import: () => K( () => import("./imba-BXg-Svbq.js"), __vite__mapDeps([74, 46]))
}, {
    id: "ini",
    name: "INI",
    aliases: ["properties"],
    import: () => K( () => import("./ini-DeVv6D4_.js"), [])
}, {
    id: "java",
    name: "Java",
    import: () => K( () => import("./java-ClXEvkw9.js"), [])
}, {
    id: "javascript",
    name: "JavaScript",
    aliases: ["js"],
    import: () => K( () => import("./javascript-Dch3xQiY.js"), [])
}, {
    id: "jinja",
    name: "Jinja",
    import: () => K( () => import("./jinja-DwshyRC8.js"), __vite__mapDeps([75, 1, 2, 3]))
}, {
    id: "jison",
    name: "Jison",
    import: () => K( () => import("./jison-5Ig0VrXv.js"), __vite__mapDeps([76, 2]))
}, {
    id: "json",
    name: "JSON",
    import: () => K( () => import("./json-CupVZNk8.js"), [])
}, {
    id: "json5",
    name: "JSON5",
    import: () => K( () => import("./json5-Bh8mriwU.js"), [])
}, {
    id: "jsonc",
    name: "JSON with Comments",
    import: () => K( () => import("./jsonc-DYI1rfmx.js"), [])
}, {
    id: "jsonl",
    name: "JSON Lines",
    import: () => K( () => import("./jsonl-BUpeXbsf.js"), [])
}, {
    id: "jsonnet",
    name: "Jsonnet",
    import: () => K( () => import("./jsonnet-C9d3aiqh.js"), [])
}, {
    id: "jssm",
    name: "JSSM",
    aliases: ["fsl"],
    import: () => K( () => import("./jssm-Dble9ECP.js"), [])
}, {
    id: "jsx",
    name: "JSX",
    import: () => K( () => import("./jsx-CsyrCbsw.js"), [])
}, {
    id: "julia",
    name: "Julia",
    aliases: ["jl"],
    import: () => K( () => import("./julia-CnoVwgV8.js"), __vite__mapDeps([29, 16, 17, 13, 18, 30, 2, 31]))
}, {
    id: "kotlin",
    name: "Kotlin",
    aliases: ["kt", "kts"],
    import: () => K( () => import("./kotlin-BIxS-Weu.js"), [])
}, {
    id: "kusto",
    name: "Kusto",
    aliases: ["kql"],
    import: () => K( () => import("./kusto-DGEpfOTx.js"), [])
}, {
    id: "latex",
    name: "LaTeX",
    import: () => K( () => import("./latex-DhY63DBA.js"), __vite__mapDeps([77, 78, 31, 39, 3, 79, 27, 1, 2, 8, 29, 16, 17, 13, 18, 30, 40, 38, 7, 41, 46, 11, 43]))
}, {
    id: "less",
    name: "Less",
    import: () => K( () => import("./less-Du6_OKDb.js"), [])
}, {
    id: "liquid",
    name: "Liquid",
    import: () => K( () => import("./liquid-Dj-jsJFu.js"), __vite__mapDeps([80, 1, 2, 3, 9]))
}, {
    id: "log",
    name: "Log file",
    import: () => K( () => import("./log-Ksn5IXup.js"), [])
}, {
    id: "logo",
    name: "Logo",
    import: () => K( () => import("./logo-DdacRhvC.js"), [])
}, {
    id: "lua",
    name: "Lua",
    import: () => K( () => import("./lua-BPmF2VOm.js"), __vite__mapDeps([40, 13]))
}, {
    id: "make",
    name: "Makefile",
    aliases: ["makefile"],
    import: () => K( () => import("./make-B9S9BZZh.js"), [])
}, {
    id: "markdown",
    name: "Markdown",
    aliases: ["md"],
    import: () => K( () => import("./markdown-BdfWgkoX.js"), [])
}, {
    id: "marko",
    name: "Marko",
    import: () => K( () => import("./marko-DTTVzMRa.js"), __vite__mapDeps([81, 3, 33, 5, 2]))
}, {
    id: "matlab",
    name: "MATLAB",
    import: () => K( () => import("./matlab-Btshr8M_.js"), [])
}, {
    id: "mdc",
    name: "MDC",
    import: () => K( () => import("./mdc-Bn_uTtpR.js"), __vite__mapDeps([82, 58, 11, 70, 1, 2, 3]))
}, {
    id: "mdx",
    name: "MDX",
    import: () => K( () => import("./mdx-CBPJd_fO.js"), [])
}, {
    id: "mermaid",
    name: "Mermaid",
    import: () => K( () => import("./mermaid-Dkb1Nx48.js"), [])
}, {
    id: "mojo",
    name: "Mojo",
    import: () => K( () => import("./mojo--7WWnkdy.js"), [])
}, {
    id: "move",
    name: "Move",
    import: () => K( () => import("./move-DOHBU7tp.js"), [])
}, {
    id: "narrat",
    name: "Narrat Language",
    aliases: ["nar"],
    import: () => K( () => import("./narrat-B9CT-1u6.js"), [])
}, {
    id: "nextflow",
    name: "Nextflow",
    aliases: ["nf"],
    import: () => K( () => import("./nextflow-DBxHOdLe.js"), [])
}, {
    id: "nginx",
    name: "Nginx",
    import: () => K( () => import("./nginx-Bo7Ko850.js"), __vite__mapDeps([83, 40, 13]))
}, {
    id: "nim",
    name: "Nim",
    import: () => K( () => import("./nim-0XdZC7BR.js"), __vite__mapDeps([84, 13, 1, 2, 3, 7, 8, 17, 58]))
}, {
    id: "nix",
    name: "Nix",
    import: () => K( () => import("./nix-B7rNE5kf.js"), [])
}, {
    id: "nushell",
    name: "nushell",
    aliases: ["nu"],
    import: () => K( () => import("./nushell-CrgTADc5.js"), [])
}, {
    id: "objective-c",
    name: "Objective-C",
    aliases: ["objc"],
    import: () => K( () => import("./objective-c-DHmGyzbM.js"), [])
}, {
    id: "objective-cpp",
    name: "Objective-C++",
    import: () => K( () => import("./objective-cpp-BWKJ1FCf.js"), [])
}, {
    id: "ocaml",
    name: "OCaml",
    import: () => K( () => import("./ocaml-RqY_Nz63.js"), [])
}, {
    id: "pascal",
    name: "Pascal",
    import: () => K( () => import("./pascal-BvCdDh2R.js"), [])
}, {
    id: "perl",
    name: "Perl",
    import: () => K( () => import("./perl-InL218rs.js"), __vite__mapDeps([37, 1, 2, 3, 7, 8, 18]))
}, {
    id: "php",
    name: "PHP",
    import: () => K( () => import("./php-DdJTc9Za.js"), __vite__mapDeps([85, 1, 2, 3, 7, 8, 18, 9]))
}, {
    id: "plsql",
    name: "PL/SQL",
    import: () => K( () => import("./plsql-BbJj1K1w.js"), [])
}, {
    id: "po",
    name: "Gettext PO",
    aliases: ["pot", "potx"],
    import: () => K( () => import("./po-HrnDn_2Q.js"), [])
}, {
    id: "postcss",
    name: "PostCSS",
    import: () => K( () => import("./postcss-DXT9h7v2.js"), [])
}, {
    id: "powerquery",
    name: "PowerQuery",
    import: () => K( () => import("./powerquery-CApMHEaB.js"), [])
}, {
    id: "powershell",
    name: "PowerShell",
    aliases: ["ps", "ps1"],
    import: () => K( () => import("./powershell-9ZOzOPqN.js"), [])
}, {
    id: "prisma",
    name: "Prisma",
    import: () => K( () => import("./prisma-BBJYjQ0k.js"), [])
}, {
    id: "prolog",
    name: "Prolog",
    import: () => K( () => import("./prolog-BH_RS3WO.js"), [])
}, {
    id: "proto",
    name: "Protocol Buffer 3",
    import: () => K( () => import("./proto-DOtRmeXT.js"), [])
}, {
    id: "pug",
    name: "Pug",
    aliases: ["jade"],
    import: () => K( () => import("./pug-BmZh5kCX.js"), __vite__mapDeps([86, 2, 3, 42, 5, 48, 15, 1]))
}, {
    id: "puppet",
    name: "Puppet",
    import: () => K( () => import("./puppet-37ic6j3l.js"), [])
}, {
    id: "purescript",
    name: "PureScript",
    import: () => K( () => import("./purescript-CfPQhs6g.js"), [])
}, {
    id: "python",
    name: "Python",
    aliases: ["py"],
    import: () => K( () => import("./python-DwuVtWc2.js"), [])
}, {
    id: "qml",
    name: "QML",
    import: () => K( () => import("./qml-DcMLa_hy.js"), __vite__mapDeps([87, 2]))
}, {
    id: "qmldir",
    name: "QML Directory",
    import: () => K( () => import("./qmldir-MS3qTAOR.js"), [])
}, {
    id: "qss",
    name: "Qt Style Sheets",
    import: () => K( () => import("./qss-FJDVp-XM.js"), [])
}, {
    id: "r",
    name: "R",
    import: () => K( () => import("./r-BXfENWL6.js"), [])
}, {
    id: "racket",
    name: "Racket",
    import: () => K( () => import("./racket-Cp2HGa90.js"), [])
}, {
    id: "raku",
    name: "Raku",
    aliases: ["perl6"],
    import: () => K( () => import("./raku-D384ylkT.js"), [])
}, {
    id: "razor",
    name: "ASP.NET Razor",
    import: () => K( () => import("./razor-CtZ59qoM.js"), __vite__mapDeps([88, 1, 2, 3, 19]))
}, {
    id: "reg",
    name: "Windows Registry Script",
    import: () => K( () => import("./reg-CrhH3_Og.js"), [])
}, {
    id: "regexp",
    name: "RegExp",
    aliases: ["regex"],
    import: () => K( () => import("./regexp-C_ZPRiAj.js"), [])
}, {
    id: "rel",
    name: "Rel",
    import: () => K( () => import("./rel-6Kuza3Wr.js"), [])
}, {
    id: "riscv",
    name: "RISC-V",
    import: () => K( () => import("./riscv-AgnqFTPX.js"), [])
}, {
    id: "rst",
    name: "reStructuredText",
    import: () => K( () => import("./rst-5AUMhdsS.js"), __vite__mapDeps([89, 70, 1, 2, 3, 16, 17, 13, 18, 30, 39, 11, 90, 38, 7, 8, 40]))
}, {
    id: "ruby",
    name: "Ruby",
    aliases: ["rb"],
    import: () => K( () => import("./ruby-CPHW1Myo.js"), __vite__mapDeps([38, 1, 2, 3, 7, 8, 18, 13, 39, 40]))
}, {
    id: "rust",
    name: "Rust",
    aliases: ["rs"],
    import: () => K( () => import("./rust-DGxQkqYo.js"), [])
}, {
    id: "sas",
    name: "SAS",
    import: () => K( () => import("./sas-WQZNIjpJ.js"), __vite__mapDeps([91, 18]))
}, {
    id: "sass",
    name: "Sass",
    import: () => K( () => import("./sass-CMDmr8et.js"), [])
}, {
    id: "scala",
    name: "Scala",
    import: () => K( () => import("./scala-vMsNTMhM.js"), [])
}, {
    id: "scheme",
    name: "Scheme",
    import: () => K( () => import("./scheme-1Je9_Reo.js"), [])
}, {
    id: "scss",
    name: "SCSS",
    import: () => K( () => import("./scss-DqznleHU.js"), __vite__mapDeps([5, 3]))
}, {
    id: "shaderlab",
    name: "ShaderLab",
    aliases: ["shader"],
    import: () => K( () => import("./shaderlab-DBpbMEBh.js"), __vite__mapDeps([92, 93]))
}, {
    id: "shellscript",
    name: "Shell",
    aliases: ["bash", "sh", "shell", "zsh"],
    import: () => K( () => import("./shellscript-BZfs-ost.js"), [])
}, {
    id: "shellsession",
    name: "Shell Session",
    aliases: ["console"],
    import: () => K( () => import("./shellsession-4WldjxEd.js"), __vite__mapDeps([94, 39]))
}, {
    id: "smalltalk",
    name: "Smalltalk",
    import: () => K( () => import("./smalltalk-DSsji4Hu.js"), [])
}, {
    id: "solidity",
    name: "Solidity",
    import: () => K( () => import("./solidity-CThH5sBG.js"), [])
}, {
    id: "soy",
    name: "Closure Templates",
    aliases: ["closure-templates"],
    import: () => K( () => import("./soy-DhLnWwFA.js"), __vite__mapDeps([95, 1, 2, 3]))
}, {
    id: "sparql",
    name: "SPARQL",
    import: () => K( () => import("./sparql-BgtC_-ln.js"), __vite__mapDeps([96, 97]))
}, {
    id: "splunk",
    name: "Splunk Query Language",
    aliases: ["spl"],
    import: () => K( () => import("./splunk-6XBPEST2.js"), [])
}, {
    id: "sql",
    name: "SQL",
    import: () => K( () => import("./sql-DbK06e1c.js"), [])
}, {
    id: "ssh-config",
    name: "SSH Config",
    import: () => K( () => import("./ssh-config-BH1M7C1g.js"), [])
}, {
    id: "stata",
    name: "Stata",
    import: () => K( () => import("./stata-8O9LehIm.js"), __vite__mapDeps([98, 18]))
}, {
    id: "stylus",
    name: "Stylus",
    aliases: ["styl"],
    import: () => K( () => import("./stylus-DSrLtGYv.js"), [])
}, {
    id: "svelte",
    name: "Svelte",
    import: () => K( () => import("./svelte-DavKDhWY.js"), __vite__mapDeps([99, 2, 46, 15, 48, 42, 3, 5, 33, 49, 86, 1, 58]))
}, {
    id: "swift",
    name: "Swift",
    import: () => K( () => import("./swift-Dez-Qvcc.js"), [])
}, {
    id: "system-verilog",
    name: "SystemVerilog",
    import: () => K( () => import("./system-verilog-BscxmKrE.js"), [])
}, {
    id: "systemd",
    name: "Systemd Units",
    import: () => K( () => import("./systemd-CuJfdYLG.js"), [])
}, {
    id: "tasl",
    name: "Tasl",
    import: () => K( () => import("./tasl-BxwAa5i0.js"), [])
}, {
    id: "tcl",
    name: "Tcl",
    import: () => K( () => import("./tcl-C_8Fx7bH.js"), [])
}, {
    id: "terraform",
    name: "Terraform",
    aliases: ["tf", "tfvars"],
    import: () => K( () => import("./terraform-DBeuZS66.js"), [])
}, {
    id: "tex",
    name: "TeX",
    import: () => K( () => import("./tex-Dk885XYG.js"), __vite__mapDeps([78, 31]))
}, {
    id: "toml",
    name: "TOML",
    import: () => K( () => import("./toml-BT9ZzGyQ.js"), [])
}, {
    id: "tsv",
    name: "TSV",
    import: () => K( () => import("./tsv-DnLUQrgA.js"), [])
}, {
    id: "tsx",
    name: "TSX",
    import: () => K( () => import("./tsx-BlxWTfDV.js"), [])
}, {
    id: "turtle",
    name: "Turtle",
    import: () => K( () => import("./turtle-C15OxdQ5.js"), [])
}, {
    id: "twig",
    name: "Twig",
    import: () => K( () => import("./twig-llAgFoxS.js"), __vite__mapDeps([100, 3, 2, 5, 85, 1, 7, 8, 18, 9, 30, 38, 13, 39, 40]))
}, {
    id: "typescript",
    name: "TypeScript",
    aliases: ["ts"],
    import: () => K( () => import("./typescript-DC8MraHL.js"), [])
}, {
    id: "typespec",
    name: "TypeSpec",
    aliases: ["tsp"],
    import: () => K( () => import("./typespec-DAP_O-zg.js"), [])
}, {
    id: "typst",
    name: "Typst",
    aliases: ["typ"],
    import: () => K( () => import("./typst-I4qd5QHW.js"), [])
}, {
    id: "v",
    name: "V",
    import: () => K( () => import("./v-C2TBxDwV.js"), [])
}, {
    id: "vala",
    name: "Vala",
    import: () => K( () => import("./vala-CO5hpdkB.js"), [])
}, {
    id: "vb",
    name: "Visual Basic",
    aliases: ["cmd"],
    import: () => K( () => import("./vb-beD-FUib.js"), [])
}, {
    id: "verilog",
    name: "Verilog",
    import: () => K( () => import("./verilog-DVfdqzEq.js"), [])
}, {
    id: "vhdl",
    name: "VHDL",
    import: () => K( () => import("./vhdl-QZ3jNtnE.js"), [])
}, {
    id: "viml",
    name: "Vim Script",
    aliases: ["vim", "vimscript"],
    import: () => K( () => import("./viml-BLluXI4E.js"), [])
}, {
    id: "vue",
    name: "Vue",
    import: () => K( () => import("./vue-DwKRC_TW.js"), __vite__mapDeps([101, 1, 2, 3, 58, 86, 42, 5, 48, 15, 33, 46, 28, 50, 9, 102, 103, 11, 45, 66, 70]))
}, {
    id: "vue-html",
    name: "Vue HTML",
    import: () => K( () => import("./vue-html-BQKlc1uT.js"), __vite__mapDeps([104, 101, 1, 2, 3, 58, 86, 42, 5, 48, 15, 33, 46, 28, 50, 9, 102, 103, 11, 45, 66, 70]))
}, {
    id: "vyper",
    name: "Vyper",
    aliases: ["vy"],
    import: () => K( () => import("./vyper-o-cPXEvd.js"), [])
}, {
    id: "wasm",
    name: "WebAssembly",
    import: () => K( () => import("./wasm-Cicx_DS6.js"), [])
}, {
    id: "wenyan",
    name: "Wenyan",
    aliases: [""],
    import: () => K( () => import("./wenyan-D3VXSfF0.js"), [])
}, {
    id: "wgsl",
    name: "WGSL",
    import: () => K( () => import("./wgsl-BZz1Hhek.js"), [])
}, {
    id: "wikitext",
    name: "Wikitext",
    aliases: ["mediawiki", "wiki"],
    import: () => K( () => import("./wikitext-2Gt4HDrj.js"), __vite__mapDeps([105, 1, 2, 3, 106, 8, 40, 13, 34, 37, 7, 18, 31, 38, 39, 85, 9, 107, 108, 11, 109, 14, 15, 16, 17, 20, 21, 25, 26, 86, 42, 5, 48, 102, 33, 35, 44, 110, 111, 30, 29, 41, 43, 46, 19, 57, 58, 112, 69, 24, 22, 77, 78, 79, 27, 113]))
}, {
    id: "wolfram",
    name: "Wolfram",
    aliases: ["wl"],
    import: () => K( () => import("./wolfram-BICIrM8O.js"), [])
}, {
    id: "xml",
    name: "XML",
    import: () => K( () => import("./xml-KWQaRJyt.js"), __vite__mapDeps([7, 8]))
}, {
    id: "xsl",
    name: "XSL",
    import: () => K( () => import("./xsl-bm8RKyr3.js"), __vite__mapDeps([108, 7, 8]))
}, {
    id: "yaml",
    name: "YAML",
    aliases: ["yml"],
    import: () => K( () => import("./yaml-C5gCGmDW.js"), [])
}, {
    id: "zenscript",
    name: "ZenScript",
    import: () => K( () => import("./zenscript-B1nm99XP.js"), [])
}, {
    id: "zig",
    name: "Zig",
    import: () => K( () => import("./zig-xtV5iK4E.js"), [])
}]
  , Vz = Object.fromEntries(gI.map(t => [t.id, t.import]))
  , $z = Object.fromEntries(gI.flatMap(t => t.aliases?.map(e => [e, t.import]) || []))
  , _I = {
    ...Vz,
    ...$z
}
  , zz = async t => K( () => import("./wasm-CsTmP73Z.js"), []).then(e => e.default(t))
  , Wz = [{
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: () => K( () => import("./andromeeda-YxQm0tCS.js"), [])
}, {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: () => K( () => import("./aurora-x-BaWyeHV_.js"), [])
}, {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: () => K( () => import("./ayu-dark-Bn5gmY5k.js"), [])
}, {
    id: "catppuccin-frappe",
    displayName: "Catppuccin Frapp",
    type: "dark",
    import: () => K( () => import("./catppuccin-frappe-CSPeAESR.js"), [])
}, {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: () => K( () => import("./catppuccin-latte-BYdKNJ10.js"), [])
}, {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: () => K( () => import("./catppuccin-macchiato-DVLwECkk.js"), [])
}, {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: () => K( () => import("./catppuccin-mocha-CEfge3mM.js"), [])
}, {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: () => K( () => import("./dark-plus-KEYLhlmT.js"), [])
}, {
    id: "dracula",
    displayName: "Dracula",
    type: "dark",
    import: () => K( () => import("./dracula-DGO8GyiP.js"), [])
}, {
    id: "dracula-soft",
    displayName: "Dracula Soft",
    type: "dark",
    import: () => K( () => import("./dracula-soft-9B1nZgL-.js"), [])
}, {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: () => K( () => import("./github-dark-CzPA46E-.js"), [])
}, {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: () => K( () => import("./github-dark-default-BXF7Vm5l.js"), [])
}, {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: () => K( () => import("./github-dark-dimmed-CRDKj6ck.js"), [])
}, {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: () => K( () => import("./github-light-CRlnGVMD.js"), [])
}, {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: () => K( () => import("./github-light-default-UREJT2Bw.js"), [])
}, {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: () => K( () => import("./houston-CZZ6oYdA.js"), [])
}, {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: () => K( () => import("./light-plus-BsvsQ1iS.js"), [])
}, {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: () => K( () => import("./material-theme-B2BuIiKK.js"), [])
}, {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: () => K( () => import("./material-theme-darker-BrGg7AAd.js"), [])
}, {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: () => K( () => import("./material-theme-lighter-DDRuGeQH.js"), [])
}, {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: () => K( () => import("./material-theme-ocean-CBL0qBdF.js"), [])
}, {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: () => K( () => import("./material-theme-palenight-D7gg1Usp.js"), [])
}, {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: () => K( () => import("./min-dark-iSbrOpM4.js"), [])
}, {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: () => K( () => import("./min-light-BITGhEdf.js"), [])
}, {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: () => K( () => import("./monokai-sMI-pExk.js"), [])
}, {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: () => K( () => import("./night-owl-BeocmOPF.js"), [])
}, {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: () => K( () => import("./nord-CsyjKwr8.js"), [])
}, {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: () => K( () => import("./one-dark-pro-BTtaZsq5.js"), [])
}, {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: () => K( () => import("./one-light-alpzPJ78.js"), [])
}, {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: () => K( () => import("./poimandres-Cda-MJFk.js"), [])
}, {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: () => K( () => import("./red-jaXbsbtS.js"), [])
}, {
    id: "rose-pine",
    displayName: "Ros Pine",
    type: "dark",
    import: () => K( () => import("./rose-pine-CX_FIdg1.js"), [])
}, {
    id: "rose-pine-dawn",
    displayName: "Ros Pine Dawn",
    type: "light",
    import: () => K( () => import("./rose-pine-dawn-Bj5xdiaE.js"), [])
}, {
    id: "rose-pine-moon",
    displayName: "Ros Pine Moon",
    type: "dark",
    import: () => K( () => import("./rose-pine-moon-CdedUr_-.js"), [])
}, {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: () => K( () => import("./slack-dark-C7oZ9nno.js"), [])
}, {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: () => K( () => import("./slack-ochin-hXH8Gyq8.js"), [])
}, {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: () => K( () => import("./snazzy-light-CA9nliXM.js"), [])
}, {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: () => K( () => import("./solarized-dark-C86elO-m.js"), [])
}, {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: () => K( () => import("./solarized-light-xPNGhBYe.js"), [])
}, {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: () => K( () => import("./synthwave-84-BBDuFDsq.js"), [])
}, {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: () => K( () => import("./tokyo-night-eJfcURhx.js"), [])
}, {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: () => K( () => import("./vesper-BSB_bK09.js"), [])
}, {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: () => K( () => import("./vitesse-black-B3g-KkBK.js"), [])
}, {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: () => K( () => import("./vitesse-dark-Bxkoe-BC.js"), [])
}, {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: () => K( () => import("./vitesse-light-Br6ll-O0.js"), [])
}]
  , Gz = Object.fromEntries(Wz.map(t => [t.id, t.import]));
var Mv = {}
  , Lm = {};
Lm.byteLength = Yz;
Lm.toByteArray = Qz;
Lm.fromByteArray = eW;
var gi = []
  , Sr = []
  , qz = typeof Uint8Array < "u" ? Uint8Array : Array
  , Xg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Ia = 0, Kz = Xg.length; Ia < Kz; ++Ia)
    gi[Ia] = Xg[Ia],
    Sr[Xg.charCodeAt(Ia)] = Ia;
Sr[45] = 62;
Sr[95] = 63;
function bI(t) {
    var e = t.length;
    if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    n === -1 && (n = e);
    var r = n === e ? 0 : 4 - n % 4;
    return [n, r]
}
function Yz(t) {
    var e = bI(t)
      , n = e[0]
      , r = e[1];
    return (n + r) * 3 / 4 - r
}
function Xz(t, e, n) {
    return (e + n) * 3 / 4 - n
}
function Qz(t) {
    var e, n = bI(t), r = n[0], i = n[1], s = new qz(Xz(t, r, i)), o = 0, a = i > 0 ? r - 4 : r, l;
    for (l = 0; l < a; l += 4)
        e = Sr[t.charCodeAt(l)] << 18 | Sr[t.charCodeAt(l + 1)] << 12 | Sr[t.charCodeAt(l + 2)] << 6 | Sr[t.charCodeAt(l + 3)],
        s[o++] = e >> 16 & 255,
        s[o++] = e >> 8 & 255,
        s[o++] = e & 255;
    return i === 2 && (e = Sr[t.charCodeAt(l)] << 2 | Sr[t.charCodeAt(l + 1)] >> 4,
    s[o++] = e & 255),
    i === 1 && (e = Sr[t.charCodeAt(l)] << 10 | Sr[t.charCodeAt(l + 1)] << 4 | Sr[t.charCodeAt(l + 2)] >> 2,
    s[o++] = e >> 8 & 255,
    s[o++] = e & 255),
    s
}
function Jz(t) {
    return gi[t >> 18 & 63] + gi[t >> 12 & 63] + gi[t >> 6 & 63] + gi[t & 63]
}
function Zz(t, e, n) {
    for (var r, i = [], s = e; s < n; s += 3)
        r = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255),
        i.push(Jz(r));
    return i.join("")
}
function eW(t) {
    for (var e, n = t.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)
        i.push(Zz(t, o, o + s > a ? a : o + s));
    return r === 1 ? (e = t[n - 1],
    i.push(gi[e >> 2] + gi[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1],
    i.push(gi[e >> 10] + gi[e >> 4 & 63] + gi[e << 2 & 63] + "=")),
    i.join("")
}
var Bv = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Bv.read = function(t, e, n, r, i) {
    var s, o, a = i * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, h = n ? i - 1 : 0, d = n ? -1 : 1, f = t[e + h];
    for (h += d,
    s = f & (1 << -u) - 1,
    f >>= -u,
    u += a; u > 0; s = s * 256 + t[e + h],
    h += d,
    u -= 8)
        ;
    for (o = s & (1 << -u) - 1,
    s >>= -u,
    u += r; u > 0; o = o * 256 + t[e + h],
    h += d,
    u -= 8)
        ;
    if (s === 0)
        s = 1 - c;
    else {
        if (s === l)
            return o ? NaN : (f ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, r),
        s = s - c
    }
    return (f ? -1 : 1) * o * Math.pow(2, s - r)
}
;
Bv.write = function(t, e, n, r, i, s) {
    var o, a, l, c = s * 8 - i - 1, u = (1 << c) - 1, h = u >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : s - 1, g = r ? 1 : -1, _ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e),
    isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
    o = u) : (o = Math.floor(Math.log(e) / Math.LN2),
    e * (l = Math.pow(2, -o)) < 1 && (o--,
    l *= 2),
    o + h >= 1 ? e += d / l : e += d * Math.pow(2, 1 - h),
    e * l >= 2 && (o++,
    l /= 2),
    o + h >= u ? (a = 0,
    o = u) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i),
    o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i),
    o = 0)); i >= 8; t[n + f] = a & 255,
    f += g,
    a /= 256,
    i -= 8)
        ;
    for (o = o << i | a,
    c += i; c > 0; t[n + f] = o & 255,
    f += g,
    o /= 256,
    c -= 8)
        ;
    t[n + f - g] |= _ * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
    const e = Lm
      , n = Bv
      , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = u,
    t.SlowBuffer = E,
    t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i;
    const {Uint8Array: s, ArrayBuffer: o, SharedArrayBuffer: a} = globalThis;
    u.TYPED_ARRAY_SUPPORT = l(),
    !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function l() {
        try {
            const F = new s(1)
              , R = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(R, s.prototype),
            Object.setPrototypeOf(F, R),
            F.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(u.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (u.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(u.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (u.isBuffer(this))
                return this.byteOffset
        }
    });
    function c(F) {
        if (F > i)
            throw new RangeError('The value "' + F + '" is invalid for option "size"');
        const R = new s(F);
        return Object.setPrototypeOf(R, u.prototype),
        R
    }
    function u(F, R, P) {
        if (typeof F == "number") {
            if (typeof R == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return g(F)
        }
        return h(F, R, P)
    }
    u.poolSize = 8192;
    function h(F, R, P) {
        if (typeof F == "string")
            return _(F, R);
        if (o.isView(F))
            return p(F);
        if (F == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof F);
        if (it(F, o) || F && it(F.buffer, o) || typeof a < "u" && (it(F, a) || F && it(F.buffer, a)))
            return b(F, R, P);
        if (typeof F == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const q = F.valueOf && F.valueOf();
        if (q != null && q !== F)
            return u.from(q, R, P);
        const Y = y(F);
        if (Y)
            return Y;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof F[Symbol.toPrimitive] == "function")
            return u.from(F[Symbol.toPrimitive]("string"), R, P);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof F)
    }
    u.from = function(F, R, P) {
        return h(F, R, P)
    }
    ,
    Object.setPrototypeOf(u.prototype, s.prototype),
    Object.setPrototypeOf(u, s);
    function d(F) {
        if (typeof F != "number")
            throw new TypeError('"size" argument must be of type number');
        if (F < 0)
            throw new RangeError('The value "' + F + '" is invalid for option "size"')
    }
    function f(F, R, P) {
        return d(F),
        F <= 0 ? c(F) : R !== void 0 ? typeof P == "string" ? c(F).fill(R, P) : c(F).fill(R) : c(F)
    }
    u.alloc = function(F, R, P) {
        return f(F, R, P)
    }
    ;
    function g(F) {
        return d(F),
        c(F < 0 ? 0 : x(F) | 0)
    }
    u.allocUnsafe = function(F) {
        return g(F)
    }
    ,
    u.allocUnsafeSlow = function(F) {
        return g(F)
    }
    ;
    function _(F, R) {
        if ((typeof R != "string" || R === "") && (R = "utf8"),
        !u.isEncoding(R))
            throw new TypeError("Unknown encoding: " + R);
        const P = w(F, R) | 0;
        let q = c(P);
        const Y = q.write(F, R);
        return Y !== P && (q = q.slice(0, Y)),
        q
    }
    function m(F) {
        const R = F.length < 0 ? 0 : x(F.length) | 0
          , P = c(R);
        for (let q = 0; q < R; q += 1)
            P[q] = F[q] & 255;
        return P
    }
    function p(F) {
        if (it(F, s)) {
            const R = new s(F);
            return b(R.buffer, R.byteOffset, R.byteLength)
        }
        return m(F)
    }
    function b(F, R, P) {
        if (R < 0 || F.byteLength < R)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (F.byteLength < R + (P || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let q;
        return R === void 0 && P === void 0 ? q = new s(F) : P === void 0 ? q = new s(F,R) : q = new s(F,R,P),
        Object.setPrototypeOf(q, u.prototype),
        q
    }
    function y(F) {
        if (u.isBuffer(F)) {
            const R = x(F.length) | 0
              , P = c(R);
            return P.length === 0 || F.copy(P, 0, 0, R),
            P
        }
        if (F.length !== void 0)
            return typeof F.length != "number" || he(F.length) ? c(0) : m(F);
        if (F.type === "Buffer" && Array.isArray(F.data))
            return m(F.data)
    }
    function x(F) {
        if (F >= i)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return F | 0
    }
    function E(F) {
        return +F != F && (F = 0),
        u.alloc(+F)
    }
    u.isBuffer = function(R) {
        return R != null && R._isBuffer === !0 && R !== u.prototype
    }
    ,
    u.compare = function(R, P) {
        if (it(R, s) && (R = u.from(R, R.offset, R.byteLength)),
        it(P, s) && (P = u.from(P, P.offset, P.byteLength)),
        !u.isBuffer(R) || !u.isBuffer(P))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (R === P)
            return 0;
        let q = R.length
          , Y = P.length;
        for (let re = 0, ce = Math.min(q, Y); re < ce; ++re)
            if (R[re] !== P[re]) {
                q = R[re],
                Y = P[re];
                break
            }
        return q < Y ? -1 : Y < q ? 1 : 0
    }
    ,
    u.isEncoding = function(R) {
        switch (String(R).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    u.concat = function(R, P) {
        if (!Array.isArray(R))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (R.length === 0)
            return u.alloc(0);
        let q;
        if (P === void 0)
            for (P = 0,
            q = 0; q < R.length; ++q)
                P += R[q].length;
        const Y = u.allocUnsafe(P);
        let re = 0;
        for (q = 0; q < R.length; ++q) {
            let ce = R[q];
            if (it(ce, s))
                re + ce.length > Y.length ? (u.isBuffer(ce) || (ce = u.from(ce)),
                ce.copy(Y, re)) : s.prototype.set.call(Y, ce, re);
            else if (u.isBuffer(ce))
                ce.copy(Y, re);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            re += ce.length
        }
        return Y
    }
    ;
    function w(F, R) {
        if (u.isBuffer(F))
            return F.length;
        if (o.isView(F) || it(F, o))
            return F.byteLength;
        if (typeof F != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof F);
        const P = F.length
          , q = arguments.length > 2 && arguments[2] === !0;
        if (!q && P === 0)
            return 0;
        let Y = !1;
        for (; ; )
            switch (R) {
            case "ascii":
            case "latin1":
            case "binary":
                return P;
            case "utf8":
            case "utf-8":
                return et(F).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return P * 2;
            case "hex":
                return P >>> 1;
            case "base64":
                return _t(F).length;
            default:
                if (Y)
                    return q ? -1 : et(F).length;
                R = ("" + R).toLowerCase(),
                Y = !0
            }
    }
    u.byteLength = w;
    function A(F, R, P) {
        let q = !1;
        if ((R === void 0 || R < 0) && (R = 0),
        R > this.length || ((P === void 0 || P > this.length) && (P = this.length),
        P <= 0) || (P >>>= 0,
        R >>>= 0,
        P <= R))
            return "";
        for (F || (F = "utf8"); ; )
            switch (F) {
            case "hex":
                return V(this, R, P);
            case "utf8":
            case "utf-8":
                return Q(this, R, P);
            case "ascii":
                return L(this, R, P);
            case "latin1":
            case "binary":
                return z(this, R, P);
            case "base64":
                return J(this, R, P);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return B(this, R, P);
            default:
                if (q)
                    throw new TypeError("Unknown encoding: " + F);
                F = (F + "").toLowerCase(),
                q = !0
            }
    }
    u.prototype._isBuffer = !0;
    function C(F, R, P) {
        const q = F[R];
        F[R] = F[P],
        F[P] = q
    }
    u.prototype.swap16 = function() {
        const R = this.length;
        if (R % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let P = 0; P < R; P += 2)
            C(this, P, P + 1);
        return this
    }
    ,
    u.prototype.swap32 = function() {
        const R = this.length;
        if (R % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let P = 0; P < R; P += 4)
            C(this, P, P + 3),
            C(this, P + 1, P + 2);
        return this
    }
    ,
    u.prototype.swap64 = function() {
        const R = this.length;
        if (R % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let P = 0; P < R; P += 8)
            C(this, P, P + 7),
            C(this, P + 1, P + 6),
            C(this, P + 2, P + 5),
            C(this, P + 3, P + 4);
        return this
    }
    ,
    u.prototype.toString = function() {
        const R = this.length;
        return R === 0 ? "" : arguments.length === 0 ? Q(this, 0, R) : A.apply(this, arguments)
    }
    ,
    u.prototype.toLocaleString = u.prototype.toString,
    u.prototype.equals = function(R) {
        if (!u.isBuffer(R))
            throw new TypeError("Argument must be a Buffer");
        return this === R ? !0 : u.compare(this, R) === 0
    }
    ,
    u.prototype.inspect = function() {
        let R = "";
        const P = t.INSPECT_MAX_BYTES;
        return R = this.toString("hex", 0, P).replace(/(.{2})/g, "$1 ").trim(),
        this.length > P && (R += " ... "),
        "<Buffer " + R + ">"
    }
    ,
    r && (u.prototype[r] = u.prototype.inspect),
    u.prototype.compare = function(R, P, q, Y, re) {
        if (it(R, s) && (R = u.from(R, R.offset, R.byteLength)),
        !u.isBuffer(R))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof R);
        if (P === void 0 && (P = 0),
        q === void 0 && (q = R ? R.length : 0),
        Y === void 0 && (Y = 0),
        re === void 0 && (re = this.length),
        P < 0 || q > R.length || Y < 0 || re > this.length)
            throw new RangeError("out of range index");
        if (Y >= re && P >= q)
            return 0;
        if (Y >= re)
            return -1;
        if (P >= q)
            return 1;
        if (P >>>= 0,
        q >>>= 0,
        Y >>>= 0,
        re >>>= 0,
        this === R)
            return 0;
        let ce = re - Y
          , Be = q - P;
        const Ke = Math.min(ce, Be)
          , bt = this.slice(Y, re)
          , mt = R.slice(P, q);
        for (let yt = 0; yt < Ke; ++yt)
            if (bt[yt] !== mt[yt]) {
                ce = bt[yt],
                Be = mt[yt];
                break
            }
        return ce < Be ? -1 : Be < ce ? 1 : 0
    }
    ;
    function k(F, R, P, q, Y) {
        if (F.length === 0)
            return -1;
        if (typeof P == "string" ? (q = P,
        P = 0) : P > 2147483647 ? P = 2147483647 : P < -2147483648 && (P = -2147483648),
        P = +P,
        he(P) && (P = Y ? 0 : F.length - 1),
        P < 0 && (P = F.length + P),
        P >= F.length) {
            if (Y)
                return -1;
            P = F.length - 1
        } else if (P < 0)
            if (Y)
                P = 0;
            else
                return -1;
        if (typeof R == "string" && (R = u.from(R, q)),
        u.isBuffer(R))
            return R.length === 0 ? -1 : I(F, R, P, q, Y);
        if (typeof R == "number")
            return R = R & 255,
            typeof s.prototype.indexOf == "function" ? Y ? s.prototype.indexOf.call(F, R, P) : s.prototype.lastIndexOf.call(F, R, P) : I(F, [R], P, q, Y);
        throw new TypeError("val must be string, number or Buffer")
    }
    function I(F, R, P, q, Y) {
        let re = 1
          , ce = F.length
          , Be = R.length;
        if (q !== void 0 && (q = String(q).toLowerCase(),
        q === "ucs2" || q === "ucs-2" || q === "utf16le" || q === "utf-16le")) {
            if (F.length < 2 || R.length < 2)
                return -1;
            re = 2,
            ce /= 2,
            Be /= 2,
            P /= 2
        }
        function Ke(mt, yt) {
            return re === 1 ? mt[yt] : mt.readUInt16BE(yt * re)
        }
        let bt;
        if (Y) {
            let mt = -1;
            for (bt = P; bt < ce; bt++)
                if (Ke(F, bt) === Ke(R, mt === -1 ? 0 : bt - mt)) {
                    if (mt === -1 && (mt = bt),
                    bt - mt + 1 === Be)
                        return mt * re
                } else
                    mt !== -1 && (bt -= bt - mt),
                    mt = -1
        } else
            for (P + Be > ce && (P = ce - Be),
            bt = P; bt >= 0; bt--) {
                let mt = !0;
                for (let yt = 0; yt < Be; yt++)
                    if (Ke(F, bt + yt) !== Ke(R, yt)) {
                        mt = !1;
                        break
                    }
                if (mt)
                    return bt
            }
        return -1
    }
    u.prototype.includes = function(R, P, q) {
        return this.indexOf(R, P, q) !== -1
    }
    ,
    u.prototype.indexOf = function(R, P, q) {
        return k(this, R, P, q, !0)
    }
    ,
    u.prototype.lastIndexOf = function(R, P, q) {
        return k(this, R, P, q, !1)
    }
    ;
    function N(F, R, P, q) {
        P = Number(P) || 0;
        const Y = F.length - P;
        q ? (q = Number(q),
        q > Y && (q = Y)) : q = Y;
        const re = R.length;
        q > re / 2 && (q = re / 2);
        let ce;
        for (ce = 0; ce < q; ++ce) {
            const Be = parseInt(R.substr(ce * 2, 2), 16);
            if (he(Be))
                return ce;
            F[P + ce] = Be
        }
        return ce
    }
    function O(F, R, P, q) {
        return St(et(R, F.length - P), F, P, q)
    }
    function M(F, R, P, q) {
        return St($t(R), F, P, q)
    }
    function H(F, R, P, q) {
        return St(_t(R), F, P, q)
    }
    function $(F, R, P, q) {
        return St(Jt(R, F.length - P), F, P, q)
    }
    u.prototype.write = function(R, P, q, Y) {
        if (P === void 0)
            Y = "utf8",
            q = this.length,
            P = 0;
        else if (q === void 0 && typeof P == "string")
            Y = P,
            q = this.length,
            P = 0;
        else if (isFinite(P))
            P = P >>> 0,
            isFinite(q) ? (q = q >>> 0,
            Y === void 0 && (Y = "utf8")) : (Y = q,
            q = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const re = this.length - P;
        if ((q === void 0 || q > re) && (q = re),
        R.length > 0 && (q < 0 || P < 0) || P > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        Y || (Y = "utf8");
        let ce = !1;
        for (; ; )
            switch (Y) {
            case "hex":
                return N(this, R, P, q);
            case "utf8":
            case "utf-8":
                return O(this, R, P, q);
            case "ascii":
            case "latin1":
            case "binary":
                return M(this, R, P, q);
            case "base64":
                return H(this, R, P, q);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return $(this, R, P, q);
            default:
                if (ce)
                    throw new TypeError("Unknown encoding: " + Y);
                Y = ("" + Y).toLowerCase(),
                ce = !0
            }
    }
    ,
    u.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function J(F, R, P) {
        return R === 0 && P === F.length ? e.fromByteArray(F) : e.fromByteArray(F.slice(R, P))
    }
    function Q(F, R, P) {
        P = Math.min(F.length, P);
        const q = [];
        let Y = R;
        for (; Y < P; ) {
            const re = F[Y];
            let ce = null
              , Be = re > 239 ? 4 : re > 223 ? 3 : re > 191 ? 2 : 1;
            if (Y + Be <= P) {
                let Ke, bt, mt, yt;
                switch (Be) {
                case 1:
                    re < 128 && (ce = re);
                    break;
                case 2:
                    Ke = F[Y + 1],
                    (Ke & 192) === 128 && (yt = (re & 31) << 6 | Ke & 63,
                    yt > 127 && (ce = yt));
                    break;
                case 3:
                    Ke = F[Y + 1],
                    bt = F[Y + 2],
                    (Ke & 192) === 128 && (bt & 192) === 128 && (yt = (re & 15) << 12 | (Ke & 63) << 6 | bt & 63,
                    yt > 2047 && (yt < 55296 || yt > 57343) && (ce = yt));
                    break;
                case 4:
                    Ke = F[Y + 1],
                    bt = F[Y + 2],
                    mt = F[Y + 3],
                    (Ke & 192) === 128 && (bt & 192) === 128 && (mt & 192) === 128 && (yt = (re & 15) << 18 | (Ke & 63) << 12 | (bt & 63) << 6 | mt & 63,
                    yt > 65535 && yt < 1114112 && (ce = yt))
                }
            }
            ce === null ? (ce = 65533,
            Be = 1) : ce > 65535 && (ce -= 65536,
            q.push(ce >>> 10 & 1023 | 55296),
            ce = 56320 | ce & 1023),
            q.push(ce),
            Y += Be
        }
        return D(q)
    }
    const ee = 4096;
    function D(F) {
        const R = F.length;
        if (R <= ee)
            return String.fromCharCode.apply(String, F);
        let P = ""
          , q = 0;
        for (; q < R; )
            P += String.fromCharCode.apply(String, F.slice(q, q += ee));
        return P
    }
    function L(F, R, P) {
        let q = "";
        P = Math.min(F.length, P);
        for (let Y = R; Y < P; ++Y)
            q += String.fromCharCode(F[Y] & 127);
        return q
    }
    function z(F, R, P) {
        let q = "";
        P = Math.min(F.length, P);
        for (let Y = R; Y < P; ++Y)
            q += String.fromCharCode(F[Y]);
        return q
    }
    function V(F, R, P) {
        const q = F.length;
        (!R || R < 0) && (R = 0),
        (!P || P < 0 || P > q) && (P = q);
        let Y = "";
        for (let re = R; re < P; ++re)
            Y += Se[F[re]];
        return Y
    }
    function B(F, R, P) {
        const q = F.slice(R, P);
        let Y = "";
        for (let re = 0; re < q.length - 1; re += 2)
            Y += String.fromCharCode(q[re] + q[re + 1] * 256);
        return Y
    }
    u.prototype.slice = function(R, P) {
        const q = this.length;
        R = ~~R,
        P = P === void 0 ? q : ~~P,
        R < 0 ? (R += q,
        R < 0 && (R = 0)) : R > q && (R = q),
        P < 0 ? (P += q,
        P < 0 && (P = 0)) : P > q && (P = q),
        P < R && (P = R);
        const Y = this.subarray(R, P);
        return Object.setPrototypeOf(Y, u.prototype),
        Y
    }
    ;
    function Z(F, R, P) {
        if (F % 1 !== 0 || F < 0)
            throw new RangeError("offset is not uint");
        if (F + R > P)
            throw new RangeError("Trying to access beyond buffer length")
    }
    u.prototype.readUintLE = u.prototype.readUIntLE = function(R, P, q) {
        R = R >>> 0,
        P = P >>> 0,
        q || Z(R, P, this.length);
        let Y = this[R]
          , re = 1
          , ce = 0;
        for (; ++ce < P && (re *= 256); )
            Y += this[R + ce] * re;
        return Y
    }
    ,
    u.prototype.readUintBE = u.prototype.readUIntBE = function(R, P, q) {
        R = R >>> 0,
        P = P >>> 0,
        q || Z(R, P, this.length);
        let Y = this[R + --P]
          , re = 1;
        for (; P > 0 && (re *= 256); )
            Y += this[R + --P] * re;
        return Y
    }
    ,
    u.prototype.readUint8 = u.prototype.readUInt8 = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 1, this.length),
        this[R]
    }
    ,
    u.prototype.readUint16LE = u.prototype.readUInt16LE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 2, this.length),
        this[R] | this[R + 1] << 8
    }
    ,
    u.prototype.readUint16BE = u.prototype.readUInt16BE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 2, this.length),
        this[R] << 8 | this[R + 1]
    }
    ,
    u.prototype.readUint32LE = u.prototype.readUInt32LE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 4, this.length),
        (this[R] | this[R + 1] << 8 | this[R + 2] << 16) + this[R + 3] * 16777216
    }
    ,
    u.prototype.readUint32BE = u.prototype.readUInt32BE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 4, this.length),
        this[R] * 16777216 + (this[R + 1] << 16 | this[R + 2] << 8 | this[R + 3])
    }
    ,
    u.prototype.readBigUInt64LE = De(function(R) {
        R = R >>> 0,
        Re(R, "offset");
        const P = this[R]
          , q = this[R + 7];
        (P === void 0 || q === void 0) && we(R, this.length - 8);
        const Y = P + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + this[++R] * 2 ** 24
          , re = this[++R] + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + q * 2 ** 24;
        return BigInt(Y) + (BigInt(re) << BigInt(32))
    }),
    u.prototype.readBigUInt64BE = De(function(R) {
        R = R >>> 0,
        Re(R, "offset");
        const P = this[R]
          , q = this[R + 7];
        (P === void 0 || q === void 0) && we(R, this.length - 8);
        const Y = P * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + this[++R]
          , re = this[++R] * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + q;
        return (BigInt(Y) << BigInt(32)) + BigInt(re)
    }),
    u.prototype.readIntLE = function(R, P, q) {
        R = R >>> 0,
        P = P >>> 0,
        q || Z(R, P, this.length);
        let Y = this[R]
          , re = 1
          , ce = 0;
        for (; ++ce < P && (re *= 256); )
            Y += this[R + ce] * re;
        return re *= 128,
        Y >= re && (Y -= Math.pow(2, 8 * P)),
        Y
    }
    ,
    u.prototype.readIntBE = function(R, P, q) {
        R = R >>> 0,
        P = P >>> 0,
        q || Z(R, P, this.length);
        let Y = P
          , re = 1
          , ce = this[R + --Y];
        for (; Y > 0 && (re *= 256); )
            ce += this[R + --Y] * re;
        return re *= 128,
        ce >= re && (ce -= Math.pow(2, 8 * P)),
        ce
    }
    ,
    u.prototype.readInt8 = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 1, this.length),
        this[R] & 128 ? (255 - this[R] + 1) * -1 : this[R]
    }
    ,
    u.prototype.readInt16LE = function(R, P) {
        R = R >>> 0,
        P || Z(R, 2, this.length);
        const q = this[R] | this[R + 1] << 8;
        return q & 32768 ? q | 4294901760 : q
    }
    ,
    u.prototype.readInt16BE = function(R, P) {
        R = R >>> 0,
        P || Z(R, 2, this.length);
        const q = this[R + 1] | this[R] << 8;
        return q & 32768 ? q | 4294901760 : q
    }
    ,
    u.prototype.readInt32LE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 4, this.length),
        this[R] | this[R + 1] << 8 | this[R + 2] << 16 | this[R + 3] << 24
    }
    ,
    u.prototype.readInt32BE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 4, this.length),
        this[R] << 24 | this[R + 1] << 16 | this[R + 2] << 8 | this[R + 3]
    }
    ,
    u.prototype.readBigInt64LE = De(function(R) {
        R = R >>> 0,
        Re(R, "offset");
        const P = this[R]
          , q = this[R + 7];
        (P === void 0 || q === void 0) && we(R, this.length - 8);
        const Y = this[R + 4] + this[R + 5] * 2 ** 8 + this[R + 6] * 2 ** 16 + (q << 24);
        return (BigInt(Y) << BigInt(32)) + BigInt(P + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + this[++R] * 2 ** 24)
    }),
    u.prototype.readBigInt64BE = De(function(R) {
        R = R >>> 0,
        Re(R, "offset");
        const P = this[R]
          , q = this[R + 7];
        (P === void 0 || q === void 0) && we(R, this.length - 8);
        const Y = (P << 24) + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + this[++R];
        return (BigInt(Y) << BigInt(32)) + BigInt(this[++R] * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + q)
    }),
    u.prototype.readFloatLE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 4, this.length),
        n.read(this, R, !0, 23, 4)
    }
    ,
    u.prototype.readFloatBE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 4, this.length),
        n.read(this, R, !1, 23, 4)
    }
    ,
    u.prototype.readDoubleLE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 8, this.length),
        n.read(this, R, !0, 52, 8)
    }
    ,
    u.prototype.readDoubleBE = function(R, P) {
        return R = R >>> 0,
        P || Z(R, 8, this.length),
        n.read(this, R, !1, 52, 8)
    }
    ;
    function se(F, R, P, q, Y, re) {
        if (!u.isBuffer(F))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (R > Y || R < re)
            throw new RangeError('"value" argument is out of bounds');
        if (P + q > F.length)
            throw new RangeError("Index out of range")
    }
    u.prototype.writeUintLE = u.prototype.writeUIntLE = function(R, P, q, Y) {
        if (R = +R,
        P = P >>> 0,
        q = q >>> 0,
        !Y) {
            const Be = Math.pow(2, 8 * q) - 1;
            se(this, R, P, q, Be, 0)
        }
        let re = 1
          , ce = 0;
        for (this[P] = R & 255; ++ce < q && (re *= 256); )
            this[P + ce] = R / re & 255;
        return P + q
    }
    ,
    u.prototype.writeUintBE = u.prototype.writeUIntBE = function(R, P, q, Y) {
        if (R = +R,
        P = P >>> 0,
        q = q >>> 0,
        !Y) {
            const Be = Math.pow(2, 8 * q) - 1;
            se(this, R, P, q, Be, 0)
        }
        let re = q - 1
          , ce = 1;
        for (this[P + re] = R & 255; --re >= 0 && (ce *= 256); )
            this[P + re] = R / ce & 255;
        return P + q
    }
    ,
    u.prototype.writeUint8 = u.prototype.writeUInt8 = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 1, 255, 0),
        this[P] = R & 255,
        P + 1
    }
    ,
    u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 2, 65535, 0),
        this[P] = R & 255,
        this[P + 1] = R >>> 8,
        P + 2
    }
    ,
    u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 2, 65535, 0),
        this[P] = R >>> 8,
        this[P + 1] = R & 255,
        P + 2
    }
    ,
    u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 4, 4294967295, 0),
        this[P + 3] = R >>> 24,
        this[P + 2] = R >>> 16,
        this[P + 1] = R >>> 8,
        this[P] = R & 255,
        P + 4
    }
    ,
    u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 4, 4294967295, 0),
        this[P] = R >>> 24,
        this[P + 1] = R >>> 16,
        this[P + 2] = R >>> 8,
        this[P + 3] = R & 255,
        P + 4
    }
    ;
    function ae(F, R, P, q, Y) {
        Ce(R, q, Y, F, P, 7);
        let re = Number(R & BigInt(4294967295));
        F[P++] = re,
        re = re >> 8,
        F[P++] = re,
        re = re >> 8,
        F[P++] = re,
        re = re >> 8,
        F[P++] = re;
        let ce = Number(R >> BigInt(32) & BigInt(4294967295));
        return F[P++] = ce,
        ce = ce >> 8,
        F[P++] = ce,
        ce = ce >> 8,
        F[P++] = ce,
        ce = ce >> 8,
        F[P++] = ce,
        P
    }
    function G(F, R, P, q, Y) {
        Ce(R, q, Y, F, P, 7);
        let re = Number(R & BigInt(4294967295));
        F[P + 7] = re,
        re = re >> 8,
        F[P + 6] = re,
        re = re >> 8,
        F[P + 5] = re,
        re = re >> 8,
        F[P + 4] = re;
        let ce = Number(R >> BigInt(32) & BigInt(4294967295));
        return F[P + 3] = ce,
        ce = ce >> 8,
        F[P + 2] = ce,
        ce = ce >> 8,
        F[P + 1] = ce,
        ce = ce >> 8,
        F[P] = ce,
        P + 8
    }
    u.prototype.writeBigUInt64LE = De(function(R, P=0) {
        return ae(this, R, P, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    u.prototype.writeBigUInt64BE = De(function(R, P=0) {
        return G(this, R, P, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    u.prototype.writeIntLE = function(R, P, q, Y) {
        if (R = +R,
        P = P >>> 0,
        !Y) {
            const Ke = Math.pow(2, 8 * q - 1);
            se(this, R, P, q, Ke - 1, -Ke)
        }
        let re = 0
          , ce = 1
          , Be = 0;
        for (this[P] = R & 255; ++re < q && (ce *= 256); )
            R < 0 && Be === 0 && this[P + re - 1] !== 0 && (Be = 1),
            this[P + re] = (R / ce >> 0) - Be & 255;
        return P + q
    }
    ,
    u.prototype.writeIntBE = function(R, P, q, Y) {
        if (R = +R,
        P = P >>> 0,
        !Y) {
            const Ke = Math.pow(2, 8 * q - 1);
            se(this, R, P, q, Ke - 1, -Ke)
        }
        let re = q - 1
          , ce = 1
          , Be = 0;
        for (this[P + re] = R & 255; --re >= 0 && (ce *= 256); )
            R < 0 && Be === 0 && this[P + re + 1] !== 0 && (Be = 1),
            this[P + re] = (R / ce >> 0) - Be & 255;
        return P + q
    }
    ,
    u.prototype.writeInt8 = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 1, 127, -128),
        R < 0 && (R = 255 + R + 1),
        this[P] = R & 255,
        P + 1
    }
    ,
    u.prototype.writeInt16LE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 2, 32767, -32768),
        this[P] = R & 255,
        this[P + 1] = R >>> 8,
        P + 2
    }
    ,
    u.prototype.writeInt16BE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 2, 32767, -32768),
        this[P] = R >>> 8,
        this[P + 1] = R & 255,
        P + 2
    }
    ,
    u.prototype.writeInt32LE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 4, 2147483647, -2147483648),
        this[P] = R & 255,
        this[P + 1] = R >>> 8,
        this[P + 2] = R >>> 16,
        this[P + 3] = R >>> 24,
        P + 4
    }
    ,
    u.prototype.writeInt32BE = function(R, P, q) {
        return R = +R,
        P = P >>> 0,
        q || se(this, R, P, 4, 2147483647, -2147483648),
        R < 0 && (R = 4294967295 + R + 1),
        this[P] = R >>> 24,
        this[P + 1] = R >>> 16,
        this[P + 2] = R >>> 8,
        this[P + 3] = R & 255,
        P + 4
    }
    ,
    u.prototype.writeBigInt64LE = De(function(R, P=0) {
        return ae(this, R, P, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    u.prototype.writeBigInt64BE = De(function(R, P=0) {
        return G(this, R, P, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function j(F, R, P, q, Y, re) {
        if (P + q > F.length)
            throw new RangeError("Index out of range");
        if (P < 0)
            throw new RangeError("Index out of range")
    }
    function oe(F, R, P, q, Y) {
        return R = +R,
        P = P >>> 0,
        Y || j(F, R, P, 4),
        n.write(F, R, P, q, 23, 4),
        P + 4
    }
    u.prototype.writeFloatLE = function(R, P, q) {
        return oe(this, R, P, !0, q)
    }
    ,
    u.prototype.writeFloatBE = function(R, P, q) {
        return oe(this, R, P, !1, q)
    }
    ;
    function le(F, R, P, q, Y) {
        return R = +R,
        P = P >>> 0,
        Y || j(F, R, P, 8),
        n.write(F, R, P, q, 52, 8),
        P + 8
    }
    u.prototype.writeDoubleLE = function(R, P, q) {
        return le(this, R, P, !0, q)
    }
    ,
    u.prototype.writeDoubleBE = function(R, P, q) {
        return le(this, R, P, !1, q)
    }
    ,
    u.prototype.copy = function(R, P, q, Y) {
        if (!u.isBuffer(R))
            throw new TypeError("argument should be a Buffer");
        if (q || (q = 0),
        !Y && Y !== 0 && (Y = this.length),
        P >= R.length && (P = R.length),
        P || (P = 0),
        Y > 0 && Y < q && (Y = q),
        Y === q || R.length === 0 || this.length === 0)
            return 0;
        if (P < 0)
            throw new RangeError("targetStart out of bounds");
        if (q < 0 || q >= this.length)
            throw new RangeError("Index out of range");
        if (Y < 0)
            throw new RangeError("sourceEnd out of bounds");
        Y > this.length && (Y = this.length),
        R.length - P < Y - q && (Y = R.length - P + q);
        const re = Y - q;
        return this === R && typeof s.prototype.copyWithin == "function" ? this.copyWithin(P, q, Y) : s.prototype.set.call(R, this.subarray(q, Y), P),
        re
    }
    ,
    u.prototype.fill = function(R, P, q, Y) {
        if (typeof R == "string") {
            if (typeof P == "string" ? (Y = P,
            P = 0,
            q = this.length) : typeof q == "string" && (Y = q,
            q = this.length),
            Y !== void 0 && typeof Y != "string")
                throw new TypeError("encoding must be a string");
            if (typeof Y == "string" && !u.isEncoding(Y))
                throw new TypeError("Unknown encoding: " + Y);
            if (R.length === 1) {
                const ce = R.charCodeAt(0);
                (Y === "utf8" && ce < 128 || Y === "latin1") && (R = ce)
            }
        } else
            typeof R == "number" ? R = R & 255 : typeof R == "boolean" && (R = Number(R));
        if (P < 0 || this.length < P || this.length < q)
            throw new RangeError("Out of range index");
        if (q <= P)
            return this;
        P = P >>> 0,
        q = q === void 0 ? this.length : q >>> 0,
        R || (R = 0);
        let re;
        if (typeof R == "number")
            for (re = P; re < q; ++re)
                this[re] = R;
        else {
            const ce = u.isBuffer(R) ? R : u.from(R, Y)
              , Be = ce.length;
            if (Be === 0)
                throw new TypeError('The value "' + R + '" is invalid for argument "value"');
            for (re = 0; re < q - P; ++re)
                this[re + P] = ce[re % Be]
        }
        return this
    }
    ;
    const de = {};
    function ne(F, R, P) {
        de[F] = class extends P {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: R.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${F}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return F
            }
            set code(Y) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: Y,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${F}]: ${this.message}`
            }
        }
    }
    ne("ERR_BUFFER_OUT_OF_BOUNDS", function(F) {
        return F ? `${F} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    ne("ERR_INVALID_ARG_TYPE", function(F, R) {
        return `The "${F}" argument must be of type number. Received type ${typeof R}`
    }, TypeError),
    ne("ERR_OUT_OF_RANGE", function(F, R, P) {
        let q = `The value of "${F}" is out of range.`
          , Y = P;
        return Number.isInteger(P) && Math.abs(P) > 2 ** 32 ? Y = pe(String(P)) : typeof P == "bigint" && (Y = String(P),
        (P > BigInt(2) ** BigInt(32) || P < -(BigInt(2) ** BigInt(32))) && (Y = pe(Y)),
        Y += "n"),
        q += ` It must be ${R}. Received ${Y}`,
        q
    }, RangeError);
    function pe(F) {
        let R = ""
          , P = F.length;
        const q = F[0] === "-" ? 1 : 0;
        for (; P >= q + 4; P -= 3)
            R = `_${F.slice(P - 3, P)}${R}`;
        return `${F.slice(0, P)}${R}`
    }
    function Te(F, R, P) {
        Re(R, "offset"),
        (F[R] === void 0 || F[R + P] === void 0) && we(R, F.length - (P + 1))
    }
    function Ce(F, R, P, q, Y, re) {
        if (F > P || F < R) {
            const ce = typeof R == "bigint" ? "n" : "";
            let Be;
            throw R === 0 || R === BigInt(0) ? Be = `>= 0${ce} and < 2${ce} ** ${(re + 1) * 8}${ce}` : Be = `>= -(2${ce} ** ${(re + 1) * 8 - 1}${ce}) and < 2 ** ${(re + 1) * 8 - 1}${ce}`,
            new de.ERR_OUT_OF_RANGE("value",Be,F)
        }
        Te(q, Y, re)
    }
    function Re(F, R) {
        if (typeof F != "number")
            throw new de.ERR_INVALID_ARG_TYPE(R,"number",F)
    }
    function we(F, R, P) {
        throw Math.floor(F) !== F ? (Re(F, P),
        new de.ERR_OUT_OF_RANGE("offset","an integer",F)) : R < 0 ? new de.ERR_BUFFER_OUT_OF_BOUNDS : new de.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${R}`,F)
    }
    const ze = /[^+/0-9A-Za-z-_]/g;
    function qe(F) {
        if (F = F.split("=")[0],
        F = F.trim().replace(ze, ""),
        F.length < 2)
            return "";
        for (; F.length % 4 !== 0; )
            F = F + "=";
        return F
    }
    function et(F, R) {
        R = R || 1 / 0;
        let P;
        const q = F.length;
        let Y = null;
        const re = [];
        for (let ce = 0; ce < q; ++ce) {
            if (P = F.charCodeAt(ce),
            P > 55295 && P < 57344) {
                if (!Y) {
                    if (P > 56319) {
                        (R -= 3) > -1 && re.push(239, 191, 189);
                        continue
                    } else if (ce + 1 === q) {
                        (R -= 3) > -1 && re.push(239, 191, 189);
                        continue
                    }
                    Y = P;
                    continue
                }
                if (P < 56320) {
                    (R -= 3) > -1 && re.push(239, 191, 189),
                    Y = P;
                    continue
                }
                P = (Y - 55296 << 10 | P - 56320) + 65536
            } else
                Y && (R -= 3) > -1 && re.push(239, 191, 189);
            if (Y = null,
            P < 128) {
                if ((R -= 1) < 0)
                    break;
                re.push(P)
            } else if (P < 2048) {
                if ((R -= 2) < 0)
                    break;
                re.push(P >> 6 | 192, P & 63 | 128)
            } else if (P < 65536) {
                if ((R -= 3) < 0)
                    break;
                re.push(P >> 12 | 224, P >> 6 & 63 | 128, P & 63 | 128)
            } else if (P < 1114112) {
                if ((R -= 4) < 0)
                    break;
                re.push(P >> 18 | 240, P >> 12 & 63 | 128, P >> 6 & 63 | 128, P & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return re
    }
    function $t(F) {
        const R = [];
        for (let P = 0; P < F.length; ++P)
            R.push(F.charCodeAt(P) & 255);
        return R
    }
    function Jt(F, R) {
        let P, q, Y;
        const re = [];
        for (let ce = 0; ce < F.length && !((R -= 2) < 0); ++ce)
            P = F.charCodeAt(ce),
            q = P >> 8,
            Y = P % 256,
            re.push(Y),
            re.push(q);
        return re
    }
    function _t(F) {
        return e.toByteArray(qe(F))
    }
    function St(F, R, P, q) {
        let Y;
        for (Y = 0; Y < q && !(Y + P >= R.length || Y >= F.length); ++Y)
            R[Y + P] = F[Y];
        return Y
    }
    function it(F, R) {
        return F instanceof R || F != null && F.constructor != null && F.constructor.name != null && F.constructor.name === R.name
    }
    function he(F) {
        return F !== F
    }
    const Se = function() {
        const F = "0123456789abcdef"
          , R = new Array(256);
        for (let P = 0; P < 16; ++P) {
            const q = P * 16;
            for (let Y = 0; Y < 16; ++Y)
                R[q + Y] = F[P] + F[Y]
        }
        return R
    }();
    function De(F) {
        return typeof BigInt > "u" ? Ge : F
    }
    function Ge() {
        throw new Error("BigInt not supported")
    }
}
)(Mv);
const Qf = Mv.Buffer
  , yI = Mv.Buffer;
var Gr;
(function(t) {
    t[t.NotSet = -1] = "NotSet",
    t[t.None = 0] = "None",
    t[t.Italic = 1] = "Italic",
    t[t.Bold = 2] = "Bold",
    t[t.Underline = 4] = "Underline"
}
)(Gr || (Gr = {}));
var Cl;
(function(t) {
    function e(u) {
        return u.toString(2).padStart(32, "0")
    }
    t.toBinaryStr = e;
    function n(u) {
        const h = t.getLanguageId(u)
          , d = t.getTokenType(u)
          , f = t.getFontStyle(u)
          , g = t.getForeground(u)
          , _ = t.getBackground(u);
        console.log({
            languageId: h,
            tokenType: d,
            fontStyle: f,
            foreground: g,
            background: _
        })
    }
    t.print = n;
    function r(u) {
        return (u & 255) >>> 0
    }
    t.getLanguageId = r;
    function i(u) {
        return (u & 768) >>> 8
    }
    t.getTokenType = i;
    function s(u) {
        return (u & 1024) !== 0
    }
    t.containsBalancedBrackets = s;
    function o(u) {
        return (u & 30720) >>> 11
    }
    t.getFontStyle = o;
    function a(u) {
        return (u & 16744448) >>> 15
    }
    t.getForeground = a;
    function l(u) {
        return (u & 4278190080) >>> 24
    }
    t.getBackground = l;
    function c(u, h, d, f, g, _, m) {
        let p = t.getLanguageId(u)
          , b = t.getTokenType(u)
          , y = t.containsBalancedBrackets(u) ? 1 : 0
          , x = t.getFontStyle(u)
          , E = t.getForeground(u)
          , w = t.getBackground(u);
        return h !== 0 && (p = h),
        d !== 8 && (b = d),
        f !== null && (y = f ? 1 : 0),
        g !== -1 && (x = g),
        _ !== 0 && (E = _),
        m !== 0 && (w = m),
        (p << 0 | b << 8 | y << 10 | x << 11 | E << 15 | w << 24) >>> 0
    }
    t.set = c
}
)(Cl || (Cl = {}));
function Jf(t, e) {
    const n = []
      , r = tW(t);
    let i = r.next();
    for (; i !== null; ) {
        let l = 0;
        if (i.length === 2 && i.charAt(1) === ":") {
            switch (i.charAt(0)) {
            case "R":
                l = 1;
                break;
            case "L":
                l = -1;
                break;
            default:
                console.log(`Unknown priority ${i} in scope selector`)
            }
            i = r.next()
        }
        let c = o();
        if (n.push({
            matcher: c,
            priority: l
        }),
        i !== ",")
            break;
        i = r.next()
    }
    return n;
    function s() {
        if (i === "-") {
            i = r.next();
            const l = s();
            return c => !!l && !l(c)
        }
        if (i === "(") {
            i = r.next();
            const l = a();
            return i === ")" && (i = r.next()),
            l
        }
        if (XS(i)) {
            const l = [];
            do
                l.push(i),
                i = r.next();
            while (XS(i));
            return c => e(l, c)
        }
        return null
    }
    function o() {
        const l = [];
        let c = s();
        for (; c; )
            l.push(c),
            c = s();
        return u => l.every(h => h(u))
    }
    function a() {
        const l = [];
        let c = o();
        for (; c && (l.push(c),
        i === "|" || i === ","); ) {
            do
                i = r.next();
            while (i === "|" || i === ",");
            c = o()
        }
        return u => l.some(h => h(u))
    }
}
function XS(t) {
    return !!t && !!t.match(/[\w\.:]+/)
}
function tW(t) {
    let e = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g
      , n = e.exec(t);
    return {
        next: () => {
            if (!n)
                return null;
            const r = n[0];
            return n = e.exec(t),
            r
        }
    }
}
function vI(t) {
    typeof t.dispose == "function" && t.dispose()
}
function nW(t) {
    return Fv(t)
}
function Fv(t) {
    return Array.isArray(t) ? rW(t) : typeof t == "object" ? iW(t) : t
}
function rW(t) {
    let e = [];
    for (let n = 0, r = t.length; n < r; n++)
        e[n] = Fv(t[n]);
    return e
}
function iW(t) {
    let e = {};
    for (let n in t)
        e[n] = Fv(t[n]);
    return e
}
function xI(t, ...e) {
    return e.forEach(n => {
        for (let r in n)
            t[r] = n[r]
    }
    ),
    t
}
function EI(t) {
    const e = ~t.lastIndexOf("/") || ~t.lastIndexOf("\\");
    return e === 0 ? t : ~e === t.length - 1 ? EI(t.substring(0, t.length - 1)) : t.substr(~e + 1)
}
let Qg = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g;
class bd {
    static hasCaptures(e) {
        return e === null ? !1 : (Qg.lastIndex = 0,
        Qg.test(e))
    }
    static replaceCaptures(e, n, r) {
        return e.replace(Qg, (i, s, o, a) => {
            let l = r[parseInt(s || o, 10)];
            if (l) {
                let c = n.substring(l.start, l.end);
                for (; c[0] === "."; )
                    c = c.substring(1);
                switch (a) {
                case "downcase":
                    return c.toLowerCase();
                case "upcase":
                    return c.toUpperCase();
                default:
                    return c
                }
            } else
                return i
        }
        )
    }
}
function SI(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
}
function wI(t, e) {
    if (t === null && e === null)
        return 0;
    if (!t)
        return -1;
    if (!e)
        return 1;
    let n = t.length
      , r = e.length;
    if (n === r) {
        for (let i = 0; i < n; i++) {
            let s = SI(t[i], e[i]);
            if (s !== 0)
                return s
        }
        return 0
    }
    return n - r
}
function QS(t) {
    return !!(/^#[0-9a-f]{6}$/i.test(t) || /^#[0-9a-f]{8}$/i.test(t) || /^#[0-9a-f]{3}$/i.test(t) || /^#[0-9a-f]{4}$/i.test(t))
}
function CI(t) {
    return t.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&")
}
class TI {
    fn;
    cache = new Map;
    constructor(e) {
        this.fn = e
    }
    get(e) {
        if (this.cache.has(e))
            return this.cache.get(e);
        const n = this.fn(e);
        return this.cache.set(e, n),
        n
    }
}
class bu {
    scopeName;
    constructor(e) {
        this.scopeName = e
    }
    toKey() {
        return this.scopeName
    }
}
class sW {
    scopeName;
    ruleName;
    constructor(e, n) {
        this.scopeName = e,
        this.ruleName = n
    }
    toKey() {
        return `${this.scopeName}#${this.ruleName}`
    }
}
class oW {
    _references = [];
    _seenReferenceKeys = new Set;
    get references() {
        return this._references
    }
    visitedRule = new Set;
    add(e) {
        const n = e.toKey();
        this._seenReferenceKeys.has(n) || (this._seenReferenceKeys.add(n),
        this._references.push(e))
    }
}
class aW {
    repo;
    initialScopeName;
    seenFullScopeRequests = new Set;
    seenPartialScopeRequests = new Set;
    Q;
    constructor(e, n) {
        this.repo = e,
        this.initialScopeName = n,
        this.seenFullScopeRequests.add(this.initialScopeName),
        this.Q = [new bu(this.initialScopeName)]
    }
    processQueue() {
        const e = this.Q;
        this.Q = [];
        const n = new oW;
        for (const r of e)
            lW(r, this.initialScopeName, this.repo, n);
        for (const r of n.references)
            if (r instanceof bu) {
                if (this.seenFullScopeRequests.has(r.scopeName))
                    continue;
                this.seenFullScopeRequests.add(r.scopeName),
                this.Q.push(r)
            } else {
                if (this.seenFullScopeRequests.has(r.scopeName) || this.seenPartialScopeRequests.has(r.toKey()))
                    continue;
                this.seenPartialScopeRequests.add(r.toKey()),
                this.Q.push(r)
            }
    }
}
function lW(t, e, n, r) {
    const i = n.lookup(t.scopeName);
    if (!i) {
        if (t.scopeName === e)
            throw new Error(`No grammar provided for <${e}>`);
        return
    }
    const s = n.lookup(e);
    t instanceof bu ? gf({
        baseGrammar: s,
        selfGrammar: i
    }, r) : $_(t.ruleName, {
        baseGrammar: s,
        selfGrammar: i,
        repository: i.repository
    }, r);
    const o = n.injections(t.scopeName);
    if (o)
        for (const a of o)
            r.add(new bu(a))
}
function $_(t, e, n) {
    if (e.repository && e.repository[t]) {
        const r = e.repository[t];
        Zf([r], e, n)
    }
}
function gf(t, e) {
    t.selfGrammar.patterns && Array.isArray(t.selfGrammar.patterns) && Zf(t.selfGrammar.patterns, {
        ...t,
        repository: t.selfGrammar.repository
    }, e),
    t.selfGrammar.injections && Zf(Object.values(t.selfGrammar.injections), {
        ...t,
        repository: t.selfGrammar.repository
    }, e)
}
function Zf(t, e, n) {
    for (const r of t) {
        if (n.visitedRule.has(r))
            continue;
        n.visitedRule.add(r);
        const i = r.repository ? xI({}, e.repository, r.repository) : e.repository;
        Array.isArray(r.patterns) && Zf(r.patterns, {
            ...e,
            repository: i
        }, n);
        const s = r.include;
        if (!s)
            continue;
        const o = AI(s);
        switch (o.kind) {
        case 0:
            gf({
                ...e,
                selfGrammar: e.baseGrammar
            }, n);
            break;
        case 1:
            gf(e, n);
            break;
        case 2:
            $_(o.ruleName, {
                ...e,
                repository: i
            }, n);
            break;
        case 3:
        case 4:
            const a = o.scopeName === e.selfGrammar.scopeName ? e.selfGrammar : o.scopeName === e.baseGrammar.scopeName ? e.baseGrammar : void 0;
            if (a) {
                const l = {
                    baseGrammar: e.baseGrammar,
                    selfGrammar: a,
                    repository: i
                };
                o.kind === 4 ? $_(o.ruleName, l, n) : gf(l, n)
            } else
                o.kind === 4 ? n.add(new sW(o.scopeName,o.ruleName)) : n.add(new bu(o.scopeName));
            break
        }
    }
}
class cW {
    kind = 0
}
class uW {
    kind = 1
}
class hW {
    ruleName;
    kind = 2;
    constructor(e) {
        this.ruleName = e
    }
}
class dW {
    scopeName;
    kind = 3;
    constructor(e) {
        this.scopeName = e
    }
}
class fW {
    scopeName;
    ruleName;
    kind = 4;
    constructor(e, n) {
        this.scopeName = e,
        this.ruleName = n
    }
}
function AI(t) {
    if (t === "$base")
        return new cW;
    if (t === "$self")
        return new uW;
    const e = t.indexOf("#");
    if (e === -1)
        return new dW(t);
    if (e === 0)
        return new hW(t.substring(1));
    {
        const n = t.substring(0, e)
          , r = t.substring(e + 1);
        return new fW(n,r)
    }
}
const pW = /\\(\d+)/
  , JS = /\\(\d+)/g
  , mW = -1
  , kI = -2;
let Fh = class {
    $location;
    id;
    _nameIsCapturing;
    _name;
    _contentNameIsCapturing;
    _contentName;
    constructor(e, n, r, i) {
        this.$location = e,
        this.id = n,
        this._name = r || null,
        this._nameIsCapturing = bd.hasCaptures(this._name),
        this._contentName = i || null,
        this._contentNameIsCapturing = bd.hasCaptures(this._contentName)
    }
    get debugName() {
        const e = this.$location ? `${EI(this.$location.filename)}:${this.$location.line}` : "unknown";
        return `${this.constructor.name}#${this.id} @ ${e}`
    }
    getName(e, n) {
        return !this._nameIsCapturing || this._name === null || e === null || n === null ? this._name : bd.replaceCaptures(this._name, e, n)
    }
    getContentName(e, n) {
        return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : bd.replaceCaptures(this._contentName, e, n)
    }
}
;
class gW extends Fh {
    retokenizeCapturedWithRuleId;
    constructor(e, n, r, i, s) {
        super(e, n, r, i),
        this.retokenizeCapturedWithRuleId = s
    }
    dispose() {}
    collectPatterns(e, n) {
        throw new Error("Not supported!")
    }
    compile(e, n) {
        throw new Error("Not supported!")
    }
    compileAG(e, n, r, i) {
        throw new Error("Not supported!")
    }
}
class _W extends Fh {
    _match;
    captures;
    _cachedCompiledPatterns;
    constructor(e, n, r, i, s) {
        super(e, n, r, null),
        this._match = new Qo(i,this.id),
        this.captures = s,
        this._cachedCompiledPatterns = null
    }
    dispose() {
        this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
        this._cachedCompiledPatterns = null)
    }
    get debugMatchRegExp() {
        return `${this._match.source}`
    }
    collectPatterns(e, n) {
        n.push(this._match)
    }
    compile(e, n) {
        return this._getCachedCompiledPatterns(e).compile(e)
    }
    compileAG(e, n, r, i) {
        return this._getCachedCompiledPatterns(e).compileAG(e, r, i)
    }
    _getCachedCompiledPatterns(e) {
        return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new yu,
        this.collectPatterns(e, this._cachedCompiledPatterns)),
        this._cachedCompiledPatterns
    }
}
class ZS extends Fh {
    hasMissingPatterns;
    patterns;
    _cachedCompiledPatterns;
    constructor(e, n, r, i, s) {
        super(e, n, r, i),
        this.patterns = s.patterns,
        this.hasMissingPatterns = s.hasMissingPatterns,
        this._cachedCompiledPatterns = null
    }
    dispose() {
        this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
        this._cachedCompiledPatterns = null)
    }
    collectPatterns(e, n) {
        for (const r of this.patterns)
            e.getRule(r).collectPatterns(e, n)
    }
    compile(e, n) {
        return this._getCachedCompiledPatterns(e).compile(e)
    }
    compileAG(e, n, r, i) {
        return this._getCachedCompiledPatterns(e).compileAG(e, r, i)
    }
    _getCachedCompiledPatterns(e) {
        return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new yu,
        this.collectPatterns(e, this._cachedCompiledPatterns)),
        this._cachedCompiledPatterns
    }
}
class z_ extends Fh {
    _begin;
    beginCaptures;
    _end;
    endHasBackReferences;
    endCaptures;
    applyEndPatternLast;
    hasMissingPatterns;
    patterns;
    _cachedCompiledPatterns;
    constructor(e, n, r, i, s, o, a, l, c, u) {
        super(e, n, r, i),
        this._begin = new Qo(s,this.id),
        this.beginCaptures = o,
        this._end = new Qo(a || "",-1),
        this.endHasBackReferences = this._end.hasBackReferences,
        this.endCaptures = l,
        this.applyEndPatternLast = c || !1,
        this.patterns = u.patterns,
        this.hasMissingPatterns = u.hasMissingPatterns,
        this._cachedCompiledPatterns = null
    }
    dispose() {
        this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
        this._cachedCompiledPatterns = null)
    }
    get debugBeginRegExp() {
        return `${this._begin.source}`
    }
    get debugEndRegExp() {
        return `${this._end.source}`
    }
    getEndWithResolvedBackReferences(e, n) {
        return this._end.resolveBackReferences(e, n)
    }
    collectPatterns(e, n) {
        n.push(this._begin)
    }
    compile(e, n) {
        return this._getCachedCompiledPatterns(e, n).compile(e)
    }
    compileAG(e, n, r, i) {
        return this._getCachedCompiledPatterns(e, n).compileAG(e, r, i)
    }
    _getCachedCompiledPatterns(e, n) {
        if (!this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns = new yu;
            for (const r of this.patterns)
                e.getRule(r).collectPatterns(e, this._cachedCompiledPatterns);
            this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)
        }
        return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, n) : this._cachedCompiledPatterns.setSource(0, n)),
        this._cachedCompiledPatterns
    }
}
class ep extends Fh {
    _begin;
    beginCaptures;
    whileCaptures;
    _while;
    whileHasBackReferences;
    hasMissingPatterns;
    patterns;
    _cachedCompiledPatterns;
    _cachedCompiledWhilePatterns;
    constructor(e, n, r, i, s, o, a, l, c) {
        super(e, n, r, i),
        this._begin = new Qo(s,this.id),
        this.beginCaptures = o,
        this.whileCaptures = l,
        this._while = new Qo(a,kI),
        this.whileHasBackReferences = this._while.hasBackReferences,
        this.patterns = c.patterns,
        this.hasMissingPatterns = c.hasMissingPatterns,
        this._cachedCompiledPatterns = null,
        this._cachedCompiledWhilePatterns = null
    }
    dispose() {
        this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(),
        this._cachedCompiledPatterns = null),
        this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(),
        this._cachedCompiledWhilePatterns = null)
    }
    get debugBeginRegExp() {
        return `${this._begin.source}`
    }
    get debugWhileRegExp() {
        return `${this._while.source}`
    }
    getWhileWithResolvedBackReferences(e, n) {
        return this._while.resolveBackReferences(e, n)
    }
    collectPatterns(e, n) {
        n.push(this._begin)
    }
    compile(e, n) {
        return this._getCachedCompiledPatterns(e).compile(e)
    }
    compileAG(e, n, r, i) {
        return this._getCachedCompiledPatterns(e).compileAG(e, r, i)
    }
    _getCachedCompiledPatterns(e) {
        if (!this._cachedCompiledPatterns) {
            this._cachedCompiledPatterns = new yu;
            for (const n of this.patterns)
                e.getRule(n).collectPatterns(e, this._cachedCompiledPatterns)
        }
        return this._cachedCompiledPatterns
    }
    compileWhile(e, n) {
        return this._getCachedCompiledWhilePatterns(e, n).compile(e)
    }
    compileWhileAG(e, n, r, i) {
        return this._getCachedCompiledWhilePatterns(e, n).compileAG(e, r, i)
    }
    _getCachedCompiledWhilePatterns(e, n) {
        return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new yu,
        this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)),
        this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, n || ""),
        this._cachedCompiledWhilePatterns
    }
}
class sn {
    static createCaptureRule(e, n, r, i, s) {
        return e.registerRule(o => new gW(n,o,r,i,s))
    }
    static getCompiledRuleId(e, n, r) {
        return e.id || n.registerRule(i => {
            if (e.id = i,
            e.match)
                return new _W(e.$vscodeTextmateLocation,e.id,e.name,e.match,sn._compileCaptures(e.captures, n, r));
            if (typeof e.begin > "u") {
                e.repository && (r = xI({}, r, e.repository));
                let s = e.patterns;
                return typeof s > "u" && e.include && (s = [{
                    include: e.include
                }]),
                new ZS(e.$vscodeTextmateLocation,e.id,e.name,e.contentName,sn._compilePatterns(s, n, r))
            }
            return e.while ? new ep(e.$vscodeTextmateLocation,e.id,e.name,e.contentName,e.begin,sn._compileCaptures(e.beginCaptures || e.captures, n, r),e.while,sn._compileCaptures(e.whileCaptures || e.captures, n, r),sn._compilePatterns(e.patterns, n, r)) : new z_(e.$vscodeTextmateLocation,e.id,e.name,e.contentName,e.begin,sn._compileCaptures(e.beginCaptures || e.captures, n, r),e.end,sn._compileCaptures(e.endCaptures || e.captures, n, r),e.applyEndPatternLast,sn._compilePatterns(e.patterns, n, r))
        }
        ),
        e.id
    }
    static _compileCaptures(e, n, r) {
        let i = [];
        if (e) {
            let s = 0;
            for (const o in e) {
                if (o === "$vscodeTextmateLocation")
                    continue;
                const a = parseInt(o, 10);
                a > s && (s = a)
            }
            for (let o = 0; o <= s; o++)
                i[o] = null;
            for (const o in e) {
                if (o === "$vscodeTextmateLocation")
                    continue;
                const a = parseInt(o, 10);
                let l = 0;
                e[o].patterns && (l = sn.getCompiledRuleId(e[o], n, r)),
                i[a] = sn.createCaptureRule(n, e[o].$vscodeTextmateLocation, e[o].name, e[o].contentName, l)
            }
        }
        return i
    }
    static _compilePatterns(e, n, r) {
        let i = [];
        if (e)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                let l = -1;
                if (a.include) {
                    const c = AI(a.include);
                    switch (c.kind) {
                    case 0:
                    case 1:
                        l = sn.getCompiledRuleId(r[a.include], n, r);
                        break;
                    case 2:
                        let u = r[c.ruleName];
                        u && (l = sn.getCompiledRuleId(u, n, r));
                        break;
                    case 3:
                    case 4:
                        const h = c.scopeName
                          , d = c.kind === 4 ? c.ruleName : null
                          , f = n.getExternalGrammar(h, r);
                        if (f)
                            if (d) {
                                let g = f.repository[d];
                                g && (l = sn.getCompiledRuleId(g, n, f.repository))
                            } else
                                l = sn.getCompiledRuleId(f.repository.$self, n, f.repository);
                        break
                    }
                } else
                    l = sn.getCompiledRuleId(a, n, r);
                if (l !== -1) {
                    const c = n.getRule(l);
                    let u = !1;
                    if ((c instanceof ZS || c instanceof z_ || c instanceof ep) && c.hasMissingPatterns && c.patterns.length === 0 && (u = !0),
                    u)
                        continue;
                    i.push(l)
                }
            }
        return {
            patterns: i,
            hasMissingPatterns: (e ? e.length : 0) !== i.length
        }
    }
}
class Qo {
    source;
    ruleId;
    hasAnchor;
    hasBackReferences;
    _anchorCache;
    constructor(e, n) {
        if (e) {
            const r = e.length;
            let i = 0
              , s = []
              , o = !1;
            for (let a = 0; a < r; a++)
                if (e.charAt(a) === "\\" && a + 1 < r) {
                    const c = e.charAt(a + 1);
                    c === "z" ? (s.push(e.substring(i, a)),
                    s.push("$(?!\\n)(?<!\\n)"),
                    i = a + 2) : (c === "A" || c === "G") && (o = !0),
                    a++
                }
            this.hasAnchor = o,
            i === 0 ? this.source = e : (s.push(e.substring(i, r)),
            this.source = s.join(""))
        } else
            this.hasAnchor = !1,
            this.source = e;
        this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null,
        this.ruleId = n,
        this.hasBackReferences = pW.test(this.source)
    }
    clone() {
        return new Qo(this.source,this.ruleId)
    }
    setSource(e) {
        this.source !== e && (this.source = e,
        this.hasAnchor && (this._anchorCache = this._buildAnchorCache()))
    }
    resolveBackReferences(e, n) {
        let r = n.map(i => e.substring(i.start, i.end));
        return JS.lastIndex = 0,
        this.source.replace(JS, (i, s) => CI(r[parseInt(s, 10)] || ""))
    }
    _buildAnchorCache() {
        let e = [], n = [], r = [], i = [], s, o, a, l;
        for (s = 0,
        o = this.source.length; s < o; s++)
            a = this.source.charAt(s),
            e[s] = a,
            n[s] = a,
            r[s] = a,
            i[s] = a,
            a === "\\" && s + 1 < o && (l = this.source.charAt(s + 1),
            l === "A" ? (e[s + 1] = "",
            n[s + 1] = "",
            r[s + 1] = "A",
            i[s + 1] = "A") : l === "G" ? (e[s + 1] = "",
            n[s + 1] = "G",
            r[s + 1] = "",
            i[s + 1] = "G") : (e[s + 1] = l,
            n[s + 1] = l,
            r[s + 1] = l,
            i[s + 1] = l),
            s++);
        return {
            A0_G0: e.join(""),
            A0_G1: n.join(""),
            A1_G0: r.join(""),
            A1_G1: i.join("")
        }
    }
    resolveAnchors(e, n) {
        return !this.hasAnchor || !this._anchorCache ? this.source : e ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0
    }
}
class yu {
    _items;
    _hasAnchors;
    _cached;
    _anchorCache;
    constructor() {
        this._items = [],
        this._hasAnchors = !1,
        this._cached = null,
        this._anchorCache = {
            A0_G0: null,
            A0_G1: null,
            A1_G0: null,
            A1_G1: null
        }
    }
    dispose() {
        this._disposeCaches()
    }
    _disposeCaches() {
        this._cached && (this._cached.dispose(),
        this._cached = null),
        this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(),
        this._anchorCache.A0_G0 = null),
        this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(),
        this._anchorCache.A0_G1 = null),
        this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(),
        this._anchorCache.A1_G0 = null),
        this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(),
        this._anchorCache.A1_G1 = null)
    }
    push(e) {
        this._items.push(e),
        this._hasAnchors = this._hasAnchors || e.hasAnchor
    }
    unshift(e) {
        this._items.unshift(e),
        this._hasAnchors = this._hasAnchors || e.hasAnchor
    }
    length() {
        return this._items.length
    }
    setSource(e, n) {
        this._items[e].source !== n && (this._disposeCaches(),
        this._items[e].setSource(n))
    }
    compile(e) {
        if (!this._cached) {
            let n = this._items.map(r => r.source);
            this._cached = new ew(e,n,this._items.map(r => r.ruleId))
        }
        return this._cached
    }
    compileAG(e, n, r) {
        return this._hasAnchors ? n ? r ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, n, r)),
        this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, n, r)),
        this._anchorCache.A1_G0) : r ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, n, r)),
        this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, n, r)),
        this._anchorCache.A0_G0) : this.compile(e)
    }
    _resolveAnchors(e, n, r) {
        let i = this._items.map(s => s.resolveAnchors(n, r));
        return new ew(e,i,this._items.map(s => s.ruleId))
    }
}
class ew {
    regExps;
    rules;
    scanner;
    constructor(e, n, r) {
        this.regExps = n,
        this.rules = r,
        this.scanner = e.createOnigScanner(n)
    }
    dispose() {
        typeof this.scanner.dispose == "function" && this.scanner.dispose()
    }
    toString() {
        const e = [];
        for (let n = 0, r = this.rules.length; n < r; n++)
            e.push("   - " + this.rules[n] + ": " + this.regExps[n]);
        return e.join(`
`)
    }
    findNextMatchSync(e, n, r) {
        const i = this.scanner.findNextMatchSync(e, n, r);
        return i ? {
            ruleId: this.rules[i.index],
            captureIndices: i.captureIndices
        } : null
    }
}
class tp {
    _colorMap;
    _defaults;
    _root;
    static createFromRawTheme(e, n) {
        return this.createFromParsedTheme(vW(e), n)
    }
    static createFromParsedTheme(e, n) {
        return EW(e, n)
    }
    _cachedMatchRoot = new TI(e => this._root.match(e));
    constructor(e, n, r) {
        this._colorMap = e,
        this._defaults = n,
        this._root = r
    }
    getColorMap() {
        return this._colorMap.getColorMap()
    }
    getDefaults() {
        return this._defaults
    }
    match(e) {
        if (e === null)
            return this._defaults;
        const n = e.scopeName
          , i = this._cachedMatchRoot.get(n).find(s => bW(e.parent, s.parentScopes));
        return i ? new RI(i.fontStyle,i.foreground,i.background) : null
    }
}
class Fo {
    parent;
    scopeName;
    static push(e, n) {
        for (const r of n)
            e = new Fo(e,r);
        return e
    }
    static from(...e) {
        let n = null;
        for (let r = 0; r < e.length; r++)
            n = new Fo(n,e[r]);
        return n
    }
    constructor(e, n) {
        this.parent = e,
        this.scopeName = n
    }
    push(e) {
        return new Fo(this,e)
    }
    getSegments() {
        let e = this;
        const n = [];
        for (; e; )
            n.push(e.scopeName),
            e = e.parent;
        return n.reverse(),
        n
    }
    toString() {
        return this.getSegments().join(" ")
    }
    extends(e) {
        return this === e ? !0 : this.parent === null ? !1 : this.parent.extends(e)
    }
    getExtensionIfDefined(e) {
        const n = [];
        let r = this;
        for (; r && r !== e; )
            n.push(r.scopeName),
            r = r.parent;
        return r === e ? n.reverse() : void 0
    }
}
function bW(t, e) {
    if (e === null)
        return !0;
    let n = 0
      , r = e[n];
    for (; t; ) {
        if (yW(t.scopeName, r)) {
            if (n++,
            n === e.length)
                return !0;
            r = e[n]
        }
        t = t.parent
    }
    return !1
}
function yW(t, e) {
    return e === t || t.startsWith(e) && t[e.length] === "."
}
class RI {
    fontStyle;
    foregroundId;
    backgroundId;
    constructor(e, n, r) {
        this.fontStyle = e,
        this.foregroundId = n,
        this.backgroundId = r
    }
}
function vW(t) {
    if (!t)
        return [];
    if (!t.settings || !Array.isArray(t.settings))
        return [];
    let e = t.settings
      , n = []
      , r = 0;
    for (let i = 0, s = e.length; i < s; i++) {
        let o = e[i];
        if (!o.settings)
            continue;
        let a;
        if (typeof o.scope == "string") {
            let h = o.scope;
            h = h.replace(/^[,]+/, ""),
            h = h.replace(/[,]+$/, ""),
            a = h.split(",")
        } else
            Array.isArray(o.scope) ? a = o.scope : a = [""];
        let l = -1;
        if (typeof o.settings.fontStyle == "string") {
            l = 0;
            let h = o.settings.fontStyle.split(" ");
            for (let d = 0, f = h.length; d < f; d++)
                switch (h[d]) {
                case "italic":
                    l = l | 1;
                    break;
                case "bold":
                    l = l | 2;
                    break;
                case "underline":
                    l = l | 4;
                    break;
                case "strikethrough":
                    l = l | 8;
                    break
                }
        }
        let c = null;
        typeof o.settings.foreground == "string" && QS(o.settings.foreground) && (c = o.settings.foreground);
        let u = null;
        typeof o.settings.background == "string" && QS(o.settings.background) && (u = o.settings.background);
        for (let h = 0, d = a.length; h < d; h++) {
            let g = a[h].trim().split(" ")
              , _ = g[g.length - 1]
              , m = null;
            g.length > 1 && (m = g.slice(0, g.length - 1),
            m.reverse()),
            n[r++] = new xW(_,m,i,l,c,u)
        }
    }
    return n
}
class xW {
    scope;
    parentScopes;
    index;
    fontStyle;
    foreground;
    background;
    constructor(e, n, r, i, s, o) {
        this.scope = e,
        this.parentScopes = n,
        this.index = r,
        this.fontStyle = i,
        this.foreground = s,
        this.background = o
    }
}
function EW(t, e) {
    t.sort( (l, c) => {
        let u = SI(l.scope, c.scope);
        return u !== 0 || (u = wI(l.parentScopes, c.parentScopes),
        u !== 0) ? u : l.index - c.index
    }
    );
    let n = 0
      , r = "#000000"
      , i = "#ffffff";
    for (; t.length >= 1 && t[0].scope === ""; ) {
        let l = t.shift();
        l.fontStyle !== -1 && (n = l.fontStyle),
        l.foreground !== null && (r = l.foreground),
        l.background !== null && (i = l.background)
    }
    let s = new SW(e)
      , o = new RI(n,s.getId(r),s.getId(i))
      , a = new zc(new vu(0,null,-1,0,0),[]);
    for (let l = 0, c = t.length; l < c; l++) {
        let u = t[l];
        a.insert(0, u.scope, u.parentScopes, u.fontStyle, s.getId(u.foreground), s.getId(u.background))
    }
    return new tp(s,o,a)
}
class SW {
    _isFrozen;
    _lastColorId;
    _id2color;
    _color2id;
    constructor(e) {
        if (this._lastColorId = 0,
        this._id2color = [],
        this._color2id = Object.create(null),
        Array.isArray(e)) {
            this._isFrozen = !0;
            for (let n = 0, r = e.length; n < r; n++)
                this._color2id[e[n]] = n,
                this._id2color[n] = e[n]
        } else
            this._isFrozen = !1
    }
    getId(e) {
        if (e === null)
            return 0;
        e = e.toUpperCase();
        let n = this._color2id[e];
        if (n)
            return n;
        if (this._isFrozen)
            throw new Error(`Missing color in color map - ${e}`);
        return n = ++this._lastColorId,
        this._color2id[e] = n,
        this._id2color[n] = e,
        n
    }
    getColorMap() {
        return this._id2color.slice(0)
    }
}
class vu {
    scopeDepth;
    parentScopes;
    fontStyle;
    foreground;
    background;
    constructor(e, n, r, i, s) {
        this.scopeDepth = e,
        this.parentScopes = n,
        this.fontStyle = r,
        this.foreground = i,
        this.background = s
    }
    clone() {
        return new vu(this.scopeDepth,this.parentScopes,this.fontStyle,this.foreground,this.background)
    }
    static cloneArr(e) {
        let n = [];
        for (let r = 0, i = e.length; r < i; r++)
            n[r] = e[r].clone();
        return n
    }
    acceptOverwrite(e, n, r, i) {
        this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e,
        n !== -1 && (this.fontStyle = n),
        r !== 0 && (this.foreground = r),
        i !== 0 && (this.background = i)
    }
}
class zc {
    _mainRule;
    _children;
    _rulesWithParentScopes;
    constructor(e, n=[], r={}) {
        this._mainRule = e,
        this._children = r,
        this._rulesWithParentScopes = n
    }
    static _sortBySpecificity(e) {
        return e.length === 1 || e.sort(this._cmpBySpecificity),
        e
    }
    static _cmpBySpecificity(e, n) {
        if (e.scopeDepth === n.scopeDepth) {
            const r = e.parentScopes
              , i = n.parentScopes;
            let s = r === null ? 0 : r.length
              , o = i === null ? 0 : i.length;
            if (s === o)
                for (let a = 0; a < s; a++) {
                    const l = r[a].length
                      , c = i[a].length;
                    if (l !== c)
                        return c - l
                }
            return o - s
        }
        return n.scopeDepth - e.scopeDepth
    }
    match(e) {
        if (e === "")
            return zc._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
        let n = e.indexOf("."), r, i;
        return n === -1 ? (r = e,
        i = "") : (r = e.substring(0, n),
        i = e.substring(n + 1)),
        this._children.hasOwnProperty(r) ? this._children[r].match(i) : zc._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes))
    }
    insert(e, n, r, i, s, o) {
        if (n === "") {
            this._doInsertHere(e, r, i, s, o);
            return
        }
        let a = n.indexOf("."), l, c;
        a === -1 ? (l = n,
        c = "") : (l = n.substring(0, a),
        c = n.substring(a + 1));
        let u;
        this._children.hasOwnProperty(l) ? u = this._children[l] : (u = new zc(this._mainRule.clone(),vu.cloneArr(this._rulesWithParentScopes)),
        this._children[l] = u),
        u.insert(e + 1, c, r, i, s, o)
    }
    _doInsertHere(e, n, r, i, s) {
        if (n === null) {
            this._mainRule.acceptOverwrite(e, r, i, s);
            return
        }
        for (let o = 0, a = this._rulesWithParentScopes.length; o < a; o++) {
            let l = this._rulesWithParentScopes[o];
            if (wI(l.parentScopes, n) === 0) {
                l.acceptOverwrite(e, r, i, s);
                return
            }
        }
        r === -1 && (r = this._mainRule.fontStyle),
        i === 0 && (i = this._mainRule.foreground),
        s === 0 && (s = this._mainRule.background),
        this._rulesWithParentScopes.push(new vu(e,n,r,i,s))
    }
}
class Jg {
    languageId;
    tokenType;
    constructor(e, n) {
        this.languageId = e,
        this.tokenType = n
    }
}
class np {
    _defaultAttributes;
    _embeddedLanguagesMatcher;
    constructor(e, n) {
        this._defaultAttributes = new Jg(e,8),
        this._embeddedLanguagesMatcher = new wW(Object.entries(n || {}))
    }
    getDefaultAttributes() {
        return this._defaultAttributes
    }
    getBasicScopeAttributes(e) {
        return e === null ? np._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e)
    }
    static _NULL_SCOPE_METADATA = new Jg(0,0);
    _getBasicScopeAttributes = new TI(e => {
        const n = this._scopeToLanguage(e)
          , r = this._toStandardTokenType(e);
        return new Jg(n,r)
    }
    );
    _scopeToLanguage(e) {
        return this._embeddedLanguagesMatcher.match(e) || 0
    }
    _toStandardTokenType(e) {
        const n = e.match(np.STANDARD_TOKEN_TYPE_REGEXP);
        if (!n)
            return 8;
        switch (n[1]) {
        case "comment":
            return 1;
        case "string":
            return 2;
        case "regex":
            return 3;
        case "meta.embedded":
            return 0
        }
        throw new Error("Unexpected match for standard token type!")
    }
    static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/
}
class wW {
    values;
    scopesRegExp;
    constructor(e) {
        if (e.length === 0)
            this.values = null,
            this.scopesRegExp = null;
        else {
            this.values = new Map(e);
            const n = e.map( ([r,i]) => CI(r));
            n.sort(),
            n.reverse(),
            this.scopesRegExp = new RegExp(`^((${n.join(")|(")}))($|\\.)`,"")
        }
    }
    match(e) {
        if (!this.scopesRegExp)
            return;
        const n = e.match(this.scopesRegExp);
        if (n)
            return this.values.get(n[1])
    }
}
class tw {
    stack;
    stoppedEarly;
    constructor(e, n) {
        this.stack = e,
        this.stoppedEarly = n
    }
}
function II(t, e, n, r, i, s, o, a) {
    const l = e.content.length;
    let c = !1
      , u = -1;
    if (o) {
        const f = CW(t, e, n, r, i, s);
        i = f.stack,
        r = f.linePos,
        n = f.isFirstLine,
        u = f.anchorPosition
    }
    const h = Date.now();
    for (; !c; ) {
        if (a !== 0 && Date.now() - h > a)
            return new tw(i,!0);
        d()
    }
    return new tw(i,!1);
    function d() {
        const f = TW(t, e, n, r, i, u);
        if (!f) {
            s.produce(i, l),
            c = !0;
            return
        }
        const g = f.captureIndices
          , _ = f.matchedRuleId
          , m = g && g.length > 0 ? g[0].end > r : !1;
        if (_ === mW) {
            const p = i.getRule(t);
            s.produce(i, g[0].start),
            i = i.withContentNameScopesList(i.nameScopesList),
            Ec(t, e, n, i, s, p.endCaptures, g),
            s.produce(i, g[0].end);
            const b = i;
            if (i = i.parent,
            u = b.getAnchorPos(),
            !m && b.getEnterPos() === r) {
                i = b,
                s.produce(i, l),
                c = !0;
                return
            }
        } else {
            const p = t.getRule(_);
            s.produce(i, g[0].start);
            const b = i
              , y = p.getName(e.content, g)
              , x = i.contentNameScopesList.pushAttributed(y, t);
            if (i = i.push(_, r, u, g[0].end === l, null, x, x),
            p instanceof z_) {
                const E = p;
                Ec(t, e, n, i, s, E.beginCaptures, g),
                s.produce(i, g[0].end),
                u = g[0].end;
                const w = E.getContentName(e.content, g)
                  , A = x.pushAttributed(w, t);
                if (i = i.withContentNameScopesList(A),
                E.endHasBackReferences && (i = i.withEndRule(E.getEndWithResolvedBackReferences(e.content, g))),
                !m && b.hasSameRuleAs(i)) {
                    i = i.pop(),
                    s.produce(i, l),
                    c = !0;
                    return
                }
            } else if (p instanceof ep) {
                const E = p;
                Ec(t, e, n, i, s, E.beginCaptures, g),
                s.produce(i, g[0].end),
                u = g[0].end;
                const w = E.getContentName(e.content, g)
                  , A = x.pushAttributed(w, t);
                if (i = i.withContentNameScopesList(A),
                E.whileHasBackReferences && (i = i.withEndRule(E.getWhileWithResolvedBackReferences(e.content, g))),
                !m && b.hasSameRuleAs(i)) {
                    i = i.pop(),
                    s.produce(i, l),
                    c = !0;
                    return
                }
            } else if (Ec(t, e, n, i, s, p.captures, g),
            s.produce(i, g[0].end),
            i = i.pop(),
            !m) {
                i = i.safePop(),
                s.produce(i, l),
                c = !0;
                return
            }
        }
        g[0].end > r && (r = g[0].end,
        n = !1)
    }
}
function CW(t, e, n, r, i, s) {
    let o = i.beginRuleCapturedEOL ? 0 : -1;
    const a = [];
    for (let l = i; l; l = l.pop()) {
        const c = l.getRule(t);
        c instanceof ep && a.push({
            rule: c,
            stack: l
        })
    }
    for (let l = a.pop(); l; l = a.pop()) {
        const {ruleScanner: c, findOptions: u} = RW(l.rule, t, l.stack.endRule, n, r === o)
          , h = c.findNextMatchSync(e, r, u);
        if (h) {
            if (h.ruleId !== kI) {
                i = l.stack.pop();
                break
            }
            h.captureIndices && h.captureIndices.length && (s.produce(l.stack, h.captureIndices[0].start),
            Ec(t, e, n, l.stack, s, l.rule.whileCaptures, h.captureIndices),
            s.produce(l.stack, h.captureIndices[0].end),
            o = h.captureIndices[0].end,
            h.captureIndices[0].end > r && (r = h.captureIndices[0].end,
            n = !1))
        } else {
            i = l.stack.pop();
            break
        }
    }
    return {
        stack: i,
        linePos: r,
        anchorPosition: o,
        isFirstLine: n
    }
}
function TW(t, e, n, r, i, s) {
    const o = AW(t, e, n, r, i, s)
      , a = t.getInjections();
    if (a.length === 0)
        return o;
    const l = kW(a, t, e, n, r, i, s);
    if (!l)
        return o;
    if (!o)
        return l;
    const c = o.captureIndices[0].start
      , u = l.captureIndices[0].start;
    return u < c || l.priorityMatch && u === c ? l : o
}
function AW(t, e, n, r, i, s) {
    const o = i.getRule(t)
      , {ruleScanner: a, findOptions: l} = PI(o, t, i.endRule, n, r === s)
      , c = a.findNextMatchSync(e, r, l);
    return c ? {
        captureIndices: c.captureIndices,
        matchedRuleId: c.ruleId
    } : null
}
function kW(t, e, n, r, i, s, o) {
    let a = Number.MAX_VALUE, l = null, c, u = 0;
    const h = s.contentNameScopesList.getScopeNames();
    for (let d = 0, f = t.length; d < f; d++) {
        const g = t[d];
        if (!g.matcher(h))
            continue;
        const _ = e.getRule(g.ruleId)
          , {ruleScanner: m, findOptions: p} = PI(_, e, null, r, i === o)
          , b = m.findNextMatchSync(n, i, p);
        if (!b)
            continue;
        const y = b.captureIndices[0].start;
        if (!(y >= a) && (a = y,
        l = b.captureIndices,
        c = b.ruleId,
        u = g.priority,
        a === i))
            break
    }
    return l ? {
        priorityMatch: u === -1,
        captureIndices: l,
        matchedRuleId: c
    } : null
}
function PI(t, e, n, r, i) {
    return {
        ruleScanner: t.compileAG(e, n, r, i),
        findOptions: 0
    }
}
function RW(t, e, n, r, i) {
    return {
        ruleScanner: t.compileWhileAG(e, n, r, i),
        findOptions: 0
    }
}
function Ec(t, e, n, r, i, s, o) {
    if (s.length === 0)
        return;
    const a = e.content
      , l = Math.min(s.length, o.length)
      , c = []
      , u = o[0].end;
    for (let h = 0; h < l; h++) {
        const d = s[h];
        if (d === null)
            continue;
        const f = o[h];
        if (f.length === 0)
            continue;
        if (f.start > u)
            break;
        for (; c.length > 0 && c[c.length - 1].endPos <= f.start; )
            i.produceFromScopes(c[c.length - 1].scopes, c[c.length - 1].endPos),
            c.pop();
        if (c.length > 0 ? i.produceFromScopes(c[c.length - 1].scopes, f.start) : i.produce(r, f.start),
        d.retokenizeCapturedWithRuleId) {
            const _ = d.getName(a, o)
              , m = r.contentNameScopesList.pushAttributed(_, t)
              , p = d.getContentName(a, o)
              , b = m.pushAttributed(p, t)
              , y = r.push(d.retokenizeCapturedWithRuleId, f.start, -1, !1, null, m, b)
              , x = t.createOnigString(a.substring(0, f.end));
            II(t, x, n && f.start === 0, f.start, y, i, !1, 0),
            vI(x);
            continue
        }
        const g = d.getName(a, o);
        if (g !== null) {
            const m = (c.length > 0 ? c[c.length - 1].scopes : r.contentNameScopesList).pushAttributed(g, t);
            c.push(new IW(m,f.end))
        }
    }
    for (; c.length > 0; )
        i.produceFromScopes(c[c.length - 1].scopes, c[c.length - 1].endPos),
        c.pop()
}
class IW {
    scopes;
    endPos;
    constructor(e, n) {
        this.scopes = e,
        this.endPos = n
    }
}
function PW(t, e, n, r, i, s, o, a) {
    return new LW(t,e,n,r,i,s,o,a)
}
function nw(t, e, n, r, i) {
    const s = Jf(e, rp)
      , o = sn.getCompiledRuleId(n, r, i.repository);
    for (const a of s)
        t.push({
            debugSelector: e,
            matcher: a.matcher,
            ruleId: o,
            grammar: i,
            priority: a.priority
        })
}
function rp(t, e) {
    if (e.length < t.length)
        return !1;
    let n = 0;
    return t.every(r => {
        for (let i = n; i < e.length; i++)
            if (DW(e[i], r))
                return n = i + 1,
                !0;
        return !1
    }
    )
}
function DW(t, e) {
    if (!t)
        return !1;
    if (t === e)
        return !0;
    const n = e.length;
    return t.length > n && t.substr(0, n) === e && t[n] === "."
}
class LW {
    _rootScopeName;
    balancedBracketSelectors;
    _onigLib;
    _rootId;
    _lastRuleId;
    _ruleId2desc;
    _includedGrammars;
    _grammarRepository;
    _grammar;
    _injections;
    _basicScopeAttributesProvider;
    _tokenTypeMatchers;
    get themeProvider() {
        return this._grammarRepository
    }
    constructor(e, n, r, i, s, o, a, l) {
        if (this._rootScopeName = e,
        this.balancedBracketSelectors = o,
        this._onigLib = l,
        this._basicScopeAttributesProvider = new np(r,i),
        this._rootId = -1,
        this._lastRuleId = 0,
        this._ruleId2desc = [null],
        this._includedGrammars = {},
        this._grammarRepository = a,
        this._grammar = rw(n, null),
        this._injections = null,
        this._tokenTypeMatchers = [],
        s)
            for (const c of Object.keys(s)) {
                const u = Jf(c, rp);
                for (const h of u)
                    this._tokenTypeMatchers.push({
                        matcher: h.matcher,
                        type: s[c]
                    })
            }
    }
    dispose() {
        for (const e of this._ruleId2desc)
            e && e.dispose()
    }
    createOnigScanner(e) {
        return this._onigLib.createOnigScanner(e)
    }
    createOnigString(e) {
        return this._onigLib.createOnigString(e)
    }
    getMetadataForScope(e) {
        return this._basicScopeAttributesProvider.getBasicScopeAttributes(e)
    }
    _collectInjections() {
        const e = {
            lookup: s => s === this._rootScopeName ? this._grammar : this.getExternalGrammar(s),
            injections: s => this._grammarRepository.injections(s)
        }
          , n = []
          , r = this._rootScopeName
          , i = e.lookup(r);
        if (i) {
            const s = i.injections;
            if (s)
                for (let a in s)
                    nw(n, a, s[a], this, i);
            const o = this._grammarRepository.injections(r);
            o && o.forEach(a => {
                const l = this.getExternalGrammar(a);
                if (l) {
                    const c = l.injectionSelector;
                    c && nw(n, c, l, this, l)
                }
            }
            )
        }
        return n.sort( (s, o) => s.priority - o.priority),
        n
    }
    getInjections() {
        return this._injections === null && (this._injections = this._collectInjections()),
        this._injections
    }
    registerRule(e) {
        const n = ++this._lastRuleId
          , r = e(n);
        return this._ruleId2desc[n] = r,
        r
    }
    getRule(e) {
        return this._ruleId2desc[e]
    }
    getExternalGrammar(e, n) {
        if (this._includedGrammars[e])
            return this._includedGrammars[e];
        if (this._grammarRepository) {
            const r = this._grammarRepository.lookup(e);
            if (r)
                return this._includedGrammars[e] = rw(r, n && n.$base),
                this._includedGrammars[e]
        }
    }
    tokenizeLine(e, n, r=0) {
        const i = this._tokenize(e, n, !1, r);
        return {
            tokens: i.lineTokens.getResult(i.ruleStack, i.lineLength),
            ruleStack: i.ruleStack,
            stoppedEarly: i.stoppedEarly
        }
    }
    tokenizeLine2(e, n, r=0) {
        const i = this._tokenize(e, n, !0, r);
        return {
            tokens: i.lineTokens.getBinaryResult(i.ruleStack, i.lineLength),
            ruleStack: i.ruleStack,
            stoppedEarly: i.stoppedEarly
        }
    }
    _tokenize(e, n, r, i) {
        this._rootId === -1 && (this._rootId = sn.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository),
        this.getInjections());
        let s;
        if (!n || n === pi.NULL) {
            s = !0;
            const u = this._basicScopeAttributesProvider.getDefaultAttributes()
              , h = this.themeProvider.getDefaults()
              , d = Cl.set(0, u.languageId, u.tokenType, null, h.fontStyle, h.foregroundId, h.backgroundId)
              , f = this.getRule(this._rootId).getName(null, null);
            let g;
            f ? g = Bn.createRootAndLookUpScopeName(f, d, this) : g = Bn.createRoot("unknown", d),
            n = new pi(null,this._rootId,-1,-1,!1,null,g,g)
        } else
            s = !1,
            n.reset();
        e = e + `
`;
        const o = this.createOnigString(e)
          , a = o.content.length
          , l = new NW(r,e,this._tokenTypeMatchers,this.balancedBracketSelectors)
          , c = II(this, o, s, 0, n, l, !0, i);
        return vI(o),
        {
            lineLength: a,
            lineTokens: l,
            ruleStack: c.stack,
            stoppedEarly: c.stoppedEarly
        }
    }
}
function rw(t, e) {
    return t = nW(t),
    t.repository = t.repository || {},
    t.repository.$self = {
        $vscodeTextmateLocation: t.$vscodeTextmateLocation,
        patterns: t.patterns,
        name: t.scopeName
    },
    t.repository.$base = e || t.repository.$self,
    t
}
class Bn {
    parent;
    scopePath;
    tokenAttributes;
    static fromExtension(e, n) {
        let r = e
          , i = e?.scopePath ?? null;
        for (const s of n)
            i = Fo.push(i, s.scopeNames),
            r = new Bn(r,i,s.encodedTokenAttributes);
        return r
    }
    static createRoot(e, n) {
        return new Bn(null,new Fo(null,e),n)
    }
    static createRootAndLookUpScopeName(e, n, r) {
        const i = r.getMetadataForScope(e)
          , s = new Fo(null,e)
          , o = r.themeProvider.themeMatch(s)
          , a = Bn.mergeAttributes(n, i, o);
        return new Bn(null,s,a)
    }
    get scopeName() {
        return this.scopePath.scopeName
    }
    constructor(e, n, r) {
        this.parent = e,
        this.scopePath = n,
        this.tokenAttributes = r
    }
    toString() {
        return this.getScopeNames().join(" ")
    }
    equals(e) {
        return Bn.equals(this, e)
    }
    static equals(e, n) {
        do {
            if (e === n || !e && !n)
                return !0;
            if (!e || !n || e.scopeName !== n.scopeName || e.tokenAttributes !== n.tokenAttributes)
                return !1;
            e = e.parent,
            n = n.parent
        } while (!0)
    }
    static mergeAttributes(e, n, r) {
        let i = -1
          , s = 0
          , o = 0;
        return r !== null && (i = r.fontStyle,
        s = r.foregroundId,
        o = r.backgroundId),
        Cl.set(e, n.languageId, n.tokenType, null, i, s, o)
    }
    pushAttributed(e, n) {
        if (e === null)
            return this;
        if (e.indexOf(" ") === -1)
            return Bn._pushAttributed(this, e, n);
        const r = e.split(/ /g);
        let i = this;
        for (const s of r)
            i = Bn._pushAttributed(i, s, n);
        return i
    }
    static _pushAttributed(e, n, r) {
        const i = r.getMetadataForScope(n)
          , s = e.scopePath.push(n)
          , o = r.themeProvider.themeMatch(s)
          , a = Bn.mergeAttributes(e.tokenAttributes, i, o);
        return new Bn(e,s,a)
    }
    getScopeNames() {
        return this.scopePath.getSegments()
    }
    getExtensionIfDefined(e) {
        const n = [];
        let r = this;
        for (; r && r !== e; )
            n.push({
                encodedTokenAttributes: r.tokenAttributes,
                scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
            }),
            r = r.parent;
        return r === e ? n.reverse() : void 0
    }
}
class pi {
    parent;
    ruleId;
    beginRuleCapturedEOL;
    endRule;
    nameScopesList;
    contentNameScopesList;
    _stackElementBrand = void 0;
    static NULL = new pi(null,0,0,0,!1,null,null,null);
    _enterPos;
    _anchorPos;
    depth;
    constructor(e, n, r, i, s, o, a, l) {
        this.parent = e,
        this.ruleId = n,
        this.beginRuleCapturedEOL = s,
        this.endRule = o,
        this.nameScopesList = a,
        this.contentNameScopesList = l,
        this.depth = this.parent ? this.parent.depth + 1 : 1,
        this._enterPos = r,
        this._anchorPos = i
    }
    equals(e) {
        return e === null ? !1 : pi._equals(this, e)
    }
    static _equals(e, n) {
        return e === n ? !0 : this._structuralEquals(e, n) ? Bn.equals(e.contentNameScopesList, n.contentNameScopesList) : !1
    }
    static _structuralEquals(e, n) {
        do {
            if (e === n || !e && !n)
                return !0;
            if (!e || !n || e.depth !== n.depth || e.ruleId !== n.ruleId || e.endRule !== n.endRule)
                return !1;
            e = e.parent,
            n = n.parent
        } while (!0)
    }
    clone() {
        return this
    }
    static _reset(e) {
        for (; e; )
            e._enterPos = -1,
            e._anchorPos = -1,
            e = e.parent
    }
    reset() {
        pi._reset(this)
    }
    pop() {
        return this.parent
    }
    safePop() {
        return this.parent ? this.parent : this
    }
    push(e, n, r, i, s, o, a) {
        return new pi(this,e,n,r,i,s,o,a)
    }
    getEnterPos() {
        return this._enterPos
    }
    getAnchorPos() {
        return this._anchorPos
    }
    getRule(e) {
        return e.getRule(this.ruleId)
    }
    toString() {
        const e = [];
        return this._writeString(e, 0),
        "[" + e.join(",") + "]"
    }
    _writeString(e, n) {
        return this.parent && (n = this.parent._writeString(e, n)),
        e[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`,
        n
    }
    withContentNameScopesList(e) {
        return this.contentNameScopesList === e ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, e)
    }
    withEndRule(e) {
        return this.endRule === e ? this : new pi(this.parent,this.ruleId,this._enterPos,this._anchorPos,this.beginRuleCapturedEOL,e,this.nameScopesList,this.contentNameScopesList)
    }
    hasSameRuleAs(e) {
        let n = this;
        for (; n && n._enterPos === e._enterPos; ) {
            if (n.ruleId === e.ruleId)
                return !0;
            n = n.parent
        }
        return !1
    }
    toStateStackFrame() {
        return {
            ruleId: this.ruleId,
            beginRuleCapturedEOL: this.beginRuleCapturedEOL,
            endRule: this.endRule,
            nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
            contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
        }
    }
    static pushFrame(e, n) {
        const r = Bn.fromExtension(e?.nameScopesList ?? null, n.nameScopesList);
        return new pi(e,n.ruleId,n.enterPos ?? -1,n.anchorPos ?? -1,n.beginRuleCapturedEOL,n.endRule,r,Bn.fromExtension(r, n.contentNameScopesList))
    }
}
class OW {
    balancedBracketScopes;
    unbalancedBracketScopes;
    allowAny = !1;
    constructor(e, n) {
        this.balancedBracketScopes = e.flatMap(r => r === "*" ? (this.allowAny = !0,
        []) : Jf(r, rp).map(i => i.matcher)),
        this.unbalancedBracketScopes = n.flatMap(r => Jf(r, rp).map(i => i.matcher))
    }
    get matchesAlways() {
        return this.allowAny && this.unbalancedBracketScopes.length === 0
    }
    get matchesNever() {
        return this.balancedBracketScopes.length === 0 && !this.allowAny
    }
    match(e) {
        for (const n of this.unbalancedBracketScopes)
            if (n(e))
                return !1;
        for (const n of this.balancedBracketScopes)
            if (n(e))
                return !0;
        return this.allowAny
    }
}
class NW {
    balancedBracketSelectors;
    _emitBinaryTokens;
    _lineText;
    _tokens;
    _binaryTokens;
    _lastTokenEndIndex;
    _tokenTypeOverrides;
    constructor(e, n, r, i) {
        this.balancedBracketSelectors = i,
        this._emitBinaryTokens = e,
        this._tokenTypeOverrides = r,
        this._lineText = null,
        this._tokens = [],
        this._binaryTokens = [],
        this._lastTokenEndIndex = 0
    }
    produce(e, n) {
        this.produceFromScopes(e.contentNameScopesList, n)
    }
    produceFromScopes(e, n) {
        if (this._lastTokenEndIndex >= n)
            return;
        if (this._emitBinaryTokens) {
            let i = e?.tokenAttributes ?? 0
              , s = !1;
            if (this.balancedBracketSelectors?.matchesAlways && (s = !0),
            this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
                const o = e?.getScopeNames() ?? [];
                for (const a of this._tokenTypeOverrides)
                    a.matcher(o) && (i = Cl.set(i, 0, a.type, null, -1, 0, 0));
                this.balancedBracketSelectors && (s = this.balancedBracketSelectors.match(o))
            }
            if (s && (i = Cl.set(i, 0, 8, s, -1, 0, 0)),
            this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === i) {
                this._lastTokenEndIndex = n;
                return
            }
            this._binaryTokens.push(this._lastTokenEndIndex),
            this._binaryTokens.push(i),
            this._lastTokenEndIndex = n;
            return
        }
        const r = e?.getScopeNames() ?? [];
        this._tokens.push({
            startIndex: this._lastTokenEndIndex,
            endIndex: n,
            scopes: r
        }),
        this._lastTokenEndIndex = n
    }
    getResult(e, n) {
        return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === n - 1 && this._tokens.pop(),
        this._tokens.length === 0 && (this._lastTokenEndIndex = -1,
        this.produce(e, n),
        this._tokens[this._tokens.length - 1].startIndex = 0),
        this._tokens
    }
    getBinaryResult(e, n) {
        this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === n - 1 && (this._binaryTokens.pop(),
        this._binaryTokens.pop()),
        this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1,
        this.produce(e, n),
        this._binaryTokens[this._binaryTokens.length - 2] = 0);
        const r = new Uint32Array(this._binaryTokens.length);
        for (let i = 0, s = this._binaryTokens.length; i < s; i++)
            r[i] = this._binaryTokens[i];
        return r
    }
}
class MW {
    _onigLibPromise;
    _grammars = new Map;
    _rawGrammars = new Map;
    _injectionGrammars = new Map;
    _theme;
    constructor(e, n) {
        this._onigLibPromise = n,
        this._theme = e
    }
    dispose() {
        for (const e of this._grammars.values())
            e.dispose()
    }
    setTheme(e) {
        this._theme = e
    }
    getColorMap() {
        return this._theme.getColorMap()
    }
    addGrammar(e, n) {
        this._rawGrammars.set(e.scopeName, e),
        n && this._injectionGrammars.set(e.scopeName, n)
    }
    lookup(e) {
        return this._rawGrammars.get(e)
    }
    injections(e) {
        return this._injectionGrammars.get(e)
    }
    getDefaults() {
        return this._theme.getDefaults()
    }
    themeMatch(e) {
        return this._theme.match(e)
    }
    async grammarForScopeName(e, n, r, i, s) {
        if (!this._grammars.has(e)) {
            let o = this._rawGrammars.get(e);
            if (!o)
                return null;
            this._grammars.set(e, PW(e, o, n, r, i, s, this, await this._onigLibPromise))
        }
        return this._grammars.get(e)
    }
}
let BW = class {
    _options;
    _syncRegistry;
    _ensureGrammarCache;
    constructor(e) {
        this._options = e,
        this._syncRegistry = new MW(tp.createFromRawTheme(e.theme, e.colorMap),e.onigLib),
        this._ensureGrammarCache = new Map
    }
    dispose() {
        this._syncRegistry.dispose()
    }
    setTheme(e, n) {
        this._syncRegistry.setTheme(tp.createFromRawTheme(e, n))
    }
    getColorMap() {
        return this._syncRegistry.getColorMap()
    }
    loadGrammarWithEmbeddedLanguages(e, n, r) {
        return this.loadGrammarWithConfiguration(e, n, {
            embeddedLanguages: r
        })
    }
    loadGrammarWithConfiguration(e, n, r) {
        return this._loadGrammar(e, n, r.embeddedLanguages, r.tokenTypes, new OW(r.balancedBracketSelectors || [],r.unbalancedBracketSelectors || []))
    }
    loadGrammar(e) {
        return this._loadGrammar(e, 0, null, null, null)
    }
    async _loadGrammar(e, n, r, i, s) {
        const o = new aW(this._syncRegistry,e);
        for (; o.Q.length > 0; )
            await Promise.all(o.Q.map(a => this._loadSingleGrammar(a.scopeName))),
            o.processQueue();
        return this._grammarForScopeName(e, n, r, i, s)
    }
    async _loadSingleGrammar(e) {
        return this._ensureGrammarCache.has(e) || this._ensureGrammarCache.set(e, this._doLoadSingleGrammar(e)),
        this._ensureGrammarCache.get(e)
    }
    async _doLoadSingleGrammar(e) {
        const n = await this._options.loadGrammar(e);
        if (n) {
            const r = typeof this._options.getInjections == "function" ? this._options.getInjections(e) : void 0;
            this._syncRegistry.addGrammar(n, r)
        }
    }
    async addGrammar(e, n=[], r=0, i=null) {
        return this._syncRegistry.addGrammar(e, n),
        await this._grammarForScopeName(e.scopeName, r, i)
    }
    _grammarForScopeName(e, n=0, r=null, i=null, s=null) {
        return this._syncRegistry.grammarForScopeName(e, n, r, i, s)
    }
}
;
const FW = pi.NULL
  , dn = {
    LANGUAGEID_MASK: 255,
    TOKEN_TYPE_MASK: 768,
    BALANCED_BRACKETS_MASK: 1024,
    FONT_STYLE_MASK: 14336,
    FOREGROUND_MASK: 8372224,
    BACKGROUND_MASK: 4286578688,
    LANGUAGEID_OFFSET: 0,
    TOKEN_TYPE_OFFSET: 8,
    BALANCED_BRACKETS_OFFSET: 10,
    FONT_STYLE_OFFSET: 11,
    FOREGROUND_OFFSET: 15,
    BACKGROUND_OFFSET: 24
};
class Hi {
    static toBinaryStr(e) {
        let n = e.toString(2);
        for (; n.length < 32; )
            n = `0${n}`;
        return n
    }
    static getLanguageId(e) {
        return (e & dn.LANGUAGEID_MASK) >>> dn.LANGUAGEID_OFFSET
    }
    static getTokenType(e) {
        return (e & dn.TOKEN_TYPE_MASK) >>> dn.TOKEN_TYPE_OFFSET
    }
    static getFontStyle(e) {
        return (e & dn.FONT_STYLE_MASK) >>> dn.FONT_STYLE_OFFSET
    }
    static getForeground(e) {
        return (e & dn.FOREGROUND_MASK) >>> dn.FOREGROUND_OFFSET
    }
    static getBackground(e) {
        return (e & dn.BACKGROUND_MASK) >>> dn.BACKGROUND_OFFSET
    }
    static containsBalancedBrackets(e) {
        return (e & dn.BALANCED_BRACKETS_MASK) !== 0
    }
    static set(e, n, r, i, s, o) {
        let a = Hi.getLanguageId(e)
          , l = Hi.getTokenType(e)
          , c = Hi.getFontStyle(e)
          , u = Hi.getForeground(e)
          , h = Hi.getBackground(e);
        const d = Hi.containsBalancedBrackets(e) ? 1 : 0;
        return n !== 0 && (a = n),
        r !== 0 && (l = r === 8 ? 0 : r),
        i !== Gr.NotSet && (c = i),
        s !== 0 && (u = s),
        o !== 0 && (h = o),
        (a << dn.LANGUAGEID_OFFSET | l << dn.TOKEN_TYPE_OFFSET | c << dn.FONT_STYLE_OFFSET | d << dn.BALANCED_BRACKETS_OFFSET | u << dn.FOREGROUND_OFFSET | h << dn.BACKGROUND_OFFSET) >>> 0
    }
}
function Om(t, e=!1) {
    const n = t.split(/(\r?\n)/g);
    let r = 0;
    const i = [];
    for (let s = 0; s < n.length; s += 2) {
        const o = e ? n[s] + (n[s + 1] || "") : n[s];
        i.push([o, r]),
        r += n[s].length,
        r += n[s + 1]?.length || 0
    }
    return i
}
function DI(t) {
    return !t || ["plaintext", "txt", "text", "plain"].includes(t)
}
function jv(t) {
    return t === "ansi" || DI(t)
}
function LI(t) {
    return t === "none"
}
function OI(t) {
    return LI(t)
}
function NI(t, e) {
    if (!e)
        return t;
    t.properties ||= {},
    t.properties.class ||= [],
    typeof t.properties.class == "string" && (t.properties.class = t.properties.class.split(/\s+/g)),
    Array.isArray(t.properties.class) || (t.properties.class = []);
    const n = Array.isArray(e) ? e : e.split(/\s+/g);
    for (const r of n)
        r && !t.properties.class.includes(r) && t.properties.class.push(r);
    return t
}
function jW(t, e) {
    let n = 0;
    const r = [];
    for (const i of e)
        i > n && r.push({
            ...t,
            content: t.content.slice(n, i),
            offset: t.offset + n
        }),
        n = i;
    return n < t.content.length && r.push({
        ...t,
        content: t.content.slice(n),
        offset: t.offset + n
    }),
    r
}
function HW(t, e) {
    const n = Array.from(e instanceof Set ? e : new Set(e)).sort( (r, i) => r - i);
    return n.length ? t.map(r => r.flatMap(i => {
        const s = n.filter(o => i.offset < o && o < i.offset + i.content.length).map(o => o - i.offset).sort( (o, a) => o - a);
        return s.length ? jW(i, s) : i
    }
    )) : t
}
function ip(t, e) {
    const n = typeof t == "string" ? {} : {
        ...t.colorReplacements
    }
      , r = typeof t == "string" ? t : t.name;
    for (const [i,s] of Object.entries(e?.colorReplacements || {}))
        typeof s == "string" ? n[i] = s : i === r && Object.assign(n, s);
    return n
}
function Ao(t, e) {
    return t && (e?.[t?.toLowerCase()] || t)
}
function MI(t) {
    const e = {};
    return t.color && (e.color = t.color),
    t.bgColor && (e["background-color"] = t.bgColor),
    t.fontStyle && (t.fontStyle & Gr.Italic && (e["font-style"] = "italic"),
    t.fontStyle & Gr.Bold && (e["font-weight"] = "bold"),
    t.fontStyle & Gr.Underline && (e["text-decoration"] = "underline")),
    e
}
function BI(t) {
    return Object.entries(t).map( ([e,n]) => `${e}:${n}`).join(";")
}
function UW(t) {
    const e = Om(t, !0).map( ([i]) => i);
    function n(i) {
        let s = i
          , o = 0;
        for (const a of e) {
            if (s < a.length)
                break;
            s -= a.length,
            o++
        }
        return {
            line: o,
            character: s
        }
    }
    function r(i, s) {
        let o = 0;
        for (let a = 0; a < i; a++)
            o += e[a].length;
        return o += s,
        o
    }
    return {
        lines: e,
        indexToPos: n,
        posToIndex: r
    }
}
var ko = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "brightBlack", "brightRed", "brightGreen", "brightYellow", "brightBlue", "brightMagenta", "brightCyan", "brightWhite"]
  , Zg = {
    1: "bold",
    2: "dim",
    3: "italic",
    4: "underline",
    7: "reverse",
    9: "strikethrough"
};
function VW(t, e) {
    const n = t.indexOf("\x1B[", e);
    if (n !== -1) {
        const r = t.indexOf("m", n);
        return {
            sequence: t.substring(n + 2, r).split(";"),
            startPosition: n,
            position: r + 1
        }
    }
    return {
        position: t.length
    }
}
function iw(t, e) {
    let n = 1;
    const r = t[e + n++];
    let i;
    if (r === "2") {
        const s = [t[e + n++], t[e + n++], t[e + n]].map(o => Number.parseInt(o));
        s.length === 3 && !s.some(o => Number.isNaN(o)) && (i = {
            type: "rgb",
            rgb: s
        })
    } else if (r === "5") {
        const s = Number.parseInt(t[e + n]);
        Number.isNaN(s) || (i = {
            type: "table",
            index: Number(s)
        })
    }
    return [n, i]
}
function $W(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n]
          , i = Number.parseInt(r);
        if (!Number.isNaN(i))
            if (i === 0)
                e.push({
                    type: "resetAll"
                });
            else if (i <= 9)
                Zg[i] && e.push({
                    type: "setDecoration",
                    value: Zg[i]
                });
            else if (i <= 29) {
                const s = Zg[i - 20];
                s && e.push({
                    type: "resetDecoration",
                    value: s
                })
            } else if (i <= 37)
                e.push({
                    type: "setForegroundColor",
                    value: {
                        type: "named",
                        name: ko[i - 30]
                    }
                });
            else if (i === 38) {
                const [s,o] = iw(t, n);
                o && e.push({
                    type: "setForegroundColor",
                    value: o
                }),
                n += s
            } else if (i === 39)
                e.push({
                    type: "resetForegroundColor"
                });
            else if (i <= 47)
                e.push({
                    type: "setBackgroundColor",
                    value: {
                        type: "named",
                        name: ko[i - 40]
                    }
                });
            else if (i === 48) {
                const [s,o] = iw(t, n);
                o && e.push({
                    type: "setBackgroundColor",
                    value: o
                }),
                n += s
            } else
                i === 49 ? e.push({
                    type: "resetBackgroundColor"
                }) : i >= 90 && i <= 97 ? e.push({
                    type: "setForegroundColor",
                    value: {
                        type: "named",
                        name: ko[i - 90 + 8]
                    }
                }) : i >= 100 && i <= 107 && e.push({
                    type: "setBackgroundColor",
                    value: {
                        type: "named",
                        name: ko[i - 100 + 8]
                    }
                })
    }
    return e
}
function zW() {
    let t = null
      , e = null
      , n = new Set;
    return {
        parse(r) {
            const i = [];
            let s = 0;
            do {
                const o = VW(r, s)
                  , a = o.sequence ? r.substring(s, o.startPosition) : r.substring(s);
                if (a.length > 0 && i.push({
                    value: a,
                    foreground: t,
                    background: e,
                    decorations: new Set(n)
                }),
                o.sequence) {
                    const l = $W(o.sequence);
                    for (const c of l)
                        c.type === "resetAll" ? (t = null,
                        e = null,
                        n.clear()) : c.type === "resetForegroundColor" ? t = null : c.type === "resetBackgroundColor" ? e = null : c.type === "resetDecoration" && n.delete(c.value);
                    for (const c of l)
                        c.type === "setForegroundColor" ? t = c.value : c.type === "setBackgroundColor" ? e = c.value : c.type === "setDecoration" && n.add(c.value)
                }
                s = o.position
            } while (s < r.length);
            return i
        }
    }
}
var WW = {
    black: "#000000",
    red: "#bb0000",
    green: "#00bb00",
    yellow: "#bbbb00",
    blue: "#0000bb",
    magenta: "#ff00ff",
    cyan: "#00bbbb",
    white: "#eeeeee",
    brightBlack: "#555555",
    brightRed: "#ff5555",
    brightGreen: "#00ff00",
    brightYellow: "#ffff55",
    brightBlue: "#5555ff",
    brightMagenta: "#ff55ff",
    brightCyan: "#55ffff",
    brightWhite: "#ffffff"
};
function GW(t=WW) {
    function e(a) {
        return t[a]
    }
    function n(a) {
        return `#${a.map(l => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`
    }
    let r;
    function i() {
        if (r)
            return r;
        r = [];
        for (let c = 0; c < ko.length; c++)
            r.push(e(ko[c]));
        let a = [0, 95, 135, 175, 215, 255];
        for (let c = 0; c < 6; c++)
            for (let u = 0; u < 6; u++)
                for (let h = 0; h < 6; h++)
                    r.push(n([a[c], a[u], a[h]]));
        let l = 8;
        for (let c = 0; c < 24; c++,
        l += 10)
            r.push(n([l, l, l]));
        return r
    }
    function s(a) {
        return i()[a]
    }
    function o(a) {
        switch (a.type) {
        case "named":
            return e(a.name);
        case "rgb":
            return n(a.rgb);
        case "table":
            return s(a.index)
        }
    }
    return {
        value: o
    }
}
function qW(t, e, n) {
    const r = ip(t, n)
      , i = Om(e)
      , s = GW(Object.fromEntries(ko.map(a => [a, t.colors?.[`terminal.ansi${a[0].toUpperCase()}${a.substring(1)}`]])))
      , o = zW();
    return i.map(a => o.parse(a[0]).map(l => {
        let c, u;
        l.decorations.has("reverse") ? (c = l.background ? s.value(l.background) : t.bg,
        u = l.foreground ? s.value(l.foreground) : t.fg) : (c = l.foreground ? s.value(l.foreground) : t.fg,
        u = l.background ? s.value(l.background) : void 0),
        c = Ao(c, r),
        u = Ao(u, r),
        l.decorations.has("dim") && (c = KW(c));
        let h = Gr.None;
        return l.decorations.has("bold") && (h |= Gr.Bold),
        l.decorations.has("italic") && (h |= Gr.Italic),
        l.decorations.has("underline") && (h |= Gr.Underline),
        {
            content: l.value,
            offset: a[1],
            color: c,
            bgColor: u,
            fontStyle: h
        }
    }
    ))
}
function KW(t) {
    const e = t.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
    if (e)
        if (e[3]) {
            const r = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
            return `#${e[1]}${e[2]}${r}`
        } else
            return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map(r => `${r}${r}`).join("")}80`;
    const n = t.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
    return n ? `var(${n[1]}-dim)` : t
}
function Hv(t, e, n={}) {
    const {lang: r="text", theme: i=t.getLoadedThemes()[0]} = n;
    if (DI(r) || LI(i))
        return Om(e).map(l => [{
            content: l[0],
            offset: l[1]
        }]);
    const {theme: s, colorMap: o} = t.setTheme(i);
    if (r === "ansi")
        return qW(s, e, n);
    const a = t.getLanguage(r);
    return YW(e, a, s, o, n)
}
function YW(t, e, n, r, i) {
    const s = ip(n, i)
      , {tokenizeMaxLineLength: o=0, tokenizeTimeLimit: a=500} = i
      , l = Om(t);
    let c = FW
      , u = [];
    const h = []
      , d = [];
    if (i.includeExplanation)
        for (const f of n.settings) {
            let g;
            switch (typeof f.scope) {
            case "string":
                g = f.scope.split(/,/).map(_ => _.trim());
                break;
            case "object":
                g = f.scope;
                break;
            default:
                continue
            }
            d.push({
                settings: f,
                selectors: g.map(_ => _.split(/ /))
            })
        }
    for (let f = 0, g = l.length; f < g; f++) {
        const [_,m] = l[f];
        if (_ === "") {
            u = [],
            h.push([]);
            continue
        }
        if (o > 0 && _.length >= o) {
            u = [],
            h.push([{
                content: _,
                offset: m,
                color: "",
                fontStyle: 0
            }]);
            continue
        }
        let p, b, y;
        i.includeExplanation && (p = e.tokenizeLine(_, c),
        b = p.tokens,
        y = 0);
        const x = e.tokenizeLine2(_, c, a)
          , E = x.tokens.length / 2;
        for (let w = 0; w < E; w++) {
            const A = x.tokens[2 * w]
              , C = w + 1 < E ? x.tokens[2 * w + 2] : _.length;
            if (A === C)
                continue;
            const k = x.tokens[2 * w + 1]
              , I = Ao(r[Hi.getForeground(k)], s)
              , N = Hi.getFontStyle(k)
              , O = {
                content: _.substring(A, C),
                offset: m + A,
                color: I,
                fontStyle: N
            };
            if (i.includeExplanation) {
                O.explanation = [];
                let M = 0;
                for (; A + M < C; ) {
                    const H = b[y]
                      , $ = _.substring(H.startIndex, H.endIndex);
                    M += $.length,
                    O.explanation.push({
                        content: $,
                        scopes: XW(d, H.scopes)
                    }),
                    y += 1
                }
            }
            u.push(O)
        }
        h.push(u),
        u = [],
        c = x.ruleStack
    }
    return h
}
function XW(t, e) {
    const n = [];
    for (let r = 0, i = e.length; r < i; r++) {
        const s = e.slice(0, r)
          , o = e[r];
        n[r] = {
            scopeName: o,
            themeMatches: JW(t, o, s)
        }
    }
    return n
}
function sw(t, e) {
    return t === e || e.substring(0, t.length) === t && e[t.length] === "."
}
function QW(t, e, n) {
    if (!sw(t[t.length - 1], e))
        return !1;
    let r = t.length - 2
      , i = n.length - 1;
    for (; r >= 0 && i >= 0; )
        sw(t[r], n[i]) && (r -= 1),
        i -= 1;
    return r === -1
}
function JW(t, e, n) {
    const r = [];
    for (const {selectors: i, settings: s} of t)
        for (const o of i)
            if (QW(o, e, n)) {
                r.push(s);
                break
            }
    return r
}
function FI(t, e, n) {
    const r = Object.entries(n.themes).filter(o => o[1]).map(o => ({
        color: o[0],
        theme: o[1]
    }))
      , i = ZW(...r.map(o => Hv(t, e, {
        ...n,
        theme: o.theme
    })));
    return i[0].map( (o, a) => o.map( (l, c) => {
        const u = {
            content: l.content,
            variants: {},
            offset: l.offset
        };
        return i.forEach( (h, d) => {
            const {content: f, explanation: g, offset: _, ...m} = h[a][c];
            u.variants[r[d].color] = m
        }
        ),
        u
    }
    ))
}
function ZW(...t) {
    const e = t.map( () => [])
      , n = t.length;
    for (let r = 0; r < t[0].length; r++) {
        const i = t.map(l => l[r])
          , s = e.map( () => []);
        e.forEach( (l, c) => l.push(s[c]));
        const o = i.map( () => 0)
          , a = i.map(l => l[0]);
        for (; a.every(l => l); ) {
            const l = Math.min(...a.map(c => c.content.length));
            for (let c = 0; c < n; c++) {
                const u = a[c];
                u.content.length === l ? (s[c].push(u),
                o[c] += 1,
                a[c] = i[c][o[c]]) : (s[c].push({
                    ...u,
                    content: u.content.slice(0, l)
                }),
                a[c] = {
                    ...u,
                    content: u.content.slice(l),
                    offset: u.offset + l
                })
            }
        }
    }
    return e
}
class ln extends Error {
    constructor(e) {
        super(e),
        this.name = "ShikiError"
    }
}
function sp(t, e, n) {
    let r, i, s, o, a;
    if ("themes"in n) {
        const {defaultColor: l="light", cssVariablePrefix: c="--shiki-"} = n
          , u = Object.entries(n.themes).filter(_ => _[1]).map(_ => ({
            color: _[0],
            theme: _[1]
        })).sort( (_, m) => _.color === l ? -1 : m.color === l ? 1 : 0);
        if (u.length === 0)
            throw new ln("`themes` option must not be empty");
        const h = FI(t, e, n);
        if (l && !u.find(_ => _.color === l))
            throw new ln(`\`themes\` option must contain the defaultColor key \`${l}\``);
        const d = u.map(_ => t.getTheme(_.theme))
          , f = u.map(_ => _.color);
        s = h.map(_ => _.map(m => eG(m, f, c, l)));
        const g = u.map(_ => ip(_.theme, n));
        i = u.map( (_, m) => (m === 0 && l ? "" : `${c + _.color}:`) + (Ao(d[m].fg, g[m]) || "inherit")).join(";"),
        r = u.map( (_, m) => (m === 0 && l ? "" : `${c + _.color}-bg:`) + (Ao(d[m].bg, g[m]) || "inherit")).join(";"),
        o = `shiki-themes ${d.map(_ => _.name).join(" ")}`,
        a = l ? void 0 : [i, r].join(";")
    } else if ("theme"in n) {
        const l = ip(n.theme, n.colorReplacements);
        s = Hv(t, e, n);
        const c = t.getTheme(n.theme);
        r = Ao(c.bg, l),
        i = Ao(c.fg, l),
        o = c.name
    } else
        throw new ln("Invalid options, either `theme` or `themes` must be provided");
    return {
        tokens: s,
        fg: i,
        bg: r,
        themeName: o,
        rootStyle: a
    }
}
function eG(t, e, n, r) {
    const i = {
        content: t.content,
        explanation: t.explanation,
        offset: t.offset
    }
      , s = e.map(l => MI(t.variants[l]))
      , o = new Set(s.flatMap(l => Object.keys(l)))
      , a = s.reduce( (l, c, u) => {
        for (const h of o) {
            const d = c[h] || "inherit";
            if (u === 0 && r)
                l[h] = d;
            else {
                const f = h === "color" ? "" : h === "background-color" ? "-bg" : `-${h}`
                  , g = n + e[u] + (h === "color" ? "" : f);
                l[h] ? l[h] += `;${g}:${d}` : l[h] = `${g}:${d}`
            }
        }
        return l
    }
    , {});
    return i.htmlStyle = r ? BI(a) : Object.values(a).join(";"),
    i
}
function tG() {
    const t = new WeakMap;
    function e(r) {
        if (!t.has(r.meta)) {
            let s = function(a) {
                return typeof a == "number" ? {
                    ...i.indexToPos(a),
                    offset: a
                } : {
                    ...a,
                    offset: i.posToIndex(a.line, a.character)
                }
            };
            const i = UW(r.source)
              , o = (r.options.decorations || []).map(a => ({
                ...a,
                start: s(a.start),
                end: s(a.end)
            }));
            n(o),
            t.set(r.meta, {
                decorations: o,
                converter: i,
                source: r.source
            })
        }
        return t.get(r.meta)
    }
    function n(r) {
        for (let i = 0; i < r.length; i++) {
            const s = r[i];
            if (s.start.offset > s.end.offset)
                throw new ln(`Invalid decoration range: ${JSON.stringify(s.start)} - ${JSON.stringify(s.end)}`);
            for (let o = i + 1; o < r.length; o++) {
                const a = r[o]
                  , l = s.start.offset < a.start.offset && a.start.offset < s.end.offset
                  , c = s.start.offset < a.end.offset && a.end.offset < s.end.offset
                  , u = a.start.offset < s.start.offset && s.start.offset < a.end.offset
                  , h = a.start.offset < s.end.offset && s.end.offset < a.end.offset;
                if (l || c || u || h) {
                    if (c && c || u && h)
                        continue;
                    throw new ln(`Decorations ${JSON.stringify(s.start)} and ${JSON.stringify(a.start)} intersect.`)
                }
            }
        }
    }
    return {
        name: "shiki:decorations",
        tokens(r) {
            if (!this.options.decorations?.length)
                return;
            const s = e(this).decorations.flatMap(a => [a.start.offset, a.end.offset]);
            return HW(r, s)
        },
        code(r) {
            if (!this.options.decorations?.length)
                return;
            const i = e(this)
              , s = Array.from(r.children).filter(h => h.type === "element" && h.tagName === "span");
            if (s.length !== i.converter.lines.length)
                throw new ln(`Number of lines in code element (${s.length}) does not match the number of lines in the source (${i.converter.lines.length}). Failed to apply decorations.`);
            function o(h, d, f, g) {
                const _ = s[h];
                let m = ""
                  , p = -1
                  , b = -1;
                function y(E) {
                    return E.type === "text" ? E.value : E.type === "element" ? E.children.map(y).join("") : ""
                }
                if (d === 0 && (p = 0),
                f === 0 && (b = 0),
                f === Number.POSITIVE_INFINITY && (b = _.children.length),
                p === -1 || b === -1)
                    for (let E = 0; E < _.children.length; E++)
                        m += y(_.children[E]),
                        p === -1 && m.length === d && (p = E + 1),
                        b === -1 && m.length === f && (b = E + 1);
                if (p === -1)
                    throw new ln(`Failed to find start index for decoration ${JSON.stringify(g.start)}`);
                if (b === -1)
                    throw new ln(`Failed to find end index for decoration ${JSON.stringify(g.end)}`);
                const x = _.children.slice(p, b);
                if (!g.alwaysWrap && x.length === _.children.length)
                    l(_, g, "line");
                else if (!g.alwaysWrap && x.length === 1 && x[0].type === "element")
                    l(x[0], g, "token");
                else {
                    const E = {
                        type: "element",
                        tagName: "span",
                        properties: {},
                        children: x
                    };
                    l(E, g, "wrapper"),
                    _.children.splice(p, x.length, E)
                }
            }
            function a(h, d) {
                s[h] = l(s[h], d, "line")
            }
            function l(h, d, f) {
                const g = d.properties || {}
                  , _ = d.transform || (m => m);
                return h.tagName = d.tagName || "span",
                h.properties = {
                    ...h.properties,
                    ...g,
                    class: h.properties.class
                },
                d.properties?.class && NI(h, d.properties.class),
                h = _(h, f) || h,
                h
            }
            const c = []
              , u = i.decorations.sort( (h, d) => d.start.offset - h.start.offset);
            for (const h of u) {
                const {start: d, end: f} = h;
                if (d.line === f.line)
                    o(d.line, d.character, f.character, h);
                else if (d.line < f.line) {
                    o(d.line, d.character, Number.POSITIVE_INFINITY, h);
                    for (let g = d.line + 1; g < f.line; g++)
                        c.unshift( () => a(g, h));
                    o(f.line, 0, f.character, h)
                }
            }
            c.forEach(h => h())
        }
    }
}
const nG = [tG()];
function op(t) {
    return [...t.transformers || [], ...nG]
}
function ap(t, e, n, r={
    meta: {},
    options: n,
    codeToHast: (i, s) => ap(t, i, s),
    codeToTokens: (i, s) => sp(t, i, s)
}) {
    let i = e;
    for (const d of op(n))
        i = d.preprocess?.call(r, i, n) || i;
    let {tokens: s, fg: o, bg: a, themeName: l, rootStyle: c} = sp(t, i, n);
    const {mergeWhitespaces: u=!0} = n;
    u === !0 ? s = iG(s) : u === "never" && (s = sG(s));
    const h = {
        ...r,
        get source() {
            return i
        }
    };
    for (const d of op(n))
        s = d.tokens?.call(h, s) || s;
    return rG(s, {
        ...n,
        fg: o,
        bg: a,
        themeName: l,
        rootStyle: c
    }, h)
}
function rG(t, e, n) {
    const r = op(e)
      , i = []
      , s = {
        type: "root",
        children: []
    }
      , {structure: o="classic"} = e;
    let a = {
        type: "element",
        tagName: "pre",
        properties: {
            class: `shiki ${e.themeName || ""}`,
            style: e.rootStyle || `background-color:${e.bg};color:${e.fg}`,
            tabindex: "0",
            ...Object.fromEntries(Array.from(Object.entries(e.meta || {})).filter( ([d]) => !d.startsWith("_")))
        },
        children: []
    }
      , l = {
        type: "element",
        tagName: "code",
        properties: {},
        children: i
    };
    const c = []
      , u = {
        ...n,
        structure: o,
        addClassToHast: NI,
        get source() {
            return n.source
        },
        get tokens() {
            return t
        },
        get options() {
            return e
        },
        get root() {
            return s
        },
        get pre() {
            return a
        },
        get code() {
            return l
        },
        get lines() {
            return c
        }
    };
    if (t.forEach( (d, f) => {
        f && (o === "inline" ? s.children.push({
            type: "element",
            tagName: "br",
            properties: {},
            children: []
        }) : o === "classic" && i.push({
            type: "text",
            value: `
`
        }));
        let g = {
            type: "element",
            tagName: "span",
            properties: {
                class: "line"
            },
            children: []
        }
          , _ = 0;
        for (const m of d) {
            let p = {
                type: "element",
                tagName: "span",
                properties: {},
                children: [{
                    type: "text",
                    value: m.content
                }]
            };
            const b = m.htmlStyle || BI(MI(m));
            b && (p.properties.style = b);
            for (const y of r)
                p = y?.span?.call(u, p, f + 1, _, g) || p;
            o === "inline" ? s.children.push(p) : o === "classic" && g.children.push(p),
            _ += m.content.length
        }
        if (o === "classic") {
            for (const m of r)
                g = m?.line?.call(u, g, f + 1) || g;
            c.push(g),
            i.push(g)
        }
    }
    ),
    o === "classic") {
        for (const d of r)
            l = d?.code?.call(u, l) || l;
        a.children.push(l);
        for (const d of r)
            a = d?.pre?.call(u, a) || a;
        s.children.push(a)
    }
    let h = s;
    for (const d of r)
        h = d?.root?.call(u, h) || h;
    return h
}
function iG(t) {
    return t.map(e => {
        const n = [];
        let r = ""
          , i = 0;
        return e.forEach( (s, o) => {
            const l = !(s.fontStyle && s.fontStyle & Gr.Underline);
            l && s.content.match(/^\s+$/) && e[o + 1] ? (i || (i = s.offset),
            r += s.content) : r ? (l ? n.push({
                ...s,
                offset: i,
                content: r + s.content
            }) : n.push({
                content: r,
                offset: i
            }, s),
            i = 0,
            r = "") : n.push(s)
        }
        ),
        n
    }
    )
}
function sG(t) {
    return t.map(e => e.flatMap(n => {
        if (n.content.match(/^\s+$/))
            return n;
        const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
        if (!r)
            return n;
        const [,i,s,o] = r;
        if (!i && !o)
            return n;
        const a = [{
            ...n,
            offset: n.offset + i.length,
            content: s
        }];
        return i && a.unshift({
            content: i,
            offset: n.offset
        }),
        o && a.push({
            content: o,
            offset: n.offset + i.length + s.length
        }),
        a
    }
    ))
}
const oG = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
class jh {
    constructor(e, n, r) {
        this.property = e,
        this.normal = n,
        r && (this.space = r)
    }
}
jh.prototype.property = {};
jh.prototype.normal = {};
jh.prototype.space = null;
function jI(t, e) {
    const n = {}
      , r = {};
    let i = -1;
    for (; ++i < t.length; )
        Object.assign(n, t[i].property),
        Object.assign(r, t[i].normal);
    return new jh(n,r,e)
}
function W_(t) {
    return t.toLowerCase()
}
class Fr {
    constructor(e, n) {
        this.property = e,
        this.attribute = n
    }
}
Fr.prototype.space = null;
Fr.prototype.boolean = !1;
Fr.prototype.booleanish = !1;
Fr.prototype.overloadedBoolean = !1;
Fr.prototype.number = !1;
Fr.prototype.commaSeparated = !1;
Fr.prototype.spaceSeparated = !1;
Fr.prototype.commaOrSpaceSeparated = !1;
Fr.prototype.mustUseProperty = !1;
Fr.prototype.defined = !1;
let aG = 0;
const Qe = va()
  , Gt = va()
  , HI = va()
  , xe = va()
  , Rt = va()
  , ll = va()
  , or = va();
function va() {
    return 2 ** ++aG
}
var G_ = Object.freeze({
    __proto__: null,
    boolean: Qe,
    booleanish: Gt,
    commaOrSpaceSeparated: or,
    commaSeparated: ll,
    number: xe,
    overloadedBoolean: HI,
    spaceSeparated: Rt
});
const e0 = Object.keys(G_);
class Uv extends Fr {
    constructor(e, n, r, i) {
        let s = -1;
        if (super(e, n),
        ow(this, "space", i),
        typeof r == "number")
            for (; ++s < e0.length; ) {
                const o = e0[s];
                ow(this, e0[s], (r & G_[o]) === G_[o])
            }
    }
}
Uv.prototype.defined = !0;
function ow(t, e, n) {
    n && (t[e] = n)
}
const lG = {}.hasOwnProperty;
function zl(t) {
    const e = {}
      , n = {};
    let r;
    for (r in t.properties)
        if (lG.call(t.properties, r)) {
            const i = t.properties[r]
              , s = new Uv(r,t.transform(t.attributes || {}, r),i,t.space);
            t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0),
            e[r] = s,
            n[W_(r)] = r,
            n[W_(s.attribute)] = r
        }
    return new jh(e,n,t.space)
}
const UI = zl({
    space: "xlink",
    transform(t, e) {
        return "xlink:" + e.slice(5).toLowerCase()
    },
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
})
  , VI = zl({
    space: "xml",
    transform(t, e) {
        return "xml:" + e.slice(3).toLowerCase()
    },
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function $I(t, e) {
    return e in t ? t[e] : e
}
function zI(t, e) {
    return $I(t, e.toLowerCase())
}
const WI = zl({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: zI,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
})
  , GI = zl({
    transform(t, e) {
        return e === "role" ? e : "aria-" + e.slice(4).toLowerCase()
    },
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: Gt,
        ariaAutoComplete: null,
        ariaBusy: Gt,
        ariaChecked: Gt,
        ariaColCount: xe,
        ariaColIndex: xe,
        ariaColSpan: xe,
        ariaControls: Rt,
        ariaCurrent: null,
        ariaDescribedBy: Rt,
        ariaDetails: null,
        ariaDisabled: Gt,
        ariaDropEffect: Rt,
        ariaErrorMessage: null,
        ariaExpanded: Gt,
        ariaFlowTo: Rt,
        ariaGrabbed: Gt,
        ariaHasPopup: null,
        ariaHidden: Gt,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: Rt,
        ariaLevel: xe,
        ariaLive: null,
        ariaModal: Gt,
        ariaMultiLine: Gt,
        ariaMultiSelectable: Gt,
        ariaOrientation: null,
        ariaOwns: Rt,
        ariaPlaceholder: null,
        ariaPosInSet: xe,
        ariaPressed: Gt,
        ariaReadOnly: Gt,
        ariaRelevant: null,
        ariaRequired: Gt,
        ariaRoleDescription: Rt,
        ariaRowCount: xe,
        ariaRowIndex: xe,
        ariaRowSpan: xe,
        ariaSelected: Gt,
        ariaSetSize: xe,
        ariaSort: null,
        ariaValueMax: xe,
        ariaValueMin: xe,
        ariaValueNow: xe,
        ariaValueText: null,
        role: null
    }
})
  , cG = zl({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: zI,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
        abbr: null,
        accept: ll,
        acceptCharset: Rt,
        accessKey: Rt,
        action: null,
        allow: null,
        allowFullScreen: Qe,
        allowPaymentRequest: Qe,
        allowUserMedia: Qe,
        alt: null,
        as: null,
        async: Qe,
        autoCapitalize: null,
        autoComplete: Rt,
        autoFocus: Qe,
        autoPlay: Qe,
        blocking: Rt,
        capture: null,
        charSet: null,
        checked: Qe,
        cite: null,
        className: Rt,
        cols: xe,
        colSpan: null,
        content: null,
        contentEditable: Gt,
        controls: Qe,
        controlsList: Rt,
        coords: xe | ll,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: Qe,
        defer: Qe,
        dir: null,
        dirName: null,
        disabled: Qe,
        download: HI,
        draggable: Gt,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: Qe,
        formTarget: null,
        headers: Rt,
        height: xe,
        hidden: Qe,
        high: xe,
        href: null,
        hrefLang: null,
        htmlFor: Rt,
        httpEquiv: Rt,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: Qe,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: Qe,
        itemId: null,
        itemProp: Rt,
        itemRef: Rt,
        itemScope: Qe,
        itemType: Rt,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: Qe,
        low: xe,
        manifest: null,
        max: null,
        maxLength: xe,
        media: null,
        method: null,
        min: null,
        minLength: xe,
        multiple: Qe,
        muted: Qe,
        name: null,
        nonce: null,
        noModule: Qe,
        noValidate: Qe,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: Qe,
        optimum: xe,
        pattern: null,
        ping: Rt,
        placeholder: null,
        playsInline: Qe,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: Qe,
        referrerPolicy: null,
        rel: Rt,
        required: Qe,
        reversed: Qe,
        rows: xe,
        rowSpan: xe,
        sandbox: Rt,
        scope: null,
        scoped: Qe,
        seamless: Qe,
        selected: Qe,
        shadowRootDelegatesFocus: Qe,
        shadowRootMode: null,
        shape: null,
        size: xe,
        sizes: null,
        slot: null,
        span: xe,
        spellCheck: Gt,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: xe,
        step: null,
        style: null,
        tabIndex: xe,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: Qe,
        useMap: null,
        value: Gt,
        width: xe,
        wrap: null,
        align: null,
        aLink: null,
        archive: Rt,
        axis: null,
        background: null,
        bgColor: null,
        border: xe,
        borderColor: null,
        bottomMargin: xe,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: Qe,
        declare: Qe,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: xe,
        leftMargin: xe,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: xe,
        marginWidth: xe,
        noResize: Qe,
        noHref: Qe,
        noShade: Qe,
        noWrap: Qe,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: xe,
        rules: null,
        scheme: null,
        scrolling: Gt,
        standby: null,
        summary: null,
        text: null,
        topMargin: xe,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: xe,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: Qe,
        disableRemotePlayback: Qe,
        prefix: null,
        property: null,
        results: xe,
        security: null,
        unselectable: null
    }
})
  , uG = zl({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: $I,
    properties: {
        about: or,
        accentHeight: xe,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: xe,
        amplitude: xe,
        arabicForm: null,
        ascent: xe,
        attributeName: null,
        attributeType: null,
        azimuth: xe,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: xe,
        by: null,
        calcMode: null,
        capHeight: xe,
        className: Rt,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: xe,
        diffuseConstant: xe,
        direction: null,
        display: null,
        dur: null,
        divisor: xe,
        dominantBaseline: null,
        download: Qe,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: xe,
        enableBackground: null,
        end: null,
        event: null,
        exponent: xe,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: xe,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: ll,
        g2: ll,
        glyphName: ll,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: xe,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: xe,
        horizOriginX: xe,
        horizOriginY: xe,
        id: null,
        ideographic: xe,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: xe,
        k: xe,
        k1: xe,
        k2: xe,
        k3: xe,
        k4: xe,
        kernelMatrix: or,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: xe,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: xe,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: xe,
        overlineThickness: xe,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: xe,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: Rt,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: xe,
        pointsAtY: xe,
        pointsAtZ: xe,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: or,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: or,
        rev: or,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: or,
        requiredFeatures: or,
        requiredFonts: or,
        requiredFormats: or,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: xe,
        specularExponent: xe,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: xe,
        strikethroughThickness: xe,
        string: null,
        stroke: null,
        strokeDashArray: or,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: xe,
        strokeOpacity: xe,
        strokeWidth: null,
        style: null,
        surfaceScale: xe,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: or,
        tabIndex: xe,
        tableValues: null,
        target: null,
        targetX: xe,
        targetY: xe,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: or,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: xe,
        underlineThickness: xe,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: xe,
        values: null,
        vAlphabetic: xe,
        vMathematical: xe,
        vectorEffect: null,
        vHanging: xe,
        vIdeographic: xe,
        version: null,
        vertAdvY: xe,
        vertOriginX: xe,
        vertOriginY: xe,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: xe,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
})
  , hG = /^data[-\w.:]+$/i
  , aw = /-[a-z]/g
  , dG = /[A-Z]/g;
function fG(t, e) {
    const n = W_(e);
    let r = e
      , i = Fr;
    if (n in t.normal)
        return t.property[t.normal[n]];
    if (n.length > 4 && n.slice(0, 4) === "data" && hG.test(e)) {
        if (e.charAt(4) === "-") {
            const s = e.slice(5).replace(aw, mG);
            r = "data" + s.charAt(0).toUpperCase() + s.slice(1)
        } else {
            const s = e.slice(4);
            if (!aw.test(s)) {
                let o = s.replace(dG, pG);
                o.charAt(0) !== "-" && (o = "-" + o),
                e = "data" + o
            }
        }
        i = Uv
    }
    return new i(r,e)
}
function pG(t) {
    return "-" + t.toLowerCase()
}
function mG(t) {
    return t.charAt(1).toUpperCase()
}
const gG = jI([VI, UI, WI, GI, cG], "html")
  , qI = jI([VI, UI, WI, GI, uG], "svg")
  , lw = {}.hasOwnProperty;
function _G(t, e) {
    const n = e || {};
    function r(i, ...s) {
        let o = r.invalid;
        const a = r.handlers;
        if (i && lw.call(i, t)) {
            const l = String(i[t]);
            o = lw.call(a, l) ? a[l] : r.unknown
        }
        if (o)
            return o.call(this, i, ...s)
    }
    return r.handlers = n.handlers || {},
    r.invalid = n.invalid,
    r.unknown = n.unknown,
    r
}
function bG(t, e) {
    if (t = t.replace(e.subset ? yG(e.subset) : /["&'<>`]/g, r),
    e.subset || e.escapeOnly)
        return t;
    return t.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, n).replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, r);
    function n(i, s, o) {
        return e.format((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536, o.charCodeAt(s + 2), e)
    }
    function r(i, s, o) {
        return e.format(i.charCodeAt(0), o.charCodeAt(s + 1), e)
    }
}
function yG(t) {
    const e = [];
    let n = -1;
    for (; ++n < t.length; )
        e.push(t[n].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
    return new RegExp("(?:" + e.join("|") + ")","g")
}
function vG(t, e, n) {
    const r = "&#x" + t.toString(16).toUpperCase();
    return n && e && !/[\dA-Fa-f]/.test(String.fromCharCode(e)) ? r : r + ";"
}
function xG(t, e, n) {
    const r = "&#" + String(t);
    return n && e && !/\d/.test(String.fromCharCode(e)) ? r : r + ";"
}
const EG = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"]
  , t0 = {
    nbsp: "",
    iexcl: "",
    cent: "",
    pound: "",
    curren: "",
    yen: "",
    brvbar: "",
    sect: "",
    uml: "",
    copy: "",
    ordf: "",
    laquo: "",
    not: "",
    shy: "",
    reg: "",
    macr: "",
    deg: "",
    plusmn: "",
    sup2: "",
    sup3: "",
    acute: "",
    micro: "",
    para: "",
    middot: "",
    cedil: "",
    sup1: "",
    ordm: "",
    raquo: "",
    frac14: "",
    frac12: "",
    frac34: "",
    iquest: "",
    Agrave: "",
    Aacute: "",
    Acirc: "",
    Atilde: "",
    Auml: "",
    Aring: "",
    AElig: "",
    Ccedil: "",
    Egrave: "",
    Eacute: "",
    Ecirc: "",
    Euml: "",
    Igrave: "",
    Iacute: "",
    Icirc: "",
    Iuml: "",
    ETH: "",
    Ntilde: "",
    Ograve: "",
    Oacute: "",
    Ocirc: "",
    Otilde: "",
    Ouml: "",
    times: "",
    Oslash: "",
    Ugrave: "",
    Uacute: "",
    Ucirc: "",
    Uuml: "",
    Yacute: "",
    THORN: "",
    szlig: "",
    agrave: "",
    aacute: "",
    acirc: "",
    atilde: "",
    auml: "",
    aring: "",
    aelig: "",
    ccedil: "",
    egrave: "",
    eacute: "",
    ecirc: "",
    euml: "",
    igrave: "",
    iacute: "",
    icirc: "",
    iuml: "",
    eth: "",
    ntilde: "",
    ograve: "",
    oacute: "",
    ocirc: "",
    otilde: "",
    ouml: "",
    divide: "",
    oslash: "",
    ugrave: "",
    uacute: "",
    ucirc: "",
    uuml: "",
    yacute: "",
    thorn: "",
    yuml: "",
    fnof: "",
    Alpha: "",
    Beta: "",
    Gamma: "",
    Delta: "",
    Epsilon: "",
    Zeta: "",
    Eta: "",
    Theta: "",
    Iota: "",
    Kappa: "",
    Lambda: "",
    Mu: "",
    Nu: "",
    Xi: "",
    Omicron: "",
    Pi: "",
    Rho: "",
    Sigma: "",
    Tau: "",
    Upsilon: "",
    Phi: "",
    Chi: "",
    Psi: "",
    Omega: "",
    alpha: "",
    beta: "",
    gamma: "",
    delta: "",
    epsilon: "",
    zeta: "",
    eta: "",
    theta: "",
    iota: "",
    kappa: "",
    lambda: "",
    mu: "",
    nu: "",
    xi: "",
    omicron: "",
    pi: "",
    rho: "",
    sigmaf: "",
    sigma: "",
    tau: "",
    upsilon: "",
    phi: "",
    chi: "",
    psi: "",
    omega: "",
    thetasym: "",
    upsih: "",
    piv: "",
    bull: "",
    hellip: "",
    prime: "",
    Prime: "",
    oline: "",
    frasl: "",
    weierp: "",
    image: "",
    real: "",
    trade: "",
    alefsym: "",
    larr: "",
    uarr: "",
    rarr: "",
    darr: "",
    harr: "",
    crarr: "",
    lArr: "",
    uArr: "",
    rArr: "",
    dArr: "",
    hArr: "",
    forall: "",
    part: "",
    exist: "",
    empty: "",
    nabla: "",
    isin: "",
    notin: "",
    ni: "",
    prod: "",
    sum: "",
    minus: "",
    lowast: "",
    radic: "",
    prop: "",
    infin: "",
    ang: "",
    and: "",
    or: "",
    cap: "",
    cup: "",
    int: "",
    there4: "",
    sim: "",
    cong: "",
    asymp: "",
    ne: "",
    equiv: "",
    le: "",
    ge: "",
    sub: "",
    sup: "",
    nsub: "",
    sube: "",
    supe: "",
    oplus: "",
    otimes: "",
    perp: "",
    sdot: "",
    lceil: "",
    rceil: "",
    lfloor: "",
    rfloor: "",
    lang: "",
    rang: "",
    loz: "",
    spades: "",
    clubs: "",
    hearts: "",
    diams: "",
    quot: '"',
    amp: "&",
    lt: "<",
    gt: ">",
    OElig: "",
    oelig: "",
    Scaron: "",
    scaron: "",
    Yuml: "",
    circ: "",
    tilde: "",
    ensp: "",
    emsp: "",
    thinsp: "",
    zwnj: "",
    zwj: "",
    lrm: "",
    rlm: "",
    ndash: "",
    mdash: "",
    lsquo: "",
    rsquo: "",
    sbquo: "",
    ldquo: "",
    rdquo: "",
    bdquo: "",
    dagger: "",
    Dagger: "",
    permil: "",
    lsaquo: "",
    rsaquo: "",
    euro: ""
}
  , SG = ["cent", "copy", "divide", "gt", "lt", "not", "para", "times"]
  , KI = {}.hasOwnProperty
  , q_ = {};
let yd;
for (yd in t0)
    KI.call(t0, yd) && (q_[t0[yd]] = yd);
function wG(t, e, n, r) {
    const i = String.fromCharCode(t);
    if (KI.call(q_, i)) {
        const s = q_[i]
          , o = "&" + s;
        return n && EG.includes(s) && !SG.includes(s) && (!r || e && e !== 61 && /[^\da-z]/i.test(String.fromCharCode(e))) ? o : o + ";"
    }
    return ""
}
function CG(t, e, n) {
    let r = vG(t, e, n.omitOptionalSemicolons), i;
    if ((n.useNamedReferences || n.useShortestReferences) && (i = wG(t, e, n.omitOptionalSemicolons, n.attribute)),
    (n.useShortestReferences || !i) && n.useShortestReferences) {
        const s = xG(t, e, n.omitOptionalSemicolons);
        s.length < r.length && (r = s)
    }
    return i && (!n.useShortestReferences || i.length < r.length) ? i : r
}
function cl(t, e) {
    return bG(t, Object.assign({
        format: CG
    }, e))
}
const TG = /^>|^->|<!--|-->|--!>|<!-$/g
  , AG = [">"]
  , kG = ["<", ">"];
function RG(t, e, n, r) {
    return r.settings.bogusComments ? "<?" + cl(t.value, Object.assign({}, r.settings.characterReferences, {
        subset: AG
    })) + ">" : "<!--" + t.value.replace(TG, i) + "-->";
    function i(s) {
        return cl(s, Object.assign({}, r.settings.characterReferences, {
            subset: kG
        }))
    }
}
function IG(t, e, n, r) {
    return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>"
}
function cw(t, e) {
    const n = String(t);
    if (typeof e != "string")
        throw new TypeError("Expected character");
    let r = 0
      , i = n.indexOf(e);
    for (; i !== -1; )
        r++,
        i = n.indexOf(e, i + e.length);
    return r
}
function PG(t, e) {
    const n = e || {};
    return (t[t.length - 1] === "" ? [...t, ""] : t).join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")).trim()
}
function DG(t) {
    return t.join(" ").trim()
}
const LG = /[ \t\n\f\r]/g;
function Vv(t) {
    return typeof t == "object" ? t.type === "text" ? uw(t.value) : !1 : uw(t)
}
function uw(t) {
    return t.replace(LG, "") === ""
}
const nn = XI(1)
  , YI = XI(-1)
  , OG = [];
function XI(t) {
    return e;
    function e(n, r, i) {
        const s = n ? n.children : OG;
        let o = (r || 0) + t
          , a = s[o];
        if (!i)
            for (; a && Vv(a); )
                o += t,
                a = s[o];
        return a
    }
}
const NG = {}.hasOwnProperty;
function QI(t) {
    return e;
    function e(n, r, i) {
        return NG.call(t, n.tagName) && t[n.tagName](n, r, i)
    }
}
const $v = QI({
    body: BG,
    caption: n0,
    colgroup: n0,
    dd: UG,
    dt: HG,
    head: n0,
    html: MG,
    li: jG,
    optgroup: VG,
    option: $G,
    p: FG,
    rp: hw,
    rt: hw,
    tbody: WG,
    td: dw,
    tfoot: GG,
    th: dw,
    thead: zG,
    tr: qG
});
function n0(t, e, n) {
    const r = nn(n, e, !0);
    return !r || r.type !== "comment" && !(r.type === "text" && Vv(r.value.charAt(0)))
}
function MG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type !== "comment"
}
function BG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type !== "comment"
}
function FG(t, e, n) {
    const r = nn(n, e);
    return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"))
}
function jG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && r.tagName === "li"
}
function HG(t, e, n) {
    const r = nn(n, e);
    return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"))
}
function UG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd")
}
function hw(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt")
}
function VG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && r.tagName === "optgroup"
}
function $G(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup")
}
function zG(t, e, n) {
    const r = nn(n, e);
    return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"))
}
function WG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot")
}
function GG(t, e, n) {
    return !nn(n, e)
}
function qG(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && r.tagName === "tr"
}
function dw(t, e, n) {
    const r = nn(n, e);
    return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th")
}
const KG = QI({
    body: QG,
    colgroup: JG,
    head: XG,
    html: YG,
    tbody: ZG
});
function YG(t) {
    const e = nn(t, -1);
    return !e || e.type !== "comment"
}
function XG(t) {
    const e = t.children
      , n = [];
    let r = -1;
    for (; ++r < e.length; ) {
        const i = e[r];
        if (i.type === "element" && (i.tagName === "title" || i.tagName === "base")) {
            if (n.includes(i.tagName))
                return !1;
            n.push(i.tagName)
        }
    }
    return e.length > 0
}
function QG(t) {
    const e = nn(t, -1, !0);
    return !e || e.type !== "comment" && !(e.type === "text" && Vv(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"))
}
function JG(t, e, n) {
    const r = YI(n, e)
      , i = nn(t, -1, !0);
    return n && r && r.type === "element" && r.tagName === "colgroup" && $v(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col")
}
function ZG(t, e, n) {
    const r = YI(n, e)
      , i = nn(t, -1);
    return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && $v(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr")
}
const vd = {
    name: [[`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")], [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]],
    unquoted: [[`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")], [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]],
    single: [["&'".split(""), "\"&'`".split("")], ["\0&'".split(""), "\0\"&'`".split("")]],
    double: [['"&'.split(""), "\"&'`".split("")], ['\0"&'.split(""), "\0\"&'`".split("")]]
};
function eq(t, e, n, r) {
    const i = r.schema
      , s = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
    let o = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
    const a = [];
    let l;
    i.space === "html" && t.tagName === "svg" && (r.schema = qI);
    const c = tq(r, t.properties)
      , u = r.all(i.space === "html" && t.tagName === "template" ? t.content : t);
    return r.schema = i,
    u && (o = !1),
    (c || !s || !KG(t, e, n)) && (a.push("<", t.tagName, c ? " " + c : ""),
    o && (i.space === "svg" || r.settings.closeSelfClosing) && (l = c.charAt(c.length - 1),
    (!r.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "),
    a.push("/")),
    a.push(">")),
    a.push(u),
    !o && (!s || !$v(t, e, n)) && a.push("</" + t.tagName + ">"),
    a.join("")
}
function tq(t, e) {
    const n = [];
    let r = -1, i;
    if (e) {
        for (i in e)
            if (e[i] !== null && e[i] !== void 0) {
                const s = nq(t, i, e[i]);
                s && n.push(s)
            }
    }
    for (; ++r < n.length; ) {
        const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
        r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ")
    }
    return n.join("")
}
function nq(t, e, n) {
    const r = fG(t.schema, e)
      , i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1
      , s = t.settings.allowDangerousCharacters ? 0 : 1;
    let o = t.quote, a;
    if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean && typeof n != "string") && (n = !!n),
    n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
        return "";
    const l = cl(r.attribute, Object.assign({}, t.settings.characterReferences, {
        subset: vd.name[i][s]
    }));
    return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? PG : DG)(n, {
        padLeft: !t.settings.tightCommaSeparatedLists
    }) : String(n),
    t.settings.collapseEmptyAttributes && !n) ? l : (t.settings.preferUnquoted && (a = cl(n, Object.assign({}, t.settings.characterReferences, {
        attribute: !0,
        subset: vd.unquoted[i][s]
    }))),
    a !== n && (t.settings.quoteSmart && cw(n, o) > cw(n, t.alternative) && (o = t.alternative),
    a = o + cl(n, Object.assign({}, t.settings.characterReferences, {
        subset: (o === "'" ? vd.single : vd.double)[i][s],
        attribute: !0
    })) + o),
    l + (a && "=" + a))
}
const rq = ["<", "&"];
function JI(t, e, n, r) {
    return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : cl(t.value, Object.assign({}, r.settings.characterReferences, {
        subset: rq
    }))
}
function iq(t, e, n, r) {
    return r.settings.allowDangerousHtml ? t.value : JI(t, e, n, r)
}
function sq(t, e, n, r) {
    return r.all(t)
}
const oq = _G("type", {
    invalid: aq,
    unknown: lq,
    handlers: {
        comment: RG,
        doctype: IG,
        element: eq,
        raw: iq,
        root: sq,
        text: JI
    }
});
function aq(t) {
    throw new Error("Expected node, not `" + t + "`")
}
function lq(t) {
    const e = t;
    throw new Error("Cannot compile unknown node `" + e.type + "`")
}
const cq = {}
  , uq = {}
  , hq = [];
function dq(t, e) {
    const n = cq
      , r = n.quote || '"'
      , i = r === '"' ? "'" : '"';
    if (r !== '"' && r !== "'")
        throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
    return {
        one: fq,
        all: pq,
        settings: {
            omitOptionalTags: n.omitOptionalTags || !1,
            allowParseErrors: n.allowParseErrors || !1,
            allowDangerousCharacters: n.allowDangerousCharacters || !1,
            quoteSmart: n.quoteSmart || !1,
            preferUnquoted: n.preferUnquoted || !1,
            tightAttributes: n.tightAttributes || !1,
            upperDoctype: n.upperDoctype || !1,
            tightDoctype: n.tightDoctype || !1,
            bogusComments: n.bogusComments || !1,
            tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
            tightSelfClosing: n.tightSelfClosing || !1,
            collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
            allowDangerousHtml: n.allowDangerousHtml || !1,
            voids: n.voids || oG,
            characterReferences: n.characterReferences || uq,
            closeSelfClosing: n.closeSelfClosing || !1,
            closeEmptyElements: n.closeEmptyElements || !1
        },
        schema: n.space === "svg" ? qI : gG,
        quote: r,
        alternative: i
    }.one(Array.isArray(t) ? {
        type: "root",
        children: t
    } : t, void 0, void 0)
}
function fq(t, e, n) {
    return oq(t, e, n, this)
}
function pq(t) {
    const e = []
      , n = t && t.children || hq;
    let r = -1;
    for (; ++r < n.length; )
        e[r] = this.one(n[r], r, t);
    return e.join("")
}
function mq(t, e, n) {
    const r = {
        meta: {},
        options: n,
        codeToHast: (s, o) => ap(t, s, o),
        codeToTokens: (s, o) => sp(t, s, o)
    };
    let i = dq(ap(t, e, n, r));
    for (const s of op(n))
        i = s.postprocess?.call(r, i, n) || i;
    return i
}
async function gq(t) {
    let e, n;
    const r = {};
    function i(_) {
        n = _,
        r.HEAPU8 = new Uint8Array(_),
        r.HEAPU32 = new Uint32Array(_)
    }
    function s() {
        return typeof performance < "u" ? performance.now() : Date.now()
    }
    function o(_, m, p) {
        r.HEAPU8.copyWithin(_, m, m + p)
    }
    function a() {
        return 2147483648
    }
    function l(_) {
        try {
            return e.grow(_ - n.byteLength + 65535 >>> 16),
            i(e.buffer),
            1
        } catch {}
    }
    function c(_) {
        const m = r.HEAPU8.length;
        _ = _ >>> 0;
        const p = a();
        if (_ > p)
            return !1;
        const b = (y, x) => y + (x - y % x) % x;
        for (let y = 1; y <= 4; y *= 2) {
            let x = m * (1 + .2 / y);
            x = Math.min(x, _ + 100663296);
            const E = Math.min(p, b(Math.max(_, x), 65536));
            if (l(E))
                return !0
        }
        return !1
    }
    const u = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
    function h(_, m, p=1024) {
        const b = m + p;
        let y = m;
        for (; _[y] && !(y >= b); )
            ++y;
        if (y - m > 16 && _.buffer && u)
            return u.decode(_.subarray(m, y));
        let x = "";
        for (; m < y; ) {
            let E = _[m++];
            if (!(E & 128)) {
                x += String.fromCharCode(E);
                continue
            }
            const w = _[m++] & 63;
            if ((E & 224) === 192) {
                x += String.fromCharCode((E & 31) << 6 | w);
                continue
            }
            const A = _[m++] & 63;
            if ((E & 240) === 224 ? E = (E & 15) << 12 | w << 6 | A : E = (E & 7) << 18 | w << 12 | A << 6 | _[m++] & 63,
            E < 65536)
                x += String.fromCharCode(E);
            else {
                const C = E - 65536;
                x += String.fromCharCode(55296 | C >> 10, 56320 | C & 1023)
            }
        }
        return x
    }
    function d(_, m) {
        return _ ? h(r.HEAPU8, _, m) : ""
    }
    const f = {
        emscripten_get_now: s,
        emscripten_memcpy_big: o,
        emscripten_resize_heap: c,
        fd_write: () => 0
    };
    async function g() {
        const m = await t({
            env: f,
            wasi_snapshot_preview1: f
        });
        e = m.memory,
        i(e.buffer),
        Object.assign(r, m),
        r.UTF8ToString = d
    }
    return await g(),
    r
}
let an = null
  , _q = !1;
function bq(t) {
    throw new ln(t.UTF8ToString(t.getLastOnigError()))
}
class Nm {
    static _utf8ByteLength(e) {
        let n = 0;
        for (let r = 0, i = e.length; r < i; r++) {
            const s = e.charCodeAt(r);
            let o = s
              , a = !1;
            if (s >= 55296 && s <= 56319 && r + 1 < i) {
                const l = e.charCodeAt(r + 1);
                l >= 56320 && l <= 57343 && (o = (s - 55296 << 10) + 65536 | l - 56320,
                a = !0)
            }
            o <= 127 ? n += 1 : o <= 2047 ? n += 2 : o <= 65535 ? n += 3 : n += 4,
            a && r++
        }
        return n
    }
    utf16Length;
    utf8Length;
    utf16Value;
    utf8Value;
    utf16OffsetToUtf8;
    utf8OffsetToUtf16;
    constructor(e) {
        const n = e.length
          , r = Nm._utf8ByteLength(e)
          , i = r !== n
          , s = i ? new Uint32Array(n + 1) : null;
        i && (s[n] = r);
        const o = i ? new Uint32Array(r + 1) : null;
        i && (o[r] = n);
        const a = new Uint8Array(r);
        let l = 0;
        for (let c = 0; c < n; c++) {
            const u = e.charCodeAt(c);
            let h = u
              , d = !1;
            if (u >= 55296 && u <= 56319 && c + 1 < n) {
                const f = e.charCodeAt(c + 1);
                f >= 56320 && f <= 57343 && (h = (u - 55296 << 10) + 65536 | f - 56320,
                d = !0)
            }
            i && (s[c] = l,
            d && (s[c + 1] = l),
            h <= 127 ? o[l + 0] = c : h <= 2047 ? (o[l + 0] = c,
            o[l + 1] = c) : h <= 65535 ? (o[l + 0] = c,
            o[l + 1] = c,
            o[l + 2] = c) : (o[l + 0] = c,
            o[l + 1] = c,
            o[l + 2] = c,
            o[l + 3] = c)),
            h <= 127 ? a[l++] = h : h <= 2047 ? (a[l++] = 192 | (h & 1984) >>> 6,
            a[l++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[l++] = 224 | (h & 61440) >>> 12,
            a[l++] = 128 | (h & 4032) >>> 6,
            a[l++] = 128 | (h & 63) >>> 0) : (a[l++] = 240 | (h & 1835008) >>> 18,
            a[l++] = 128 | (h & 258048) >>> 12,
            a[l++] = 128 | (h & 4032) >>> 6,
            a[l++] = 128 | (h & 63) >>> 0),
            d && c++
        }
        this.utf16Length = n,
        this.utf8Length = r,
        this.utf16Value = e,
        this.utf8Value = a,
        this.utf16OffsetToUtf8 = s,
        this.utf8OffsetToUtf16 = o
    }
    createString(e) {
        const n = e.omalloc(this.utf8Length);
        return e.HEAPU8.set(this.utf8Value, n),
        n
    }
}
class wr {
    static LAST_ID = 0;
    static _sharedPtr = 0;
    static _sharedPtrInUse = !1;
    id = ++wr.LAST_ID;
    _onigBinding;
    content;
    utf16Length;
    utf8Length;
    utf16OffsetToUtf8;
    utf8OffsetToUtf16;
    ptr;
    constructor(e) {
        if (!an)
            throw new ln("Must invoke loadWasm first.");
        this._onigBinding = an,
        this.content = e;
        const n = new Nm(e);
        this.utf16Length = n.utf16Length,
        this.utf8Length = n.utf8Length,
        this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8,
        this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16,
        this.utf8Length < 1e4 && !wr._sharedPtrInUse ? (wr._sharedPtr || (wr._sharedPtr = an.omalloc(1e4)),
        wr._sharedPtrInUse = !0,
        an.HEAPU8.set(n.utf8Value, wr._sharedPtr),
        this.ptr = wr._sharedPtr) : this.ptr = n.createString(an)
    }
    convertUtf8OffsetToUtf16(e) {
        return this.utf8OffsetToUtf16 ? e < 0 ? 0 : e > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[e] : e
    }
    convertUtf16OffsetToUtf8(e) {
        return this.utf16OffsetToUtf8 ? e < 0 ? 0 : e > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[e] : e
    }
    dispose() {
        this.ptr === wr._sharedPtr ? wr._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr)
    }
}
class yq {
    _onigBinding;
    _ptr;
    constructor(e) {
        if (!an)
            throw new ln("Must invoke loadWasm first.");
        const n = []
          , r = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = new Nm(e[a]);
            n[a] = c.createString(an),
            r[a] = c.utf8Length
        }
        const i = an.omalloc(4 * e.length);
        an.HEAPU32.set(n, i / 4);
        const s = an.omalloc(4 * e.length);
        an.HEAPU32.set(r, s / 4);
        const o = an.createOnigScanner(i, s, e.length);
        for (let a = 0, l = e.length; a < l; a++)
            an.ofree(n[a]);
        an.ofree(s),
        an.ofree(i),
        o === 0 && bq(an),
        this._onigBinding = an,
        this._ptr = o
    }
    dispose() {
        this._onigBinding.freeOnigScanner(this._ptr)
    }
    findNextMatchSync(e, n, r) {
        let i = _q
          , s = 0;
        if (typeof r == "number" ? (r & 8 && (i = !0),
        s = r) : typeof r == "boolean" && (i = r),
        typeof e == "string") {
            e = new wr(e);
            const o = this._findNextMatchSync(e, n, i, s);
            return e.dispose(),
            o
        }
        return this._findNextMatchSync(e, n, i, s)
    }
    _findNextMatchSync(e, n, r, i) {
        const s = this._onigBinding;
        let o;
        if (r ? o = s.findNextOnigScannerMatchDbg(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(n), i) : o = s.findNextOnigScannerMatch(this._ptr, e.id, e.ptr, e.utf8Length, e.convertUtf16OffsetToUtf8(n), i),
        o === 0)
            return null;
        const a = s.HEAPU32;
        let l = o / 4;
        const c = a[l++]
          , u = a[l++]
          , h = [];
        for (let d = 0; d < u; d++) {
            const f = e.convertUtf8OffsetToUtf16(a[l++])
              , g = e.convertUtf8OffsetToUtf16(a[l++]);
            h[d] = {
                start: f,
                end: g,
                length: g - f
            }
        }
        return {
            index: c,
            captureIndices: h
        }
    }
}
function vq(t) {
    return typeof t.instantiator == "function"
}
function xq(t) {
    return typeof t.default == "function"
}
function Eq(t) {
    return typeof t.data < "u"
}
function Sq(t) {
    return typeof Response < "u" && t instanceof Response
}
function wq(t) {
    return typeof ArrayBuffer < "u" && (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) || typeof Qf < "u" && Qf.isBuffer?.(t) || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer || typeof Uint32Array < "u" && t instanceof Uint32Array
}
let xd;
function Cq(t) {
    if (xd)
        return xd;
    async function e() {
        an = await gq(async n => {
            let r = t;
            return r = await r,
            typeof r == "function" && (r = await r(n)),
            typeof r == "function" && (r = await r(n)),
            vq(r) ? r = await r.instantiator(n) : xq(r) ? r = await r.default(n) : (Eq(r) && (r = r.data),
            Sq(r) ? typeof WebAssembly.instantiateStreaming == "function" ? r = await Tq(r)(n) : r = await Aq(r)(n) : wq(r) ? r = await r0(r)(n) : r instanceof WebAssembly.Module ? r = await r0(r)(n) : "default"in r && r.default instanceof WebAssembly.Module && (r = await r0(r.default)(n))),
            "instance"in r && (r = r.instance),
            "exports"in r && (r = r.exports),
            r
        }
        )
    }
    return xd = e(),
    xd
}
function r0(t) {
    return e => WebAssembly.instantiate(t, e)
}
function Tq(t) {
    return e => WebAssembly.instantiateStreaming(t, e)
}
function Aq(t) {
    return async e => {
        const n = await t.arrayBuffer();
        return WebAssembly.instantiate(n, e)
    }
}
function kq(t) {
    return new wr(t)
}
function Rq(t) {
    return new yq(t)
}
const fw = {
    light: "#333333",
    dark: "#bbbbbb"
}
  , pw = {
    light: "#fffffe",
    dark: "#1e1e1e"
}
  , mw = "__shiki_resolved";
function ZI(t) {
    if (t?.[mw])
        return t;
    const e = {
        ...t
    };
    e.tokenColors && !e.settings && (e.settings = e.tokenColors,
    delete e.tokenColors),
    e.type ||= "dark",
    e.colorReplacements = {
        ...e.colorReplacements
    },
    e.settings ||= [];
    let {bg: n, fg: r} = e;
    if (!n || !r) {
        const a = e.settings ? e.settings.find(l => !l.name && !l.scope) : void 0;
        a?.settings?.foreground && (r = a.settings.foreground),
        a?.settings?.background && (n = a.settings.background),
        !r && e?.colors?.["editor.foreground"] && (r = e.colors["editor.foreground"]),
        !n && e?.colors?.["editor.background"] && (n = e.colors["editor.background"]),
        r || (r = e.type === "light" ? fw.light : fw.dark),
        n || (n = e.type === "light" ? pw.light : pw.dark),
        e.fg = r,
        e.bg = n
    }
    e.settings[0] && e.settings[0].settings && !e.settings[0].scope || e.settings.unshift({
        settings: {
            foreground: e.fg,
            background: e.bg
        }
    });
    let i = 0;
    const s = new Map;
    function o(a) {
        if (s.has(a))
            return s.get(a);
        i += 1;
        const l = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
        return e.colorReplacements?.[`#${l}`] ? o(a) : (s.set(a, l),
        l)
    }
    e.settings = e.settings.map(a => {
        const l = a.settings?.foreground && !a.settings.foreground.startsWith("#")
          , c = a.settings?.background && !a.settings.background.startsWith("#");
        if (!l && !c)
            return a;
        const u = {
            ...a,
            settings: {
                ...a.settings
            }
        };
        if (l) {
            const h = o(a.settings.foreground);
            e.colorReplacements[h] = a.settings.foreground,
            u.settings.foreground = h
        }
        if (c) {
            const h = o(a.settings.background);
            e.colorReplacements[h] = a.settings.background,
            u.settings.background = h
        }
        return u
    }
    );
    for (const a of Object.keys(e.colors || {}))
        if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !e.colors[a]?.startsWith("#")) {
            const l = o(e.colors[a]);
            e.colorReplacements[l] = e.colors[a],
            e.colors[a] = l
        }
    return Object.defineProperty(e, mw, {
        enumerable: !1,
        writable: !1,
        value: !0
    }),
    e
}
class Iq extends BW {
    _resolver;
    _themes;
    _langs;
    _alias;
    _resolvedThemes = new Map;
    _resolvedGrammars = new Map;
    _langMap = new Map;
    _langGraph = new Map;
    _textmateThemeCache = new WeakMap;
    _loadedThemesCache = null;
    _loadedLanguagesCache = null;
    constructor(e, n, r, i={}) {
        super(e),
        this._resolver = e,
        this._themes = n,
        this._langs = r,
        this._alias = i,
        n.forEach(s => this.loadTheme(s)),
        r.forEach(s => this.loadLanguage(s))
    }
    getTheme(e) {
        return typeof e == "string" ? this._resolvedThemes.get(e) : this.loadTheme(e)
    }
    loadTheme(e) {
        const n = ZI(e);
        return n.name && (this._resolvedThemes.set(n.name, n),
        this._loadedThemesCache = null),
        n
    }
    getLoadedThemes() {
        return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]),
        this._loadedThemesCache
    }
    setTheme(e) {
        let n = this._textmateThemeCache.get(e);
        n || (n = tp.createFromRawTheme(e),
        this._textmateThemeCache.set(e, n)),
        this._syncRegistry.setTheme(n)
    }
    getGrammar(e) {
        if (this._alias[e]) {
            const n = new Set([e]);
            for (; this._alias[e]; ) {
                if (e = this._alias[e],
                n.has(e))
                    throw new ln(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
                n.add(e)
            }
        }
        return this._resolvedGrammars.get(e)
    }
    async loadLanguage(e) {
        if (this.getGrammar(e.name))
            return;
        const n = new Set([...this._langMap.values()].filter(s => s.embeddedLangsLazy?.includes(e.name)));
        this._resolver.addLanguage(e);
        const r = {
            balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
            unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
        };
        this._syncRegistry._rawGrammars.set(e.scopeName, e);
        const i = await this.loadGrammarWithConfiguration(e.scopeName, 1, r);
        if (this._resolvedGrammars.set(e.name, i),
        e.aliases && e.aliases.forEach(s => {
            this._alias[s] = e.name
        }
        ),
        this._loadedLanguagesCache = null,
        n.size)
            for (const s of n)
                this._resolvedGrammars.delete(s.name),
                this._loadedLanguagesCache = null,
                this._syncRegistry?._injectionGrammars?.delete(s.scopeName),
                this._syncRegistry?._grammars?.delete(s.scopeName),
                await this.loadLanguage(this._langMap.get(s.name))
    }
    async init() {
        this._themes.map(e => this.loadTheme(e)),
        await this.loadLanguages(this._langs)
    }
    dispose() {
        super.dispose(),
        this._resolvedThemes.clear(),
        this._resolvedGrammars.clear(),
        this._langMap.clear(),
        this._langGraph.clear(),
        this._loadedThemesCache = null
    }
    async loadLanguages(e) {
        for (const i of e)
            this.resolveEmbeddedLanguages(i);
        const n = Array.from(this._langGraph.entries())
          , r = n.filter( ([i,s]) => !s);
        if (r.length) {
            const i = n.filter( ([s,o]) => o && o.embeddedLangs?.some(a => r.map( ([l]) => l).includes(a))).filter(s => !r.includes(s));
            throw new ln(`Missing languages ${r.map( ([s]) => `\`${s}\``).join(", ")}, required by ${i.map( ([s]) => `\`${s}\``).join(", ")}`)
        }
        for (const [i,s] of n)
            this._resolver.addLanguage(s);
        for (const [i,s] of n)
            await this.loadLanguage(s)
    }
    getLoadedLanguages() {
        return this._loadedLanguagesCache || (this._loadedLanguagesCache = [...new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])]),
        this._loadedLanguagesCache
    }
    resolveEmbeddedLanguages(e) {
        if (this._langMap.set(e.name, e),
        this._langGraph.set(e.name, e),
        e.embeddedLangs)
            for (const n of e.embeddedLangs)
                this._langGraph.set(n, this._langMap.get(n))
    }
}
class Pq {
    _langs = new Map;
    _scopeToLang = new Map;
    _injections = new Map;
    _onigLibPromise;
    constructor(e, n) {
        this._onigLibPromise = e,
        n.forEach(r => this.addLanguage(r))
    }
    get onigLib() {
        return this._onigLibPromise
    }
    getLangRegistration(e) {
        return this._langs.get(e)
    }
    async loadGrammar(e) {
        return this._scopeToLang.get(e)
    }
    addLanguage(e) {
        this._langs.set(e.name, e),
        e.aliases && e.aliases.forEach(n => {
            this._langs.set(n, e)
        }
        ),
        this._scopeToLang.set(e.scopeName, e),
        e.injectTo && e.injectTo.forEach(n => {
            this._injections.get(n) || this._injections.set(n, []),
            this._injections.get(n).push(e.scopeName)
        }
        )
    }
    getInjections(e) {
        const n = e.split(".");
        let r = [];
        for (let i = 1; i <= n.length; i++) {
            const s = n.slice(0, i).join(".");
            r = [...r, ...this._injections.get(s) || []]
        }
        return r
    }
}
let Dq, ic = 0;
async function Lq(t={}) {
    ic += 1,
    t.warnings !== !1 && ic >= 10 && ic % 10 === 0 && console.warn(`[Shiki] ${ic} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
    let e = !1;
    async function n(y) {
        return Promise.resolve(typeof y == "function" ? y() : y).then(x => x.default || x)
    }
    async function r(y) {
        return Array.from(new Set((await Promise.all(y.filter(x => !jv(x)).map(async x => await n(x).then(E => Array.isArray(E) ? E : [E])))).flat()))
    }
    const i = t.loadWasm || Dq
      , [s,o] = await Promise.all([Promise.all((t.themes || []).map(n)).then(y => y.map(ZI)), r(t.langs || []), i ? Cq(i) : void 0])
      , a = new Pq(Promise.resolve({
        createOnigScanner(y) {
            return Rq(y)
        },
        createOnigString(y) {
            return kq(y)
        }
    }),o)
      , l = new Iq(a,s,o,t.langAlias);
    await l.init();
    let c;
    function u(y) {
        p();
        const x = l.getGrammar(typeof y == "string" ? y : y.name);
        if (!x)
            throw new ln(`Language \`${y}\` not found, you may need to load it first`);
        return x
    }
    function h(y) {
        if (y === "none")
            return {
                bg: "",
                fg: "",
                name: "none",
                settings: [],
                type: "dark"
            };
        p();
        const x = l.getTheme(y);
        if (!x)
            throw new ln(`Theme \`${y}\` not found, you may need to load it first`);
        return x
    }
    function d(y) {
        p();
        const x = h(y);
        c !== y && (l.setTheme(x),
        c = y);
        const E = l.getColorMap();
        return {
            theme: x,
            colorMap: E
        }
    }
    function f() {
        return p(),
        l.getLoadedThemes()
    }
    function g() {
        return p(),
        l.getLoadedLanguages()
    }
    async function _(...y) {
        p(),
        await l.loadLanguages(await r(y))
    }
    async function m(...y) {
        p(),
        await Promise.all(y.map(async x => OI(x) ? null : l.loadTheme(await n(x))))
    }
    function p() {
        if (e)
            throw new ln("Shiki instance has been disposed")
    }
    function b() {
        e || (e = !0,
        l.dispose(),
        ic -= 1)
    }
    return {
        setTheme: d,
        getTheme: h,
        getLanguage: u,
        getLoadedThemes: f,
        getLoadedLanguages: g,
        loadLanguage: _,
        loadTheme: m,
        dispose: b,
        [Symbol.dispose]: b
    }
}
async function Oq(t={}) {
    const e = await Lq(t);
    return {
        codeToTokensBase: (n, r) => Hv(e, n, r),
        codeToTokensWithThemes: (n, r) => FI(e, n, r),
        codeToTokens: (n, r) => sp(e, n, r),
        codeToHast: (n, r) => ap(e, n, r),
        codeToHtml: (n, r) => mq(e, n, r),
        ...e,
        getInternalContext: () => e
    }
}
function Nq(t, e, n) {
    async function r(i) {
        function s(u) {
            if (typeof u == "string") {
                if (jv(u))
                    return [];
                const h = t[u];
                if (!h)
                    throw new ln(`Language \`${u}\` is not included in this bundle. You may want to load it from external source.`);
                return h
            }
            return u
        }
        function o(u) {
            if (OI(u))
                return "none";
            if (typeof u == "string") {
                const h = e[u];
                if (!h)
                    throw new ln(`Theme \`${u}\` is not included in this bundle. You may want to load it from external source.`);
                return h
            }
            return u
        }
        const a = (i.themes ?? []).map(u => o(u))
          , l = (i.langs ?? []).map(u => s(u))
          , c = await Oq({
            ...i,
            themes: a,
            langs: l,
            loadWasm: n
        });
        return {
            ...c,
            loadLanguage(...u) {
                return c.loadLanguage(...u.map(s))
            },
            loadTheme(...u) {
                return c.loadTheme(...u.map(o))
            }
        }
    }
    return r
}
function Mq(t) {
    let e;
    async function n(r={}) {
        if (e) {
            const i = await e;
            return await Promise.all([i.loadTheme(...r.themes || []), i.loadLanguage(...r.langs || [])]),
            i
        } else
            return e = t({
                ...r,
                themes: r.themes || [],
                langs: r.langs || []
            }),
            e
    }
    return n
}
function Bq(t) {
    const e = Mq(t);
    return {
        getSingletonHighlighter(n) {
            return e(n)
        },
        async codeToHtml(n, r) {
            return (await e({
                langs: [r.lang],
                themes: "theme"in r ? [r.theme] : Object.values(r.themes)
            })).codeToHtml(n, r)
        },
        async codeToHast(n, r) {
            return (await e({
                langs: [r.lang],
                themes: "theme"in r ? [r.theme] : Object.values(r.themes)
            })).codeToHast(n, r)
        },
        async codeToTokens(n, r) {
            return (await e({
                langs: [r.lang],
                themes: "theme"in r ? [r.theme] : Object.values(r.themes)
            })).codeToTokens(n, r)
        },
        async codeToTokensBase(n, r) {
            return (await e({
                langs: [r.lang],
                themes: [r.theme]
            })).codeToTokensBase(n, r)
        },
        async codeToTokensWithThemes(n, r) {
            return (await e({
                langs: [r.lang],
                themes: Object.values(r.themes).filter(Boolean)
            })).codeToTokensWithThemes(n, r)
        }
    }
}
const eP = Nq(_I, Gz, zz)
  , {codeToHtml: Fq, codeToHast: Qye, codeToTokens: Jye, codeToTokensBase: Zye, codeToTokensWithThemes: eve, getSingletonHighlighter: tve} = Bq(eP)
  , jq = {
    langs: ["shell"],
    themes: ["light-plus", "dark-plus"]
}
  , Hq = await eP(jq);
function tP({className: t, theme: e, code: n}) {
    const r = Ie(da);
    return e ??= r,
    v.jsx("div", {
        className: be("text-xs w-full", t),
        dangerouslySetInnerHTML: {
            __html: Hq.codeToHtml(n, {
                lang: "shell",
                theme: e === "light" ? "light-plus" : "dark-plus"
            })
        }
    })
}
const Uq = nr("ChatHistory")
  , Ws = "bolt-chats"
  , lp = "bolt-deployments"
  , Tl = "bolt-chat-metadata";
async function Vq() {
    return new Promise(t => {
        const e = indexedDB.open("boltHistory", 5);
        e.onupgradeneeded = n => {
            const r = n.target.result;
            r.objectStoreNames.contains(Ws) || r.createObjectStore(Ws, {
                keyPath: "slug"
            }).createIndex("slug", "slug", {
                unique: !0
            }),
            r.objectStoreNames.contains(lp) || r.createObjectStore(lp, {
                keyPath: "slug"
            }).createIndex("slug", "slug", {
                unique: !0
            }),
            r.objectStoreNames.contains(Tl) || r.createObjectStore(Tl, {
                keyPath: "slug"
            })
        }
        ,
        e.onsuccess = n => {
            t(n.target.result)
        }
        ,
        e.onerror = n => {
            t(void 0),
            Uq.error(n.target.error)
        }
    }
    )
}
async function $q(t) {
    return new Promise( (e, n) => {
        const s = t.transaction(Ws, "readonly").objectStore(Ws).getAll();
        s.onsuccess = () => e(s.result),
        s.onerror = () => n(s.error)
    }
    )
}
function zq(t) {
    return new Promise( (e, n) => {
        const s = t.transaction(Ws, "readwrite").objectStore(Ws).clear();
        s.onsuccess = () => e(),
        s.onerror = () => n(s.error)
    }
    )
}
async function nP(t, e) {
    return new Promise( (n, r) => {
        const o = t.transaction(lp, "readonly").objectStore(lp).get(e);
        o.onsuccess = () => n(o.result?.deployInfo),
        o.onerror = () => r(o.error)
    }
    )
}
async function Wq(t, e) {
    return new Promise( (n, r) => {
        const o = t.transaction(Ws, "readwrite").objectStore(Ws).delete(e);
        o.onsuccess = () => n(void 0),
        o.onerror = () => r(o.error)
    }
    )
}
async function Gq(t, e) {
    return new Promise( (n, r) => {
        const o = t.transaction(Tl, "readonly").objectStore(Tl).get(e);
        o.onsuccess = () => n(o.result),
        o.onerror = () => r(o.error)
    }
    )
}
async function rP(t, e) {
    return new Promise( (n, r) => {
        const o = t.transaction(Tl, "readwrite").objectStore(Tl).put(e);
        o.onsuccess = () => n(),
        o.onerror = () => r(o.error)
    }
    )
}
const K_ = S.memo( ({title: t, message: e}) => v.jsxs("div", {
    children: [v.jsx("h1", {
        className: "text-bolt-elements-textPrimary font-medium",
        children: t
    }), v.jsx("div", {
        className: "text-bolt-elements-textSecondary",
        children: e
    })]
}));
class qq {
    #t;
    #e = wt();
    #n = wt();
    #r = wt(!1);
    #i = [];
    #o = [];
    visibility = wt();
    canManage = wt();
    isForking = wt(!1);
    projectTooBig = wt(!1);
    frozen = wt(!1);
    setProjectId(e) {
        this.#t = e
    }
    getProjectId() {
        return this.#t
    }
    setSlug(e) {
        this.#e.set(e)
    }
    getSlug() {
        return this.#e.get()
    }
    getSlugStore() {
        return this.#e
    }
    waitForSlug() {
        return new Promise(e => {
            this.#e.subscribe(n => {
                n && e(n)
            }
            )
        }
        )
    }
    setEditedAt(e) {
        this.#n.set(e)
    }
    getEditedAt() {
        return this.#n.get()
    }
    setShouldFork(e, n) {
        if (typeof e == "boolean") {
            this.#r.set(e);
            return
        }
        const {canManage: r, currentUserIsOwner: i} = e;
        this.#r.set(!(r || i) || !!n)
    }
    shouldFork() {
        return this.#r.get()
    }
    registerConflictListener(e) {
        return this.#i.push(e),
        () => {
            this.#i = this.#i.filter(n => n !== e)
        }
    }
    conflictDetected(e, n) {
        this.#i.forEach(r => r(e, n))
    }
    registerForkListener(e) {
        return this.#o.push(e),
        () => {
            this.#o = this.#o.filter(n => n !== e)
        }
    }
    fork() {
        this.isForking.set(!0),
        this.#o.forEach(e => e())
    }
    setTooBig(e) {
        this.projectTooBig.set(e)
    }
    updateProject(e) {
        this.setProjectId(e.id),
        this.setEditedAt(e.editedAt),
        this.setSlug(e.slug),
        this.frozen.set(e.frozen),
        this.setShouldFork(e.access, e.frozen),
        this.canManage.set(e.access.canManage),
        this.visibility.set(e.visibility)
    }
}
const Ne = new qq;
class Kq {
    constructor(e, n) {
        this._workbenchStore = n,
        this.#t = e,
        n.isStreaming.subscribe(r => {
            r && (this.#e = !1)
        }
        )
    }
    #t;
    #e = !1;
    selectedFile = wt();
    streamingFile = wt(void 0);
    documents = ma({});
    currentDocument = sl([this.documents, this.selectedFile, this.streamingFile], (e, n, r) => {
        if (n)
            return n === r?.path ? {
                ...e[n],
                value: r.content,
                filePath: r.path
            } : e[n]
    }
    );
    setStreamingFile(e) {
        e.status === "start" ? (this.#e || this.setSelectedFileProgrammatically(e.path),
        this._workbenchStore.currentView.set("code"),
        this.#t.createInMemoryFileIfMissing(e.path),
        this.streamingFile.set(e)) : e.status === "stream" ? this.streamingFile.set(e) : e.status === "end" && this.streamingFile.set(void 0)
    }
    setDocuments(e) {
        const n = this.documents.value
          , r = {};
        for (const i in e) {
            const s = e[i];
            if (s && s.type !== "folder") {
                const o = n?.[i];
                r[i] = {
                    value: s.content,
                    filePath: i,
                    scroll: o?.scroll
                }
            }
        }
        this.documents.set(r)
    }
    setSelectedFile(e) {
        this.setSelectedFileProgrammatically(e),
        this.#e = !0
    }
    setSelectedFileProgrammatically(e) {
        this.selectedFile.set(e)
    }
    updateScrollPosition(e, n) {
        const i = this.documents.get()[e];
        i && this.documents.setKey(e, {
            ...i,
            scroll: n
        })
    }
    updateFile(e, n) {
        const i = this.documents.get()[e];
        if (!i)
            return;
        i.value !== n && this.documents.setKey(e, {
            ...i,
            value: n
        })
    }
}
function ai(t) {
    if (typeof t != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(t))
}
function gw(t, e) {
    for (var n = "", r = 0, i = -1, s = 0, o, a = 0; a <= t.length; ++a) {
        if (a < t.length)
            o = t.charCodeAt(a);
        else {
            if (o === 47)
                break;
            o = 47
        }
        if (o === 47) {
            if (!(i === a - 1 || s === 1))
                if (i !== a - 1 && s === 2) {
                    if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
                        if (n.length > 2) {
                            var l = n.lastIndexOf("/");
                            if (l !== n.length - 1) {
                                l === -1 ? (n = "",
                                r = 0) : (n = n.slice(0, l),
                                r = n.length - 1 - n.lastIndexOf("/")),
                                i = a,
                                s = 0;
                                continue
                            }
                        } else if (n.length === 2 || n.length === 1) {
                            n = "",
                            r = 0,
                            i = a,
                            s = 0;
                            continue
                        }
                    }
                    e && (n.length > 0 ? n += "/.." : n = "..",
                    r = 2)
                } else
                    n.length > 0 ? n += "/" + t.slice(i + 1, a) : n = t.slice(i + 1, a),
                    r = a - i - 1;
            i = a,
            s = 0
        } else
            o === 46 && s !== -1 ? ++s : s = -1
    }
    return n
}
function Yq(t, e) {
    var n = e.dir || e.root
      , r = e.base || (e.name || "") + (e.ext || "");
    return n ? n === e.root ? n + r : n + t + r : r
}
var ul = {
    resolve: function() {
        for (var e = "", n = !1, r, i = arguments.length - 1; i >= -1 && !n; i--) {
            var s;
            i >= 0 ? s = arguments[i] : (r === void 0 && (r = lu.cwd()),
            s = r),
            ai(s),
            s.length !== 0 && (e = s + "/" + e,
            n = s.charCodeAt(0) === 47)
        }
        return e = gw(e, !n),
        n ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : "."
    },
    normalize: function(e) {
        if (ai(e),
        e.length === 0)
            return ".";
        var n = e.charCodeAt(0) === 47
          , r = e.charCodeAt(e.length - 1) === 47;
        return e = gw(e, !n),
        e.length === 0 && !n && (e = "."),
        e.length > 0 && r && (e += "/"),
        n ? "/" + e : e
    },
    isAbsolute: function(e) {
        return ai(e),
        e.length > 0 && e.charCodeAt(0) === 47
    },
    join: function() {
        if (arguments.length === 0)
            return ".";
        for (var e, n = 0; n < arguments.length; ++n) {
            var r = arguments[n];
            ai(r),
            r.length > 0 && (e === void 0 ? e = r : e += "/" + r)
        }
        return e === void 0 ? "." : ul.normalize(e)
    },
    relative: function(e, n) {
        if (ai(e),
        ai(n),
        e === n || (e = ul.resolve(e),
        n = ul.resolve(n),
        e === n))
            return "";
        for (var r = 1; r < e.length && e.charCodeAt(r) === 47; ++r)
            ;
        for (var i = e.length, s = i - r, o = 1; o < n.length && n.charCodeAt(o) === 47; ++o)
            ;
        for (var a = n.length, l = a - o, c = s < l ? s : l, u = -1, h = 0; h <= c; ++h) {
            if (h === c) {
                if (l > c) {
                    if (n.charCodeAt(o + h) === 47)
                        return n.slice(o + h + 1);
                    if (h === 0)
                        return n.slice(o + h)
                } else
                    s > c && (e.charCodeAt(r + h) === 47 ? u = h : h === 0 && (u = 0));
                break
            }
            var d = e.charCodeAt(r + h)
              , f = n.charCodeAt(o + h);
            if (d !== f)
                break;
            d === 47 && (u = h)
        }
        var g = "";
        for (h = r + u + 1; h <= i; ++h)
            (h === i || e.charCodeAt(h) === 47) && (g.length === 0 ? g += ".." : g += "/..");
        return g.length > 0 ? g + n.slice(o + u) : (o += u,
        n.charCodeAt(o) === 47 && ++o,
        n.slice(o))
    },
    _makeLong: function(e) {
        return e
    },
    dirname: function(e) {
        if (ai(e),
        e.length === 0)
            return ".";
        for (var n = e.charCodeAt(0), r = n === 47, i = -1, s = !0, o = e.length - 1; o >= 1; --o)
            if (n = e.charCodeAt(o),
            n === 47) {
                if (!s) {
                    i = o;
                    break
                }
            } else
                s = !1;
        return i === -1 ? r ? "/" : "." : r && i === 1 ? "//" : e.slice(0, i)
    },
    basename: function(e, n) {
        if (n !== void 0 && typeof n != "string")
            throw new TypeError('"ext" argument must be a string');
        ai(e);
        var r = 0, i = -1, s = !0, o;
        if (n !== void 0 && n.length > 0 && n.length <= e.length) {
            if (n.length === e.length && n === e)
                return "";
            var a = n.length - 1
              , l = -1;
            for (o = e.length - 1; o >= 0; --o) {
                var c = e.charCodeAt(o);
                if (c === 47) {
                    if (!s) {
                        r = o + 1;
                        break
                    }
                } else
                    l === -1 && (s = !1,
                    l = o + 1),
                    a >= 0 && (c === n.charCodeAt(a) ? --a === -1 && (i = o) : (a = -1,
                    i = l))
            }
            return r === i ? i = l : i === -1 && (i = e.length),
            e.slice(r, i)
        } else {
            for (o = e.length - 1; o >= 0; --o)
                if (e.charCodeAt(o) === 47) {
                    if (!s) {
                        r = o + 1;
                        break
                    }
                } else
                    i === -1 && (s = !1,
                    i = o + 1);
            return i === -1 ? "" : e.slice(r, i)
        }
    },
    extname: function(e) {
        ai(e);
        for (var n = -1, r = 0, i = -1, s = !0, o = 0, a = e.length - 1; a >= 0; --a) {
            var l = e.charCodeAt(a);
            if (l === 47) {
                if (!s) {
                    r = a + 1;
                    break
                }
                continue
            }
            i === -1 && (s = !1,
            i = a + 1),
            l === 46 ? n === -1 ? n = a : o !== 1 && (o = 1) : n !== -1 && (o = -1)
        }
        return n === -1 || i === -1 || o === 0 || o === 1 && n === i - 1 && n === r + 1 ? "" : e.slice(n, i)
    },
    format: function(e) {
        if (e === null || typeof e != "object")
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
        return Yq("/", e)
    },
    parse: function(e) {
        ai(e);
        var n = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (e.length === 0)
            return n;
        var r = e.charCodeAt(0), i = r === 47, s;
        i ? (n.root = "/",
        s = 1) : s = 0;
        for (var o = -1, a = 0, l = -1, c = !0, u = e.length - 1, h = 0; u >= s; --u) {
            if (r = e.charCodeAt(u),
            r === 47) {
                if (!c) {
                    a = u + 1;
                    break
                }
                continue
            }
            l === -1 && (c = !1,
            l = u + 1),
            r === 46 ? o === -1 ? o = u : h !== 1 && (h = 1) : o !== -1 && (h = -1)
        }
        return o === -1 || l === -1 || h === 0 || h === 1 && o === l - 1 && o === a + 1 ? l !== -1 && (a === 0 && i ? n.base = n.name = e.slice(1, l) : n.base = n.name = e.slice(a, l)) : (a === 0 && i ? (n.name = e.slice(1, o),
        n.base = e.slice(1, l)) : (n.name = e.slice(a, o),
        n.base = e.slice(a, l)),
        n.ext = e.slice(o, l)),
        a > 0 ? n.dir = e.slice(0, a - 1) : i && (n.dir = "/"),
        n
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
ul.posix = ul;
var Hn = ul;
const Xq = Eh(Hn);
function _f(t, e) {
    if (!t)
        return null;
    const n = "utf8"
      , r = "binary"
      , i = e?.chunkLength ?? 24;
    let s = e?.chunkBegin ?? 0;
    if (e?.chunkBegin == null) {
        let o = _f(t, {
            chunkLength: i,
            chunkBegin: s
        });
        return o === n && (s = Math.max(0, Math.floor(t.length / 2) - i),
        o = _f(t, {
            chunkLength: i,
            chunkBegin: s
        }),
        o === n && (s = Math.max(0, t.length - i),
        o = _f(t, {
            chunkLength: i,
            chunkBegin: s
        }))),
        o
    } else {
        if (s = Qq(t, s),
        s === -1)
            return r;
        const o = Jq(t, Math.min(t.length, s + i));
        if (o > t.length)
            return r;
        const a = t.toString(n, s, o);
        for (let l = 0; l < a.length; ++l) {
            const c = a.charCodeAt(l);
            if (c === 65533 || c <= 8)
                return r
        }
        return n
    }
}
function Qq(t, e) {
    if (e === 0)
        return 0;
    if (!Zq(t[e]))
        return e;
    let n = e - 3;
    return n >= 0 && hl(t[n]) || (n = e - 2,
    n >= 0 && (hl(t[n]) || cp(t[n]))) || (n = e - 1,
    n >= 0 && (hl(t[n]) || cp(t[n]) || iP(t[n]))) ? n : -1
}
function Jq(t, e) {
    if (e === t.length)
        return e;
    let n = e - 3;
    if (n >= 0 && hl(t[n]))
        return e + 1;
    if (n = e - 2,
    n >= 0) {
        if (hl(t[n]))
            return e + 2;
        if (cp(t[n]))
            return e + 1
    }
    if (n = e - 1,
    n >= 0) {
        if (hl(t[n]))
            return e + 3;
        if (cp(t[n]))
            return e + 2;
        if (iP(t[n]))
            return e + 1
    }
    return e
}
function hl(t) {
    return t >> 3 === 30
}
function cp(t) {
    return t >> 4 === 14
}
function iP(t) {
    return t >> 5 === 6
}
function Zq(t) {
    return t >> 6 === 2
}
function _w(t, e) {
    const n = []
      , r = {};
    for (const [i,s] of eK(t)) {
        let o = !1;
        for (; n.length > 0; ) {
            const {folderPath: l, matched: c} = n[n.length - 1];
            if (i.startsWith(l)) {
                o = c;
                break
            }
            n.pop()
        }
        const a = !!e(s, o);
        a && (r[i] = s),
        s?.type === "folder" && n.push({
            folderPath: i + "/",
            matched: a
        })
    }
    return r
}
function eK(t) {
    const e = Object.entries(t);
    return e.sort( (n, r) => n[0].localeCompare(r[0])),
    e
}
const Y_ = [".contentlayer", ".svelte-kit", ".vitepress", ".nuxt", ".vscode", ".stackblitz", ".bolt"]
  , tK = /\/(\.[^\/]+)\//g;
function i0({fullPath: t, isDirectory: e}) {
    const n = t.slice(t.lastIndexOf("/") + 1);
    if (n === "node_modules" || t.includes("/node_modules/") || e && n.startsWith(".") && !Y_.includes(n))
        return !0;
    for (const [,r] of t.matchAll(tK))
        if (!Y_.includes(r))
            return !0;
    return !1
}
function nK(t) {
    let e = "", n = "", r, i;
    return (i = t.indexOf("Opera")) != -1 ? e = "Opera" : (i = t.indexOf("MSIE")) != -1 ? e = "Microsoft Internet Explorer" : (i = t.indexOf("Edg")) != -1 ? e = "Edge" : (i = t.indexOf("Chrome")) != -1 ? e = "Chrome" : (i = t.indexOf("Safari")) != -1 ? e = "Safari" : (i = t.indexOf("Firefox")) != -1 ? (e = "Firefox",
    n = t.substring(i + 8)) : (r = t.lastIndexOf(" ") + 1) < (i = t.lastIndexOf("/")) && (e = t.substring(r, i),
    navigator && e.toLowerCase() == e.toUpperCase() && (e = navigator.appName)),
    {
        browserName: e,
        fullVersion: n
    }
}
function bn(t, e) {
    if (!t)
        throw new Error(e ?? "Invariance failed")
}
function rK(t) {
    const {browserName: e, fullVersion: n} = nK(t);
    return ["Chrome", "Edge", "Opera"].includes(e) || e === "Firefox" && (bn(n),
    iK(n) > 118) ? "credentialless" : "require-corp"
}
function iK(t) {
    return parseInt(t.split(".")[0], 10)
}
let Nr = new Promise( () => {}
);
Object.assign(globalThis, {
    WEBCONTAINER_API_IFRAME_URL: KF
});
{
    const t = rK(navigator.userAgent);
    Nr = Promise.resolve().then( () => YF.boot({
        workdirName: gk,
        forwardPreviewErrors: !0,
        coep: t
    })).then(e => e)
}
function s0(t, e) {
    let n, r = [], i = Promise.resolve();
    const s = () => {
        n = self.setTimeout(async () => {
            await i,
            r.length > 0 && (i = Promise.resolve(e(r))),
            n = void 0,
            r = []
        }
        , t)
    }
    ;
    return (...o) => {
        r.push(o),
        n || s()
    }
}
function sP({blob: t, filename: e}) {
    const n = document.createElement("a");
    n.href = URL.createObjectURL(t),
    n.style.display = "none",
    n.download = e,
    document.body.appendChild(n),
    n.click(),
    document.body.removeChild(n),
    URL.revokeObjectURL(n.href)
}
const sK = [".eleventy.js"];
function oK(t) {
    return t.split(Hn.sep).some(n => n.startsWith(".") && !sK.includes(n))
}
new TextEncoder;
function jo(t) {
    throw new Error(`Unreachable: ${t}`)
}
const bw = nr("FilesStore")
  , aK = new TextDecoder("utf8",{
    fatal: !0
});
class Er extends Error {
    constructor(e, n="UNKNOWN") {
        super(e),
        this.code = n
    }
}
class lK {
    #t;
    #e = 0;
    #n;
    files = ma({});
    lockedFiles = sl(this.files, e => _w(e, (n, r) => n?.isLocked || r && !n?.isTargeted));
    targetedFiles = sl(this.files, e => _w(e, (n, r) => n?.isTargeted || r && !n?.isLocked));
    watchPersistence = void 0;
    hasPersistedChanges = !0;
    #r = null;
    #i = null;
    waitForImport = Promise.resolve();
    fileImportComplete = !0;
    #o = wt(!1);
    #l = wt(!1);
    #a;
    get filesCount() {
        return this.#e
    }
    constructor(e, n) {
        this.#t = e,
        this.watchPersistence ??= sl(n.isStreaming, r => !r),
        this.#f()
    }
    setInitialFiles(e) {
        this.#n = e
    }
    getInitialFiles() {
        return this.#n
    }
    getFile(e, n) {
        const r = this.files.get()[e];
        if (!r && n?.errorIfNotExists)
            throw new Er("File does not exist");
        if (r?.type === "file")
            return r
    }
    isAIAllowedToEdit(e) {
        const n = this.lockedFiles.get()
          , r = this.targetedFiles.get()
          , i = Object.keys(n).length
          , s = Object.keys(r).length;
        if (i === 0 && s === 0)
            return !0;
        const o = Pt(hi(e))
          , a = Hn.dirname(o);
        return s > 0 ? o in r || a in r : i > 0 ? !(o in n) && !(a in n) : !0
    }
    removeFromTargetOrLockedFiles(e) {
        this.#s(e, {
            isLocked: !1,
            isTargeted: !1
        })
    }
    setFileOrFolderTarget(e, n) {
        this.#s(e, {
            isTargeted: n,
            isLocked: !1
        })
    }
    setFileOrFolderLocked(e, n) {
        this.#s(e, {
            isTargeted: !1,
            isLocked: n
        })
    }
    resetAllLockedTargetedFiles() {
        const e = this.files.get()
          , n = Object.entries(e).filter(r => r[1] !== void 0);
        this.files.set(Object.fromEntries(n.map( ([r,i]) => [r, {
            ...i,
            isLocked: !1,
            isTargeted: !1
        }])))
    }
    #s(e, n) {
        const r = this.files.get()
          , i = Pt(hi(e))
          , s = r[i];
        if (!s)
            return;
        if (s.type === "file") {
            this.files.setKey(i, {
                ...s,
                ...n
            });
            return
        }
        const o = {
            ...r
        };
        for (const [a,l] of Object.entries(r))
            l?.type === "file" && a.startsWith(`${i}/`) && (o[a] = {
                ...l,
                ...n
            });
        this.files.set(o)
    }
    async rename(e, n) {
        const r = hi(e)
          , i = hi(n)
          , s = Pt(r)
          , o = Pt(i)
          , a = this.files.get()
          , l = a[s];
        if (!l)
            throw new Er(`Rename: '${r}' does not exists`);
        if (o in a)
            throw new Er(`Rename: '${i}' already exists`);
        if (o.startsWith(`${s}/`))
            throw new Er(`Rename: '${r}' cannot be moved inside itself`);
        const c = Hn.dirname(o);
        if (c !== jt && !(c in a))
            throw new Er(`Cannot rename '${r}' to '${i}' as directory '${Fn(c)}' does not exists`);
        if (i0({
            fullPath: o,
            isDirectory: l.type === "folder"
        }))
            throw new Er(`Cannot create '${o}': operation not allowed.`);
        const u = {};
        for (const [d,f] of Object.entries(a))
            if (d === s)
                u[o] = f;
            else if (d.startsWith(`${s}/`)) {
                const g = o + d.slice(s.length);
                u[g] = f
            } else
                f && (u[d] = f);
        this.files.set(u),
        await (await this.#t).fs.rename(r, i)
    }
    cut(e, n, r) {
        const i = this.#c(n, r);
        return this.rename(e, i)
    }
    async writeFile(e, n, r) {
        const i = hi(e)
          , s = Pt(i);
        if (r?.errorIfExists && s in this.files.get())
            throw new Er("File already exists","EEXISTS");
        if (r?.errorIfIgnored && i0({
            fullPath: s,
            isDirectory: !1
        }))
            throw new Er(`Cannot create '${e}': operation not allowed.`);
        if (typeof n.content == "string") {
            const l = Pt(i)
              , c = this.files.get()[l];
            this.#h(l, {
                ...n,
                isLocked: c?.isLocked ?? !1,
                isTargeted: c?.isTargeted ?? !1
            })
        }
        const o = Hn.dirname(i)
          , a = await this.#t;
        return await a.fs.mkdir(o, {
            recursive: !0
        }),
        a.fs.writeFile(i, n.content, {
            encoding: r?.encoding || null
        })
    }
    createInMemoryFileIfMissing(e) {
        this.files.get()[e] || this.files.setKey(e, {
            type: "file",
            content: "",
            isBinary: !1,
            isFakeBinary: !1,
            isLocked: !1,
            isTargeted: !1
        })
    }
    async copyFile(e, n) {
        const r = this.getFile(Pt(e), {
            errorIfNotExists: !0
        })
          , i = this.#c(n, "file");
        return await this.writeFile(i, r),
        i
    }
    async removeFile(e) {
        const n = hi(e);
        return this.files.setKey(Pt(n), void 0),
        (await this.#t).fs.rm(n, {
            force: !0
        })
    }
    async createDirectory(e, n) {
        const r = hi(e)
          , i = Pt(r);
        if (n?.errorIfExists && i in this.files.get())
            throw new Er("Folder already exists","EEXISTS");
        if (n?.errorIfIgnored && i0({
            fullPath: i,
            isDirectory: !0
        }))
            throw new Er(`Cannot create '${e}': operation not allowed.`);
        return this.#h(i, {
            type: "folder",
            isLocked: !1,
            isTargeted: !1
        }),
        (await this.#t).fs.mkdir(r, {
            recursive: !0
        })
    }
    async copyDirectory(e, n) {
        const r = this.#c(n, "folder")
          , i = Pt(e)
          , s = Object.entries(this.files.get());
        await this.createDirectory(r);
        for (const [o,a] of s) {
            if (o === i || !o.startsWith(`${i}/`))
                continue;
            const l = Fn(o.replace(e, r));
            a?.type === "file" ? await this.writeFile(l, a) : await this.createDirectory(l)
        }
    }
    async removeDirectory(e) {
        const n = hi(e)
          , r = Pt(n);
        for (const s of Object.keys(this.files.value ?? {}))
            (s === r || s.startsWith(`${r}/`)) && this.files.setKey(s, void 0);
        return (await this.#t).fs.rm(n, {
            recursive: !0,
            force: !0
        })
    }
    async importProjectFiles(e) {
        this.fileImportComplete = !1,
        this.waitForImport = this.#t.then(async n => {
            delete e[XF];
            const r = []
              , i = [];
            for (const s of Object.values(e))
                try {
                    if (s.type === "file") {
                        const {isBinary: o, fullPath: a, contents: l, blobId: c} = s;
                        if (r.push(this.writeFile(a, {
                            type: "file",
                            content: l,
                            isBinary: o,
                            isFakeBinary: o,
                            blobId: c
                        })),
                        o) {
                            const u = fetch(l).then(h => h.arrayBuffer()).then(h => {
                                n.fs.writeFile(a, new Uint8Array(h))
                            }
                            );
                            i.push(u)
                        }
                    } else {
                        const {fullPath: o} = s;
                        await n.fs.mkdir(o)
                    }
                } catch (o) {
                    ct.error(o && "message"in o ? o.message : JSON.stringify(o))
                }
            try {
                await Promise.all([...i, ...r])
            } catch (s) {
                "message"in s && ct.error(s.message)
            }
            this.setInitialFiles(e),
            this.fileImportComplete = !0
        }
        )
    }
    async saveFile(e, n) {
        const r = await this.#t;
        await this.waitForImport;
        try {
            const i = Hn.relative(r.workdir, e);
            if (!i)
                throw new Error(`EINVAL: invalid file path, write '${i}'`);
            const s = this.getFile(e);
            s === void 0 && jo("Expected file to be defined"),
            this.files.setKey(e, {
                ...s,
                content: n
            }),
            await r.fs.writeFile(i, n),
            bw.info("File updated")
        } catch (i) {
            throw bw.error(`Failed to update file content

${i}`),
            i
        }
    }
    async saveFileHistory(e) {
        const n = e === void 0 || !e.every(oK);
        this.#i && this.#i.abort(),
        n && Object.keys(this.files.get()).length > 0 && (this.#o.get() ? this.#l.set(!0) : this.#u()),
        this.hasPersistedChanges = !0,
        this.#i = null
    }
    #h(e, n) {
        const i = {
            ...this.files.get()
        };
        let s = e;
        for (; (s = Hn.dirname(s)) !== jt && !i[s]; )
            i[s] = {
                type: "folder",
                isLocked: !1,
                isTargeted: !1
            };
        i[e] = n,
        this.files.set(i)
    }
    async #u() {
        if (this.#o.set(!0),
        this.#l.set(!1),
        await this.waitForImport,
        Ne.isForking.get()) {
            this.#b();
            return
        }
        const e = Ne.getEditedAt();
        if (!e || Ne.shouldFork() || !Kt.getUser())
            return;
        let n = Ne.getSlug();
        n || (n = await Ne.waitForSlug()),
        bn(n);
        try {
            const r = await DP({
                slug: n,
                editedAt: e,
                files: this.files.get(),
                conflictHandler: (i, s) => Ne.conflictDetected(i, s),
                fork: async () => Ne.fork()
            });
            r && Ne.setEditedAt(r.editedAt)
        } catch (r) {
            console.error(r),
            this.#y(),
            this.#l.set(!1)
        }
        this.#o.set(!1),
        this.#l.get() && await this.#u()
    }
    async #f() {
        const e = await this.#t;
        e.internal.watchPaths({
            path: jt,
            include: Y_,
            exclude: ["**/node_modules"],
            includeContent: !0,
            ignoreHiddenFiles: !1,
            ignoreHiddenFolders: !1
        }, s0(100, this.#d.bind(this))),
        e.internal.watchPaths({
            include: [`${jt}/**`],
            exclude: ["**/node_modules", ".git"],
            includeContent: !0,
            ignoreHiddenFiles: !1,
            ignoreHiddenFolders: !0
        }, s0(100, this.#d.bind(this))),
        this.watchPersistence.subscribe(this.#p.bind(this))
    }
    #p(e) {
        this.#r?.(),
        e ? (this.saveFileHistory(),
        this.#r = this.files.listen(this.#m())) : this.#r = null
    }
    #m() {
        const e = s0(1e3, this.#g.bind(this));
        return (...n) => {
            this.hasPersistedChanges = !1,
            e(...n)
        }
    }
    #g(e) {
        this.saveFileHistory(e.map( ([,,n]) => n).filter(Boolean))
    }
    #d(e) {
        const n = e.flat(2)
          , r = [];
        for (const {type: i, path: s, buffer: o} of n) {
            const a = hi(s);
            switch (i) {
            case "add_dir":
                {
                    this.files.setKey(a, {
                        type: "folder",
                        isLocked: !1,
                        isTargeted: !1
                    });
                    break
                }
            case "remove_dir":
                {
                    this.files.setKey(a, void 0);
                    for (const [l] of Object.entries(this.files))
                        (l === a || l.startsWith(`${a}/`)) && this.files.setKey(l, void 0);
                    break
                }
            case "add_file":
            case "change":
                {
                    i === "add_file" && this.#e++;
                    let l = "";
                    const c = cK(o);
                    let u;
                    this.files.get()[a] && (u = this.files.get()[a]),
                    u?.isFakeBinary ? l = u.content : c || (l = this.#_(o)),
                    this.files.setKey(a, {
                        type: "file",
                        content: l,
                        isBinary: u?.isBinary ?? c,
                        isFakeBinary: u?.isFakeBinary ?? !1,
                        blobId: u?.blobId,
                        isLocked: u?.isLocked ?? !1,
                        isTargeted: u?.isTargeted ?? !1
                    });
                    break
                }
            case "remove_file":
                {
                    this.#e--,
                    this.files.setKey(a, void 0);
                    break
                }
            }
            r.push(s)
        }
        this.watchPersistence.get() || this.saveFileHistory(r)
    }
    #_(e) {
        if (!e || e.byteLength === 0)
            return "";
        try {
            return aK.decode(e)
        } catch (n) {
            return console.log(n),
            ""
        }
    }
    #b() {
        this.#a || (this.#a = Ne.isForking.subscribe(e => {
            e || (this.#u(),
            this.#a?.(),
            this.#a = void 0)
        }
        ))
    }
    #y() {
        ct.error("Failed to save project. You can download your project by clicking this notification", {
            autoClose: !1,
            closeOnClick: !0,
            onClick: async () => {
                let e = !0
                  , n = null
                  , r = !1
                  , i = !1;
                setTimeout( () => {
                    e && (n = ct.info("Creating a zip and downloading the project...", {
                        autoClose: !1
                    }),
                    setTimeout( () => {
                        r = !0,
                        i && ct.dismiss(n)
                    }
                    , 1e3))
                }
                , 500);
                const s = await Nr;
                await new Promise(a => setTimeout(a, 5500));
                const o = await s.internal.serialize(jt, {
                    format: "zip"
                });
                sP({
                    blob: new Blob([o],{
                        type: "application/zip"
                    }),
                    filename: `${Ne.getSlug()}-backup.zip`
                }),
                e = !1,
                n && r && ct.dismiss(n),
                i = !0
            }
        })
    }
    #c(e, n) {
        const r = Pt(e);
        if (!(n === "file" ? this.getFile(r) == null : Object.keys(this.files.get()).every(s => s !== r && !s.startsWith(`${r}/`)))) {
            let s = e.lastIndexOf(".");
            return s = s > 0 ? s : e.length,
            e = e.substring(0, s) + " copy" + e.substring(s),
            this.#c(e, n)
        }
        return e
    }
}
function cK(t) {
    return t === void 0 ? !1 : _f(uK(t), {
        chunkLength: 100
    }) === "binary"
}
function uK(t) {
    const e = new Uint8Array(t.buffer,t.byteOffset,t.byteLength);
    return Object.setPrototypeOf(e, yI.prototype),
    e
}
class hK {
    #t = new Map;
    #e;
    previews = wt([]);
    constructor(e) {
        this.#e = e,
        this.#n()
    }
    async #n() {
        (await this.#e).on("port", (n, r, i) => {
            let s = this.#t.get(n);
            if (r === "close" && s) {
                this.#t.delete(n),
                this.previews.set(this.previews.get().filter(a => a.port !== n));
                return
            }
            const o = this.previews.get();
            s || (s = {
                port: n,
                ready: r === "open",
                baseUrl: i
            },
            this.#t.set(n, s),
            o.push(s)),
            s.ready = r === "open",
            s.baseUrl = i,
            this.previews.set([...o])
        }
        )
    }
}
var ut;
(function(t) {
    t.assertEqual = i => i;
    function e(i) {}
    t.assertIs = e;
    function n(i) {
        throw new Error
    }
    t.assertNever = n,
    t.arrayToEnum = i => {
        const s = {};
        for (const o of i)
            s[o] = o;
        return s
    }
    ,
    t.getValidEnumValues = i => {
        const s = t.objectKeys(i).filter(a => typeof i[i[a]] != "number")
          , o = {};
        for (const a of s)
            o[a] = i[a];
        return t.objectValues(o)
    }
    ,
    t.objectValues = i => t.objectKeys(i).map(function(s) {
        return i[s]
    }),
    t.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => {
        const s = [];
        for (const o in i)
            Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
        return s
    }
    ,
    t.find = (i, s) => {
        for (const o of i)
            if (s(o))
                return o
    }
    ,
    t.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
    function r(i, s=" | ") {
        return i.map(o => typeof o == "string" ? `'${o}'` : o).join(s)
    }
    t.joinValues = r,
    t.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s
}
)(ut || (ut = {}));
var X_;
(function(t) {
    t.mergeShapes = (e, n) => ({
        ...e,
        ...n
    })
}
)(X_ || (X_ = {}));
const Pe = ut.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , Cs = t => {
    switch (typeof t) {
    case "undefined":
        return Pe.undefined;
    case "string":
        return Pe.string;
    case "number":
        return isNaN(t) ? Pe.nan : Pe.number;
    case "boolean":
        return Pe.boolean;
    case "function":
        return Pe.function;
    case "bigint":
        return Pe.bigint;
    case "symbol":
        return Pe.symbol;
    case "object":
        return Array.isArray(t) ? Pe.array : t === null ? Pe.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Pe.promise : typeof Map < "u" && t instanceof Map ? Pe.map : typeof Set < "u" && t instanceof Set ? Pe.set : typeof Date < "u" && t instanceof Date ? Pe.date : Pe.object;
    default:
        return Pe.unknown
    }
}
  , ye = ut.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
  , dK = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class mr extends Error {
    constructor(e) {
        super(),
        this.issues = [],
        this.addIssue = r => {
            this.issues = [...this.issues, r]
        }
        ,
        this.addIssues = (r=[]) => {
            this.issues = [...this.issues, ...r]
        }
        ;
        const n = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n,
        this.name = "ZodError",
        this.issues = e
    }
    get errors() {
        return this.issues
    }
    format(e) {
        const n = e || function(s) {
            return s.message
        }
          , r = {
            _errors: []
        }
          , i = s => {
            for (const o of s.issues)
                if (o.code === "invalid_union")
                    o.unionErrors.map(i);
                else if (o.code === "invalid_return_type")
                    i(o.returnTypeError);
                else if (o.code === "invalid_arguments")
                    i(o.argumentsError);
                else if (o.path.length === 0)
                    r._errors.push(n(o));
                else {
                    let a = r
                      , l = 0;
                    for (; l < o.path.length; ) {
                        const c = o.path[l];
                        l === o.path.length - 1 ? (a[c] = a[c] || {
                            _errors: []
                        },
                        a[c]._errors.push(n(o))) : a[c] = a[c] || {
                            _errors: []
                        },
                        a = a[c],
                        l++
                    }
                }
        }
        ;
        return i(this),
        r
    }
    static assert(e) {
        if (!(e instanceof mr))
            throw new Error(`Not a ZodError: ${e}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, ut.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(e=n => n.message) {
        const n = {}
          , r = [];
        for (const i of this.issues)
            i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [],
            n[i.path[0]].push(e(i))) : r.push(e(i));
        return {
            formErrors: r,
            fieldErrors: n
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
mr.create = t => new mr(t);
const Al = (t, e) => {
    let n;
    switch (t.code) {
    case ye.invalid_type:
        t.received === Pe.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
        break;
    case ye.invalid_literal:
        n = `Invalid literal value, expected ${JSON.stringify(t.expected, ut.jsonStringifyReplacer)}`;
        break;
    case ye.unrecognized_keys:
        n = `Unrecognized key(s) in object: ${ut.joinValues(t.keys, ", ")}`;
        break;
    case ye.invalid_union:
        n = "Invalid input";
        break;
    case ye.invalid_union_discriminator:
        n = `Invalid discriminator value. Expected ${ut.joinValues(t.options)}`;
        break;
    case ye.invalid_enum_value:
        n = `Invalid enum value. Expected ${ut.joinValues(t.options)}, received '${t.received}'`;
        break;
    case ye.invalid_arguments:
        n = "Invalid function arguments";
        break;
    case ye.invalid_return_type:
        n = "Invalid function return type";
        break;
    case ye.invalid_date:
        n = "Invalid date";
        break;
    case ye.invalid_string:
        typeof t.validation == "object" ? "includes"in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`,
        typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith"in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith"in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : ut.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
        break;
    case ye.too_small:
        t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
        break;
    case ye.too_big:
        t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
        break;
    case ye.custom:
        n = "Invalid input";
        break;
    case ye.invalid_intersection_types:
        n = "Intersection results could not be merged";
        break;
    case ye.not_multiple_of:
        n = `Number must be a multiple of ${t.multipleOf}`;
        break;
    case ye.not_finite:
        n = "Number must be finite";
        break;
    default:
        n = e.defaultError,
        ut.assertNever(t)
    }
    return {
        message: n
    }
}
;
let oP = Al;
function fK(t) {
    oP = t
}
function up() {
    return oP
}
const hp = t => {
    const {data: e, path: n, errorMaps: r, issueData: i} = t
      , s = [...n, ...i.path || []]
      , o = {
        ...i,
        path: s
    };
    if (i.message !== void 0)
        return {
            ...i,
            path: s,
            message: i.message
        };
    let a = "";
    const l = r.filter(c => !!c).slice().reverse();
    for (const c of l)
        a = c(o, {
            data: e,
            defaultError: a
        }).message;
    return {
        ...i,
        path: s,
        message: a
    }
}
  , pK = [];
function ke(t, e) {
    const n = up()
      , r = hp({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, n, n === Al ? void 0 : Al].filter(i => !!i)
    });
    t.common.issues.push(r)
}
class Ln {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(e, n) {
        const r = [];
        for (const i of n) {
            if (i.status === "aborted")
                return $e;
            i.status === "dirty" && e.dirty(),
            r.push(i.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
    static async mergeObjectAsync(e, n) {
        const r = [];
        for (const i of n) {
            const s = await i.key
              , o = await i.value;
            r.push({
                key: s,
                value: o
            })
        }
        return Ln.mergeObjectSync(e, r)
    }
    static mergeObjectSync(e, n) {
        const r = {};
        for (const i of n) {
            const {key: s, value: o} = i;
            if (s.status === "aborted" || o.status === "aborted")
                return $e;
            s.status === "dirty" && e.dirty(),
            o.status === "dirty" && e.dirty(),
            s.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[s.value] = o.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
}
const $e = Object.freeze({
    status: "aborted"
})
  , Qa = t => ({
    status: "dirty",
    value: t
})
  , zn = t => ({
    status: "valid",
    value: t
})
  , Q_ = t => t.status === "aborted"
  , J_ = t => t.status === "dirty"
  , xu = t => t.status === "valid"
  , Eu = t => typeof Promise < "u" && t instanceof Promise;
function dp(t, e, n, r) {
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return e.get(t)
}
function aP(t, e, n, r, i) {
    if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return e.set(t, n),
    n
}
var Fe;
(function(t) {
    t.errToObj = e => typeof e == "string" ? {
        message: e
    } : e || {},
    t.toString = e => typeof e == "string" ? e : e?.message
}
)(Fe || (Fe = {}));
var Sc, wc;
class Pi {
    constructor(e, n, r, i) {
        this._cachedPath = [],
        this.parent = e,
        this.data = n,
        this._path = r,
        this._key = i
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const yw = (t, e) => {
    if (xu(e))
        return {
            success: !0,
            data: e.value
        };
    if (!t.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const n = new mr(t.common.issues);
            return this._error = n,
            this._error
        }
    }
}
;
function Xe(t) {
    if (!t)
        return {};
    const {errorMap: e, invalid_type_error: n, required_error: r, description: i} = t;
    if (e && (n || r))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: i
    } : {
        errorMap: (o, a) => {
            var l, c;
            const {message: u} = t;
            return o.code === "invalid_enum_value" ? {
                message: u ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: (l = u ?? r) !== null && l !== void 0 ? l : a.defaultError
            } : o.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: (c = u ?? n) !== null && c !== void 0 ? c : a.defaultError
            }
        }
        ,
        description: i
    }
}
class Ze {
    constructor(e) {
        this.spa = this.safeParseAsync,
        this._def = e,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this)
    }
    get description() {
        return this._def.description
    }
    _getType(e) {
        return Cs(e.data)
    }
    _getOrReturnCtx(e, n) {
        return n || {
            common: e.parent.common,
            data: e.data,
            parsedType: Cs(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new Ln,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: Cs(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const n = this._parse(e);
        if (Eu(n))
            throw new Error("Synchronous parse encountered promise.");
        return n
    }
    _parseAsync(e) {
        const n = this._parse(e);
        return Promise.resolve(n)
    }
    parse(e, n) {
        const r = this.safeParse(e, n);
        if (r.success)
            return r.data;
        throw r.error
    }
    safeParse(e, n) {
        var r;
        const i = {
            common: {
                issues: [],
                async: (r = n?.async) !== null && r !== void 0 ? r : !1,
                contextualErrorMap: n?.errorMap
            },
            path: n?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Cs(e)
        }
          , s = this._parseSync({
            data: e,
            path: i.path,
            parent: i
        });
        return yw(i, s)
    }
    async parseAsync(e, n) {
        const r = await this.safeParseAsync(e, n);
        if (r.success)
            return r.data;
        throw r.error
    }
    async safeParseAsync(e, n) {
        const r = {
            common: {
                issues: [],
                contextualErrorMap: n?.errorMap,
                async: !0
            },
            path: n?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Cs(e)
        }
          , i = this._parse({
            data: e,
            path: r.path,
            parent: r
        })
          , s = await (Eu(i) ? i : Promise.resolve(i));
        return yw(r, s)
    }
    refine(e, n) {
        const r = i => typeof n == "string" || typeof n > "u" ? {
            message: n
        } : typeof n == "function" ? n(i) : n;
        return this._refinement( (i, s) => {
            const o = e(i)
              , a = () => s.addIssue({
                code: ye.custom,
                ...r(i)
            });
            return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (a(),
            !1)) : o ? !0 : (a(),
            !1)
        }
        )
    }
    refinement(e, n) {
        return this._refinement( (r, i) => e(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n),
        !1))
    }
    _refinement(e) {
        return new ti({
            schema: this,
            typeName: Ve.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    optional() {
        return ki.create(this, this._def)
    }
    nullable() {
        return Ys.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Qr.create(this, this._def)
    }
    promise() {
        return Rl.create(this, this._def)
    }
    or(e) {
        return Tu.create([this, e], this._def)
    }
    and(e) {
        return Au.create(this, e, this._def)
    }
    transform(e) {
        return new ti({
            ...Xe(this._def),
            schema: this,
            typeName: Ve.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default(e) {
        const n = typeof e == "function" ? e : () => e;
        return new Du({
            ...Xe(this._def),
            innerType: this,
            defaultValue: n,
            typeName: Ve.ZodDefault
        })
    }
    brand() {
        return new zv({
            typeName: Ve.ZodBranded,
            type: this,
            ...Xe(this._def)
        })
    }
    catch(e) {
        const n = typeof e == "function" ? e : () => e;
        return new Lu({
            ...Xe(this._def),
            innerType: this,
            catchValue: n,
            typeName: Ve.ZodCatch
        })
    }
    describe(e) {
        const n = this.constructor;
        return new n({
            ...this._def,
            description: e
        })
    }
    pipe(e) {
        return Hh.create(this, e)
    }
    readonly() {
        return Ou.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const mK = /^c[^\s-]{8,}$/i
  , gK = /^[0-9a-z]+$/
  , _K = /^[0-9A-HJKMNP-TV-Z]{26}$/
  , bK = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , yK = /^[a-z0-9_-]{21}$/i
  , vK = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , xK = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , EK = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let o0;
const SK = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , wK = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
  , CK = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , lP = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , TK = new RegExp(`^${lP}$`);
function cP(t) {
    let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`),
    e
}
function AK(t) {
    return new RegExp(`^${cP(t)}$`)
}
function uP(t) {
    let e = `${lP}T${cP(t)}`;
    const n = [];
    return n.push(t.local ? "Z?" : "Z"),
    t.offset && n.push("([+-]\\d{2}:?\\d{2})"),
    e = `${e}(${n.join("|")})`,
    new RegExp(`^${e}$`)
}
function kK(t, e) {
    return !!((e === "v4" || !e) && SK.test(t) || (e === "v6" || !e) && wK.test(t))
}
class qr extends Ze {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)),
        this._getType(e) !== Pe.string) {
            const s = this._getOrReturnCtx(e);
            return ke(s, {
                code: ye.invalid_type,
                expected: Pe.string,
                received: s.parsedType
            }),
            $e
        }
        const r = new Ln;
        let i;
        for (const s of this._def.checks)
            if (s.kind === "min")
                e.data.length < s.value && (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.too_small,
                    minimum: s.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "max")
                e.data.length > s.value && (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.too_big,
                    maximum: s.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "length") {
                const o = e.data.length > s.value
                  , a = e.data.length < s.value;
                (o || a) && (i = this._getOrReturnCtx(e, i),
                o ? ke(i, {
                    code: ye.too_big,
                    maximum: s.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: s.message
                }) : a && ke(i, {
                    code: ye.too_small,
                    minimum: s.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: s.message
                }),
                r.dirty())
            } else if (s.kind === "email")
                xK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "email",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "emoji")
                o0 || (o0 = new RegExp(EK,"u")),
                o0.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "emoji",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "uuid")
                bK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "uuid",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "nanoid")
                yK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "nanoid",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "cuid")
                mK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "cuid",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "cuid2")
                gK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "cuid2",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "ulid")
                _K.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "ulid",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty());
            else if (s.kind === "url")
                try {
                    new URL(e.data)
                } catch {
                    i = this._getOrReturnCtx(e, i),
                    ke(i, {
                        validation: "url",
                        code: ye.invalid_string,
                        message: s.message
                    }),
                    r.dirty()
                }
            else
                s.kind === "regex" ? (s.regex.lastIndex = 0,
                s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "regex",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.invalid_string,
                    validation: {
                        includes: s.value,
                        position: s.position
                    },
                    message: s.message
                }),
                r.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.invalid_string,
                    validation: {
                        startsWith: s.value
                    },
                    message: s.message
                }),
                r.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.invalid_string,
                    validation: {
                        endsWith: s.value
                    },
                    message: s.message
                }),
                r.dirty()) : s.kind === "datetime" ? uP(s).test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.invalid_string,
                    validation: "datetime",
                    message: s.message
                }),
                r.dirty()) : s.kind === "date" ? TK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.invalid_string,
                    validation: "date",
                    message: s.message
                }),
                r.dirty()) : s.kind === "time" ? AK(s).test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    code: ye.invalid_string,
                    validation: "time",
                    message: s.message
                }),
                r.dirty()) : s.kind === "duration" ? vK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "duration",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty()) : s.kind === "ip" ? kK(e.data, s.version) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "ip",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty()) : s.kind === "base64" ? CK.test(e.data) || (i = this._getOrReturnCtx(e, i),
                ke(i, {
                    validation: "base64",
                    code: ye.invalid_string,
                    message: s.message
                }),
                r.dirty()) : ut.assertNever(s);
        return {
            status: r.value,
            value: e.data
        }
    }
    _regex(e, n, r) {
        return this.refinement(i => e.test(i), {
            validation: n,
            code: ye.invalid_string,
            ...Fe.errToObj(r)
        })
    }
    _addCheck(e) {
        return new qr({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...Fe.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...Fe.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...Fe.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...Fe.errToObj(e)
        })
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...Fe.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...Fe.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...Fe.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...Fe.errToObj(e)
        })
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...Fe.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...Fe.errToObj(e)
        })
    }
    datetime(e) {
        var n, r;
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof e?.precision > "u" ? null : e?.precision,
            offset: (n = e?.offset) !== null && n !== void 0 ? n : !1,
            local: (r = e?.local) !== null && r !== void 0 ? r : !1,
            ...Fe.errToObj(e?.message)
        })
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        })
    }
    time(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: typeof e?.precision > "u" ? null : e?.precision,
            ...Fe.errToObj(e?.message)
        })
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...Fe.errToObj(e)
        })
    }
    regex(e, n) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...Fe.errToObj(n)
        })
    }
    includes(e, n) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: n?.position,
            ...Fe.errToObj(n?.message)
        })
    }
    startsWith(e, n) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...Fe.errToObj(n)
        })
    }
    endsWith(e, n) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...Fe.errToObj(n)
        })
    }
    min(e, n) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...Fe.errToObj(n)
        })
    }
    max(e, n) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...Fe.errToObj(n)
        })
    }
    length(e, n) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...Fe.errToObj(n)
        })
    }
    nonempty(e) {
        return this.min(1, Fe.errToObj(e))
    }
    trim() {
        return new qr({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new qr({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new qr({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(e => e.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(e => e.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(e => e.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(e => e.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }
    get isBase64() {
        return !!this._def.checks.find(e => e.kind === "base64")
    }
    get minLength() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
}
qr.create = t => {
    var e;
    return new qr({
        checks: [],
        typeName: Ve.ZodString,
        coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
        ...Xe(t)
    })
}
;
function RK(t, e) {
    const n = (t.toString().split(".")[1] || "").length
      , r = (e.toString().split(".")[1] || "").length
      , i = n > r ? n : r
      , s = parseInt(t.toFixed(i).replace(".", ""))
      , o = parseInt(e.toFixed(i).replace(".", ""));
    return s % o / Math.pow(10, i)
}
class Gs extends Ze {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)),
        this._getType(e) !== Pe.number) {
            const s = this._getOrReturnCtx(e);
            return ke(s, {
                code: ye.invalid_type,
                expected: Pe.number,
                received: s.parsedType
            }),
            $e
        }
        let r;
        const i = new Ln;
        for (const s of this._def.checks)
            s.kind === "int" ? ut.isInteger(e.data) || (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.invalid_type,
                expected: "integer",
                received: "float",
                message: s.message
            }),
            i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.too_small,
                minimum: s.value,
                type: "number",
                inclusive: s.inclusive,
                exact: !1,
                message: s.message
            }),
            i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.too_big,
                maximum: s.value,
                type: "number",
                inclusive: s.inclusive,
                exact: !1,
                message: s.message
            }),
            i.dirty()) : s.kind === "multipleOf" ? RK(e.data, s.value) !== 0 && (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.not_multiple_of,
                multipleOf: s.value,
                message: s.message
            }),
            i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.not_finite,
                message: s.message
            }),
            i.dirty()) : ut.assertNever(s);
        return {
            status: i.value,
            value: e.data
        }
    }
    gte(e, n) {
        return this.setLimit("min", e, !0, Fe.toString(n))
    }
    gt(e, n) {
        return this.setLimit("min", e, !1, Fe.toString(n))
    }
    lte(e, n) {
        return this.setLimit("max", e, !0, Fe.toString(n))
    }
    lt(e, n) {
        return this.setLimit("max", e, !1, Fe.toString(n))
    }
    setLimit(e, n, r, i) {
        return new Gs({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: n,
                inclusive: r,
                message: Fe.toString(i)
            }]
        })
    }
    _addCheck(e) {
        return new Gs({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: Fe.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Fe.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Fe.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Fe.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Fe.toString(e)
        })
    }
    multipleOf(e, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Fe.toString(n)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: Fe.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Fe.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Fe.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && ut.isInteger(e.value))
    }
    get isFinite() {
        let e = null
          , n = null;
        for (const r of this._def.checks) {
            if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
                return !0;
            r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value)
        }
        return Number.isFinite(n) && Number.isFinite(e)
    }
}
Gs.create = t => new Gs({
    checks: [],
    typeName: Ve.ZodNumber,
    coerce: t?.coerce || !1,
    ...Xe(t)
});
class qs extends Ze {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce && (e.data = BigInt(e.data)),
        this._getType(e) !== Pe.bigint) {
            const s = this._getOrReturnCtx(e);
            return ke(s, {
                code: ye.invalid_type,
                expected: Pe.bigint,
                received: s.parsedType
            }),
            $e
        }
        let r;
        const i = new Ln;
        for (const s of this._def.checks)
            s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.too_small,
                type: "bigint",
                minimum: s.value,
                inclusive: s.inclusive,
                message: s.message
            }),
            i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.too_big,
                type: "bigint",
                maximum: s.value,
                inclusive: s.inclusive,
                message: s.message
            }),
            i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r),
            ke(r, {
                code: ye.not_multiple_of,
                multipleOf: s.value,
                message: s.message
            }),
            i.dirty()) : ut.assertNever(s);
        return {
            status: i.value,
            value: e.data
        }
    }
    gte(e, n) {
        return this.setLimit("min", e, !0, Fe.toString(n))
    }
    gt(e, n) {
        return this.setLimit("min", e, !1, Fe.toString(n))
    }
    lte(e, n) {
        return this.setLimit("max", e, !0, Fe.toString(n))
    }
    lt(e, n) {
        return this.setLimit("max", e, !1, Fe.toString(n))
    }
    setLimit(e, n, r, i) {
        return new qs({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: n,
                inclusive: r,
                message: Fe.toString(i)
            }]
        })
    }
    _addCheck(e) {
        return new qs({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Fe.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Fe.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Fe.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Fe.toString(e)
        })
    }
    multipleOf(e, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Fe.toString(n)
        })
    }
    get minValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
}
qs.create = t => {
    var e;
    return new qs({
        checks: [],
        typeName: Ve.ZodBigInt,
        coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
        ...Xe(t)
    })
}
;
class Su extends Ze {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data),
        this._getType(e) !== Pe.boolean) {
            const r = this._getOrReturnCtx(e);
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.boolean,
                received: r.parsedType
            }),
            $e
        }
        return zn(e.data)
    }
}
Su.create = t => new Su({
    typeName: Ve.ZodBoolean,
    coerce: t?.coerce || !1,
    ...Xe(t)
});
class Jo extends Ze {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)),
        this._getType(e) !== Pe.date) {
            const s = this._getOrReturnCtx(e);
            return ke(s, {
                code: ye.invalid_type,
                expected: Pe.date,
                received: s.parsedType
            }),
            $e
        }
        if (isNaN(e.data.getTime())) {
            const s = this._getOrReturnCtx(e);
            return ke(s, {
                code: ye.invalid_date
            }),
            $e
        }
        const r = new Ln;
        let i;
        for (const s of this._def.checks)
            s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i),
            ke(i, {
                code: ye.too_small,
                message: s.message,
                inclusive: !0,
                exact: !1,
                minimum: s.value,
                type: "date"
            }),
            r.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i),
            ke(i, {
                code: ye.too_big,
                message: s.message,
                inclusive: !0,
                exact: !1,
                maximum: s.value,
                type: "date"
            }),
            r.dirty()) : ut.assertNever(s);
        return {
            status: r.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new Jo({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, n) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: Fe.toString(n)
        })
    }
    max(e, n) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: Fe.toString(n)
        })
    }
    get minDate() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e != null ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const n of this._def.checks)
            n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e != null ? new Date(e) : null
    }
}
Jo.create = t => new Jo({
    checks: [],
    coerce: t?.coerce || !1,
    typeName: Ve.ZodDate,
    ...Xe(t)
});
class fp extends Ze {
    _parse(e) {
        if (this._getType(e) !== Pe.symbol) {
            const r = this._getOrReturnCtx(e);
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.symbol,
                received: r.parsedType
            }),
            $e
        }
        return zn(e.data)
    }
}
fp.create = t => new fp({
    typeName: Ve.ZodSymbol,
    ...Xe(t)
});
class wu extends Ze {
    _parse(e) {
        if (this._getType(e) !== Pe.undefined) {
            const r = this._getOrReturnCtx(e);
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.undefined,
                received: r.parsedType
            }),
            $e
        }
        return zn(e.data)
    }
}
wu.create = t => new wu({
    typeName: Ve.ZodUndefined,
    ...Xe(t)
});
class Cu extends Ze {
    _parse(e) {
        if (this._getType(e) !== Pe.null) {
            const r = this._getOrReturnCtx(e);
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.null,
                received: r.parsedType
            }),
            $e
        }
        return zn(e.data)
    }
}
Cu.create = t => new Cu({
    typeName: Ve.ZodNull,
    ...Xe(t)
});
class kl extends Ze {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(e) {
        return zn(e.data)
    }
}
kl.create = t => new kl({
    typeName: Ve.ZodAny,
    ...Xe(t)
});
class Ho extends Ze {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(e) {
        return zn(e.data)
    }
}
Ho.create = t => new Ho({
    typeName: Ve.ZodUnknown,
    ...Xe(t)
});
class is extends Ze {
    _parse(e) {
        const n = this._getOrReturnCtx(e);
        return ke(n, {
            code: ye.invalid_type,
            expected: Pe.never,
            received: n.parsedType
        }),
        $e
    }
}
is.create = t => new is({
    typeName: Ve.ZodNever,
    ...Xe(t)
});
class pp extends Ze {
    _parse(e) {
        if (this._getType(e) !== Pe.undefined) {
            const r = this._getOrReturnCtx(e);
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.void,
                received: r.parsedType
            }),
            $e
        }
        return zn(e.data)
    }
}
pp.create = t => new pp({
    typeName: Ve.ZodVoid,
    ...Xe(t)
});
class Qr extends Ze {
    _parse(e) {
        const {ctx: n, status: r} = this._processInputParams(e)
          , i = this._def;
        if (n.parsedType !== Pe.array)
            return ke(n, {
                code: ye.invalid_type,
                expected: Pe.array,
                received: n.parsedType
            }),
            $e;
        if (i.exactLength !== null) {
            const o = n.data.length > i.exactLength.value
              , a = n.data.length < i.exactLength.value;
            (o || a) && (ke(n, {
                code: o ? ye.too_big : ye.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: o ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }),
            r.dirty())
        }
        if (i.minLength !== null && n.data.length < i.minLength.value && (ke(n, {
            code: ye.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }),
        r.dirty()),
        i.maxLength !== null && n.data.length > i.maxLength.value && (ke(n, {
            code: ye.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
        }),
        r.dirty()),
        n.common.async)
            return Promise.all([...n.data].map( (o, a) => i.type._parseAsync(new Pi(n,o,n.path,a)))).then(o => Ln.mergeArray(r, o));
        const s = [...n.data].map( (o, a) => i.type._parseSync(new Pi(n,o,n.path,a)));
        return Ln.mergeArray(r, s)
    }
    get element() {
        return this._def.type
    }
    min(e, n) {
        return new Qr({
            ...this._def,
            minLength: {
                value: e,
                message: Fe.toString(n)
            }
        })
    }
    max(e, n) {
        return new Qr({
            ...this._def,
            maxLength: {
                value: e,
                message: Fe.toString(n)
            }
        })
    }
    length(e, n) {
        return new Qr({
            ...this._def,
            exactLength: {
                value: e,
                message: Fe.toString(n)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Qr.create = (t, e) => new Qr({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Ve.ZodArray,
    ...Xe(e)
});
function Ua(t) {
    if (t instanceof Mt) {
        const e = {};
        for (const n in t.shape) {
            const r = t.shape[n];
            e[n] = ki.create(Ua(r))
        }
        return new Mt({
            ...t._def,
            shape: () => e
        })
    } else
        return t instanceof Qr ? new Qr({
            ...t._def,
            type: Ua(t.element)
        }) : t instanceof ki ? ki.create(Ua(t.unwrap())) : t instanceof Ys ? Ys.create(Ua(t.unwrap())) : t instanceof Di ? Di.create(t.items.map(e => Ua(e))) : t
}
class Mt extends Ze {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const e = this._def.shape()
          , n = ut.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: n
        }
    }
    _parse(e) {
        if (this._getType(e) !== Pe.object) {
            const c = this._getOrReturnCtx(e);
            return ke(c, {
                code: ye.invalid_type,
                expected: Pe.object,
                received: c.parsedType
            }),
            $e
        }
        const {status: r, ctx: i} = this._processInputParams(e)
          , {shape: s, keys: o} = this._getCached()
          , a = [];
        if (!(this._def.catchall instanceof is && this._def.unknownKeys === "strip"))
            for (const c in i.data)
                o.includes(c) || a.push(c);
        const l = [];
        for (const c of o) {
            const u = s[c]
              , h = i.data[c];
            l.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: u._parse(new Pi(i,h,i.path,c)),
                alwaysSet: c in i.data
            })
        }
        if (this._def.catchall instanceof is) {
            const c = this._def.unknownKeys;
            if (c === "passthrough")
                for (const u of a)
                    l.push({
                        key: {
                            status: "valid",
                            value: u
                        },
                        value: {
                            status: "valid",
                            value: i.data[u]
                        }
                    });
            else if (c === "strict")
                a.length > 0 && (ke(i, {
                    code: ye.unrecognized_keys,
                    keys: a
                }),
                r.dirty());
            else if (c !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const c = this._def.catchall;
            for (const u of a) {
                const h = i.data[u];
                l.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: c._parse(new Pi(i,h,i.path,u)),
                    alwaysSet: u in i.data
                })
            }
        }
        return i.common.async ? Promise.resolve().then(async () => {
            const c = [];
            for (const u of l) {
                const h = await u.key
                  , d = await u.value;
                c.push({
                    key: h,
                    value: d,
                    alwaysSet: u.alwaysSet
                })
            }
            return c
        }
        ).then(c => Ln.mergeObjectSync(r, c)) : Ln.mergeObjectSync(r, l)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return Fe.errToObj,
        new Mt({
            ...this._def,
            unknownKeys: "strict",
            ...e !== void 0 ? {
                errorMap: (n, r) => {
                    var i, s, o, a;
                    const l = (o = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
                    return n.code === "unrecognized_keys" ? {
                        message: (a = Fe.errToObj(e).message) !== null && a !== void 0 ? a : l
                    } : {
                        message: l
                    }
                }
            } : {}
        })
    }
    strip() {
        return new Mt({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new Mt({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new Mt({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new Mt({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: Ve.ZodObject
        })
    }
    setKey(e, n) {
        return this.augment({
            [e]: n
        })
    }
    catchall(e) {
        return new Mt({
            ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const n = {};
        return ut.objectKeys(e).forEach(r => {
            e[r] && this.shape[r] && (n[r] = this.shape[r])
        }
        ),
        new Mt({
            ...this._def,
            shape: () => n
        })
    }
    omit(e) {
        const n = {};
        return ut.objectKeys(this.shape).forEach(r => {
            e[r] || (n[r] = this.shape[r])
        }
        ),
        new Mt({
            ...this._def,
            shape: () => n
        })
    }
    deepPartial() {
        return Ua(this)
    }
    partial(e) {
        const n = {};
        return ut.objectKeys(this.shape).forEach(r => {
            const i = this.shape[r];
            e && !e[r] ? n[r] = i : n[r] = i.optional()
        }
        ),
        new Mt({
            ...this._def,
            shape: () => n
        })
    }
    required(e) {
        const n = {};
        return ut.objectKeys(this.shape).forEach(r => {
            if (e && !e[r])
                n[r] = this.shape[r];
            else {
                let s = this.shape[r];
                for (; s instanceof ki; )
                    s = s._def.innerType;
                n[r] = s
            }
        }
        ),
        new Mt({
            ...this._def,
            shape: () => n
        })
    }
    keyof() {
        return hP(ut.objectKeys(this.shape))
    }
}
Mt.create = (t, e) => new Mt({
    shape: () => t,
    unknownKeys: "strip",
    catchall: is.create(),
    typeName: Ve.ZodObject,
    ...Xe(e)
});
Mt.strictCreate = (t, e) => new Mt({
    shape: () => t,
    unknownKeys: "strict",
    catchall: is.create(),
    typeName: Ve.ZodObject,
    ...Xe(e)
});
Mt.lazycreate = (t, e) => new Mt({
    shape: t,
    unknownKeys: "strip",
    catchall: is.create(),
    typeName: Ve.ZodObject,
    ...Xe(e)
});
class Tu extends Ze {
    _parse(e) {
        const {ctx: n} = this._processInputParams(e)
          , r = this._def.options;
        function i(s) {
            for (const a of s)
                if (a.result.status === "valid")
                    return a.result;
            for (const a of s)
                if (a.result.status === "dirty")
                    return n.common.issues.push(...a.ctx.common.issues),
                    a.result;
            const o = s.map(a => new mr(a.ctx.common.issues));
            return ke(n, {
                code: ye.invalid_union,
                unionErrors: o
            }),
            $e
        }
        if (n.common.async)
            return Promise.all(r.map(async s => {
                const o = {
                    ...n,
                    common: {
                        ...n.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await s._parseAsync({
                        data: n.data,
                        path: n.path,
                        parent: o
                    }),
                    ctx: o
                }
            }
            )).then(i);
        {
            let s;
            const o = [];
            for (const l of r) {
                const c = {
                    ...n,
                    common: {
                        ...n.common,
                        issues: []
                    },
                    parent: null
                }
                  , u = l._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: c
                });
                if (u.status === "valid")
                    return u;
                u.status === "dirty" && !s && (s = {
                    result: u,
                    ctx: c
                }),
                c.common.issues.length && o.push(c.common.issues)
            }
            if (s)
                return n.common.issues.push(...s.ctx.common.issues),
                s.result;
            const a = o.map(l => new mr(l));
            return ke(n, {
                code: ye.invalid_union,
                unionErrors: a
            }),
            $e
        }
    }
    get options() {
        return this._def.options
    }
}
Tu.create = (t, e) => new Tu({
    options: t,
    typeName: Ve.ZodUnion,
    ...Xe(e)
});
const Fi = t => t instanceof Ru ? Fi(t.schema) : t instanceof ti ? Fi(t.innerType()) : t instanceof Iu ? [t.value] : t instanceof Ks ? t.options : t instanceof Pu ? ut.objectValues(t.enum) : t instanceof Du ? Fi(t._def.innerType) : t instanceof wu ? [void 0] : t instanceof Cu ? [null] : t instanceof ki ? [void 0, ...Fi(t.unwrap())] : t instanceof Ys ? [null, ...Fi(t.unwrap())] : t instanceof zv || t instanceof Ou ? Fi(t.unwrap()) : t instanceof Lu ? Fi(t._def.innerType) : [];
class Mm extends Ze {
    _parse(e) {
        const {ctx: n} = this._processInputParams(e);
        if (n.parsedType !== Pe.object)
            return ke(n, {
                code: ye.invalid_type,
                expected: Pe.object,
                received: n.parsedType
            }),
            $e;
        const r = this.discriminator
          , i = n.data[r]
          , s = this.optionsMap.get(i);
        return s ? n.common.async ? s._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }) : s._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }) : (ke(n, {
            code: ye.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [r]
        }),
        $e)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(e, n, r) {
        const i = new Map;
        for (const s of n) {
            const o = Fi(s.shape[e]);
            if (!o.length)
                throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const a of o) {
                if (i.has(a))
                    throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
                i.set(a, s)
            }
        }
        return new Mm({
            typeName: Ve.ZodDiscriminatedUnion,
            discriminator: e,
            options: n,
            optionsMap: i,
            ...Xe(r)
        })
    }
}
function Z_(t, e) {
    const n = Cs(t)
      , r = Cs(e);
    if (t === e)
        return {
            valid: !0,
            data: t
        };
    if (n === Pe.object && r === Pe.object) {
        const i = ut.objectKeys(e)
          , s = ut.objectKeys(t).filter(a => i.indexOf(a) !== -1)
          , o = {
            ...t,
            ...e
        };
        for (const a of s) {
            const l = Z_(t[a], e[a]);
            if (!l.valid)
                return {
                    valid: !1
                };
            o[a] = l.data
        }
        return {
            valid: !0,
            data: o
        }
    } else if (n === Pe.array && r === Pe.array) {
        if (t.length !== e.length)
            return {
                valid: !1
            };
        const i = [];
        for (let s = 0; s < t.length; s++) {
            const o = t[s]
              , a = e[s]
              , l = Z_(o, a);
            if (!l.valid)
                return {
                    valid: !1
                };
            i.push(l.data)
        }
        return {
            valid: !0,
            data: i
        }
    } else
        return n === Pe.date && r === Pe.date && +t == +e ? {
            valid: !0,
            data: t
        } : {
            valid: !1
        }
}
class Au extends Ze {
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e)
          , i = (s, o) => {
            if (Q_(s) || Q_(o))
                return $e;
            const a = Z_(s.value, o.value);
            return a.valid ? ((J_(s) || J_(o)) && n.dirty(),
            {
                status: n.value,
                value: a.data
            }) : (ke(r, {
                code: ye.invalid_intersection_types
            }),
            $e)
        }
        ;
        return r.common.async ? Promise.all([this._def.left._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        })]).then( ([s,o]) => i(s, o)) : i(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }))
    }
}
Au.create = (t, e, n) => new Au({
    left: t,
    right: e,
    typeName: Ve.ZodIntersection,
    ...Xe(n)
});
class Di extends Ze {
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== Pe.array)
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.array,
                received: r.parsedType
            }),
            $e;
        if (r.data.length < this._def.items.length)
            return ke(r, {
                code: ye.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            $e;
        !this._def.rest && r.data.length > this._def.items.length && (ke(r, {
            code: ye.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        n.dirty());
        const s = [...r.data].map( (o, a) => {
            const l = this._def.items[a] || this._def.rest;
            return l ? l._parse(new Pi(r,o,r.path,a)) : null
        }
        ).filter(o => !!o);
        return r.common.async ? Promise.all(s).then(o => Ln.mergeArray(n, o)) : Ln.mergeArray(n, s)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new Di({
            ...this._def,
            rest: e
        })
    }
}
Di.create = (t, e) => {
    if (!Array.isArray(t))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Di({
        items: t,
        typeName: Ve.ZodTuple,
        rest: null,
        ...Xe(e)
    })
}
;
class ku extends Ze {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== Pe.object)
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.object,
                received: r.parsedType
            }),
            $e;
        const i = []
          , s = this._def.keyType
          , o = this._def.valueType;
        for (const a in r.data)
            i.push({
                key: s._parse(new Pi(r,a,r.path,a)),
                value: o._parse(new Pi(r,r.data[a],r.path,a)),
                alwaysSet: a in r.data
            });
        return r.common.async ? Ln.mergeObjectAsync(n, i) : Ln.mergeObjectSync(n, i)
    }
    get element() {
        return this._def.valueType
    }
    static create(e, n, r) {
        return n instanceof Ze ? new ku({
            keyType: e,
            valueType: n,
            typeName: Ve.ZodRecord,
            ...Xe(r)
        }) : new ku({
            keyType: qr.create(),
            valueType: e,
            typeName: Ve.ZodRecord,
            ...Xe(n)
        })
    }
}
class mp extends Ze {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== Pe.map)
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.map,
                received: r.parsedType
            }),
            $e;
        const i = this._def.keyType
          , s = this._def.valueType
          , o = [...r.data.entries()].map( ([a,l], c) => ({
            key: i._parse(new Pi(r,a,r.path,[c, "key"])),
            value: s._parse(new Pi(r,l,r.path,[c, "value"]))
        }));
        if (r.common.async) {
            const a = new Map;
            return Promise.resolve().then(async () => {
                for (const l of o) {
                    const c = await l.key
                      , u = await l.value;
                    if (c.status === "aborted" || u.status === "aborted")
                        return $e;
                    (c.status === "dirty" || u.status === "dirty") && n.dirty(),
                    a.set(c.value, u.value)
                }
                return {
                    status: n.value,
                    value: a
                }
            }
            )
        } else {
            const a = new Map;
            for (const l of o) {
                const c = l.key
                  , u = l.value;
                if (c.status === "aborted" || u.status === "aborted")
                    return $e;
                (c.status === "dirty" || u.status === "dirty") && n.dirty(),
                a.set(c.value, u.value)
            }
            return {
                status: n.value,
                value: a
            }
        }
    }
}
mp.create = (t, e, n) => new mp({
    valueType: e,
    keyType: t,
    typeName: Ve.ZodMap,
    ...Xe(n)
});
class Zo extends Ze {
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== Pe.set)
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.set,
                received: r.parsedType
            }),
            $e;
        const i = this._def;
        i.minSize !== null && r.data.size < i.minSize.value && (ke(r, {
            code: ye.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }),
        n.dirty()),
        i.maxSize !== null && r.data.size > i.maxSize.value && (ke(r, {
            code: ye.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }),
        n.dirty());
        const s = this._def.valueType;
        function o(l) {
            const c = new Set;
            for (const u of l) {
                if (u.status === "aborted")
                    return $e;
                u.status === "dirty" && n.dirty(),
                c.add(u.value)
            }
            return {
                status: n.value,
                value: c
            }
        }
        const a = [...r.data.values()].map( (l, c) => s._parse(new Pi(r,l,r.path,c)));
        return r.common.async ? Promise.all(a).then(l => o(l)) : o(a)
    }
    min(e, n) {
        return new Zo({
            ...this._def,
            minSize: {
                value: e,
                message: Fe.toString(n)
            }
        })
    }
    max(e, n) {
        return new Zo({
            ...this._def,
            maxSize: {
                value: e,
                message: Fe.toString(n)
            }
        })
    }
    size(e, n) {
        return this.min(e, n).max(e, n)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Zo.create = (t, e) => new Zo({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: Ve.ZodSet,
    ...Xe(e)
});
class dl extends Ze {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(e) {
        const {ctx: n} = this._processInputParams(e);
        if (n.parsedType !== Pe.function)
            return ke(n, {
                code: ye.invalid_type,
                expected: Pe.function,
                received: n.parsedType
            }),
            $e;
        function r(a, l) {
            return hp({
                data: a,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, up(), Al].filter(c => !!c),
                issueData: {
                    code: ye.invalid_arguments,
                    argumentsError: l
                }
            })
        }
        function i(a, l) {
            return hp({
                data: a,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, up(), Al].filter(c => !!c),
                issueData: {
                    code: ye.invalid_return_type,
                    returnTypeError: l
                }
            })
        }
        const s = {
            errorMap: n.common.contextualErrorMap
        }
          , o = n.data;
        if (this._def.returns instanceof Rl) {
            const a = this;
            return zn(async function(...l) {
                const c = new mr([])
                  , u = await a._def.args.parseAsync(l, s).catch(f => {
                    throw c.addIssue(r(l, f)),
                    c
                }
                )
                  , h = await Reflect.apply(o, this, u);
                return await a._def.returns._def.type.parseAsync(h, s).catch(f => {
                    throw c.addIssue(i(h, f)),
                    c
                }
                )
            })
        } else {
            const a = this;
            return zn(function(...l) {
                const c = a._def.args.safeParse(l, s);
                if (!c.success)
                    throw new mr([r(l, c.error)]);
                const u = Reflect.apply(o, this, c.data)
                  , h = a._def.returns.safeParse(u, s);
                if (!h.success)
                    throw new mr([i(u, h.error)]);
                return h.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...e) {
        return new dl({
            ...this._def,
            args: Di.create(e).rest(Ho.create())
        })
    }
    returns(e) {
        return new dl({
            ...this._def,
            returns: e
        })
    }
    implement(e) {
        return this.parse(e)
    }
    strictImplement(e) {
        return this.parse(e)
    }
    static create(e, n, r) {
        return new dl({
            args: e || Di.create([]).rest(Ho.create()),
            returns: n || Ho.create(),
            typeName: Ve.ZodFunction,
            ...Xe(r)
        })
    }
}
class Ru extends Ze {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const {ctx: n} = this._processInputParams(e);
        return this._def.getter()._parse({
            data: n.data,
            path: n.path,
            parent: n
        })
    }
}
Ru.create = (t, e) => new Ru({
    getter: t,
    typeName: Ve.ZodLazy,
    ...Xe(e)
});
class Iu extends Ze {
    _parse(e) {
        if (e.data !== this._def.value) {
            const n = this._getOrReturnCtx(e);
            return ke(n, {
                received: n.data,
                code: ye.invalid_literal,
                expected: this._def.value
            }),
            $e
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
Iu.create = (t, e) => new Iu({
    value: t,
    typeName: Ve.ZodLiteral,
    ...Xe(e)
});
function hP(t, e) {
    return new Ks({
        values: t,
        typeName: Ve.ZodEnum,
        ...Xe(e)
    })
}
class Ks extends Ze {
    constructor() {
        super(...arguments),
        Sc.set(this, void 0)
    }
    _parse(e) {
        if (typeof e.data != "string") {
            const n = this._getOrReturnCtx(e)
              , r = this._def.values;
            return ke(n, {
                expected: ut.joinValues(r),
                received: n.parsedType,
                code: ye.invalid_type
            }),
            $e
        }
        if (dp(this, Sc) || aP(this, Sc, new Set(this._def.values)),
        !dp(this, Sc).has(e.data)) {
            const n = this._getOrReturnCtx(e)
              , r = this._def.values;
            return ke(n, {
                received: n.data,
                code: ye.invalid_enum_value,
                options: r
            }),
            $e
        }
        return zn(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const n of this._def.values)
            e[n] = n;
        return e
    }
    get Values() {
        const e = {};
        for (const n of this._def.values)
            e[n] = n;
        return e
    }
    get Enum() {
        const e = {};
        for (const n of this._def.values)
            e[n] = n;
        return e
    }
    extract(e, n=this._def) {
        return Ks.create(e, {
            ...this._def,
            ...n
        })
    }
    exclude(e, n=this._def) {
        return Ks.create(this.options.filter(r => !e.includes(r)), {
            ...this._def,
            ...n
        })
    }
}
Sc = new WeakMap;
Ks.create = hP;
class Pu extends Ze {
    constructor() {
        super(...arguments),
        wc.set(this, void 0)
    }
    _parse(e) {
        const n = ut.getValidEnumValues(this._def.values)
          , r = this._getOrReturnCtx(e);
        if (r.parsedType !== Pe.string && r.parsedType !== Pe.number) {
            const i = ut.objectValues(n);
            return ke(r, {
                expected: ut.joinValues(i),
                received: r.parsedType,
                code: ye.invalid_type
            }),
            $e
        }
        if (dp(this, wc) || aP(this, wc, new Set(ut.getValidEnumValues(this._def.values))),
        !dp(this, wc).has(e.data)) {
            const i = ut.objectValues(n);
            return ke(r, {
                received: r.data,
                code: ye.invalid_enum_value,
                options: i
            }),
            $e
        }
        return zn(e.data)
    }
    get enum() {
        return this._def.values
    }
}
wc = new WeakMap;
Pu.create = (t, e) => new Pu({
    values: t,
    typeName: Ve.ZodNativeEnum,
    ...Xe(e)
});
class Rl extends Ze {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const {ctx: n} = this._processInputParams(e);
        if (n.parsedType !== Pe.promise && n.common.async === !1)
            return ke(n, {
                code: ye.invalid_type,
                expected: Pe.promise,
                received: n.parsedType
            }),
            $e;
        const r = n.parsedType === Pe.promise ? n.data : Promise.resolve(n.data);
        return zn(r.then(i => this._def.type.parseAsync(i, {
            path: n.path,
            errorMap: n.common.contextualErrorMap
        })))
    }
}
Rl.create = (t, e) => new Rl({
    type: t,
    typeName: Ve.ZodPromise,
    ...Xe(e)
});
class ti extends Ze {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === Ve.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e)
          , i = this._def.effect || null
          , s = {
            addIssue: o => {
                ke(r, o),
                o.fatal ? n.abort() : n.dirty()
            }
            ,
            get path() {
                return r.path
            }
        };
        if (s.addIssue = s.addIssue.bind(s),
        i.type === "preprocess") {
            const o = i.transform(r.data, s);
            if (r.common.async)
                return Promise.resolve(o).then(async a => {
                    if (n.value === "aborted")
                        return $e;
                    const l = await this._def.schema._parseAsync({
                        data: a,
                        path: r.path,
                        parent: r
                    });
                    return l.status === "aborted" ? $e : l.status === "dirty" || n.value === "dirty" ? Qa(l.value) : l
                }
                );
            {
                if (n.value === "aborted")
                    return $e;
                const a = this._def.schema._parseSync({
                    data: o,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? $e : a.status === "dirty" || n.value === "dirty" ? Qa(a.value) : a
            }
        }
        if (i.type === "refinement") {
            const o = a => {
                const l = i.refinement(a, s);
                if (r.common.async)
                    return Promise.resolve(l);
                if (l instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a
            }
            ;
            if (r.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? $e : (a.status === "dirty" && n.dirty(),
                o(a.value),
                {
                    status: n.value,
                    value: a.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                }).then(a => a.status === "aborted" ? $e : (a.status === "dirty" && n.dirty(),
                o(a.value).then( () => ({
                    status: n.value,
                    value: a.value
                }))))
        }
        if (i.type === "transform")
            if (r.common.async === !1) {
                const o = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                if (!xu(o))
                    return o;
                const a = i.transform(o.value, s);
                if (a instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: n.value,
                    value: a
                }
            } else
                return this._def.schema._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                }).then(o => xu(o) ? Promise.resolve(i.transform(o.value, s)).then(a => ({
                    status: n.value,
                    value: a
                })) : o);
        ut.assertNever(i)
    }
}
ti.create = (t, e, n) => new ti({
    schema: t,
    typeName: Ve.ZodEffects,
    effect: e,
    ...Xe(n)
});
ti.createWithPreprocess = (t, e, n) => new ti({
    schema: e,
    effect: {
        type: "preprocess",
        transform: t
    },
    typeName: Ve.ZodEffects,
    ...Xe(n)
});
class ki extends Ze {
    _parse(e) {
        return this._getType(e) === Pe.undefined ? zn(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
ki.create = (t, e) => new ki({
    innerType: t,
    typeName: Ve.ZodOptional,
    ...Xe(e)
});
class Ys extends Ze {
    _parse(e) {
        return this._getType(e) === Pe.null ? zn(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Ys.create = (t, e) => new Ys({
    innerType: t,
    typeName: Ve.ZodNullable,
    ...Xe(e)
});
class Du extends Ze {
    _parse(e) {
        const {ctx: n} = this._processInputParams(e);
        let r = n.data;
        return n.parsedType === Pe.undefined && (r = this._def.defaultValue()),
        this._def.innerType._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
Du.create = (t, e) => new Du({
    innerType: t,
    typeName: Ve.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...Xe(e)
});
class Lu extends Ze {
    _parse(e) {
        const {ctx: n} = this._processInputParams(e)
          , r = {
            ...n,
            common: {
                ...n.common,
                issues: []
            }
        }
          , i = this._def.innerType._parse({
            data: r.data,
            path: r.path,
            parent: {
                ...r
            }
        });
        return Eu(i) ? i.then(s => ({
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new mr(r.common.issues)
                },
                input: r.data
            })
        })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new mr(r.common.issues)
                },
                input: r.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
Lu.create = (t, e) => new Lu({
    innerType: t,
    typeName: Ve.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...Xe(e)
});
class gp extends Ze {
    _parse(e) {
        if (this._getType(e) !== Pe.nan) {
            const r = this._getOrReturnCtx(e);
            return ke(r, {
                code: ye.invalid_type,
                expected: Pe.nan,
                received: r.parsedType
            }),
            $e
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
gp.create = t => new gp({
    typeName: Ve.ZodNaN,
    ...Xe(t)
});
const IK = Symbol("zod_brand");
class zv extends Ze {
    _parse(e) {
        const {ctx: n} = this._processInputParams(e)
          , r = n.data;
        return this._def.type._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    unwrap() {
        return this._def.type
    }
}
class Hh extends Ze {
    _parse(e) {
        const {status: n, ctx: r} = this._processInputParams(e);
        if (r.common.async)
            return (async () => {
                const s = await this._def.in._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return s.status === "aborted" ? $e : s.status === "dirty" ? (n.dirty(),
                Qa(s.value)) : this._def.out._parseAsync({
                    data: s.value,
                    path: r.path,
                    parent: r
                })
            }
            )();
        {
            const i = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return i.status === "aborted" ? $e : i.status === "dirty" ? (n.dirty(),
            {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: r.path,
                parent: r
            })
        }
    }
    static create(e, n) {
        return new Hh({
            in: e,
            out: n,
            typeName: Ve.ZodPipeline
        })
    }
}
class Ou extends Ze {
    _parse(e) {
        const n = this._def.innerType._parse(e)
          , r = i => (xu(i) && (i.value = Object.freeze(i.value)),
        i);
        return Eu(n) ? n.then(i => r(i)) : r(n)
    }
    unwrap() {
        return this._def.innerType
    }
}
Ou.create = (t, e) => new Ou({
    innerType: t,
    typeName: Ve.ZodReadonly,
    ...Xe(e)
});
function dP(t, e={}, n) {
    return t ? kl.create().superRefine( (r, i) => {
        var s, o;
        if (!t(r)) {
            const a = typeof e == "function" ? e(r) : typeof e == "string" ? {
                message: e
            } : e
              , l = (o = (s = a.fatal) !== null && s !== void 0 ? s : n) !== null && o !== void 0 ? o : !0
              , c = typeof a == "string" ? {
                message: a
            } : a;
            i.addIssue({
                code: "custom",
                ...c,
                fatal: l
            })
        }
    }
    ) : kl.create()
}
const PK = {
    object: Mt.lazycreate
};
var Ve;
(function(t) {
    t.ZodString = "ZodString",
    t.ZodNumber = "ZodNumber",
    t.ZodNaN = "ZodNaN",
    t.ZodBigInt = "ZodBigInt",
    t.ZodBoolean = "ZodBoolean",
    t.ZodDate = "ZodDate",
    t.ZodSymbol = "ZodSymbol",
    t.ZodUndefined = "ZodUndefined",
    t.ZodNull = "ZodNull",
    t.ZodAny = "ZodAny",
    t.ZodUnknown = "ZodUnknown",
    t.ZodNever = "ZodNever",
    t.ZodVoid = "ZodVoid",
    t.ZodArray = "ZodArray",
    t.ZodObject = "ZodObject",
    t.ZodUnion = "ZodUnion",
    t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    t.ZodIntersection = "ZodIntersection",
    t.ZodTuple = "ZodTuple",
    t.ZodRecord = "ZodRecord",
    t.ZodMap = "ZodMap",
    t.ZodSet = "ZodSet",
    t.ZodFunction = "ZodFunction",
    t.ZodLazy = "ZodLazy",
    t.ZodLiteral = "ZodLiteral",
    t.ZodEnum = "ZodEnum",
    t.ZodEffects = "ZodEffects",
    t.ZodNativeEnum = "ZodNativeEnum",
    t.ZodOptional = "ZodOptional",
    t.ZodNullable = "ZodNullable",
    t.ZodDefault = "ZodDefault",
    t.ZodCatch = "ZodCatch",
    t.ZodPromise = "ZodPromise",
    t.ZodBranded = "ZodBranded",
    t.ZodPipeline = "ZodPipeline",
    t.ZodReadonly = "ZodReadonly"
}
)(Ve || (Ve = {}));
const DK = (t, e={
    message: `Input not instance of ${t.name}`
}) => dP(n => n instanceof t, e)
  , fP = qr.create
  , pP = Gs.create
  , LK = gp.create
  , OK = qs.create
  , mP = Su.create
  , NK = Jo.create
  , MK = fp.create
  , BK = wu.create
  , FK = Cu.create
  , jK = kl.create
  , HK = Ho.create
  , UK = is.create
  , VK = pp.create
  , $K = Qr.create
  , zK = Mt.create
  , WK = Mt.strictCreate
  , GK = Tu.create
  , qK = Mm.create
  , KK = Au.create
  , YK = Di.create
  , XK = ku.create
  , QK = mp.create
  , JK = Zo.create
  , ZK = dl.create
  , eY = Ru.create
  , tY = Iu.create
  , nY = Ks.create
  , rY = Pu.create
  , iY = Rl.create
  , vw = ti.create
  , sY = ki.create
  , oY = Ys.create
  , aY = ti.createWithPreprocess
  , lY = Hh.create
  , cY = () => fP().optional()
  , uY = () => pP().optional()
  , hY = () => mP().optional()
  , dY = {
    string: t => qr.create({
        ...t,
        coerce: !0
    }),
    number: t => Gs.create({
        ...t,
        coerce: !0
    }),
    boolean: t => Su.create({
        ...t,
        coerce: !0
    }),
    bigint: t => qs.create({
        ...t,
        coerce: !0
    }),
    date: t => Jo.create({
        ...t,
        coerce: !0
    })
}
  , fY = $e;
var Et = Object.freeze({
    __proto__: null,
    defaultErrorMap: Al,
    setErrorMap: fK,
    getErrorMap: up,
    makeIssue: hp,
    EMPTY_PATH: pK,
    addIssueToContext: ke,
    ParseStatus: Ln,
    INVALID: $e,
    DIRTY: Qa,
    OK: zn,
    isAborted: Q_,
    isDirty: J_,
    isValid: xu,
    isAsync: Eu,
    get util() {
        return ut
    },
    get objectUtil() {
        return X_
    },
    ZodParsedType: Pe,
    getParsedType: Cs,
    ZodType: Ze,
    datetimeRegex: uP,
    ZodString: qr,
    ZodNumber: Gs,
    ZodBigInt: qs,
    ZodBoolean: Su,
    ZodDate: Jo,
    ZodSymbol: fp,
    ZodUndefined: wu,
    ZodNull: Cu,
    ZodAny: kl,
    ZodUnknown: Ho,
    ZodNever: is,
    ZodVoid: pp,
    ZodArray: Qr,
    ZodObject: Mt,
    ZodUnion: Tu,
    ZodDiscriminatedUnion: Mm,
    ZodIntersection: Au,
    ZodTuple: Di,
    ZodRecord: ku,
    ZodMap: mp,
    ZodSet: Zo,
    ZodFunction: dl,
    ZodLazy: Ru,
    ZodLiteral: Iu,
    ZodEnum: Ks,
    ZodNativeEnum: Pu,
    ZodPromise: Rl,
    ZodEffects: ti,
    ZodTransformer: ti,
    ZodOptional: ki,
    ZodNullable: Ys,
    ZodDefault: Du,
    ZodCatch: Lu,
    ZodNaN: gp,
    BRAND: IK,
    ZodBranded: zv,
    ZodPipeline: Hh,
    ZodReadonly: Ou,
    custom: dP,
    Schema: Ze,
    ZodSchema: Ze,
    late: PK,
    get ZodFirstPartyTypeKind() {
        return Ve
    },
    coerce: dY,
    any: jK,
    array: $K,
    bigint: OK,
    boolean: mP,
    date: NK,
    discriminatedUnion: qK,
    effect: vw,
    enum: nY,
    function: ZK,
    instanceof: DK,
    intersection: KK,
    lazy: eY,
    literal: tY,
    map: QK,
    nan: LK,
    nativeEnum: rY,
    never: UK,
    null: FK,
    nullable: oY,
    number: pP,
    object: zK,
    oboolean: hY,
    onumber: uY,
    optional: sY,
    ostring: cY,
    pipeline: lY,
    preprocess: aY,
    promise: iY,
    record: XK,
    set: JK,
    strictObject: WK,
    string: fP,
    symbol: MK,
    transformer: vw,
    tuple: YK,
    undefined: BK,
    union: GK,
    unknown: HK,
    void: VK,
    NEVER: fY,
    ZodIssueCode: ye,
    quotelessJson: dK,
    ZodError: mr
});
const jr = Et.object({
    code: Et.string(),
    message: Et.string(),
    isRetryable: Et.boolean()
})
  , pY = jr.extend({
    code: Et.literal("rate-limited"),
    providerLimitHit: Et.boolean(),
    isRetryable: Et.literal(!0)
})
  , mY = jr.extend({
    code: Et.literal("free-user-rate-limited"),
    isRetryable: Et.literal(!0)
})
  , gY = jr.extend({
    code: Et.literal("project-too-big")
})
  , _Y = jr.extend({
    code: Et.literal("overloaded"),
    isRetryable: Et.literal(!0)
})
  , bY = jr.extend({
    code: Et.literal("request-too-large"),
    isRetryable: Et.literal(!1)
})
  , yY = jr.extend({
    code: Et.literal("api-error")
})
  , vY = jr.extend({
    code: Et.literal("usage-blocked"),
    isRetryable: Et.literal(!1)
})
  , xY = jr.extend({
    code: Et.literal("billing-error"),
    isRetryable: Et.literal(!0)
})
  , EY = jr.extend({
    code: Et.literal("content-filter"),
    isRetryable: Et.literal(!1)
})
  , gP = jr.extend({
    code: Et.literal("unknown")
})
  , SY = jr.extend({
    code: Et.literal("site-creation-error"),
    isRetryable: Et.literal(!0),
    error: Et.string().optional()
})
  , wY = jr.extend({
    code: Et.literal("site-deployment-error"),
    isRetryable: Et.literal(!0),
    error: Et.string().optional()
});
class _P extends Response {
    constructor(e, n, r) {
        super(JSON.stringify(n), {
            status: e,
            headers: {
                "content-type": "application/json"
            },
            ...r
        }),
        this.data = n
    }
    static parse({schema: e}, n, r="An unknown error occurred.") {
        const i = o => Object.assign(new Error(o.message), o)
          , s = o => {
            try {
                const a = typeof o == "string" ? JSON.parse(o) : o;
                try {
                    return i(e.parse(a))
                } catch {
                    return i(gP.parse({
                        code: "unknown",
                        message: a.message ?? r,
                        isRetryable: !0,
                        ...a
                    }))
                }
            } catch {
                return i({
                    code: "unknown",
                    message: r,
                    isRetryable: !0
                })
            }
        }
        ;
        return n instanceof Response ? n.text().then(o => s(o)).catch( () => s("")) : s(n)
    }
}
class Vi extends _P {
    static schema = Et.union([pY, mY, gY, bY, _Y, xY, yY, gP, EY, SY, wY, vY])
}
const CY = 1
  , TY = {
    "withastro/astro": "65bfefb96bd70bf948022e71b72684259fbd5105",
    "stackblitz/starters": "93dd1ac8df79ae1768f26607ffa21aedfd4f94e2",
    "nuxt/starter": "b3f66d947323a67f4036a5364b9cd3e7d04f65b2",
    "vitejs/vite": "1a76300cd16827f0640924fdc21747ce140c35fb",
    "nativescript/stackblitz-templates": "3c3321bb1cc9c520560fd3159558311775572158"
}
  , AY = {
    vite: {
        description: "A versatile template for general web development using Vite with vanilla JavaScript. Ideal for simple HTML, CSS, and JavaScript projects.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-vanilla"
        },
        build: {
            command: "npx vite build",
            output: "dist"
        }
    },
    "vite-ts": {
        description: "A versatile template for general web development using Vite with TypeScript. Ideal for projects requiring a modern build system with TypeScript support.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-vanilla-ts"
        },
        build: "vite"
    },
    "bolt-vite-react-ts": {
        description: "A versatile template for general web development using Vite with the React Framework. Ideal for building WebApps.",
        source: {
            repo: "stackblitz/starters",
            path: "bolt-vite-react-ts"
        },
        build: "vite"
    },
    astro: {
        description: "A versatile template for content-driven websites using Astro, for example blogs, documentation sites, and more.",
        source: {
            repo: "withastro/astro",
            path: "examples/basics"
        },
        build: {
            command: "npx astro build",
            output: "dist"
        }
    },
    nuxt: {
        description: "A bootstrapped project using Nuxt, the intuitive Vue Framework.",
        source: {
            repo: "nuxt/starter"
        },
        build: {
            command: "npx nuxt generate",
            output: ".output/public"
        }
    },
    node: {
        description: "A basic template for a simple Node.js project with no dependencies, using plain JavaScript.",
        source: {
            repo: "stackblitz/starters",
            path: "node"
        }
    },
    angular: {
        description: "A basic template using Angular with TypeScript.",
        source: {
            repo: "stackblitz/starters",
            path: "angular"
        },
        build: {
            command: "npx ng build",
            output: "dist/demo/browser"
        }
    },
    qwik: {
        description: "A template for Qwik development.",
        source: {
            repo: "stackblitz/starters",
            path: "bolt-qwik"
        },
        build: {
            command: "npx qwik build",
            output: "dist",
            env: {
                BOLT_DEPLOY_URL: "BOLT_DEPLOY_URL"
            }
        }
    },
    slidev: {
        description: "A template for Slidev development. Presentation Slides for Developers.",
        source: {
            repo: "stackblitz/starters",
            path: "slidev"
        },
        build: {
            command: "npx slidev build",
            output: "dist"
        }
    },
    "vite-vue": {
        description: "A basic template using the Vue framework with vanilla JavaScript.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-vue"
        },
        build: "vite"
    },
    "vite-vue-ts": {
        description: "A basic template using the Vue framework with TypeScript.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-vue-ts"
        },
        build: "vite"
    },
    "vite-react": {
        description: "A template for React development using Vite with HMR (Hot Module Replacement).",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-react"
        },
        build: "vite"
    },
    "vite-react-ts": {
        description: "A template for React development using Vite with TypeScript and HMR (Hot Module Replacement).",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-react-ts"
        },
        build: "vite"
    },
    "vite-svelte": {
        description: "A template for Svelte development using Vite.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-svelte"
        },
        build: "vite"
    },
    "vite-svelte-ts": {
        description: "A template for Svelte development using Vite with TypeScript.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-svelte-ts"
        },
        build: "vite"
    },
    "vite-solid": {
        description: "A template for Solid development using Vite.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-solid"
        },
        build: "vite"
    },
    "vite-solid-ts": {
        description: "A template for Solid development using Vite with TypeScript.",
        source: {
            repo: "vitejs/vite",
            path: "packages/create-vite/template-solid-ts"
        },
        build: "vite"
    },
    "vite-shadcn": {
        description: "A template for shadcn development using Vite.",
        source: {
            repo: "stackblitz/starters",
            path: "vite-shadcn"
        },
        build: "vite"
    },
    "astro-shadcn": {
        description: "A template for shadcn development using Astro.",
        source: {
            repo: "stackblitz/starters",
            path: "astro-shadcn"
        },
        build: "astro"
    },
    "nextjs-shadcn": {
        description: "A template for shadcn development using using Next.js, the React Framework.",
        source: {
            repo: "stackblitz/starters",
            path: "nextjs-shadcn"
        },
        build: {
            command: "npx next build",
            output: "out"
        }
    },
    "nativescript-typescript": {
        description: "A basic template using NativeScript with TypeScript.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-typescript"
        }
    },
    "nativescript-javascript": {
        description: "A basic template using NativeScript with JavaScript.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-javascript"
        }
    },
    "nativescript-angular": {
        description: "A basic template using NativeScript with Angular.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-angular"
        }
    },
    "nativescript-react": {
        description: "A basic template using NativeScript with React.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-react"
        }
    },
    "nativescript-solid": {
        description: "A basic template using NativeScript with Solid.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-solid"
        }
    },
    "nativescript-svelte": {
        description: "A basic template using NativeScript with Svelte.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-svelte"
        }
    },
    "nativescript-vue": {
        description: "A basic template using NativeScript with Vue.",
        source: {
            repo: "nativescript/stackblitz-templates",
            path: "apps/nativescript-starter-vue"
        }
    }
}
  , kY = {
    version: CY,
    repos: TY,
    starters: AY
};
function bP(t) {
    const e = kY.starters[t]?.build;
    return typeof e == "string" ? bP(e) : e
}
function RY(t) {
    return t != null && typeof t.set == "function" && typeof t.get == "function" && "value"in t
}
class xa {
    constructor(e, n, r, i="") {
        this.artifactId = e,
        this.messageId = n,
        this.id = r,
        this.content.set(i)
    }
    executed = !1;
    input;
    status = wt("pending");
    content = wt("");
    #t = new AbortController;
    #e = new Set;
    listen(e) {
        const n = [this.status.listen(e), this.content.listen(e)];
        return () => {
            n.forEach(r => r())
        }
    }
    get abortSignal() {
        return this.#t.signal
    }
    update(e) {
        for (const [n,r] of Object.entries(e)) {
            const i = n;
            r != null && (RY(this[i]) ? i === "status" && this[i].get() !== "aborted" && this[i].set(r) : this[i] = r)
        }
    }
    abort() {
        if (this.status.value !== "aborted") {
            this.#t.abort("aborted"),
            this.status.set("aborted");
            for (const e of this.#e)
                e("aborted")
        }
    }
}
class Wv extends xa {
    actions = wt([]);
    constructor(e, n, r, i) {
        super(e, n, r),
        this.actions.set(i)
    }
    async run() {
        let e, n;
        this.abortSignal.addEventListener("abort", () => {
            n.abort()
        }
        );
        for (n of this.actions.get()) {
            if (this.abortSignal.aborted)
                break;
            if (n.status.get() === "pending")
                try {
                    n.input = e,
                    n.status.set("running"),
                    e = await n.run(),
                    n.status.set("complete")
                } catch (r) {
                    throw n.status.set("failed"),
                    r
                }
        }
        return e
    }
}
class IY extends xa {
    constructor(e, n, r, i, s) {
        super(e, n, r, s),
        this.filePath = i;
        const o = me.files.get();
        this.actionType = o[Pt(i)] ? "Update" : "Create"
    }
    type = "file";
    actionType;
    async run() {
        await me.writeFile(this.filePath, {
            type: "file",
            content: this.content.value,
            isBinary: !1,
            isFakeBinary: !1
        })
    }
}
class PY extends Wv {
    constructor(e, n, r, i, s) {
        const o = new DY(e,n,`${r}-import`,i,s);
        super(e, n, r, [o]),
        this.target = i
    }
    type = "import";
    async run() {
        await super.run();
        const e = me.files.get();
        if (!e)
            return;
        const n = {}
          , r = e[Pt(lX)]
          , i = r?.type === "file" && r.content;
        if (i)
            try {
                const a = JSON.parse(i);
                n.scripts = a.scripts,
                n.dependencies = a.scripts,
                n.devDependencies = a.scripts
            } catch {}
        const s = kP(n)
          , o = [new bf(this.artifactId,this.messageId,`${this.id}-install`)];
        s && o.push(new Bm(this.artifactId,this.messageId,`${this.id}-start`,!1,s)),
        this.actions.set([...this.actions.get(), ...o]),
        this.update({
            status: "running"
        }),
        await super.run()
    }
}
class DY extends xa {
    constructor(e, n, r, i, s) {
        super(e, n, r, s),
        this.target = i
    }
    type = "import-project";
    async run() {
        await JY()
    }
}
class Xs extends xa {
    #t = !1;
    #e = "";
    exitCode = null;
    output = "";
    stderr = "";
    constructor(e, n, r, i) {
        super(e, n, r, i)
    }
    get command() {
        return this.#e || this.content.get()
    }
    set command(e) {
        this.#e = e
    }
    async run() {
        const e = me.runShellAction(this);
        this.abortSignal.addEventListener("abort", () => {
            this.#t || e.kill()
        }
        );
        try {
            return this.exitCode = await e.exit,
            pa.debug(`Process terminated with code ${this.exitCode}`),
            this.exitCode
        } catch {
            return
        } finally {
            this.#t = !0
        }
    }
}
class bf extends Xs {
    type = "install";
    constructor(e, n, r) {
        super(e, n, r, "npm install")
    }
}
class Bm extends Xs {
    constructor(e, n, r, i, s) {
        typeof s == "object" && (s = s.startCommand("npm")),
        super(e, n, r, s),
        this.autocreated = i
    }
    type = "start"
}
class yP extends Xs {
    type = "shell"
}
class LY extends xa {
    type = "import-template";
    #t;
    constructor(e, n, r, i) {
        super(e, n, r),
        this.#t = i
    }
    async run() {
        const e = async i => {
            let s;
            i.isBinary ? s = new Uint8Array(yI.from(i.contents, "base64").buffer) : s = i.contents,
            await me.writeFile(i.fullPath, {
                type: "file",
                content: s,
                isBinary: i.isBinary,
                isFakeBinary: !1
            })
        }
        ;
        for (const i of Object.values(this.#t.files))
            i.type === "file" && await e(i);
        const n = await Nr;
        let r = {};
        try {
            r = JSON.parse(await n.fs.readFile(eb, "utf8"))
        } catch {}
        r.template = this.#t.id,
        await e({
            fullPath: eb,
            contents: JSON.stringify(r, void 0, 2) + `
`,
            isBinary: !1
        }),
        me.setInitialFiles(this.#t.files)
    }
}
class OY extends xa {
    constructor(e, n, r, i) {
        super(e, n, r),
        this.provider = i
    }
    type = "deploy";
    deploymentInfo;
    async run() {
        try {
            const e = this.input;
            if (typeof e != "string")
                throw new Error("Failed to deploy because the build directory was not specified.");
            const n = Ne.getProjectId();
            if (!n)
                throw new Error("Could not deploy as we are currently not inside a project.");
            bn(this.deploymentInfo, "Deployment info is not set.");
            const i = await (await Nr).internal.serialize(e, {
                format: "zip"
            })
              , s = `/api/deploy/${n}`
              , o = await fetch(s, {
                method: "PUT",
                headers: {
                    "Content-Type": "application/zip"
                },
                body: i
            })
              , a = await o.text();
            if (!o.ok)
                throw Vi.parse(Vi, a, "An unknown error occurred when deploying your project.");
            return this.content.set(this.deploymentInfo.deploy_url),
            this.deploymentInfo
        } catch (e) {
            throw Rr({
                action: Ir.Track,
                payload: {
                    event: Yr.SiteDeployFailure,
                    properties: {
                        error: e.message,
                        projectId: Ne.getProjectId()
                    }
                }
            }),
            e
        }
    }
}
class NY extends xa {
    type = "build";
    deploymentInfo;
    #t;
    constructor(e, n, r) {
        super(e, n, r)
    }
    setBuildConfig(e) {
        this.#t = e
    }
    async run() {
        try {
            const e = await this.#n();
            this.content.set(e.command);
            const n = this.#e(e);
            let r = e.command;
            n && (r = `${n} ${r}`);
            const i = new yP(this.artifactId,this.messageId,this.id,r);
            try {
                const s = await i.run();
                if (s != null && s !== 0)
                    throw new Error(`Process exited with exit code ${s}`)
            } catch {
                throw new Error("Failed building the project. Make sure the build command is correct and try again.")
            }
            return e.output
        } catch (e) {
            throw Rr({
                action: Ir.Track,
                payload: {
                    event: Yr.SiteBuildFailed,
                    properties: {
                        error: e.message,
                        projectId: Ne.getProjectId()
                    }
                }
            }),
            e
        }
    }
    #e(e) {
        if (!e.env)
            return;
        const n = {
            BOLT_DEPLOY_URL: this.deploymentInfo?.deploy_url
        };
        return Object.entries(e.env).map( ([r,i]) => n[i] ? `${r}=${n[i]}` : void 0).filter(Boolean).join(" ")
    }
    async #n() {
        const e = await Nr;
        let n;
        try {
            n = JSON.parse(await e.fs.readFile(eb, "utf8"))
        } catch {}
        if (n?.build)
            return n.build;
        const r = me.framework.get();
        if (r?.build)
            return {
                command: r.build.command("npm"),
                output: r.build.output
            };
        if (n?.template) {
            const i = bP(n.template);
            if (i)
                return i
        }
        if (this.#t)
            return this.#t;
        throw Error("Could not build the project because no build configuration was found.")
    }
}
class MY extends Wv {
    type = "build-and-deploy";
    deploymentInfo;
    #t;
    #e;
    #n;
    constructor(e, n, r, i, s) {
        const o = new NY(e,n,`${r}-build`)
          , a = new OY(e,n,`${r}-deploy`,i);
        super(e, n, r, [o, a]),
        this.#t = o,
        this.#e = a,
        this.#n = s
    }
    update(e) {
        super.update(e),
        "status"in e && e.status === "complete" && (this.#t.update({
            status: e.status
        }),
        this.#e.update({
            status: e.status
        }))
    }
    setBuildConfig(e) {
        this.#t.setBuildConfig(e)
    }
    async run() {
        const e = Ne.getProjectId();
        try {
            if (!e)
                throw new Error("Could not deploy as we are currently not inside a project.");
            this.deploymentInfo = await this.#r(e),
            this.#t.deploymentInfo = this.deploymentInfo,
            this.#e.deploymentInfo = this.deploymentInfo
        } catch (n) {
            throw this.#t.abort(),
            this.#e.abort(),
            Rr({
                action: Ir.Track,
                payload: {
                    event: Yr.SiteDeployFailure,
                    properties: {
                        error: n.message,
                        projectId: e
                    }
                }
            }),
            n
        }
        try {
            return await super.run()
        } catch (n) {
            throw await this.#i(),
            n
        }
    }
    async #r(e) {
        let n = `/api/deploy/${e}`;
        this.#n && (n += `/${this.#n}`);
        const r = await fetch(n, {
            method: "POST"
        })
          , i = await r.text();
        if (!r.ok)
            throw Vi.parse(Vi, i, "An unknown error occurred when deploying your project.");
        const s = JSON.parse(i);
        return {
            claim_url: s.claim_url,
            deploy_url: s.site_url
        }
    }
    async #i() {
        const e = Ne.getProjectId();
        if (e)
            try {
                await fetch(`/api/deploy/${e}`, {
                    method: "DELETE"
                })
            } catch {}
    }
}
const BY = ""
  , FY = 130
  , jY = ""
  , HY = ""
  , UY = jY + HY;
class VY {
    _commands = [];
    _shell;
    _currentCommand;
    _processList = new Set;
    _killing;
    _oldMessageIDs = new Set;
    _promptListeners = new Set;
    _processStartedListeners = new Set;
    _processEndedListeners = new Set;
    _outputListeners = new Set;
    start(e) {
        if (this._shell)
            throw new Error("It is not possible to start the ShellDriver twice.");
        this._shell = e;
        let n = !1;
        e.registerOscHandler(r => {
            if (r === "prompt") {
                if (n = this._processList.size > 0,
                n)
                    return;
                for (const i of this._promptListeners)
                    i()
            } else if (r.startsWith("pid=")) {
                if (n)
                    return;
                const i = Number.parseInt(r.slice(4), 10);
                this._processList.add(i);
                for (const s of this._processStartedListeners)
                    s(i)
            } else if (r.startsWith("exit=")) {
                const [i,s] = r.slice(5).split(":").map(o => Number.parseInt(o));
                if (i !== 0 && !this._processList.has(i))
                    return;
                this._processList.delete(i);
                for (const o of this._processEndedListeners)
                    o(i, s)
            }
        }
        ),
        e.registerOutputHandler(r => {
            this._outputListeners.forEach(i => {
                i(r)
            }
            )
        }
        ),
        this._startProcessing()
    }
    processCommand(e) {
        if (this._oldMessageIDs.has(e.shellAction.messageId)) {
            e.skip();
            return
        }
        if (this._currentCommand && e.shellAction.messageId !== this._currentCommand.shellAction.messageId && (this._currentCommand.shellAction.type !== "start" || e.shellAction.type !== "start" || !e.shellAction.autocreated)) {
            this._oldMessageIDs.add(this._currentCommand.shellAction.messageId);
            const n = this._commands;
            this._commands = [];
            for (const r of n)
                r.shellAction.messageId === e.shellAction.messageId ? this._commands.push(r) : r.skip();
            this._killing = this._kill()
        }
        !this._currentCommand && this._processList.size > 0 && (this._killing = this._kill()),
        this._commands.push(e),
        this._startProcessing()
    }
    async _startProcessing() {
        if (!this._shell)
            return;
        if (this._killing) {
            const r = this._killing;
            this._killing = void 0,
            await r,
            this._currentCommand = void 0
        }
        if (this._currentCommand)
            return;
        const e = this._commands.shift();
        if (!e)
            return;
        await this._shell.ready(),
        this._currentCommand = e;
        const n = await this._runCommand(e.shellAction.command, r => {
            e.shellAction.output += r
        }
        );
        if (n === FY && e.shellAction.type === "start") {
            const r = [];
            for (const i of this._commands)
                i.shellAction.type === "start" && i.shellAction.autocreated ? i.skip() : r.push(i);
            this._commands = r
        }
        this._currentCommand = void 0,
        e.onExit(n),
        this._startProcessing()
    }
    async _kill() {
        return new Promise(e => {
            const n = setTimeout(async () => {
                for (const i of this._processList)
                    for (const s of this._processEndedListeners)
                        s(i, 130);
                this._processList.clear(),
                await this._shell.restart(!1),
                e()
            }
            , 200)
              , r = () => {
                clearTimeout(n),
                this._promptListeners.delete(r),
                e()
            }
            ;
            this._promptListeners.add(r),
            this._shell.write(BY)
        }
        )
    }
    _runCommand(e, n) {
        return new Promise(r => {
            let i = 0
              , s = !1;
            const o = c => {
                s && n(c),
                s ||= c.includes("\x1B[?2004l")
            }
              , a = (c, u) => {
                this._outputListeners.delete(o),
                i = u,
                this._processList.size === 0 && this._outputListeners.delete(n)
            }
              , l = () => {
                this._outputListeners.delete(o),
                this._processEndedListeners.delete(a),
                this._promptListeners.delete(l),
                r(i)
            }
            ;
            this._promptListeners.add(l),
            this._processEndedListeners.add(a),
            this._shell.write(`${UY}${e}
`),
            this._outputListeners.add(o)
        }
        )
    }
}
class $Y {
    showTerminal = wt(!1);
    terminalDriver;
    constructor() {
        this.terminalDriver = new VY
    }
    toggleTerminal(e) {
        this.showTerminal.set(e !== void 0 ? e : !this.showTerminal.get())
    }
    processCommand(e) {
        this.terminalDriver.processCommand(e)
    }
}
function Gv(t) {
    const e = new URL(window.location.href);
    e.pathname = `/~/${t}`,
    e.searchParams.delete("prompt"),
    window.history.replaceState({}, "", e),
    Rr({
        action: Ir.Page,
        payload: {
            properties: {
                url: e.href
            }
        }
    })
}
async function vP() {
    try {
        Ne.isForking.set(!0);
        const t = Ne.getSlug();
        bn(t);
        const e = await PP({
            slug: t,
            files: me.files.get()
        });
        Ne.updateProject(e),
        Gv(e.slug),
        Ne.isForking.set(!1),
        Ne.setShouldFork(!1)
    } finally {
        Ne.isForking.set(!1)
    }
}
function Qi() {
    if (typeof Promise.withResolvers == "function")
        return Promise.withResolvers();
    let t, e;
    const n = new Promise( (r, i) => {
        t = r,
        e = i
    }
    );
    return {
        resolve: t,
        reject: e,
        promise: n
    }
}
class zY {
    #t = Promise.resolve();
    #e = void 0;
    stateUpdates = wt(0);
    actions = new Map;
    getDeployStatus() {
        return this.#e?.promise
    }
    addAction(e, n) {
        const r = e.action.id;
        this.actions.get(r) || (this.actions.set(r, e.action),
        n || this.#r(r, {
            status: "complete",
            executed: !0
        }),
        this.actions.set(r, e.action),
        this.#i(),
        e.action.type === "build-and-deploy" && (this.#e = Qi()),
        n && this.#t.then( () => {
            this.#r(r, {
                status: "running"
            })
        }
        ))
    }
    async runAction(e) {
        const n = e.action.id
          , r = this.actions.get(n);
        return r || jo(`Action ${n} not found`),
        r.executed ? this.#t : (this.#r(n, {
            content: e.action.content.get(),
            executed: !0
        }),
        this.#t = this.#t.then( () => this.#n(n)).catch(i => {
            throw console.error(`Action failed

${i}`),
            i
        }
        ),
        this.#t)
    }
    async #n(e) {
        const n = this.actions.get(e);
        n || jo(`Action ${e} not found`);
        const r = n.type === "build-and-deploy";
        this.#r(e, {
            status: "running"
        });
        try {
            const i = await n.run();
            r && (this.#e?.resolve(i),
            Rr({
                action: Ir.Track,
                payload: {
                    event: Yr.SiteDeploySuccess
                }
            }));
            let s = "complete";
            n.abortSignal.aborted ? s = n.abortSignal.reason : n instanceof Xs && (i === void 0 ? s = "skipped" : i === 130 ? s = "aborted" : i !== 0 && (s = "failed")),
            this.#r(e, {
                status: s
            })
        } catch (i) {
            throw r && this.#e?.reject(i),
            this.#r(e, {
                status: "failed"
            }),
            i
        }
    }
    abort() {
        for (const e of Object.values(this.actions))
            e.status.value === "running" && e.abort()
    }
    #r(e, n) {
        const r = this.actions.get(e);
        r || jo(`Action ${e} not found`),
        r.update(n),
        this.#i()
    }
    #i() {
        this.stateUpdates.set(this.stateUpdates.get() + 1)
    }
    listen(e) {
        const n = new Set;
        n.add(this.stateUpdates.listen(e));
        for (const r of this.actions.values())
            n.add(r.listen(e));
        return () => {
            n.forEach(r => r())
        }
    }
}
const sc = new Set
  , WY = /^\s*npm i(nstall)?\s*($|&&\s*)/gm;
class GY {
    artifacts = ma({});
    hasArtifacts = wt(!1);
    showWorkbench = wt(!1);
    currentView = wt("code");
    currentFileTreeView = wt("files");
    unsavedFiles = wt(new Set);
    isStreaming = wt(!1);
    #t = new hK(Nr);
    #e = new lK(Nr,this);
    #n = new Kq(this.#e,this);
    #r = new $Y;
    _artifactIdList = new Set;
    get artifactList() {
        return [...this._artifactIdList].map(e => this.getArtifact(e))
    }
    constructor() {}
    get runningCommands() {
        return Object.values(this.artifacts.get()).flatMap(r => [...r.runner.actions.values()]).filter(r => r.type === "shell" && r.status.get() === "running")
    }
    get previews() {
        return this.#t.previews
    }
    get files() {
        return this.#e.files
    }
    get lockedFiles() {
        return this.#e.lockedFiles
    }
    get targetedFiles() {
        return this.#e.targetedFiles
    }
    framework = sl(this.files, e => {
        const n = Pt("package.json")
          , r = e[n];
        if (r?.type === "file")
            try {
                const i = JSON.parse(r.content);
                return kP(i)
            } catch {
                return
            }
    }
    );
    get currentDocument() {
        return this.#n.currentDocument
    }
    get selectedFile() {
        return this.#n.selectedFile
    }
    get firstArtifact() {
        return this.artifactList[0]
    }
    get lastArtifact() {
        return this.artifactList.at(-1)
    }
    get filesCount() {
        return this.#e.filesCount
    }
    get showTerminal() {
        return this.#r.showTerminal
    }
    get terminalDriver() {
        return this.#r.terminalDriver
    }
    get watchPersistence() {
        return this.#e.watchPersistence
    }
    get hasPersistedChanges() {
        return this.#e.hasPersistedChanges
    }
    setInitialFiles(e) {
        this.#e.setInitialFiles(e)
    }
    getInitialFiles() {
        return this.#e.getInitialFiles()
    }
    writeFile(e, n, r) {
        return this.#e.writeFile(e, n, r)
    }
    async copyFile(e, n) {
        return this.#e.copyFile(e, n)
    }
    removeFile(e) {
        return this.#e.removeFile(e)
    }
    rename(e, n) {
        return this.#e.rename(e, n)
    }
    cut(e, n, r) {
        return this.#e.cut(e, n, r)
    }
    createDirectory(e, n) {
        return this.#e.createDirectory(e, n)
    }
    async copyDirectory(e, n) {
        return this.#e.copyDirectory(e, n)
    }
    removeDirectory(e) {
        return this.#e.removeDirectory(e)
    }
    toggleTerminal(e) {
        this.#r.toggleTerminal(e)
    }
    removeFromTargetOrLockedFiles(e) {
        this.#e.removeFromTargetOrLockedFiles(e)
    }
    isAIAllowedToEdit(e) {
        return this.#e.isAIAllowedToEdit(e)
    }
    setFileOrFolderTarget(e, n) {
        this.#e.setFileOrFolderTarget(e, n)
    }
    setFileOrFolderLocked(e, n) {
        this.#e.setFileOrFolderLocked(e, n)
    }
    resetAllLockedTargetedFiles() {
        this.#e.resetAllLockedTargetedFiles()
    }
    setDocuments(e) {
        if (this.#n.setDocuments(e),
        this.#e.filesCount > 0 && this.currentDocument.get() === void 0) {
            for (const [n,r] of Object.entries(e))
                if (r?.type === "file") {
                    this.setSelectedFileProgrammatically(n);
                    break
                }
        }
    }
    setCurrentDocumentContent(e) {
        const n = this.currentDocument.get()?.filePath;
        if (!n)
            return;
        const r = this.#e.getFile(n)?.content
          , i = r !== void 0 && r !== e;
        this.#n.updateFile(n, e);
        const s = this.currentDocument.get();
        if (s) {
            const o = this.unsavedFiles.get();
            if (this.isStreaming.get() || i && o.has(s.filePath))
                return;
            const a = new Set(o);
            i ? a.add(s.filePath) : a.delete(s.filePath),
            this.unsavedFiles.set(a)
        }
    }
    setCurrentDocumentScrollPosition(e) {
        const n = this.currentDocument.get();
        if (!n)
            return;
        const {filePath: r} = n;
        this.#n.updateScrollPosition(r, e)
    }
    setSelectedFile(e) {
        e && (e = Pt(e)),
        this.#n.setSelectedFile(e)
    }
    setSelectedFileProgrammatically(e) {
        e && (e = Pt(e)),
        this.#n.setSelectedFileProgrammatically(e)
    }
    setStreamingFile(e) {
        this.#n.setStreamingFile(e)
    }
    async saveFile(e) {
        const r = this.#n.documents.get()[e];
        if (r === void 0)
            return;
        if (Ne.shouldFork() && !Ne.isForking.get()) {
            Ne.isForking.set(!0);
            const s = Ne.getSlug();
            bn(s),
            vP()
        }
        await this.#e.saveFile(e, r.value);
        const i = new Set(this.unsavedFiles.get());
        i.delete(e),
        this.unsavedFiles.set(i)
    }
    async saveCurrentDocument() {
        const e = this.currentDocument.get();
        e !== void 0 && await this.saveFile(e.filePath)
    }
    resetCurrentDocument() {
        const e = this.currentDocument.get();
        if (e === void 0)
            return;
        const {filePath: n} = e
          , r = this.#e.getFile(n);
        r && this.setCurrentDocumentContent(r.content)
    }
    async saveFileHistory(e) {
        return this.#e.saveFileHistory(e)
    }
    waitForImport() {
        return this.#e.waitForImport
    }
    get fileImportComplete() {
        return this.#e.fileImportComplete
    }
    importProjectFiles(e) {
        this.#e.importProjectFiles(e).catch(n => {
            ct.error("There was a problem loading files into WebContainer"),
            pa.error(n)
        }
        )
    }
    async saveAllFiles() {
        for (const e of this.unsavedFiles.get())
            await this.saveFile(e);
        await this.#e.saveFileHistory()
    }
    abortAllActions() {
        for (const e of Object.values(this.artifacts.get()))
            e.runner.abort()
    }
    addArtifact({title: e, slug: n, id: r}) {
        this.getArtifact(r) || (this.hasArtifacts.get() || this.hasArtifacts.set(!0),
        this.artifacts.setKey(r, {
            id: r,
            slug: n,
            title: e,
            closed: !1,
            runner: new zY
        }),
        this._artifactIdList.add(r))
    }
    async updateArtifact({id: e, messageId: n}, r, i=!0) {
        const s = this.getArtifact(e);
        if (s) {
            if (!s.closed && r.closed) {
                await this.#e.waitForImport;
                const o = this.framework.get();
                if (o) {
                    const a = {
                        artifactId: s.id,
                        messageId: n,
                        action: new Bm(s.id,n,`${s.id}:restart`,!0,o)
                    };
                    [...s.runner.actions.values()].some( ({type: c}) => c === "start") || (this.addAction(a, i),
                    this.runAction(a))
                }
            }
            this.artifacts.setKey(e, {
                ...s,
                ...r
            })
        }
    }
    get actions() {
        const e = [];
        for (const n of this.artifactList)
            for (const r of n.runner.actions.values())
                e.push(r);
        return e
    }
    subscribeToActions(e) {
        const n = new Set
          , r = () => {
            n.forEach(s => s()),
            n.clear()
        }
          , i = () => {
            r(),
            n.add(me.artifacts.listen(i));
            for (const s of this.artifactList)
                n.add(s.runner.listen(i));
            e(this.actions)
        }
        ;
        return i(),
        r
    }
    addAction(e, n) {
        const {artifactId: r} = e
          , i = this.getArtifact(r);
        if (i.closed)
            return;
        if (i || jo("Artifact not found"),
        e.action.type === "shell") {
            const c = e.action.content.value;
            if (sc.has(e.artifactId)) {
                const u = c.replace(WY, "");
                if (!u)
                    return;
                e.action.content.set(u)
            }
        }
        const s = [...this.actions, e.action]
          , o = s.findLastIndex( ({type: c}) => c === "import-template" || c === "import-project");
        if (!(e.action instanceof bf) && o >= 0 && s[o + 1] === e.action && !xw(e.action)) {
            const c = {
                artifactId: e.artifactId,
                messageId: e.messageId,
                action: new bf(e.artifactId,e.messageId,`install:${e.action.id}`)
            };
            sc.add(e.artifactId),
            this.addAction(c, n),
            this.runAction(c)
        }
        i.runner.addAction(e, n)
    }
    async runAction(e) {
        const {artifactId: n} = e
          , r = this.getArtifact(n);
        if (!r.closed && (r || jo("Artifact not found"),
        await r.runner.runAction(e),
        xw(e.action))) {
            const i = `${e.artifactId}:${e.action.id}`;
            if (!sc.has(i)) {
                const s = {
                    artifactId: e.artifactId,
                    messageId: e.messageId,
                    action: new bf(e.artifactId,e.messageId,`${e.action.id}:install`)
                };
                sc.add(i),
                sc.add(e.artifactId),
                this.addAction(s, !0),
                await this.runAction(s)
            }
        }
    }
    runShellAction(e) {
        this.#r.toggleTerminal(!0);
        const {promise: n, resolve: r, reject: i} = Qi()
          , s = new AbortController;
        return this.#r.processCommand({
            shellAction: e,
            abortController: s,
            skip: i,
            onExit: r
        }),
        {
            exit: n,
            kill: () => {
                s.abort()
            }
        }
    }
    getArtifact(e) {
        return this.artifacts.get()[e]
    }
}
const me = new GY;
function xw(t) {
    return t.type === "file" && t.filePath === "package.json"
}
function qv(t) {
    const {id: e="project-import", title: n, description: r, boltActions: i, hiddenFiles: s} = t
      , o = [];
    return r && o.push(`${r}
`),
    o.push("Here is an artifact that contains all files of the project visible to you."),
    o.push("Consider the contents of ALL files in the project."),
    o.push(""),
    o.push(`<boltArtifact id=${JSON.stringify(e)} title=${JSON.stringify(n)}>${i}</boltArtifact>`),
    s && s.length > 0 && o.push("", KY(s)),
    o.join(`
`)
}
const qY = "Here is a list of files that exist on the file system but are not being shown to you:";
function KY(t) {
    return [qY, "", ...t.map(e => `  - ${e}`)].join(`
`)
}
function Kv(t) {
    const e = []
      , n = U6(t);
    return {
        boltActions: Object.values(t).map(i => {
            const {fullPath: s, type: o} = i;
            if (o !== "folder") {
                if (n({
                    path: s,
                    contents: i.contents,
                    isBinary: i.isBinary
                })) {
                    e.push(s);
                    return
                }
                return QY(i)
            }
        }
        ).join(""),
        hiddenFiles: e
    }
}
function YY(t) {
    const e = []
      , n = Ly(t);
    return {
        boltActions: Object.entries(t).map( ([i,s]) => {
            const o = i.substring(jt.length + 1);
            if (s && s.type !== "folder") {
                if (n({
                    path: o,
                    contents: s.content,
                    isBinary: s.isBinary
                })) {
                    e.push(i);
                    return
                }
                return XY(o, s)
            }
        }
        ).filter(Boolean).join(""),
        hiddenFiles: e
    }
}
function XY(t, e) {
    return xP(e.type, t, e.type === "file" ? e.content : void 0)
}
function QY(t) {
    return xP(t.type, t.fullPath, t.type === "file" ? t.contents : void 0)
}
function xP(t, e, n) {
    if (t === "folder")
        return;
    const r = (n ?? "").replaceAll("</boltAction>", "");
    return `<boltAction type="file" filePath=${JSON.stringify(e)}>${r}</boltAction>`
}
function EP({id: t, appFiles: e, title: n, description: r, editedAt: i}, s, o) {
    const a = [];
    me.importProjectFiles(e),
    Ne.getSlug() && Ne.setEditedAt(i),
    RP(t, {
        description: n
    });
    let c = "I've successfully imported your project. I'm ready to assist you with analyzing and improving your code.";
    o?.deploy_url && (c += `

Your project has been previously deployed to ${o.deploy_url}.`),
    a.push({
        id: im,
        messageId: s?.lastAssistantMessageId,
        type: "chat",
        status: "complete",
        content: `

${Ry(c)}`,
        role: "assistant",
        ignore: !0
    });
    const u = e[a_]?.type === "file" ? e[a_].contents : "";
    u && a.push({
        id: ak,
        type: "chat",
        status: "complete",
        fileSelections: [],
        content: u,
        role: "user",
        hidden: !0
    });
    const {boltActions: h, hiddenFiles: d} = Kv(e)
      , f = qv({
        title: n,
        description: r,
        boltActions: h,
        hiddenFiles: d
    });
    return a.push({
        id: au,
        type: "chat",
        status: "complete",
        fileSelections: [],
        content: f,
        role: "user",
        hidden: !0,
        ephemeral: !0
    }),
    a
}
const mn = ma({
    statusMessage: "",
    messages: [],
    chatLoadingStatus: "LOADING",
    deploymentInfo: void 0
})
  , Uo = Qi();
function JY() {
    return Promise.all([Uo.promise, Nr]).then( () => me.waitForImport())
}
function ZY(t, e) {
    const n = new Set(Object.keys(t))
      , r = [];
    for (const [i,s] of Object.entries(e)) {
        const o = Pt(i)
          , a = t[o];
        n.delete(o);
        let l = Hn.dirname(o);
        for (; l !== jt; )
            n.delete(l),
            l = Hn.dirname(l);
        if (a?.type == "folder" && s.type === "file")
            for (const c of n)
                c.startsWith(`${o}/`) && n.delete(c);
        a ? a.type === "folder" ? s.type === "file" && (r.push({
            type: "rmdir",
            filePath: o,
            dirent: a
        }),
        r.push({
            type: "writeFile",
            filePath: o,
            dirent: s
        })) : a.type === "file" && (s.type === "file" ? a.content !== s.content && r.push({
            type: "writeFile",
            filePath: o,
            dirent: s
        }) : (r.push({
            type: "removeFile",
            filePath: o,
            dirent: a
        }),
        r.push({
            type: "mkdir",
            filePath: o,
            dirent: s
        }))) : s.type === "file" ? r.push({
            type: "writeFile",
            filePath: o,
            dirent: s
        }) : r.push({
            type: "mkdir",
            filePath: o,
            dirent: s
        })
    }
    for (const i of n) {
        const s = t[i];
        s?.type === "file" ? r.push({
            type: "removeFile",
            filePath: i,
            dirent: s
        }) : s?.type === "folder" && r.push({
            type: "rmdir",
            filePath: i,
            dirent: s
        })
    }
    return r
}
class a0 {
    title;
    createdAt;
    #t;
    #e;
    #n;
    #r = Promise.resolve();
    constructor(e, n) {
        this.#t = e,
        this.#e = n.messageId,
        this.#n = n.finalized ?? !1,
        this.createdAt = n.createdAt,
        this.title = n.title
    }
    get id() {
        return this.#e
    }
    async finalize(e) {
        if (this.#n)
            return;
        this.#n = !0;
        const n = {}
          , r = new Set;
        for (const [s,o] of Object.entries(e)) {
            if (!o)
                continue;
            const a = Fn(s);
            if (o.type === "folder")
                r.has(a) || (n[a] = {
                    type: o.type
                });
            else {
                const l = Xq.dirname(a);
                r.add(l),
                n[a] = {
                    type: o.type,
                    content: o.content,
                    ...o.isBinary && {
                        isBinary: !0
                    },
                    ...o.blobId && {
                        blobId: o.blobId
                    }
                },
                n[l] && n[l].type === "folder" && delete n[l]
            }
        }
        const i = async (s=1) => {
            try {
                const o = {
                    id: this.#e,
                    snapshot: JSON.stringify(n)
                };
                if (!(await fetch(`/api/snapshot/${this.#t}`, {
                    method: "POST",
                    body: JSON.stringify(o)
                })).ok)
                    throw new Error("Failed to save snapshot")
            } catch (o) {
                if (s >= 5)
                    throw o;
                setTimeout( () => {
                    i(s + 1)
                }
                , s * 500)
            }
        }
        ;
        this.#r = i(),
        await this.#r
    }
    async getAsFileMap() {
        const e = await this.#i()
          , n = {};
        for (const [r,i] of Object.entries(e))
            i.type === "folder" ? n[Pt(r)] = {
                type: "folder",
                isLocked: !1,
                isTargeted: !1
            } : n[Pt(r)] = {
                ...i,
                isLocked: !1,
                isTargeted: !1
            };
        return n
    }
    async apply(e, n) {
        await this.#r;
        const r = await this.#i()
          , i = ZY(e, r);
        for (const {type: s, filePath: o, dirent: a} of i)
            switch (s) {
            case "rmdir":
                {
                    bn(a.type === "folder", "Expected folder"),
                    await n.rmdir(o);
                    break
                }
            case "mkdir":
                {
                    bn(a.type === "folder", "Expected folder"),
                    await n.mkdir(o);
                    break
                }
            case "writeFile":
                {
                    bn(a.type === "file", "Expected file"),
                    a.blobId && (a.isFakeBinary = !0),
                    await n.writeFile(o, a);
                    break
                }
            case "removeFile":
                {
                    bn(a.type === "file", "Expected file"),
                    await n.removeFile(o);
                    break
                }
            }
        await fetch(`/api/snapshot/${this.#t}/apply/${this.#e}`, {
            method: "POST"
        })
    }
    async #i() {
        const e = await fetch(`/api/snapshot/${this.#t}/${this.#e}`);
        if (!e.ok)
            throw new Error("Failed to load snapshot");
        const {snapshot: n} = await e.json();
        return n
    }
}
class eX {
    #t = !1;
    snapshots = ma({});
    async fetchSnapshots(e, n) {
        const r = await fetch(`/api/snapshot/${e}`, {
            signal: n
        })
          , {snapshots: i} = await r.json();
        this.snapshots.set(i.reduce( (s, o) => {
            const a = o.messageId;
            return s[a] = new a0(e,{
                ...o,
                finalized: !0
            }),
            s
        }
        , {
            ...this.snapshots.get()
        }))
    }
    create(e, n, r) {
        const i = new a0(e,{
            messageId: n,
            createdAt: Date.now()
        });
        return i.finalize(r),
        this.snapshots.setKey(n, i),
        i
    }
    hydrate(e, n) {
        const r = {};
        for (const i of n)
            if (i.snapshot) {
                const s = i.createdAt ? new Date(i.createdAt).getTime() : Date.now();
                r[i.id] = new a0(e,{
                    messageId: i.id,
                    createdAt: s,
                    finalized: !0
                })
            }
        this.snapshots.set(r)
    }
    async checkout(e, n, r) {
        bn(!this.#t, "Already checking out"),
        this.#t = !0,
        await this.snapshots.get()[e]?.apply(n, r),
        this.#t = !1
    }
}
const ea = new eX
  , SP = wt()
  , wP = SP;
function CP(t) {
    SP.set(t)
}
function Ew() {
    return wP.get()
}
function TP(t) {
    return t.replaceAll("&", "%26")
}
function tX() {
    const {slug: t, projectId: e} = Fl()
      , n = Ie(Kt.user)
      , r = ky()
      , [i,s] = S.useState(!1)
      , o = Qi()
      , a = Ry`
    I'm importing your StackBlitz project into Bolt. This may take a moment as I set everything up. Once it's ready, you'll be able to explore and interact with your code.

    <boltArtifact id="stackblitz-import" title="Importing StackBlitz Project">
      <boltAction type="import" target=${JSON.stringify(t)}></boltAction>
    </boltArtifact>
  `
      , l = [{
        id: sm,
        type: "chat",
        role: "assistant",
        status: "complete",
        content: a,
        ignore: !0,
        merge: !1
    }];
    return S.useEffect( () => {
        async function c() {
            const f = await fetch("/api/import/stackblitz", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    slug: t
                })
            });
            if (f.status === 404)
                return n || r(`/login?next=${TP(location.pathname)}`),
                Promise.reject(new Error("Project not found"));
            const g = await f.json();
            return "errorMessage"in g ? g : {
                ...g,
                id: String(g.id)
            }
        }
        async function u() {
            const f = await hX(e)
              , g = f?.messages ?? [];
            ea.hydrate(e, g);
            const _ = [...g, ...l];
            return mn.setKey("messages", _),
            f
        }
        async function h() {
            const f = await fetch(`/api/deploy/${e}`);
            if (f.status === 404) {
                if (Un) {
                    const _ = await nP(Un, t);
                    if (_?.deploy_url)
                        return {
                            deploy_url: _?.deploy_url
                        }
                }
                return
            }
            return {
                deploy_url: (await f.json()).site_url
            }
        }
        async function d() {
            if (Un)
                return Gq(Un, t)
        }
        Promise.all([c(), u(), h(), d()]).then( ([f,g,_,m]) => {
            if ("errorMessage"in f) {
                Uo.reject(),
                mn.setKey("statusMessage", f.errorMessage);
                return
            }
            Ne.updateProject(f),
            CP(f.title);
            const p = [...g?.messages ?? [], ...l, ...EP(f, m, _)];
            mn.setKey("deploymentInfo", _),
            mn.setKey("messages", p),
            o.resolve(g),
            Uo.resolve(),
            s(!0)
        }
        ).catch(f => {
            Uo.reject(),
            mn.setKey("statusMessage", f.message)
        }
        )
    }
    , []),
    {
        ready: i,
        chatHistory: o.promise,
        initialMessages: l
    }
}
function nX() {
    const {target: t} = Fl()
      , e = Ie(Kt.user)
      , n = ky()
      , [r,i] = S.useState(!1)
      , s = Ry`
    I'm importing your repository into Bolt. This may take a moment as I set everything up. Once it's ready, you'll be able to explore and interact with your code.

    <boltArtifact id="github-import" title="Importing Github Repository">
      <boltAction type="import" target="${t}"></boltAction>
    </boltArtifact>
  `
      , o = [{
        id: sm,
        type: "chat",
        role: "assistant",
        status: "complete",
        content: s,
        ignore: !0,
        merge: !1
    }];
    return S.useEffect( () => {
        mn.setKey("messages", o);
        async function a() {
            const c = await fetch("/api/import/github", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    target: t
                })
            });
            if (c.status === 404)
                return e || n(`/login?next=${TP(location.pathname)}`),
                Promise.reject(new Error("You don't have access to the repository"));
            if (c.status === 204)
                return await new Promise(h => setTimeout(h, 1e3)),
                await a();
            const u = await c.json();
            return "errorMessage"in u ? u : {
                ...u,
                id: String(u.id)
            }
        }
        const l = setTimeout( () => {
            mn.setKey("statusMessage", "We are still retrieving the repository, hang tight.")
        }
        , 5e3);
        a().then(c => {
            if ("errorMessage"in c) {
                Uo.reject(),
                mn.setKey("statusMessage", c.errorMessage);
                return
            }
            const u = lk(e);
            yk(u.plan, c.estimatedSize) && Ne.projectTooBig.set(!0);
            const h = c
              , {slug: d} = h;
            Uo.resolve(),
            mn.setKey("messages", [...o, ...EP(h)]),
            mn.setKey("statusMessage", ""),
            Ne.updateProject(h),
            Gv(d),
            i(!0)
        }
        ).catch(c => {
            Uo.reject(),
            mn.setKey("statusMessage", c.message)
        }
        ).finally( () => {
            clearTimeout(l)
        }
        )
    }
    , []),
    {
        ready: r,
        initialMessages: o
    }
}
var rX = {
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const iX = nr("ChatHistory")
  , Sw = [au, sm, im, l_]
  , sX = !rX.VITE_DISABLE_PERSISTENCE
  , Ed = new Map
  , oX = new Intl.DateTimeFormat(globalThis?.navigator?.language ?? "en-US",{
    dateStyle: "full",
    timeStyle: "short"
})
  , Un = sX ? await Vq() : void 0;
function Yv({projectReady: t, chatHistory: e}) {
    const {slug: n, projectId: r} = Fl()
      , [i,s] = S.useState(!1)
      , o = async l => {
        if (!Un)
            return;
        const c = await nP(Un, l);
        c && mn.setKey("deploymentInfo", c)
    }
    ;
    S.useEffect( () => {
        if (t)
            if (n || r) {
                const l = n ?? Ne.getSlug();
                o(l).catch(c => {
                    iX.error(c)
                }
                ).finally( () => {
                    s(!0)
                }
                )
            } else
                s(!0)
    }
    , [t]),
    S.useEffect( () => {
        if (!e)
            return;
        async function l() {
            const c = await e;
            if (c && c.messages.length > 0) {
                const {messages: u, editedAt: h} = c;
                if (aX(h, Ne.getEditedAt()) !== 0) {
                    const f = oX.format(new Date(Ne.getEditedAt()));
                    ct.info(v.jsx(K_, {
                        title: "Chat history may be incomplete",
                        message: "This project was last updated outside of Bolt on " + f + "."
                    }), {
                        autoClose: !1
                    })
                }
                ea.hydrate(r, u);
                const d = Ed.get(n) ?? new Set;
                for (const f of u)
                    d.add(f.id);
                Ed.set(n, d)
            }
            mn.setKey("chatLoadingStatus", "LOADED")
        }
        l()
    }
    , [e]);
    let a = Promise.resolve();
    return {
        ready: !n || i,
        storeMessageHistory: async l => {
            const c = Ne.getSlug();
            if (!Un || l.length === 0 || !i || !c)
                return;
            l = l.filter( ({id: g}) => !Sw.includes(g));
            const {firstArtifact: u} = me
              , h = Ne.getProjectId();
            if (!Ew()) {
                if (!u?.slug || !u?.title || !t)
                    return;
                CP(u?.title),
                mX(c, {
                    title: u.title
                }),
                a = fetch("/api/chats", {
                    method: "POST",
                    body: JSON.stringify({
                        projectId: h,
                        description: u.title
                    })
                })
            }
            const d = l.findLast( ({role: g}) => g === "assistant");
            if (d) {
                const g = d?.messageId ?? d?.id;
                await rP(Un, {
                    slug: c,
                    lastAssistantMessageId: g
                })
            }
            a = a.then( () => f());
            async function f(g=0) {
                if (!h)
                    return;
                const _ = Ed.get(c) ?? new Set
                  , m = [];
                for (const p of l.values()) {
                    const {id: b, role: y, content: x, createdAt: E, status: w, hidden: A, type: C} = p;
                    if (w !== "complete")
                        break;
                    Sw.includes(b) || _.has(b) || A || (_.add(b),
                    m.push({
                        id: b,
                        role: y,
                        content: x,
                        createdAt: E,
                        ...C === "problems" ? {
                            type: C,
                            problems: p.problems,
                            resolved: p.resolved
                        } : {}
                    }))
                }
                if (m.length > 0) {
                    Ed.set(c, _);
                    try {
                        if (!(await fetch(`/api/chats/${h}`, {
                            method: "POST",
                            body: JSON.stringify({
                                messages: m
                            })
                        })).ok)
                            throw new Error("Failed to update chat messages")
                    } catch {
                        for (const p of l)
                            _.delete(p.id);
                        g < 2 && (await fetch("/api/chats", {
                            method: "POST",
                            body: JSON.stringify({
                                projectId: h,
                                description: Ew()
                            })
                        }),
                        await f(g + 1))
                    }
                }
            }
        }
    }
}
function aX(t, e) {
    return !t || !e ? 0 : new Date(t).getTime() - new Date(e).getTime()
}
const lX = "package.json"
  , eb = ".bolt/config.json"
  , AP = [{
    name: "nextjs",
    startCommand: () => "npx next dev",
    detectors: {
        every: [vr("next")]
    }
}, {
    name: "remix",
    startCommand: t => `${t} run dev`,
    detectors: {
        every: [vr("remix"), Ur("dev")]
    }
}, {
    name: "nuxt3",
    startCommand: t => `${t} run dev`,
    detectors: {
        every: [vr("nuxt3"), Ur("dev")]
    }
}, {
    name: "nuxt2",
    startCommand: t => `${t} run dev`,
    detectors: {
        every: [vr("nuxt"), Ur("dev")]
    }
}, {
    name: "sveltekit",
    startCommand: t => `${t} run dev`,
    detectors: {
        every: [vr("@sveltejs/kit"), Ur("dev")]
    }
}, {
    name: "nestjs",
    startCommand: t => `${t} start`,
    detectors: {
        every: [vr("@nestjs/core"), Ur("start")]
    }
}, {
    name: "astro",
    startCommand: t => `${t} run dev`,
    build: {
        command: () => "npx astro build",
        output: "dist"
    },
    detectors: {
        every: [vr("astro"), Ur("dev")]
    }
}, {
    name: "docusaurus",
    startCommand: t => `${t} start`,
    detectors: {
        every: [vr("@docusaurus/core"), Ur("start")]
    }
}, {
    name: "slidev",
    startCommand: t => `${t} run dev`,
    build: {
        command: () => "npx slidev build",
        output: "dist"
    },
    detectors: {
        every: [vr("@slidev/cli"), Ur("dev")]
    }
}, {
    name: "eleventy",
    startCommand: t => `${t} start`,
    detectors: {
        every: [vr("@11ty/eleventy"), Ur("start")]
    }
}, {
    name: "nativescript",
    startCommand: () => "setup-nativescript-stackblitz && ns preview",
    detectors: {
        every: [vr("@nativescript/core"), vr("@nativescript/stackblitz")]
    }
}, {
    name: "DEFAULT_TO_DEV",
    startCommand: t => `${t} run dev`,
    detectors: {
        every: [Ur("dev")]
    }
}, {
    name: "DEFAULT_TO_START",
    startCommand: t => `${t} start`,
    detectors: {
        every: [Ur("start")]
    }
}];
function cX(t) {
    return AP.some(e => e.build?.command("npm") === t)
}
function vr(t) {
    return e => !!(e.dependencies?.[t] || e.devDependencies?.[t])
}
function Ur(t) {
    return e => !!e.scripts?.[t]
}
function kP(t) {
    return AP.find( ({detectors: e}) => {
        const n = [];
        return e.every?.length && n.push(e.every.every(r => r(t))),
        e.some?.length && n.push(e.some.some(r => r(t))),
        n.length > 0 && n.every(Boolean)
    }
    )
}
async function uX() {
    const t = await fetch("/api/chats");
    return t.ok ? (await t.json()).chats.map(n => ({
        ...n,
        timestamp: n.updatedAt,
        messages: []
    })) : (ct.error("Failed to load chats."),
    [])
}
async function hX(t) {
    const e = await fetch(`/api/chats/${t}`);
    if (!e.ok)
        return;
    const n = await e.json();
    return {
        editedAt: n.editedAt ? new Date(n.editedAt) : void 0,
        messages: n.messages.map(r => ({
            ...r,
            status: "complete",
            skipAction: !0
        }))
    }
}
async function dX(t) {
    (await fetch(`/api/chats/${t}`, {
        method: "DELETE"
    })).ok || ct.error("Failed to remove the chat.")
}
let Pa, ww = Promise.resolve();
async function RP(t, e) {
    const n = {};
    if (e.editedAt && (n.editedAt = new Date(e.editedAt).getTime()),
    e.description && (n.description = e.description),
    Object.keys(n).length !== 0) {
        if (Pa) {
            Pa = n;
            return
        }
        Pa = n,
        ww = ww.then(async () => {
            if (!Pa)
                return;
            const r = JSON.stringify(Pa);
            Pa = void 0,
            await fetch(`/api/chats/${t}`, {
                method: "PUT",
                body: r
            })
        }
        )
    }
}
const yf = wt();
function fX(t) {
    yf.set(t)
}
function IP() {
    return Kt.loggedIn.get() ? yf.get() ? Promise.resolve(yf.get()) : new Promise(t => yf.subscribe(e => {
        e && t(e)
    }
    )) : Promise.resolve()
}
async function pX() {
    pa.debug("Create empty project");
    const t = await Uh("api/projects/sb1/fork", {
        project: {
            appFiles: {}
        }
    }, "POST");
    return bn(t),
    {
        ...t,
        id: String(t.id)
    }
}
async function PP(t) {
    const {slug: e, files: n} = t
      , r = LP(n)
      , i = await Uh(`api/projects/${e}/fork`, {
        project: {
            appFiles: r
        }
    }, "POST");
    bn(i);
    const s = String(i.id)
      , o = i.slug
      , a = i.editedAt;
    return {
        id: s,
        slug: o,
        editedAt: a,
        access: i.access,
        visibility: i.visibility,
        frozen: i.frozen
    }
}
async function mX(t, e) {
    const {title: n} = e;
    await Uh(`api/projects/${t}`, {
        project: {
            title: n
        }
    }, "PATCH")
}
async function gX(t, e) {
    await Uh(`api/projects/${t}`, {
        project: {
            visibility: e
        }
    }, "PATCH")
}
async function DP(t) {
    const {slug: e, editedAt: n, files: r, force: i=!1, conflictHandler: s} = t
      , o = LP(r)
      , a = await Uh(`api/projects/${e}`, {
        project: {
            appFiles: o,
            editedAt: i ? void 0 : n
        }
    }, "PATCH", {
        409: async l => {
            const {lastEditor: c, editedAt: u} = await l.json();
            return s?.(c.username, u),
            !0
        }
        ,
        422: async l => {
            const c = await l.json();
            return bX(c) && c.errors.app_files && c.errors.app_files.includes("files changed for frozen project") ? (t.fork?.(),
            !0) : !1
        }
    });
    if (a)
        return RP(a.id, {
            editedAt: a.editedAt,
            description: a.title
        }),
        {
            id: a.id,
            editedAt: a.editedAt,
            title: a.title
        }
}
async function Uh(t, e, n, r) {
    let i;
    try {
        const s = await IP();
        if (!s || (i = await fetch(`${om}/${t}`, {
            headers: {
                "Content-Type": "application/json",
                authorization: `Bearer ${s}`
            },
            body: JSON.stringify(e),
            method: n
        }),
        r?.[i.status] && await r[i.status](i)))
            return;
        const o = await i.json();
        if (!i.ok)
            throw new Error(o.errors.map(a => a.message).join(`
`));
        return o
    } catch (s) {
        let o;
        try {
            o = i?.text()
        } catch {
            o = "response.text() failed"
        }
        throw Rr({
            action: Ir.Track,
            payload: {
                event: Yr.RailsApiCallFailed,
                properties: {
                    apiRoute: t,
                    method: n,
                    error: s.message,
                    status: i?.status,
                    statusText: i?.statusText,
                    body: JSON.stringify(e),
                    responseBody: o,
                    stack: new Error().stack
                }
            }
        }),
        s
    }
}
function _X(t, e) {
    return e.type === "file" ? {
        fullPath: t,
        contents: e?.type === "file" ? e.content : "",
        name: Cw(t),
        isBinary: e?.type === "file" ? e.isBinary ?? !1 : !1,
        type: "file",
        lastModified: Date.now(),
        blobId: e.blobId
    } : {
        type: "folder",
        fullPath: t,
        name: Cw(t),
        lastModified: Date.now()
    }
}
function LP(t) {
    const e = {};
    if (Object.keys(t).length === 0)
        return Promise.resolve();
    for (const [n,r] of Object.entries(t))
        if (r) {
            const i = n.substring(jt.length + 1);
            e[i] = _X(i, r)
        }
    return e
}
function bX(t) {
    return typeof t == "object" && t !== null && "errors"in t
}
function Cw(t) {
    return t.split("/").pop()
}
const yX = new Set(["shell", "start"])
  , vX = S.memo( ({id: t, scrollToBottom: e}) => {
    const n = S.useRef(!1)
      , [r,i] = S.useState(!1)
      , o = Ie(me.artifacts)[t];
    Ie(o.runner.stateUpdates);
    const a = [...o.runner.actions.values()]
      , l = S.useCallback(c => {
        n.current = !0,
        i(c)
    }
    , []);
    return S.useEffect( () => {
        a.length && !r && !n.current && i(!0)
    }
    , [a]),
    v.jsx(Dm, {
        open: r,
        scrollToBottom: e,
        onToggle: l,
        "data-artifact-id": o.id,
        className: "artifact",
        titleClassName: "bg-bolt-elements-artifacts-background",
        title: v.jsx("div", {
            className: "p-5 grow text-bolt-elements-textPrimary font-medium",
            children: o.title
        }),
        toggleButton: a.length > 0 && "large",
        children: v.jsx(hs, {
            children: a.length > 0 && v.jsx("div", {
                className: "actions p-5 text-left bg-bolt-elements-actions-background",
                children: v.jsx(SX, {
                    actions: a
                })
            })
        })
    })
}
)
  , xX = {
    hidden: {
        opacity: 0,
        y: 20
    },
    visible: {
        opacity: 1,
        y: 0
    }
}
  , EX = S.memo( ({action: t, isLast: e}) => {
    const n = Ie(me.currentView)
      , r = Ie(me.selectedFile)
      , i = Ie(mn)
      , s = Ie(t.content)
      , o = Ie(t.status)
      , {type: a} = t
      , l = t.type === "file"
      , c = n === "code"
      , u = n === "preview"
      , h = t instanceof Bm
      , d = u && h || l && c && r === Pt(t.filePath)
      , f = !d && (h || l)
      , g = TX(t);
    return v.jsxs(It.li, {
        variants: xX,
        initial: "hidden",
        animate: "visible",
        transition: {
            duration: .2,
            ease: Ft
        },
        children: [v.jsxs("button", {
            className: be("group select-none flex gap-1.5 text-sm bg-transparent text-left", {
                "text-bolt-elements-item-contentAccent": d,
                "hover:underline": f,
                "pointer-events-none": !f,
                "pb-1": t instanceof Xs || a === "import-project"
            }),
            onClick: () => {
                h ? me.currentView.set("preview") : a === "file" && (me.currentView.set("code"),
                me.setSelectedFile(t.filePath))
            }
            ,
            children: [v.jsxs("div", {
                className: "flex items-center gap-1.5",
                children: [v.jsx("div", {
                    className: be("text-lg", wX(o)),
                    children: o === "running" ? v.jsx(v.Fragment, {
                        children: !yX.has(t.type) || cX(t.content.value) ? v.jsx("div", {
                            className: "i-svg-spinners:90-ring-with-bg"
                        }) : v.jsx("div", {
                            className: "i-ph:terminal"
                        })
                    }) : o === "pending" || o === "skipped" ? v.jsx("div", {
                        className: "i-ph:circle-duotone"
                    }) : o === "complete" ? v.jsx("div", {
                        className: "i-ph:check"
                    }) : o === "failed" || o === "aborted" ? v.jsx("div", {
                        className: "i-ph:x"
                    }) : null
                }), CX(t)]
            }), g && v.jsx("span", {
                children: v.jsx("code", {
                    className: be("select-text bg-bolt-elements-artifacts-inlineCode-background px-1.5 py-1 rounded-md break-all", {
                        "text-bolt-elements-artifacts-inlineCode-text": !d
                    }),
                    children: g
                })
            })]
        }), a === "import-project" && i.statusMessage.length > 0 && v.jsx("div", {
            className: "ml-6 mt-1 text-sm text-bolt-elements-textSecondary",
            children: i.statusMessage
        }), (t instanceof Xs || a === "build") && s && v.jsx(tP, {
            className: be("border border-bolt-elements-borderColor overflow-hidden rounded-lg w-full mt-1", {
                "mb-3.5": !e
            }),
            code: s
        }), a === "deploy" && s && v.jsx("div", {
            className: "ml-6 mt-1 text-sm text-bolt-elements-textSecondary",
            children: v.jsx("a", {
                href: s,
                target: "_blank",
                children: "Open website"
            })
        })]
    })
}
)
  , SX = S.memo( ({actions: t}) => {
    const [e,n] = S.useState([]);
    S.useEffect( () => me.subscribeToActions(n), []);
    const r = S.useMemo( () => {
        const i = e.find(o => o.type === "start" && (o.status.value === "running" || o.status.value === "pending"))
          , s = t.filter(o => o.type !== "start" ? !0 : o.status.value === "skipped" ? !1 : o.status.value === "running" || o.status.value === "pending" ? o === i : !0);
        return s.length ? s : t
    }
    , [t, e]);
    return v.jsx("ul", {
        className: "list-none space-y-2.5",
        children: r.flatMap( (i, s) => {
            const o = s === r.length - 1;
            return OP(i, o)
        }
        )
    })
}
);
function OP(t, e) {
    if (t instanceof Wv) {
        const n = Ie(t.actions);
        return n.flatMap( (r, i) => {
            const s = i === n.length - 1;
            return OP(r, e && s)
        }
        )
    }
    return v.jsx(EX, {
        action: t,
        isLast: e
    }, t.id)
}
function wX(t) {
    switch (t) {
    case "skipped":
    case "pending":
        return "text-bolt-elements-textTertiary";
    case "running":
        return "text-bolt-elements-loader-progress";
    case "complete":
        return "text-bolt-elements-icon-success";
    case "aborted":
        return "text-bolt-elements-textSecondary";
    case "failed":
        return "text-bolt-elements-icon-error";
    default:
        return
    }
}
function CX(t) {
    switch (t.type) {
    case "file":
        return t.actionType;
    case "import-project":
        return "Import";
    case "install":
        return "Install dependencies";
    case "start":
        return "Start application";
    case "shell":
        return "Run command";
    case "import-template":
        return "Create initial files";
    case "build":
        return "Build application";
    case "deploy":
        return "Deploy to"
    }
    return null
}
function TX(t) {
    switch (t.type) {
    case "file":
        return t.filePath;
    case "import-project":
        return t.target;
    case "deploy":
        return t.provider
    }
    return null
}
const Tw = nr("CodeBlock")
  , NP = S.memo( ({className: t, code: e, language: n="plaintext", theme: r="dark-plus", disableCopy: i=!1}) => {
    const [s,o] = S.useState(void 0)
      , [a,l] = S.useState(!1)
      , c = () => {
        a || (navigator.clipboard.writeText(e),
        l(!0),
        setTimeout( () => {
            l(!1)
        }
        , 2e3))
    }
    ;
    return S.useEffect( () => {
        n && !jv(n) && !(n in _I) && (Tw.warn(`Unsupported language '${n}'`),
        n = "plaintext"),
        Tw.trace(`Language = ${n}`),
        (async () => {
            o(await Fq(e, {
                lang: n,
                theme: r
            }))
        }
        )()
    }
    , [e]),
    v.jsxs("div", {
        className: be("relative group text-left", t),
        children: [v.jsx("div", {
            className: "bg-gray-100 dark:bg-gray-800 text-gray-950 dark:text-gray-400 absolute top-[10px] right-[10px] rounded-md text-lg z-10 flex items-center justify-center opacity-0 group-hover:opacity-100",
            children: !i && v.jsx("button", {
                className: "flex items-center bg-transparent p-1.5 justify-center",
                title: "Copy Code",
                onClick: () => c(),
                children: v.jsx("div", {
                    className: a ? "i-ph:check" : "i-ph:clipboard-text"
                })
            })
        }), v.jsx("div", {
            dangerouslySetInnerHTML: {
                __html: s ?? ""
            }
        })]
    })
}
);
function AX() {
    He.showPricingOverlay()
}
const kX = S.memo( ({text: t}) => v.jsx("button", {
    className: "bg-transparent text-bolt-elements-messages-linkColor hover:underline",
    onClick: AX,
    children: t || "Upgrade"
}))
  , MP = ["a", "b", "blockquote", "br", "code", "dd", "del", "details", "div", "dl", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "ins", "kbd", "li", "ol", "p", "pre", "q", "rp", "rt", "ruby", "s", "samp", "source", "span", "strike", "strong", "sub", "summary", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul", "var"]
  , Aw = /[#.]/g;
function RX(t, e) {
    const n = t || ""
      , r = {};
    let i = 0, s, o;
    for (; i < n.length; ) {
        Aw.lastIndex = i;
        const a = Aw.exec(n)
          , l = n.slice(i, a ? a.index : n.length);
        l && (s ? s === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : o = l,
        i += l.length),
        a && (s = a[0],
        i++)
    }
    return {
        type: "element",
        tagName: o || e || "div",
        properties: r,
        children: []
    }
}
const IX = new Set(["button", "menu", "reset", "submit"])
  , tb = {}.hasOwnProperty;
function BP(t, e, n) {
    const r = n && OX(n);
    function i(s, o, ...a) {
        let l = -1, c;
        if (s == null) {
            c = {
                type: "root",
                children: []
            };
            const u = o;
            a.unshift(u)
        } else if (c = RX(s, e),
        c.tagName = c.tagName.toLowerCase(),
        r && tb.call(r, c.tagName) && (c.tagName = r[c.tagName]),
        PX(o, c.tagName)) {
            let u;
            for (u in o)
                tb.call(o, u) && DX(t, c.properties, u, o[u])
        } else
            a.unshift(o);
        for (; ++l < a.length; )
            nb(c.children, a[l]);
        return c.type === "element" && c.tagName === "template" && (c.content = {
            type: "root",
            children: c.children
        },
        c.children = []),
        c
    }
    return i
}
function PX(t, e) {
    return t == null || typeof t != "object" || Array.isArray(t) ? !1 : e === "input" || !t.type || typeof t.type != "string" ? !0 : "children"in t && Array.isArray(t.children) ? !1 : e === "button" ? IX.has(t.type.toLowerCase()) : !("value"in t)
}
function DX(t, e, n, r) {
    const i = Cm(t, n);
    let s = -1, o;
    if (r != null) {
        if (typeof r == "number") {
            if (Number.isNaN(r))
                return;
            o = r
        } else
            typeof r == "boolean" ? o = r : typeof r == "string" ? i.spaceSeparated ? o = hS(r) : i.commaSeparated ? o = oS(r) : i.commaOrSpaceSeparated ? o = hS(oS(r).join(" ")) : o = kw(i, i.property, r) : Array.isArray(r) ? o = r.concat() : o = i.property === "style" ? LX(r) : String(r);
        if (Array.isArray(o)) {
            const a = [];
            for (; ++s < o.length; ) {
                const l = kw(i, i.property, o[s]);
                a[s] = l
            }
            o = a
        }
        if (i.property === "className" && Array.isArray(e.className)) {
            const a = o;
            o = e.className.concat(a)
        }
        e[i.property] = o
    }
}
function nb(t, e) {
    let n = -1;
    if (e != null)
        if (typeof e == "string" || typeof e == "number")
            t.push({
                type: "text",
                value: String(e)
            });
        else if (Array.isArray(e))
            for (; ++n < e.length; )
                nb(t, e[n]);
        else if (typeof e == "object" && "type"in e)
            e.type === "root" ? nb(t, e.children) : t.push(e);
        else
            throw new Error("Expected node, nodes, or string, got `" + e + "`")
}
function kw(t, e, n) {
    if (typeof n == "string") {
        if (t.number && n && !Number.isNaN(Number(n)))
            return Number(n);
        if ((t.boolean || t.overloadedBoolean) && (n === "" || gu(n) === gu(e)))
            return !0
    }
    return n
}
function LX(t) {
    const e = [];
    let n;
    for (n in t)
        tb.call(t, n) && e.push([n, t[n]].join(": "));
    return e.join("; ")
}
function OX(t) {
    const e = {};
    let n = -1;
    for (; ++n < t.length; )
        e[t[n].toLowerCase()] = t[n];
    return e
}
const NX = ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"]
  , MX = BP(Oh, "div")
  , BX = BP(so, "g", NX)
  , l0 = /\r?\n|\r/g;
function FX(t) {
    const e = String(t)
      , n = [];
    for (l0.lastIndex = 0; l0.test(e); )
        n.push(l0.lastIndex);
    return n.push(e.length + 1),
    {
        toPoint: r,
        toOffset: i
    };
    function r(s) {
        let o = -1;
        if (typeof s == "number" && s > -1 && s < n[n.length - 1]) {
            for (; ++o < n.length; )
                if (n[o] > s)
                    return {
                        line: o + 1,
                        column: s - (o > 0 ? n[o - 1] : 0) + 1,
                        offset: s
                    }
        }
    }
    function i(s) {
        const o = s && s.line
          , a = s && s.column;
        if (typeof o == "number" && typeof a == "number" && !Number.isNaN(o) && !Number.isNaN(a) && o - 1 in n) {
            const l = (n[o - 2] || 0) + a - 1 || 0;
            if (l > -1 && l < n[n.length - 1])
                return l
        }
    }
}
const Ro = {
    html: "http://www.w3.org/1999/xhtml",
    mathml: "http://www.w3.org/1998/Math/MathML",
    svg: "http://www.w3.org/2000/svg",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
}
  , FP = {}.hasOwnProperty
  , jX = Object.prototype;
function HX(t, e) {
    const n = e || {};
    return Xv({
        file: n.file || void 0,
        location: !1,
        schema: n.space === "svg" ? so : Oh,
        verbose: n.verbose || !1
    }, t)
}
function Xv(t, e) {
    let n;
    switch (e.nodeName) {
    case "#comment":
        {
            const r = e;
            return n = {
                type: "comment",
                value: r.data
            },
            vf(t, r, n),
            n
        }
    case "#document":
    case "#document-fragment":
        {
            const r = e
              , i = "mode"in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
            if (n = {
                type: "root",
                children: jP(t, e.childNodes),
                data: {
                    quirksMode: i
                }
            },
            t.file && t.location) {
                const s = String(t.file)
                  , o = FX(s)
                  , a = o.toPoint(0)
                  , l = o.toPoint(s.length);
                n.position = {
                    start: a,
                    end: l
                }
            }
            return n
        }
    case "#documentType":
        {
            const r = e;
            return n = {
                type: "doctype"
            },
            vf(t, r, n),
            n
        }
    case "#text":
        {
            const r = e;
            return n = {
                type: "text",
                value: r.value
            },
            vf(t, r, n),
            n
        }
    default:
        return n = UX(t, e),
        n
    }
}
function jP(t, e) {
    let n = -1;
    const r = [];
    for (; ++n < e.length; ) {
        const i = Xv(t, e[n]);
        r.push(i)
    }
    return r
}
function UX(t, e) {
    const n = t.schema;
    t.schema = e.namespaceURI === Ro.svg ? so : Oh;
    let r = -1;
    const i = {};
    for (; ++r < e.attrs.length; ) {
        const a = e.attrs[r]
          , l = (a.prefix ? a.prefix + ":" : "") + a.name;
        FP.call(jX, l) || (i[l] = a.value)
    }
    const o = (t.schema.space === "svg" ? BX : MX)(e.tagName, i, jP(t, e.childNodes));
    if (vf(t, e, o),
    o.tagName === "template") {
        const a = e
          , l = a.sourceCodeLocation
          , c = l && l.startTag && Ja(l.startTag)
          , u = l && l.endTag && Ja(l.endTag)
          , h = Xv(t, a.content);
        c && u && t.file && (h.position = {
            start: c.end,
            end: u.start
        }),
        o.content = h
    }
    return t.schema = n,
    o
}
function vf(t, e, n) {
    if ("sourceCodeLocation"in e && e.sourceCodeLocation && t.file) {
        const r = VX(t, n, e.sourceCodeLocation);
        r && (t.location = !0,
        n.position = r)
    }
}
function VX(t, e, n) {
    const r = Ja(n);
    if (e.type === "element") {
        const i = e.children[e.children.length - 1];
        if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)),
        t.verbose) {
            const s = {};
            let o;
            if (n.attrs)
                for (o in n.attrs)
                    FP.call(n.attrs, o) && (s[Cm(t.schema, o).property] = Ja(n.attrs[o]));
            n.startTag;
            const a = Ja(n.startTag)
              , l = n.endTag ? Ja(n.endTag) : void 0
              , c = {
                opening: a
            };
            l && (c.closing = l),
            c.properties = s,
            e.data = {
                position: c
            }
        }
    }
    return r
}
function Ja(t) {
    const e = Rw({
        line: t.startLine,
        column: t.startCol,
        offset: t.startOffset
    })
      , n = Rw({
        line: t.endLine,
        column: t.endCol,
        offset: t.endOffset
    });
    return e || n ? {
        start: e,
        end: n
    } : void 0
}
function Rw(t) {
    return t.line && t.column ? t : void 0
}
const Iw = {}.hasOwnProperty;
function HP(t, e) {
    const n = e || {};
    function r(i, ...s) {
        let o = r.invalid;
        const a = r.handlers;
        if (i && Iw.call(i, t)) {
            const l = String(i[t]);
            o = Iw.call(a, l) ? a[l] : r.unknown
        }
        if (o)
            return o.call(this, i, ...s)
    }
    return r.handlers = n.handlers || {},
    r.invalid = n.invalid,
    r.unknown = n.unknown,
    r
}
const $X = {}
  , zX = {}.hasOwnProperty
  , UP = HP("type", {
    handlers: {
        root: GX,
        element: QX,
        text: YX,
        comment: XX,
        doctype: KX
    }
});
function WX(t, e) {
    const r = (e || $X).space;
    return UP(t, r === "svg" ? so : Oh)
}
function GX(t, e) {
    const n = {
        nodeName: "#document",
        mode: (t.data || {}).quirksMode ? "quirks" : "no-quirks",
        childNodes: []
    };
    return n.childNodes = Qv(t.children, n, e),
    Wl(t, n),
    n
}
function qX(t, e) {
    const n = {
        nodeName: "#document-fragment",
        childNodes: []
    };
    return n.childNodes = Qv(t.children, n, e),
    Wl(t, n),
    n
}
function KX(t) {
    const e = {
        nodeName: "#documentType",
        name: "html",
        publicId: "",
        systemId: "",
        parentNode: null
    };
    return Wl(t, e),
    e
}
function YX(t) {
    const e = {
        nodeName: "#text",
        value: t.value,
        parentNode: null
    };
    return Wl(t, e),
    e
}
function XX(t) {
    const e = {
        nodeName: "#comment",
        data: t.value,
        parentNode: null
    };
    return Wl(t, e),
    e
}
function QX(t, e) {
    const n = e;
    let r = n;
    t.type === "element" && t.tagName.toLowerCase() === "svg" && n.space === "html" && (r = so);
    const i = [];
    let s;
    if (t.properties) {
        for (s in t.properties)
            if (s !== "children" && zX.call(t.properties, s)) {
                const l = JX(r, s, t.properties[s]);
                l && i.push(l)
            }
    }
    const o = r.space
      , a = {
        nodeName: t.tagName,
        tagName: t.tagName,
        attrs: i,
        namespaceURI: Ro[o],
        childNodes: [],
        parentNode: null
    };
    return a.childNodes = Qv(t.children, a, r),
    Wl(t, a),
    t.tagName === "template" && t.content && (a.content = qX(t.content, r)),
    a
}
function JX(t, e, n) {
    const r = Cm(t, e);
    if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
        return;
    Array.isArray(n) && (n = r.commaSeparated ? R2(n) : F2(n));
    const i = {
        name: r.attribute,
        value: n === !0 ? "" : String(n)
    };
    if (r.space && r.space !== "html" && r.space !== "svg") {
        const s = i.name.indexOf(":");
        s < 0 ? i.prefix = "" : (i.name = i.name.slice(s + 1),
        i.prefix = r.attribute.slice(0, s)),
        i.namespace = Ro[r.space]
    }
    return i
}
function Qv(t, e, n) {
    let r = -1;
    const i = [];
    if (t)
        for (; ++r < t.length; ) {
            const s = UP(t[r], n);
            s.parentNode = e,
            i.push(s)
        }
    return i
}
function Wl(t, e) {
    const n = t.position;
    n && n.start && n.end && (n.start.offset,
    n.end.offset,
    e.sourceCodeLocation = {
        startLine: n.start.line,
        startCol: n.start.column,
        startOffset: n.start.offset,
        endLine: n.end.line,
        endCol: n.end.column,
        endOffset: n.end.offset
    })
}
const ZX = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]
  , eQ = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111])
  , Lt = "";
var U;
(function(t) {
    t[t.EOF = -1] = "EOF",
    t[t.NULL = 0] = "NULL",
    t[t.TABULATION = 9] = "TABULATION",
    t[t.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN",
    t[t.LINE_FEED = 10] = "LINE_FEED",
    t[t.FORM_FEED = 12] = "FORM_FEED",
    t[t.SPACE = 32] = "SPACE",
    t[t.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK",
    t[t.QUOTATION_MARK = 34] = "QUOTATION_MARK",
    t[t.NUMBER_SIGN = 35] = "NUMBER_SIGN",
    t[t.AMPERSAND = 38] = "AMPERSAND",
    t[t.APOSTROPHE = 39] = "APOSTROPHE",
    t[t.HYPHEN_MINUS = 45] = "HYPHEN_MINUS",
    t[t.SOLIDUS = 47] = "SOLIDUS",
    t[t.DIGIT_0 = 48] = "DIGIT_0",
    t[t.DIGIT_9 = 57] = "DIGIT_9",
    t[t.SEMICOLON = 59] = "SEMICOLON",
    t[t.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN",
    t[t.EQUALS_SIGN = 61] = "EQUALS_SIGN",
    t[t.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN",
    t[t.QUESTION_MARK = 63] = "QUESTION_MARK",
    t[t.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A",
    t[t.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F",
    t[t.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X",
    t[t.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z",
    t[t.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET",
    t[t.GRAVE_ACCENT = 96] = "GRAVE_ACCENT",
    t[t.LATIN_SMALL_A = 97] = "LATIN_SMALL_A",
    t[t.LATIN_SMALL_F = 102] = "LATIN_SMALL_F",
    t[t.LATIN_SMALL_X = 120] = "LATIN_SMALL_X",
    t[t.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z",
    t[t.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER"
}
)(U = U || (U = {}));
const qn = {
    DASH_DASH: "--",
    CDATA_START: "[CDATA[",
    DOCTYPE: "doctype",
    SCRIPT: "script",
    PUBLIC: "public",
    SYSTEM: "system"
};
function VP(t) {
    return t >= 55296 && t <= 57343
}
function tQ(t) {
    return t >= 56320 && t <= 57343
}
function nQ(t, e) {
    return (t - 55296) * 1024 + 9216 + e
}
function $P(t) {
    return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159
}
function zP(t) {
    return t >= 64976 && t <= 65007 || eQ.has(t)
}
var ue;
(function(t) {
    t.controlCharacterInInputStream = "control-character-in-input-stream",
    t.noncharacterInInputStream = "noncharacter-in-input-stream",
    t.surrogateInInputStream = "surrogate-in-input-stream",
    t.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus",
    t.endTagWithAttributes = "end-tag-with-attributes",
    t.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus",
    t.unexpectedSolidusInTag = "unexpected-solidus-in-tag",
    t.unexpectedNullCharacter = "unexpected-null-character",
    t.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name",
    t.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name",
    t.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name",
    t.missingEndTagName = "missing-end-tag-name",
    t.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name",
    t.unknownNamedCharacterReference = "unknown-named-character-reference",
    t.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference",
    t.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier",
    t.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value",
    t.eofBeforeTagName = "eof-before-tag-name",
    t.eofInTag = "eof-in-tag",
    t.missingAttributeValue = "missing-attribute-value",
    t.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes",
    t.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword",
    t.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers",
    t.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword",
    t.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier",
    t.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier",
    t.missingDoctypePublicIdentifier = "missing-doctype-public-identifier",
    t.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier",
    t.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier",
    t.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier",
    t.cdataInHtmlContent = "cdata-in-html-content",
    t.incorrectlyOpenedComment = "incorrectly-opened-comment",
    t.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text",
    t.eofInDoctype = "eof-in-doctype",
    t.nestedComment = "nested-comment",
    t.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment",
    t.eofInComment = "eof-in-comment",
    t.incorrectlyClosedComment = "incorrectly-closed-comment",
    t.eofInCdata = "eof-in-cdata",
    t.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference",
    t.nullCharacterReference = "null-character-reference",
    t.surrogateCharacterReference = "surrogate-character-reference",
    t.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range",
    t.controlCharacterReference = "control-character-reference",
    t.noncharacterCharacterReference = "noncharacter-character-reference",
    t.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name",
    t.missingDoctypeName = "missing-doctype-name",
    t.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name",
    t.duplicateAttribute = "duplicate-attribute",
    t.nonConformingDoctype = "non-conforming-doctype",
    t.missingDoctype = "missing-doctype",
    t.misplacedDoctype = "misplaced-doctype",
    t.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element",
    t.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements",
    t.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head",
    t.openElementsLeftAfterEof = "open-elements-left-after-eof",
    t.abandonedHeadElementChild = "abandoned-head-element-child",
    t.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element",
    t.nestedNoscriptInHead = "nested-noscript-in-head",
    t.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text"
}
)(ue = ue || (ue = {}));
const rQ = 65536;
class iQ {
    constructor(e) {
        this.handler = e,
        this.html = "",
        this.pos = -1,
        this.lastGapPos = -2,
        this.gapStack = [],
        this.skipNextNewLine = !1,
        this.lastChunkWritten = !1,
        this.endOfChunkHit = !1,
        this.bufferWaterline = rQ,
        this.isEol = !1,
        this.lineStartPos = 0,
        this.droppedBufferSize = 0,
        this.line = 1,
        this.lastErrOffset = -1
    }
    get col() {
        return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos)
    }
    get offset() {
        return this.droppedBufferSize + this.pos
    }
    getError(e) {
        const {line: n, col: r, offset: i} = this;
        return {
            code: e,
            startLine: n,
            endLine: n,
            startCol: r,
            endCol: r,
            startOffset: i,
            endOffset: i
        }
    }
    _err(e) {
        this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset,
        this.handler.onParseError(this.getError(e)))
    }
    _addGap() {
        this.gapStack.push(this.lastGapPos),
        this.lastGapPos = this.pos
    }
    _processSurrogate(e) {
        if (this.pos !== this.html.length - 1) {
            const n = this.html.charCodeAt(this.pos + 1);
            if (tQ(n))
                return this.pos++,
                this._addGap(),
                nQ(e, n)
        } else if (!this.lastChunkWritten)
            return this.endOfChunkHit = !0,
            U.EOF;
        return this._err(ue.surrogateInInputStream),
        e
    }
    willDropParsedChunk() {
        return this.pos > this.bufferWaterline
    }
    dropParsedChunk() {
        this.willDropParsedChunk() && (this.html = this.html.substring(this.pos),
        this.lineStartPos -= this.pos,
        this.droppedBufferSize += this.pos,
        this.pos = 0,
        this.lastGapPos = -2,
        this.gapStack.length = 0)
    }
    write(e, n) {
        this.html.length > 0 ? this.html += e : this.html = e,
        this.endOfChunkHit = !1,
        this.lastChunkWritten = n
    }
    insertHtmlAtCurrentPos(e) {
        this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1),
        this.endOfChunkHit = !1
    }
    startsWith(e, n) {
        if (this.pos + e.length > this.html.length)
            return this.endOfChunkHit = !this.lastChunkWritten,
            !1;
        if (n)
            return this.html.startsWith(e, this.pos);
        for (let r = 0; r < e.length; r++)
            if ((this.html.charCodeAt(this.pos + r) | 32) !== e.charCodeAt(r))
                return !1;
        return !0
    }
    peek(e) {
        const n = this.pos + e;
        if (n >= this.html.length)
            return this.endOfChunkHit = !this.lastChunkWritten,
            U.EOF;
        const r = this.html.charCodeAt(n);
        return r === U.CARRIAGE_RETURN ? U.LINE_FEED : r
    }
    advance() {
        if (this.pos++,
        this.isEol && (this.isEol = !1,
        this.line++,
        this.lineStartPos = this.pos),
        this.pos >= this.html.length)
            return this.endOfChunkHit = !this.lastChunkWritten,
            U.EOF;
        let e = this.html.charCodeAt(this.pos);
        return e === U.CARRIAGE_RETURN ? (this.isEol = !0,
        this.skipNextNewLine = !0,
        U.LINE_FEED) : e === U.LINE_FEED && (this.isEol = !0,
        this.skipNextNewLine) ? (this.line--,
        this.skipNextNewLine = !1,
        this._addGap(),
        this.advance()) : (this.skipNextNewLine = !1,
        VP(e) && (e = this._processSurrogate(e)),
        this.handler.onParseError === null || e > 31 && e < 127 || e === U.LINE_FEED || e === U.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e),
        e)
    }
    _checkForProblematicCharacters(e) {
        $P(e) ? this._err(ue.controlCharacterInInputStream) : zP(e) && this._err(ue.noncharacterInInputStream)
    }
    retreat(e) {
        for (this.pos -= e; this.pos < this.lastGapPos; )
            this.lastGapPos = this.gapStack.pop(),
            this.pos--;
        this.isEol = !1
    }
}
var tt;
(function(t) {
    t[t.CHARACTER = 0] = "CHARACTER",
    t[t.NULL_CHARACTER = 1] = "NULL_CHARACTER",
    t[t.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER",
    t[t.START_TAG = 3] = "START_TAG",
    t[t.END_TAG = 4] = "END_TAG",
    t[t.COMMENT = 5] = "COMMENT",
    t[t.DOCTYPE = 6] = "DOCTYPE",
    t[t.EOF = 7] = "EOF",
    t[t.HIBERNATION = 8] = "HIBERNATION"
}
)(tt = tt || (tt = {}));
function WP(t, e) {
    for (let n = t.attrs.length - 1; n >= 0; n--)
        if (t.attrs[n].name === e)
            return t.attrs[n].value;
    return null
}
const _s = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(t => t.charCodeAt(0)))
  , sQ = new Uint16Array("aglq	\x1B\0\0p;os;t;t;uot;".split("").map(t => t.charCodeAt(0)));
var c0;
const oQ = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]])
  , aQ = (c0 = String.fromCodePoint) !== null && c0 !== void 0 ? c0 : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536,
    e += String.fromCharCode(t >>> 10 & 1023 | 55296),
    t = 56320 | t & 1023),
    e += String.fromCharCode(t),
    e
}
;
function lQ(t) {
    var e;
    return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = oQ.get(t)) !== null && e !== void 0 ? e : t
}
var cn;
(function(t) {
    t[t.NUM = 35] = "NUM",
    t[t.SEMI = 59] = "SEMI",
    t[t.EQUALS = 61] = "EQUALS",
    t[t.ZERO = 48] = "ZERO",
    t[t.NINE = 57] = "NINE",
    t[t.LOWER_A = 97] = "LOWER_A",
    t[t.LOWER_F = 102] = "LOWER_F",
    t[t.LOWER_X = 120] = "LOWER_X",
    t[t.LOWER_Z = 122] = "LOWER_Z",
    t[t.UPPER_A = 65] = "UPPER_A",
    t[t.UPPER_F = 70] = "UPPER_F",
    t[t.UPPER_Z = 90] = "UPPER_Z"
}
)(cn || (cn = {}));
const cQ = 32;
var xi;
(function(t) {
    t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH",
    t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH",
    t[t.JUMP_TABLE = 127] = "JUMP_TABLE"
}
)(xi || (xi = {}));
function rb(t) {
    return t >= cn.ZERO && t <= cn.NINE
}
function uQ(t) {
    return t >= cn.UPPER_A && t <= cn.UPPER_F || t >= cn.LOWER_A && t <= cn.LOWER_F
}
function hQ(t) {
    return t >= cn.UPPER_A && t <= cn.UPPER_Z || t >= cn.LOWER_A && t <= cn.LOWER_Z || rb(t)
}
function dQ(t) {
    return t === cn.EQUALS || hQ(t)
}
var rn;
(function(t) {
    t[t.EntityStart = 0] = "EntityStart",
    t[t.NumericStart = 1] = "NumericStart",
    t[t.NumericDecimal = 2] = "NumericDecimal",
    t[t.NumericHex = 3] = "NumericHex",
    t[t.NamedEntity = 4] = "NamedEntity"
}
)(rn || (rn = {}));
var wo;
(function(t) {
    t[t.Legacy = 0] = "Legacy",
    t[t.Strict = 1] = "Strict",
    t[t.Attribute = 2] = "Attribute"
}
)(wo || (wo = {}));
class fQ {
    constructor(e, n, r) {
        this.decodeTree = e,
        this.emitCodePoint = n,
        this.errors = r,
        this.state = rn.EntityStart,
        this.consumed = 1,
        this.result = 0,
        this.treeIndex = 0,
        this.excess = 1,
        this.decodeMode = wo.Strict
    }
    startEntity(e) {
        this.decodeMode = e,
        this.state = rn.EntityStart,
        this.result = 0,
        this.treeIndex = 0,
        this.excess = 1,
        this.consumed = 1
    }
    write(e, n) {
        switch (this.state) {
        case rn.EntityStart:
            return e.charCodeAt(n) === cn.NUM ? (this.state = rn.NumericStart,
            this.consumed += 1,
            this.stateNumericStart(e, n + 1)) : (this.state = rn.NamedEntity,
            this.stateNamedEntity(e, n));
        case rn.NumericStart:
            return this.stateNumericStart(e, n);
        case rn.NumericDecimal:
            return this.stateNumericDecimal(e, n);
        case rn.NumericHex:
            return this.stateNumericHex(e, n);
        case rn.NamedEntity:
            return this.stateNamedEntity(e, n)
        }
    }
    stateNumericStart(e, n) {
        return n >= e.length ? -1 : (e.charCodeAt(n) | cQ) === cn.LOWER_X ? (this.state = rn.NumericHex,
        this.consumed += 1,
        this.stateNumericHex(e, n + 1)) : (this.state = rn.NumericDecimal,
        this.stateNumericDecimal(e, n))
    }
    addToNumericResult(e, n, r, i) {
        if (n !== r) {
            const s = r - n;
            this.result = this.result * Math.pow(i, s) + parseInt(e.substr(n, s), i),
            this.consumed += s
        }
    }
    stateNumericHex(e, n) {
        const r = n;
        for (; n < e.length; ) {
            const i = e.charCodeAt(n);
            if (rb(i) || uQ(i))
                n += 1;
            else
                return this.addToNumericResult(e, r, n, 16),
                this.emitNumericEntity(i, 3)
        }
        return this.addToNumericResult(e, r, n, 16),
        -1
    }
    stateNumericDecimal(e, n) {
        const r = n;
        for (; n < e.length; ) {
            const i = e.charCodeAt(n);
            if (rb(i))
                n += 1;
            else
                return this.addToNumericResult(e, r, n, 10),
                this.emitNumericEntity(i, 2)
        }
        return this.addToNumericResult(e, r, n, 10),
        -1
    }
    emitNumericEntity(e, n) {
        var r;
        if (this.consumed <= n)
            return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed),
            0;
        if (e === cn.SEMI)
            this.consumed += 1;
        else if (this.decodeMode === wo.Strict)
            return 0;
        return this.emitCodePoint(lQ(this.result), this.consumed),
        this.errors && (e !== cn.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
        this.errors.validateNumericCharacterReference(this.result)),
        this.consumed
    }
    stateNamedEntity(e, n) {
        const {decodeTree: r} = this;
        let i = r[this.treeIndex]
          , s = (i & xi.VALUE_LENGTH) >> 14;
        for (; n < e.length; n++,
        this.excess++) {
            const o = e.charCodeAt(n);
            if (this.treeIndex = qP(r, i, this.treeIndex + Math.max(1, s), o),
            this.treeIndex < 0)
                return this.result === 0 || this.decodeMode === wo.Attribute && (s === 0 || dQ(o)) ? 0 : this.emitNotTerminatedNamedEntity();
            if (i = r[this.treeIndex],
            s = (i & xi.VALUE_LENGTH) >> 14,
            s !== 0) {
                if (o === cn.SEMI)
                    return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
                this.decodeMode !== wo.Strict && (this.result = this.treeIndex,
                this.consumed += this.excess,
                this.excess = 0)
            }
        }
        return -1
    }
    emitNotTerminatedNamedEntity() {
        var e;
        const {result: n, decodeTree: r} = this
          , i = (r[n] & xi.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(n, i, this.consumed),
        (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(),
        this.consumed
    }
    emitNamedEntityData(e, n, r) {
        const {decodeTree: i} = this;
        return this.emitCodePoint(n === 1 ? i[e] & ~xi.VALUE_LENGTH : i[e + 1], r),
        n === 3 && this.emitCodePoint(i[e + 2], r),
        r
    }
    end() {
        var e;
        switch (this.state) {
        case rn.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== wo.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        case rn.NumericDecimal:
            return this.emitNumericEntity(0, 2);
        case rn.NumericHex:
            return this.emitNumericEntity(0, 3);
        case rn.NumericStart:
            return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed),
            0;
        case rn.EntityStart:
            return 0
        }
    }
}
function GP(t) {
    let e = "";
    const n = new fQ(t,r => e += aQ(r));
    return function(i, s) {
        let o = 0
          , a = 0;
        for (; (a = i.indexOf("&", a)) >= 0; ) {
            e += i.slice(o, a),
            n.startEntity(s);
            const c = n.write(i, a + 1);
            if (c < 0) {
                o = a + n.end();
                break
            }
            o = a + c,
            a = c === 0 ? o + 1 : o
        }
        const l = e + i.slice(o);
        return e = "",
        l
    }
}
function qP(t, e, n, r) {
    const i = (e & xi.BRANCH_LENGTH) >> 7
      , s = e & xi.JUMP_TABLE;
    if (i === 0)
        return s !== 0 && r === s ? n : -1;
    if (s) {
        const l = r - s;
        return l < 0 || l >= i ? -1 : t[n + l] - 1
    }
    let o = n
      , a = o + i - 1;
    for (; o <= a; ) {
        const l = o + a >>> 1
          , c = t[l];
        if (c < r)
            o = l + 1;
        else if (c > r)
            a = l - 1;
        else
            return t[l + i]
    }
    return -1
}
GP(_s);
GP(sQ);
var fe;
(function(t) {
    t.HTML = "http://www.w3.org/1999/xhtml",
    t.MATHML = "http://www.w3.org/1998/Math/MathML",
    t.SVG = "http://www.w3.org/2000/svg",
    t.XLINK = "http://www.w3.org/1999/xlink",
    t.XML = "http://www.w3.org/XML/1998/namespace",
    t.XMLNS = "http://www.w3.org/2000/xmlns/"
}
)(fe = fe || (fe = {}));
var Ls;
(function(t) {
    t.TYPE = "type",
    t.ACTION = "action",
    t.ENCODING = "encoding",
    t.PROMPT = "prompt",
    t.NAME = "name",
    t.COLOR = "color",
    t.FACE = "face",
    t.SIZE = "size"
}
)(Ls = Ls || (Ls = {}));
var ur;
(function(t) {
    t.NO_QUIRKS = "no-quirks",
    t.QUIRKS = "quirks",
    t.LIMITED_QUIRKS = "limited-quirks"
}
)(ur = ur || (ur = {}));
var ie;
(function(t) {
    t.A = "a",
    t.ADDRESS = "address",
    t.ANNOTATION_XML = "annotation-xml",
    t.APPLET = "applet",
    t.AREA = "area",
    t.ARTICLE = "article",
    t.ASIDE = "aside",
    t.B = "b",
    t.BASE = "base",
    t.BASEFONT = "basefont",
    t.BGSOUND = "bgsound",
    t.BIG = "big",
    t.BLOCKQUOTE = "blockquote",
    t.BODY = "body",
    t.BR = "br",
    t.BUTTON = "button",
    t.CAPTION = "caption",
    t.CENTER = "center",
    t.CODE = "code",
    t.COL = "col",
    t.COLGROUP = "colgroup",
    t.DD = "dd",
    t.DESC = "desc",
    t.DETAILS = "details",
    t.DIALOG = "dialog",
    t.DIR = "dir",
    t.DIV = "div",
    t.DL = "dl",
    t.DT = "dt",
    t.EM = "em",
    t.EMBED = "embed",
    t.FIELDSET = "fieldset",
    t.FIGCAPTION = "figcaption",
    t.FIGURE = "figure",
    t.FONT = "font",
    t.FOOTER = "footer",
    t.FOREIGN_OBJECT = "foreignObject",
    t.FORM = "form",
    t.FRAME = "frame",
    t.FRAMESET = "frameset",
    t.H1 = "h1",
    t.H2 = "h2",
    t.H3 = "h3",
    t.H4 = "h4",
    t.H5 = "h5",
    t.H6 = "h6",
    t.HEAD = "head",
    t.HEADER = "header",
    t.HGROUP = "hgroup",
    t.HR = "hr",
    t.HTML = "html",
    t.I = "i",
    t.IMG = "img",
    t.IMAGE = "image",
    t.INPUT = "input",
    t.IFRAME = "iframe",
    t.KEYGEN = "keygen",
    t.LABEL = "label",
    t.LI = "li",
    t.LINK = "link",
    t.LISTING = "listing",
    t.MAIN = "main",
    t.MALIGNMARK = "malignmark",
    t.MARQUEE = "marquee",
    t.MATH = "math",
    t.MENU = "menu",
    t.META = "meta",
    t.MGLYPH = "mglyph",
    t.MI = "mi",
    t.MO = "mo",
    t.MN = "mn",
    t.MS = "ms",
    t.MTEXT = "mtext",
    t.NAV = "nav",
    t.NOBR = "nobr",
    t.NOFRAMES = "noframes",
    t.NOEMBED = "noembed",
    t.NOSCRIPT = "noscript",
    t.OBJECT = "object",
    t.OL = "ol",
    t.OPTGROUP = "optgroup",
    t.OPTION = "option",
    t.P = "p",
    t.PARAM = "param",
    t.PLAINTEXT = "plaintext",
    t.PRE = "pre",
    t.RB = "rb",
    t.RP = "rp",
    t.RT = "rt",
    t.RTC = "rtc",
    t.RUBY = "ruby",
    t.S = "s",
    t.SCRIPT = "script",
    t.SECTION = "section",
    t.SELECT = "select",
    t.SOURCE = "source",
    t.SMALL = "small",
    t.SPAN = "span",
    t.STRIKE = "strike",
    t.STRONG = "strong",
    t.STYLE = "style",
    t.SUB = "sub",
    t.SUMMARY = "summary",
    t.SUP = "sup",
    t.TABLE = "table",
    t.TBODY = "tbody",
    t.TEMPLATE = "template",
    t.TEXTAREA = "textarea",
    t.TFOOT = "tfoot",
    t.TD = "td",
    t.TH = "th",
    t.THEAD = "thead",
    t.TITLE = "title",
    t.TR = "tr",
    t.TRACK = "track",
    t.TT = "tt",
    t.U = "u",
    t.UL = "ul",
    t.SVG = "svg",
    t.VAR = "var",
    t.WBR = "wbr",
    t.XMP = "xmp"
}
)(ie = ie || (ie = {}));
var T;
(function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN",
    t[t.A = 1] = "A",
    t[t.ADDRESS = 2] = "ADDRESS",
    t[t.ANNOTATION_XML = 3] = "ANNOTATION_XML",
    t[t.APPLET = 4] = "APPLET",
    t[t.AREA = 5] = "AREA",
    t[t.ARTICLE = 6] = "ARTICLE",
    t[t.ASIDE = 7] = "ASIDE",
    t[t.B = 8] = "B",
    t[t.BASE = 9] = "BASE",
    t[t.BASEFONT = 10] = "BASEFONT",
    t[t.BGSOUND = 11] = "BGSOUND",
    t[t.BIG = 12] = "BIG",
    t[t.BLOCKQUOTE = 13] = "BLOCKQUOTE",
    t[t.BODY = 14] = "BODY",
    t[t.BR = 15] = "BR",
    t[t.BUTTON = 16] = "BUTTON",
    t[t.CAPTION = 17] = "CAPTION",
    t[t.CENTER = 18] = "CENTER",
    t[t.CODE = 19] = "CODE",
    t[t.COL = 20] = "COL",
    t[t.COLGROUP = 21] = "COLGROUP",
    t[t.DD = 22] = "DD",
    t[t.DESC = 23] = "DESC",
    t[t.DETAILS = 24] = "DETAILS",
    t[t.DIALOG = 25] = "DIALOG",
    t[t.DIR = 26] = "DIR",
    t[t.DIV = 27] = "DIV",
    t[t.DL = 28] = "DL",
    t[t.DT = 29] = "DT",
    t[t.EM = 30] = "EM",
    t[t.EMBED = 31] = "EMBED",
    t[t.FIELDSET = 32] = "FIELDSET",
    t[t.FIGCAPTION = 33] = "FIGCAPTION",
    t[t.FIGURE = 34] = "FIGURE",
    t[t.FONT = 35] = "FONT",
    t[t.FOOTER = 36] = "FOOTER",
    t[t.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT",
    t[t.FORM = 38] = "FORM",
    t[t.FRAME = 39] = "FRAME",
    t[t.FRAMESET = 40] = "FRAMESET",
    t[t.H1 = 41] = "H1",
    t[t.H2 = 42] = "H2",
    t[t.H3 = 43] = "H3",
    t[t.H4 = 44] = "H4",
    t[t.H5 = 45] = "H5",
    t[t.H6 = 46] = "H6",
    t[t.HEAD = 47] = "HEAD",
    t[t.HEADER = 48] = "HEADER",
    t[t.HGROUP = 49] = "HGROUP",
    t[t.HR = 50] = "HR",
    t[t.HTML = 51] = "HTML",
    t[t.I = 52] = "I",
    t[t.IMG = 53] = "IMG",
    t[t.IMAGE = 54] = "IMAGE",
    t[t.INPUT = 55] = "INPUT",
    t[t.IFRAME = 56] = "IFRAME",
    t[t.KEYGEN = 57] = "KEYGEN",
    t[t.LABEL = 58] = "LABEL",
    t[t.LI = 59] = "LI",
    t[t.LINK = 60] = "LINK",
    t[t.LISTING = 61] = "LISTING",
    t[t.MAIN = 62] = "MAIN",
    t[t.MALIGNMARK = 63] = "MALIGNMARK",
    t[t.MARQUEE = 64] = "MARQUEE",
    t[t.MATH = 65] = "MATH",
    t[t.MENU = 66] = "MENU",
    t[t.META = 67] = "META",
    t[t.MGLYPH = 68] = "MGLYPH",
    t[t.MI = 69] = "MI",
    t[t.MO = 70] = "MO",
    t[t.MN = 71] = "MN",
    t[t.MS = 72] = "MS",
    t[t.MTEXT = 73] = "MTEXT",
    t[t.NAV = 74] = "NAV",
    t[t.NOBR = 75] = "NOBR",
    t[t.NOFRAMES = 76] = "NOFRAMES",
    t[t.NOEMBED = 77] = "NOEMBED",
    t[t.NOSCRIPT = 78] = "NOSCRIPT",
    t[t.OBJECT = 79] = "OBJECT",
    t[t.OL = 80] = "OL",
    t[t.OPTGROUP = 81] = "OPTGROUP",
    t[t.OPTION = 82] = "OPTION",
    t[t.P = 83] = "P",
    t[t.PARAM = 84] = "PARAM",
    t[t.PLAINTEXT = 85] = "PLAINTEXT",
    t[t.PRE = 86] = "PRE",
    t[t.RB = 87] = "RB",
    t[t.RP = 88] = "RP",
    t[t.RT = 89] = "RT",
    t[t.RTC = 90] = "RTC",
    t[t.RUBY = 91] = "RUBY",
    t[t.S = 92] = "S",
    t[t.SCRIPT = 93] = "SCRIPT",
    t[t.SECTION = 94] = "SECTION",
    t[t.SELECT = 95] = "SELECT",
    t[t.SOURCE = 96] = "SOURCE",
    t[t.SMALL = 97] = "SMALL",
    t[t.SPAN = 98] = "SPAN",
    t[t.STRIKE = 99] = "STRIKE",
    t[t.STRONG = 100] = "STRONG",
    t[t.STYLE = 101] = "STYLE",
    t[t.SUB = 102] = "SUB",
    t[t.SUMMARY = 103] = "SUMMARY",
    t[t.SUP = 104] = "SUP",
    t[t.TABLE = 105] = "TABLE",
    t[t.TBODY = 106] = "TBODY",
    t[t.TEMPLATE = 107] = "TEMPLATE",
    t[t.TEXTAREA = 108] = "TEXTAREA",
    t[t.TFOOT = 109] = "TFOOT",
    t[t.TD = 110] = "TD",
    t[t.TH = 111] = "TH",
    t[t.THEAD = 112] = "THEAD",
    t[t.TITLE = 113] = "TITLE",
    t[t.TR = 114] = "TR",
    t[t.TRACK = 115] = "TRACK",
    t[t.TT = 116] = "TT",
    t[t.U = 117] = "U",
    t[t.UL = 118] = "UL",
    t[t.SVG = 119] = "SVG",
    t[t.VAR = 120] = "VAR",
    t[t.WBR = 121] = "WBR",
    t[t.XMP = 122] = "XMP"
}
)(T = T || (T = {}));
const pQ = new Map([[ie.A, T.A], [ie.ADDRESS, T.ADDRESS], [ie.ANNOTATION_XML, T.ANNOTATION_XML], [ie.APPLET, T.APPLET], [ie.AREA, T.AREA], [ie.ARTICLE, T.ARTICLE], [ie.ASIDE, T.ASIDE], [ie.B, T.B], [ie.BASE, T.BASE], [ie.BASEFONT, T.BASEFONT], [ie.BGSOUND, T.BGSOUND], [ie.BIG, T.BIG], [ie.BLOCKQUOTE, T.BLOCKQUOTE], [ie.BODY, T.BODY], [ie.BR, T.BR], [ie.BUTTON, T.BUTTON], [ie.CAPTION, T.CAPTION], [ie.CENTER, T.CENTER], [ie.CODE, T.CODE], [ie.COL, T.COL], [ie.COLGROUP, T.COLGROUP], [ie.DD, T.DD], [ie.DESC, T.DESC], [ie.DETAILS, T.DETAILS], [ie.DIALOG, T.DIALOG], [ie.DIR, T.DIR], [ie.DIV, T.DIV], [ie.DL, T.DL], [ie.DT, T.DT], [ie.EM, T.EM], [ie.EMBED, T.EMBED], [ie.FIELDSET, T.FIELDSET], [ie.FIGCAPTION, T.FIGCAPTION], [ie.FIGURE, T.FIGURE], [ie.FONT, T.FONT], [ie.FOOTER, T.FOOTER], [ie.FOREIGN_OBJECT, T.FOREIGN_OBJECT], [ie.FORM, T.FORM], [ie.FRAME, T.FRAME], [ie.FRAMESET, T.FRAMESET], [ie.H1, T.H1], [ie.H2, T.H2], [ie.H3, T.H3], [ie.H4, T.H4], [ie.H5, T.H5], [ie.H6, T.H6], [ie.HEAD, T.HEAD], [ie.HEADER, T.HEADER], [ie.HGROUP, T.HGROUP], [ie.HR, T.HR], [ie.HTML, T.HTML], [ie.I, T.I], [ie.IMG, T.IMG], [ie.IMAGE, T.IMAGE], [ie.INPUT, T.INPUT], [ie.IFRAME, T.IFRAME], [ie.KEYGEN, T.KEYGEN], [ie.LABEL, T.LABEL], [ie.LI, T.LI], [ie.LINK, T.LINK], [ie.LISTING, T.LISTING], [ie.MAIN, T.MAIN], [ie.MALIGNMARK, T.MALIGNMARK], [ie.MARQUEE, T.MARQUEE], [ie.MATH, T.MATH], [ie.MENU, T.MENU], [ie.META, T.META], [ie.MGLYPH, T.MGLYPH], [ie.MI, T.MI], [ie.MO, T.MO], [ie.MN, T.MN], [ie.MS, T.MS], [ie.MTEXT, T.MTEXT], [ie.NAV, T.NAV], [ie.NOBR, T.NOBR], [ie.NOFRAMES, T.NOFRAMES], [ie.NOEMBED, T.NOEMBED], [ie.NOSCRIPT, T.NOSCRIPT], [ie.OBJECT, T.OBJECT], [ie.OL, T.OL], [ie.OPTGROUP, T.OPTGROUP], [ie.OPTION, T.OPTION], [ie.P, T.P], [ie.PARAM, T.PARAM], [ie.PLAINTEXT, T.PLAINTEXT], [ie.PRE, T.PRE], [ie.RB, T.RB], [ie.RP, T.RP], [ie.RT, T.RT], [ie.RTC, T.RTC], [ie.RUBY, T.RUBY], [ie.S, T.S], [ie.SCRIPT, T.SCRIPT], [ie.SECTION, T.SECTION], [ie.SELECT, T.SELECT], [ie.SOURCE, T.SOURCE], [ie.SMALL, T.SMALL], [ie.SPAN, T.SPAN], [ie.STRIKE, T.STRIKE], [ie.STRONG, T.STRONG], [ie.STYLE, T.STYLE], [ie.SUB, T.SUB], [ie.SUMMARY, T.SUMMARY], [ie.SUP, T.SUP], [ie.TABLE, T.TABLE], [ie.TBODY, T.TBODY], [ie.TEMPLATE, T.TEMPLATE], [ie.TEXTAREA, T.TEXTAREA], [ie.TFOOT, T.TFOOT], [ie.TD, T.TD], [ie.TH, T.TH], [ie.THEAD, T.THEAD], [ie.TITLE, T.TITLE], [ie.TR, T.TR], [ie.TRACK, T.TRACK], [ie.TT, T.TT], [ie.U, T.U], [ie.UL, T.UL], [ie.SVG, T.SVG], [ie.VAR, T.VAR], [ie.WBR, T.WBR], [ie.XMP, T.XMP]]);
function Gl(t) {
    var e;
    return (e = pQ.get(t)) !== null && e !== void 0 ? e : T.UNKNOWN
}
const _e = T
  , mQ = {
    [fe.HTML]: new Set([_e.ADDRESS, _e.APPLET, _e.AREA, _e.ARTICLE, _e.ASIDE, _e.BASE, _e.BASEFONT, _e.BGSOUND, _e.BLOCKQUOTE, _e.BODY, _e.BR, _e.BUTTON, _e.CAPTION, _e.CENTER, _e.COL, _e.COLGROUP, _e.DD, _e.DETAILS, _e.DIR, _e.DIV, _e.DL, _e.DT, _e.EMBED, _e.FIELDSET, _e.FIGCAPTION, _e.FIGURE, _e.FOOTER, _e.FORM, _e.FRAME, _e.FRAMESET, _e.H1, _e.H2, _e.H3, _e.H4, _e.H5, _e.H6, _e.HEAD, _e.HEADER, _e.HGROUP, _e.HR, _e.HTML, _e.IFRAME, _e.IMG, _e.INPUT, _e.LI, _e.LINK, _e.LISTING, _e.MAIN, _e.MARQUEE, _e.MENU, _e.META, _e.NAV, _e.NOEMBED, _e.NOFRAMES, _e.NOSCRIPT, _e.OBJECT, _e.OL, _e.P, _e.PARAM, _e.PLAINTEXT, _e.PRE, _e.SCRIPT, _e.SECTION, _e.SELECT, _e.SOURCE, _e.STYLE, _e.SUMMARY, _e.TABLE, _e.TBODY, _e.TD, _e.TEMPLATE, _e.TEXTAREA, _e.TFOOT, _e.TH, _e.THEAD, _e.TITLE, _e.TR, _e.TRACK, _e.UL, _e.WBR, _e.XMP]),
    [fe.MATHML]: new Set([_e.MI, _e.MO, _e.MN, _e.MS, _e.MTEXT, _e.ANNOTATION_XML]),
    [fe.SVG]: new Set([_e.TITLE, _e.FOREIGN_OBJECT, _e.DESC]),
    [fe.XLINK]: new Set,
    [fe.XML]: new Set,
    [fe.XMLNS]: new Set
};
function KP(t) {
    return t === _e.H1 || t === _e.H2 || t === _e.H3 || t === _e.H4 || t === _e.H5 || t === _e.H6
}
ie.STYLE,
ie.SCRIPT,
ie.XMP,
ie.IFRAME,
ie.NOEMBED,
ie.NOFRAMES,
ie.PLAINTEXT;
const gQ = new Map([[128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
var W;
(function(t) {
    t[t.DATA = 0] = "DATA",
    t[t.RCDATA = 1] = "RCDATA",
    t[t.RAWTEXT = 2] = "RAWTEXT",
    t[t.SCRIPT_DATA = 3] = "SCRIPT_DATA",
    t[t.PLAINTEXT = 4] = "PLAINTEXT",
    t[t.TAG_OPEN = 5] = "TAG_OPEN",
    t[t.END_TAG_OPEN = 6] = "END_TAG_OPEN",
    t[t.TAG_NAME = 7] = "TAG_NAME",
    t[t.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN",
    t[t.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN",
    t[t.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME",
    t[t.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN",
    t[t.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN",
    t[t.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME",
    t[t.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN",
    t[t.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN",
    t[t.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME",
    t[t.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START",
    t[t.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH",
    t[t.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED",
    t[t.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH",
    t[t.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH",
    t[t.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",
    t[t.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN",
    t[t.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME",
    t[t.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START",
    t[t.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED",
    t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH",
    t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",
    t[t.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",
    t[t.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END",
    t[t.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME",
    t[t.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME",
    t[t.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME",
    t[t.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE",
    t[t.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED",
    t[t.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED",
    t[t.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED",
    t[t.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED",
    t[t.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG",
    t[t.BOGUS_COMMENT = 40] = "BOGUS_COMMENT",
    t[t.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN",
    t[t.COMMENT_START = 42] = "COMMENT_START",
    t[t.COMMENT_START_DASH = 43] = "COMMENT_START_DASH",
    t[t.COMMENT = 44] = "COMMENT",
    t[t.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN",
    t[t.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG",
    t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH",
    t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",
    t[t.COMMENT_END_DASH = 49] = "COMMENT_END_DASH",
    t[t.COMMENT_END = 50] = "COMMENT_END",
    t[t.COMMENT_END_BANG = 51] = "COMMENT_END_BANG",
    t[t.DOCTYPE = 52] = "DOCTYPE",
    t[t.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME",
    t[t.DOCTYPE_NAME = 54] = "DOCTYPE_NAME",
    t[t.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME",
    t[t.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD",
    t[t.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",
    t[t.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",
    t[t.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",
    t[t.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER",
    t[t.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",
    t[t.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD",
    t[t.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",
    t[t.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",
    t[t.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",
    t[t.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER",
    t[t.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE",
    t[t.CDATA_SECTION = 68] = "CDATA_SECTION",
    t[t.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET",
    t[t.CDATA_SECTION_END = 70] = "CDATA_SECTION_END",
    t[t.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE",
    t[t.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE",
    t[t.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND",
    t[t.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE",
    t[t.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START",
    t[t.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE",
    t[t.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE",
    t[t.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END"
}
)(W || (W = {}));
const Vt = {
    DATA: W.DATA,
    RCDATA: W.RCDATA,
    RAWTEXT: W.RAWTEXT,
    SCRIPT_DATA: W.SCRIPT_DATA,
    PLAINTEXT: W.PLAINTEXT,
    CDATA_SECTION: W.CDATA_SECTION
};
function Wc(t) {
    return t >= U.DIGIT_0 && t <= U.DIGIT_9
}
function Cc(t) {
    return t >= U.LATIN_CAPITAL_A && t <= U.LATIN_CAPITAL_Z
}
function _Q(t) {
    return t >= U.LATIN_SMALL_A && t <= U.LATIN_SMALL_Z
}
function bs(t) {
    return _Q(t) || Cc(t)
}
function ib(t) {
    return bs(t) || Wc(t)
}
function YP(t) {
    return t >= U.LATIN_CAPITAL_A && t <= U.LATIN_CAPITAL_F
}
function XP(t) {
    return t >= U.LATIN_SMALL_A && t <= U.LATIN_SMALL_F
}
function bQ(t) {
    return Wc(t) || YP(t) || XP(t)
}
function Sd(t) {
    return t + 32
}
function QP(t) {
    return t === U.SPACE || t === U.LINE_FEED || t === U.TABULATION || t === U.FORM_FEED
}
function yQ(t) {
    return t === U.EQUALS_SIGN || ib(t)
}
function Pw(t) {
    return QP(t) || t === U.SOLIDUS || t === U.GREATER_THAN_SIGN
}
class vQ {
    constructor(e, n) {
        this.options = e,
        this.handler = n,
        this.paused = !1,
        this.inLoop = !1,
        this.inForeignNode = !1,
        this.lastStartTagName = "",
        this.active = !1,
        this.state = W.DATA,
        this.returnState = W.DATA,
        this.charRefCode = -1,
        this.consumedAfterSnapshot = -1,
        this.currentCharacterToken = null,
        this.currentToken = null,
        this.currentAttr = {
            name: "",
            value: ""
        },
        this.preprocessor = new iQ(n),
        this.currentLocation = this.getCurrentLocation(-1)
    }
    _err(e) {
        var n, r;
        (r = (n = this.handler).onParseError) === null || r === void 0 || r.call(n, this.preprocessor.getError(e))
    }
    getCurrentLocation(e) {
        return this.options.sourceCodeLocationInfo ? {
            startLine: this.preprocessor.line,
            startCol: this.preprocessor.col - e,
            startOffset: this.preprocessor.offset - e,
            endLine: -1,
            endCol: -1,
            endOffset: -1
        } : null
    }
    _runParsingLoop() {
        if (!this.inLoop) {
            for (this.inLoop = !0; this.active && !this.paused; ) {
                this.consumedAfterSnapshot = 0;
                const e = this._consume();
                this._ensureHibernation() || this._callState(e)
            }
            this.inLoop = !1
        }
    }
    pause() {
        this.paused = !0
    }
    resume(e) {
        if (!this.paused)
            throw new Error("Parser was already resumed");
        this.paused = !1,
        !this.inLoop && (this._runParsingLoop(),
        this.paused || e?.())
    }
    write(e, n, r) {
        this.active = !0,
        this.preprocessor.write(e, n),
        this._runParsingLoop(),
        this.paused || r?.()
    }
    insertHtmlAtCurrentPos(e) {
        this.active = !0,
        this.preprocessor.insertHtmlAtCurrentPos(e),
        this._runParsingLoop()
    }
    _ensureHibernation() {
        return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot),
        this.active = !1,
        !0) : !1
    }
    _consume() {
        return this.consumedAfterSnapshot++,
        this.preprocessor.advance()
    }
    _unconsume(e) {
        this.consumedAfterSnapshot -= e,
        this.preprocessor.retreat(e)
    }
    _reconsumeInState(e, n) {
        this.state = e,
        this._callState(n)
    }
    _advanceBy(e) {
        this.consumedAfterSnapshot += e;
        for (let n = 0; n < e; n++)
            this.preprocessor.advance()
    }
    _consumeSequenceIfMatch(e, n) {
        return this.preprocessor.startsWith(e, n) ? (this._advanceBy(e.length - 1),
        !0) : !1
    }
    _createStartTagToken() {
        this.currentToken = {
            type: tt.START_TAG,
            tagName: "",
            tagID: T.UNKNOWN,
            selfClosing: !1,
            ackSelfClosing: !1,
            attrs: [],
            location: this.getCurrentLocation(1)
        }
    }
    _createEndTagToken() {
        this.currentToken = {
            type: tt.END_TAG,
            tagName: "",
            tagID: T.UNKNOWN,
            selfClosing: !1,
            ackSelfClosing: !1,
            attrs: [],
            location: this.getCurrentLocation(2)
        }
    }
    _createCommentToken(e) {
        this.currentToken = {
            type: tt.COMMENT,
            data: "",
            location: this.getCurrentLocation(e)
        }
    }
    _createDoctypeToken(e) {
        this.currentToken = {
            type: tt.DOCTYPE,
            name: e,
            forceQuirks: !1,
            publicId: null,
            systemId: null,
            location: this.currentLocation
        }
    }
    _createCharacterToken(e, n) {
        this.currentCharacterToken = {
            type: e,
            chars: n,
            location: this.currentLocation
        }
    }
    _createAttr(e) {
        this.currentAttr = {
            name: e,
            value: ""
        },
        this.currentLocation = this.getCurrentLocation(0)
    }
    _leaveAttrName() {
        var e, n;
        const r = this.currentToken;
        if (WP(r, this.currentAttr.name) === null) {
            if (r.attrs.push(this.currentAttr),
            r.location && this.currentLocation) {
                const i = (e = (n = r.location).attrs) !== null && e !== void 0 ? e : n.attrs = Object.create(null);
                i[this.currentAttr.name] = this.currentLocation,
                this._leaveAttrValue()
            }
        } else
            this._err(ue.duplicateAttribute)
    }
    _leaveAttrValue() {
        this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line,
        this.currentLocation.endCol = this.preprocessor.col,
        this.currentLocation.endOffset = this.preprocessor.offset)
    }
    prepareToken(e) {
        this._emitCurrentCharacterToken(e.location),
        this.currentToken = null,
        e.location && (e.location.endLine = this.preprocessor.line,
        e.location.endCol = this.preprocessor.col + 1,
        e.location.endOffset = this.preprocessor.offset + 1),
        this.currentLocation = this.getCurrentLocation(-1)
    }
    emitCurrentTagToken() {
        const e = this.currentToken;
        this.prepareToken(e),
        e.tagID = Gl(e.tagName),
        e.type === tt.START_TAG ? (this.lastStartTagName = e.tagName,
        this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(ue.endTagWithAttributes),
        e.selfClosing && this._err(ue.endTagWithTrailingSolidus),
        this.handler.onEndTag(e)),
        this.preprocessor.dropParsedChunk()
    }
    emitCurrentComment(e) {
        this.prepareToken(e),
        this.handler.onComment(e),
        this.preprocessor.dropParsedChunk()
    }
    emitCurrentDoctype(e) {
        this.prepareToken(e),
        this.handler.onDoctype(e),
        this.preprocessor.dropParsedChunk()
    }
    _emitCurrentCharacterToken(e) {
        if (this.currentCharacterToken) {
            switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine,
            this.currentCharacterToken.location.endCol = e.startCol,
            this.currentCharacterToken.location.endOffset = e.startOffset),
            this.currentCharacterToken.type) {
            case tt.CHARACTER:
                {
                    this.handler.onCharacter(this.currentCharacterToken);
                    break
                }
            case tt.NULL_CHARACTER:
                {
                    this.handler.onNullCharacter(this.currentCharacterToken);
                    break
                }
            case tt.WHITESPACE_CHARACTER:
                {
                    this.handler.onWhitespaceCharacter(this.currentCharacterToken);
                    break
                }
            }
            this.currentCharacterToken = null
        }
    }
    _emitEOFToken() {
        const e = this.getCurrentLocation(0);
        e && (e.endLine = e.startLine,
        e.endCol = e.startCol,
        e.endOffset = e.startOffset),
        this._emitCurrentCharacterToken(e),
        this.handler.onEof({
            type: tt.EOF,
            location: e
        }),
        this.active = !1
    }
    _appendCharToCurrentCharacterToken(e, n) {
        if (this.currentCharacterToken)
            if (this.currentCharacterToken.type !== e)
                this.currentLocation = this.getCurrentLocation(0),
                this._emitCurrentCharacterToken(this.currentLocation),
                this.preprocessor.dropParsedChunk();
            else {
                this.currentCharacterToken.chars += n;
                return
            }
        this._createCharacterToken(e, n)
    }
    _emitCodePoint(e) {
        const n = QP(e) ? tt.WHITESPACE_CHARACTER : e === U.NULL ? tt.NULL_CHARACTER : tt.CHARACTER;
        this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(e))
    }
    _emitChars(e) {
        this._appendCharToCurrentCharacterToken(tt.CHARACTER, e)
    }
    _matchNamedCharacterReference(e) {
        let n = null
          , r = 0
          , i = !1;
        for (let s = 0, o = _s[0]; s >= 0 && (s = qP(_s, o, s + 1, e),
        !(s < 0)); e = this._consume()) {
            r += 1,
            o = _s[s];
            const a = o & xi.VALUE_LENGTH;
            if (a) {
                const l = (a >> 14) - 1;
                if (e !== U.SEMICOLON && this._isCharacterReferenceInAttribute() && yQ(this.preprocessor.peek(1)) ? (n = [U.AMPERSAND],
                s += l) : (n = l === 0 ? [_s[s] & ~xi.VALUE_LENGTH] : l === 1 ? [_s[++s]] : [_s[++s], _s[++s]],
                r = 0,
                i = e !== U.SEMICOLON),
                l === 0) {
                    this._consume();
                    break
                }
            }
        }
        return this._unconsume(r),
        i && !this.preprocessor.endOfChunkHit && this._err(ue.missingSemicolonAfterCharacterReference),
        this._unconsume(1),
        n
    }
    _isCharacterReferenceInAttribute() {
        return this.returnState === W.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === W.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === W.ATTRIBUTE_VALUE_UNQUOTED
    }
    _flushCodePointConsumedAsCharacterReference(e) {
        this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e)
    }
    _callState(e) {
        switch (this.state) {
        case W.DATA:
            {
                this._stateData(e);
                break
            }
        case W.RCDATA:
            {
                this._stateRcdata(e);
                break
            }
        case W.RAWTEXT:
            {
                this._stateRawtext(e);
                break
            }
        case W.SCRIPT_DATA:
            {
                this._stateScriptData(e);
                break
            }
        case W.PLAINTEXT:
            {
                this._statePlaintext(e);
                break
            }
        case W.TAG_OPEN:
            {
                this._stateTagOpen(e);
                break
            }
        case W.END_TAG_OPEN:
            {
                this._stateEndTagOpen(e);
                break
            }
        case W.TAG_NAME:
            {
                this._stateTagName(e);
                break
            }
        case W.RCDATA_LESS_THAN_SIGN:
            {
                this._stateRcdataLessThanSign(e);
                break
            }
        case W.RCDATA_END_TAG_OPEN:
            {
                this._stateRcdataEndTagOpen(e);
                break
            }
        case W.RCDATA_END_TAG_NAME:
            {
                this._stateRcdataEndTagName(e);
                break
            }
        case W.RAWTEXT_LESS_THAN_SIGN:
            {
                this._stateRawtextLessThanSign(e);
                break
            }
        case W.RAWTEXT_END_TAG_OPEN:
            {
                this._stateRawtextEndTagOpen(e);
                break
            }
        case W.RAWTEXT_END_TAG_NAME:
            {
                this._stateRawtextEndTagName(e);
                break
            }
        case W.SCRIPT_DATA_LESS_THAN_SIGN:
            {
                this._stateScriptDataLessThanSign(e);
                break
            }
        case W.SCRIPT_DATA_END_TAG_OPEN:
            {
                this._stateScriptDataEndTagOpen(e);
                break
            }
        case W.SCRIPT_DATA_END_TAG_NAME:
            {
                this._stateScriptDataEndTagName(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPE_START:
            {
                this._stateScriptDataEscapeStart(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPE_START_DASH:
            {
                this._stateScriptDataEscapeStartDash(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPED:
            {
                this._stateScriptDataEscaped(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPED_DASH:
            {
                this._stateScriptDataEscapedDash(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPED_DASH_DASH:
            {
                this._stateScriptDataEscapedDashDash(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
            {
                this._stateScriptDataEscapedLessThanSign(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:
            {
                this._stateScriptDataEscapedEndTagOpen(e);
                break
            }
        case W.SCRIPT_DATA_ESCAPED_END_TAG_NAME:
            {
                this._stateScriptDataEscapedEndTagName(e);
                break
            }
        case W.SCRIPT_DATA_DOUBLE_ESCAPE_START:
            {
                this._stateScriptDataDoubleEscapeStart(e);
                break
            }
        case W.SCRIPT_DATA_DOUBLE_ESCAPED:
            {
                this._stateScriptDataDoubleEscaped(e);
                break
            }
        case W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:
            {
                this._stateScriptDataDoubleEscapedDash(e);
                break
            }
        case W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:
            {
                this._stateScriptDataDoubleEscapedDashDash(e);
                break
            }
        case W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:
            {
                this._stateScriptDataDoubleEscapedLessThanSign(e);
                break
            }
        case W.SCRIPT_DATA_DOUBLE_ESCAPE_END:
            {
                this._stateScriptDataDoubleEscapeEnd(e);
                break
            }
        case W.BEFORE_ATTRIBUTE_NAME:
            {
                this._stateBeforeAttributeName(e);
                break
            }
        case W.ATTRIBUTE_NAME:
            {
                this._stateAttributeName(e);
                break
            }
        case W.AFTER_ATTRIBUTE_NAME:
            {
                this._stateAfterAttributeName(e);
                break
            }
        case W.BEFORE_ATTRIBUTE_VALUE:
            {
                this._stateBeforeAttributeValue(e);
                break
            }
        case W.ATTRIBUTE_VALUE_DOUBLE_QUOTED:
            {
                this._stateAttributeValueDoubleQuoted(e);
                break
            }
        case W.ATTRIBUTE_VALUE_SINGLE_QUOTED:
            {
                this._stateAttributeValueSingleQuoted(e);
                break
            }
        case W.ATTRIBUTE_VALUE_UNQUOTED:
            {
                this._stateAttributeValueUnquoted(e);
                break
            }
        case W.AFTER_ATTRIBUTE_VALUE_QUOTED:
            {
                this._stateAfterAttributeValueQuoted(e);
                break
            }
        case W.SELF_CLOSING_START_TAG:
            {
                this._stateSelfClosingStartTag(e);
                break
            }
        case W.BOGUS_COMMENT:
            {
                this._stateBogusComment(e);
                break
            }
        case W.MARKUP_DECLARATION_OPEN:
            {
                this._stateMarkupDeclarationOpen(e);
                break
            }
        case W.COMMENT_START:
            {
                this._stateCommentStart(e);
                break
            }
        case W.COMMENT_START_DASH:
            {
                this._stateCommentStartDash(e);
                break
            }
        case W.COMMENT:
            {
                this._stateComment(e);
                break
            }
        case W.COMMENT_LESS_THAN_SIGN:
            {
                this._stateCommentLessThanSign(e);
                break
            }
        case W.COMMENT_LESS_THAN_SIGN_BANG:
            {
                this._stateCommentLessThanSignBang(e);
                break
            }
        case W.COMMENT_LESS_THAN_SIGN_BANG_DASH:
            {
                this._stateCommentLessThanSignBangDash(e);
                break
            }
        case W.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:
            {
                this._stateCommentLessThanSignBangDashDash(e);
                break
            }
        case W.COMMENT_END_DASH:
            {
                this._stateCommentEndDash(e);
                break
            }
        case W.COMMENT_END:
            {
                this._stateCommentEnd(e);
                break
            }
        case W.COMMENT_END_BANG:
            {
                this._stateCommentEndBang(e);
                break
            }
        case W.DOCTYPE:
            {
                this._stateDoctype(e);
                break
            }
        case W.BEFORE_DOCTYPE_NAME:
            {
                this._stateBeforeDoctypeName(e);
                break
            }
        case W.DOCTYPE_NAME:
            {
                this._stateDoctypeName(e);
                break
            }
        case W.AFTER_DOCTYPE_NAME:
            {
                this._stateAfterDoctypeName(e);
                break
            }
        case W.AFTER_DOCTYPE_PUBLIC_KEYWORD:
            {
                this._stateAfterDoctypePublicKeyword(e);
                break
            }
        case W.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
            {
                this._stateBeforeDoctypePublicIdentifier(e);
                break
            }
        case W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
            {
                this._stateDoctypePublicIdentifierDoubleQuoted(e);
                break
            }
        case W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
            {
                this._stateDoctypePublicIdentifierSingleQuoted(e);
                break
            }
        case W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
            {
                this._stateAfterDoctypePublicIdentifier(e);
                break
            }
        case W.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
            {
                this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
                break
            }
        case W.AFTER_DOCTYPE_SYSTEM_KEYWORD:
            {
                this._stateAfterDoctypeSystemKeyword(e);
                break
            }
        case W.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
            {
                this._stateBeforeDoctypeSystemIdentifier(e);
                break
            }
        case W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
            {
                this._stateDoctypeSystemIdentifierDoubleQuoted(e);
                break
            }
        case W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
            {
                this._stateDoctypeSystemIdentifierSingleQuoted(e);
                break
            }
        case W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
            {
                this._stateAfterDoctypeSystemIdentifier(e);
                break
            }
        case W.BOGUS_DOCTYPE:
            {
                this._stateBogusDoctype(e);
                break
            }
        case W.CDATA_SECTION:
            {
                this._stateCdataSection(e);
                break
            }
        case W.CDATA_SECTION_BRACKET:
            {
                this._stateCdataSectionBracket(e);
                break
            }
        case W.CDATA_SECTION_END:
            {
                this._stateCdataSectionEnd(e);
                break
            }
        case W.CHARACTER_REFERENCE:
            {
                this._stateCharacterReference(e);
                break
            }
        case W.NAMED_CHARACTER_REFERENCE:
            {
                this._stateNamedCharacterReference(e);
                break
            }
        case W.AMBIGUOUS_AMPERSAND:
            {
                this._stateAmbiguousAmpersand(e);
                break
            }
        case W.NUMERIC_CHARACTER_REFERENCE:
            {
                this._stateNumericCharacterReference(e);
                break
            }
        case W.HEXADEMICAL_CHARACTER_REFERENCE_START:
            {
                this._stateHexademicalCharacterReferenceStart(e);
                break
            }
        case W.HEXADEMICAL_CHARACTER_REFERENCE:
            {
                this._stateHexademicalCharacterReference(e);
                break
            }
        case W.DECIMAL_CHARACTER_REFERENCE:
            {
                this._stateDecimalCharacterReference(e);
                break
            }
        case W.NUMERIC_CHARACTER_REFERENCE_END:
            {
                this._stateNumericCharacterReferenceEnd(e);
                break
            }
        default:
            throw new Error("Unknown state")
        }
    }
    _stateData(e) {
        switch (e) {
        case U.LESS_THAN_SIGN:
            {
                this.state = W.TAG_OPEN;
                break
            }
        case U.AMPERSAND:
            {
                this.returnState = W.DATA,
                this.state = W.CHARACTER_REFERENCE;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitCodePoint(e);
                break
            }
        case U.EOF:
            {
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateRcdata(e) {
        switch (e) {
        case U.AMPERSAND:
            {
                this.returnState = W.RCDATA,
                this.state = W.CHARACTER_REFERENCE;
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.RCDATA_LESS_THAN_SIGN;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateRawtext(e) {
        switch (e) {
        case U.LESS_THAN_SIGN:
            {
                this.state = W.RAWTEXT_LESS_THAN_SIGN;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateScriptData(e) {
        switch (e) {
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_LESS_THAN_SIGN;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _statePlaintext(e) {
        switch (e) {
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateTagOpen(e) {
        if (bs(e))
            this._createStartTagToken(),
            this.state = W.TAG_NAME,
            this._stateTagName(e);
        else
            switch (e) {
            case U.EXCLAMATION_MARK:
                {
                    this.state = W.MARKUP_DECLARATION_OPEN;
                    break
                }
            case U.SOLIDUS:
                {
                    this.state = W.END_TAG_OPEN;
                    break
                }
            case U.QUESTION_MARK:
                {
                    this._err(ue.unexpectedQuestionMarkInsteadOfTagName),
                    this._createCommentToken(1),
                    this.state = W.BOGUS_COMMENT,
                    this._stateBogusComment(e);
                    break
                }
            case U.EOF:
                {
                    this._err(ue.eofBeforeTagName),
                    this._emitChars("<"),
                    this._emitEOFToken();
                    break
                }
            default:
                this._err(ue.invalidFirstCharacterOfTagName),
                this._emitChars("<"),
                this.state = W.DATA,
                this._stateData(e)
            }
    }
    _stateEndTagOpen(e) {
        if (bs(e))
            this._createEndTagToken(),
            this.state = W.TAG_NAME,
            this._stateTagName(e);
        else
            switch (e) {
            case U.GREATER_THAN_SIGN:
                {
                    this._err(ue.missingEndTagName),
                    this.state = W.DATA;
                    break
                }
            case U.EOF:
                {
                    this._err(ue.eofBeforeTagName),
                    this._emitChars("</"),
                    this._emitEOFToken();
                    break
                }
            default:
                this._err(ue.invalidFirstCharacterOfTagName),
                this._createCommentToken(2),
                this.state = W.BOGUS_COMMENT,
                this._stateBogusComment(e)
            }
    }
    _stateTagName(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this.state = W.BEFORE_ATTRIBUTE_NAME;
                break
            }
        case U.SOLIDUS:
            {
                this.state = W.SELF_CLOSING_START_TAG;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentTagToken();
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.tagName += Lt;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            n.tagName += String.fromCodePoint(Cc(e) ? Sd(e) : e)
        }
    }
    _stateRcdataLessThanSign(e) {
        e === U.SOLIDUS ? this.state = W.RCDATA_END_TAG_OPEN : (this._emitChars("<"),
        this.state = W.RCDATA,
        this._stateRcdata(e))
    }
    _stateRcdataEndTagOpen(e) {
        bs(e) ? (this.state = W.RCDATA_END_TAG_NAME,
        this._stateRcdataEndTagName(e)) : (this._emitChars("</"),
        this.state = W.RCDATA,
        this._stateRcdata(e))
    }
    handleSpecialEndTag(e) {
        if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
            return !this._ensureHibernation();
        this._createEndTagToken();
        const n = this.currentToken;
        switch (n.tagName = this.lastStartTagName,
        this.preprocessor.peek(this.lastStartTagName.length)) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            return this._advanceBy(this.lastStartTagName.length),
            this.state = W.BEFORE_ATTRIBUTE_NAME,
            !1;
        case U.SOLIDUS:
            return this._advanceBy(this.lastStartTagName.length),
            this.state = W.SELF_CLOSING_START_TAG,
            !1;
        case U.GREATER_THAN_SIGN:
            return this._advanceBy(this.lastStartTagName.length),
            this.emitCurrentTagToken(),
            this.state = W.DATA,
            !1;
        default:
            return !this._ensureHibernation()
        }
    }
    _stateRcdataEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"),
        this.state = W.RCDATA,
        this._stateRcdata(e))
    }
    _stateRawtextLessThanSign(e) {
        e === U.SOLIDUS ? this.state = W.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"),
        this.state = W.RAWTEXT,
        this._stateRawtext(e))
    }
    _stateRawtextEndTagOpen(e) {
        bs(e) ? (this.state = W.RAWTEXT_END_TAG_NAME,
        this._stateRawtextEndTagName(e)) : (this._emitChars("</"),
        this.state = W.RAWTEXT,
        this._stateRawtext(e))
    }
    _stateRawtextEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"),
        this.state = W.RAWTEXT,
        this._stateRawtext(e))
    }
    _stateScriptDataLessThanSign(e) {
        switch (e) {
        case U.SOLIDUS:
            {
                this.state = W.SCRIPT_DATA_END_TAG_OPEN;
                break
            }
        case U.EXCLAMATION_MARK:
            {
                this.state = W.SCRIPT_DATA_ESCAPE_START,
                this._emitChars("<!");
                break
            }
        default:
            this._emitChars("<"),
            this.state = W.SCRIPT_DATA,
            this._stateScriptData(e)
        }
    }
    _stateScriptDataEndTagOpen(e) {
        bs(e) ? (this.state = W.SCRIPT_DATA_END_TAG_NAME,
        this._stateScriptDataEndTagName(e)) : (this._emitChars("</"),
        this.state = W.SCRIPT_DATA,
        this._stateScriptData(e))
    }
    _stateScriptDataEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"),
        this.state = W.SCRIPT_DATA,
        this._stateScriptData(e))
    }
    _stateScriptDataEscapeStart(e) {
        e === U.HYPHEN_MINUS ? (this.state = W.SCRIPT_DATA_ESCAPE_START_DASH,
        this._emitChars("-")) : (this.state = W.SCRIPT_DATA,
        this._stateScriptData(e))
    }
    _stateScriptDataEscapeStartDash(e) {
        e === U.HYPHEN_MINUS ? (this.state = W.SCRIPT_DATA_ESCAPED_DASH_DASH,
        this._emitChars("-")) : (this.state = W.SCRIPT_DATA,
        this._stateScriptData(e))
    }
    _stateScriptDataEscaped(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.SCRIPT_DATA_ESCAPED_DASH,
                this._emitChars("-");
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateScriptDataEscapedDash(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.SCRIPT_DATA_ESCAPED_DASH_DASH,
                this._emitChars("-");
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.state = W.SCRIPT_DATA_ESCAPED,
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break
            }
        default:
            this.state = W.SCRIPT_DATA_ESCAPED,
            this._emitCodePoint(e)
        }
    }
    _stateScriptDataEscapedDashDash(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this._emitChars("-");
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA,
                this._emitChars(">");
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.state = W.SCRIPT_DATA_ESCAPED,
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break
            }
        default:
            this.state = W.SCRIPT_DATA_ESCAPED,
            this._emitCodePoint(e)
        }
    }
    _stateScriptDataEscapedLessThanSign(e) {
        e === U.SOLIDUS ? this.state = W.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : bs(e) ? (this._emitChars("<"),
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPE_START,
        this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"),
        this.state = W.SCRIPT_DATA_ESCAPED,
        this._stateScriptDataEscaped(e))
    }
    _stateScriptDataEscapedEndTagOpen(e) {
        bs(e) ? (this.state = W.SCRIPT_DATA_ESCAPED_END_TAG_NAME,
        this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"),
        this.state = W.SCRIPT_DATA_ESCAPED,
        this._stateScriptDataEscaped(e))
    }
    _stateScriptDataEscapedEndTagName(e) {
        this.handleSpecialEndTag(e) && (this._emitChars("</"),
        this.state = W.SCRIPT_DATA_ESCAPED,
        this._stateScriptDataEscaped(e))
    }
    _stateScriptDataDoubleEscapeStart(e) {
        if (this.preprocessor.startsWith(qn.SCRIPT, !1) && Pw(this.preprocessor.peek(qn.SCRIPT.length))) {
            this._emitCodePoint(e);
            for (let n = 0; n < qn.SCRIPT.length; n++)
                this._emitCodePoint(this._consume());
            this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED
        } else
            this._ensureHibernation() || (this.state = W.SCRIPT_DATA_ESCAPED,
            this._stateScriptDataEscaped(e))
    }
    _stateScriptDataDoubleEscaped(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH,
                this._emitChars("-");
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,
                this._emitChars("<");
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateScriptDataDoubleEscapedDash(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH,
                this._emitChars("-");
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,
                this._emitChars("<");
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break
            }
        default:
            this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED,
            this._emitCodePoint(e)
        }
    }
    _stateScriptDataDoubleEscapedDashDash(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this._emitChars("-");
                break
            }
        case U.LESS_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,
                this._emitChars("<");
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.SCRIPT_DATA,
                this._emitChars(">");
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._emitChars(Lt);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break
            }
        default:
            this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED,
            this._emitCodePoint(e)
        }
    }
    _stateScriptDataDoubleEscapedLessThanSign(e) {
        e === U.SOLIDUS ? (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPE_END,
        this._emitChars("/")) : (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED,
        this._stateScriptDataDoubleEscaped(e))
    }
    _stateScriptDataDoubleEscapeEnd(e) {
        if (this.preprocessor.startsWith(qn.SCRIPT, !1) && Pw(this.preprocessor.peek(qn.SCRIPT.length))) {
            this._emitCodePoint(e);
            for (let n = 0; n < qn.SCRIPT.length; n++)
                this._emitCodePoint(this._consume());
            this.state = W.SCRIPT_DATA_ESCAPED
        } else
            this._ensureHibernation() || (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED,
            this._stateScriptDataDoubleEscaped(e))
    }
    _stateBeforeAttributeName(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.SOLIDUS:
        case U.GREATER_THAN_SIGN:
        case U.EOF:
            {
                this.state = W.AFTER_ATTRIBUTE_NAME,
                this._stateAfterAttributeName(e);
                break
            }
        case U.EQUALS_SIGN:
            {
                this._err(ue.unexpectedEqualsSignBeforeAttributeName),
                this._createAttr("="),
                this.state = W.ATTRIBUTE_NAME;
                break
            }
        default:
            this._createAttr(""),
            this.state = W.ATTRIBUTE_NAME,
            this._stateAttributeName(e)
        }
    }
    _stateAttributeName(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
        case U.SOLIDUS:
        case U.GREATER_THAN_SIGN:
        case U.EOF:
            {
                this._leaveAttrName(),
                this.state = W.AFTER_ATTRIBUTE_NAME,
                this._stateAfterAttributeName(e);
                break
            }
        case U.EQUALS_SIGN:
            {
                this._leaveAttrName(),
                this.state = W.BEFORE_ATTRIBUTE_VALUE;
                break
            }
        case U.QUOTATION_MARK:
        case U.APOSTROPHE:
        case U.LESS_THAN_SIGN:
            {
                this._err(ue.unexpectedCharacterInAttributeName),
                this.currentAttr.name += String.fromCodePoint(e);
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.currentAttr.name += Lt;
                break
            }
        default:
            this.currentAttr.name += String.fromCodePoint(Cc(e) ? Sd(e) : e)
        }
    }
    _stateAfterAttributeName(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.SOLIDUS:
            {
                this.state = W.SELF_CLOSING_START_TAG;
                break
            }
        case U.EQUALS_SIGN:
            {
                this.state = W.BEFORE_ATTRIBUTE_VALUE;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentTagToken();
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            this._createAttr(""),
            this.state = W.ATTRIBUTE_NAME,
            this._stateAttributeName(e)
        }
    }
    _stateBeforeAttributeValue(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.QUOTATION_MARK:
            {
                this.state = W.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                this.state = W.ATTRIBUTE_VALUE_SINGLE_QUOTED;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.missingAttributeValue),
                this.state = W.DATA,
                this.emitCurrentTagToken();
                break
            }
        default:
            this.state = W.ATTRIBUTE_VALUE_UNQUOTED,
            this._stateAttributeValueUnquoted(e)
        }
    }
    _stateAttributeValueDoubleQuoted(e) {
        switch (e) {
        case U.QUOTATION_MARK:
            {
                this.state = W.AFTER_ATTRIBUTE_VALUE_QUOTED;
                break
            }
        case U.AMPERSAND:
            {
                this.returnState = W.ATTRIBUTE_VALUE_DOUBLE_QUOTED,
                this.state = W.CHARACTER_REFERENCE;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.currentAttr.value += Lt;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            this.currentAttr.value += String.fromCodePoint(e)
        }
    }
    _stateAttributeValueSingleQuoted(e) {
        switch (e) {
        case U.APOSTROPHE:
            {
                this.state = W.AFTER_ATTRIBUTE_VALUE_QUOTED;
                break
            }
        case U.AMPERSAND:
            {
                this.returnState = W.ATTRIBUTE_VALUE_SINGLE_QUOTED,
                this.state = W.CHARACTER_REFERENCE;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.currentAttr.value += Lt;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            this.currentAttr.value += String.fromCodePoint(e)
        }
    }
    _stateAttributeValueUnquoted(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this._leaveAttrValue(),
                this.state = W.BEFORE_ATTRIBUTE_NAME;
                break
            }
        case U.AMPERSAND:
            {
                this.returnState = W.ATTRIBUTE_VALUE_UNQUOTED,
                this.state = W.CHARACTER_REFERENCE;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._leaveAttrValue(),
                this.state = W.DATA,
                this.emitCurrentTagToken();
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                this.currentAttr.value += Lt;
                break
            }
        case U.QUOTATION_MARK:
        case U.APOSTROPHE:
        case U.LESS_THAN_SIGN:
        case U.EQUALS_SIGN:
        case U.GRAVE_ACCENT:
            {
                this._err(ue.unexpectedCharacterInUnquotedAttributeValue),
                this.currentAttr.value += String.fromCodePoint(e);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            this.currentAttr.value += String.fromCodePoint(e)
        }
    }
    _stateAfterAttributeValueQuoted(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this._leaveAttrValue(),
                this.state = W.BEFORE_ATTRIBUTE_NAME;
                break
            }
        case U.SOLIDUS:
            {
                this._leaveAttrValue(),
                this.state = W.SELF_CLOSING_START_TAG;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._leaveAttrValue(),
                this.state = W.DATA,
                this.emitCurrentTagToken();
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingWhitespaceBetweenAttributes),
            this.state = W.BEFORE_ATTRIBUTE_NAME,
            this._stateBeforeAttributeName(e)
        }
    }
    _stateSelfClosingStartTag(e) {
        switch (e) {
        case U.GREATER_THAN_SIGN:
            {
                const n = this.currentToken;
                n.selfClosing = !0,
                this.state = W.DATA,
                this.emitCurrentTagToken();
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInTag),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.unexpectedSolidusInTag),
            this.state = W.BEFORE_ATTRIBUTE_NAME,
            this._stateBeforeAttributeName(e)
        }
    }
    _stateBogusComment(e) {
        const n = this.currentToken;
        switch (e) {
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentComment(n);
                break
            }
        case U.EOF:
            {
                this.emitCurrentComment(n),
                this._emitEOFToken();
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.data += Lt;
                break
            }
        default:
            n.data += String.fromCodePoint(e)
        }
    }
    _stateMarkupDeclarationOpen(e) {
        this._consumeSequenceIfMatch(qn.DASH_DASH, !0) ? (this._createCommentToken(qn.DASH_DASH.length + 1),
        this.state = W.COMMENT_START) : this._consumeSequenceIfMatch(qn.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(qn.DOCTYPE.length + 1),
        this.state = W.DOCTYPE) : this._consumeSequenceIfMatch(qn.CDATA_START, !0) ? this.inForeignNode ? this.state = W.CDATA_SECTION : (this._err(ue.cdataInHtmlContent),
        this._createCommentToken(qn.CDATA_START.length + 1),
        this.currentToken.data = "[CDATA[",
        this.state = W.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(ue.incorrectlyOpenedComment),
        this._createCommentToken(2),
        this.state = W.BOGUS_COMMENT,
        this._stateBogusComment(e))
    }
    _stateCommentStart(e) {
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.COMMENT_START_DASH;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.abruptClosingOfEmptyComment),
                this.state = W.DATA;
                const n = this.currentToken;
                this.emitCurrentComment(n);
                break
            }
        default:
            this.state = W.COMMENT,
            this._stateComment(e)
        }
    }
    _stateCommentStartDash(e) {
        const n = this.currentToken;
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.COMMENT_END;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.abruptClosingOfEmptyComment),
                this.state = W.DATA,
                this.emitCurrentComment(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInComment),
                this.emitCurrentComment(n),
                this._emitEOFToken();
                break
            }
        default:
            n.data += "-",
            this.state = W.COMMENT,
            this._stateComment(e)
        }
    }
    _stateComment(e) {
        const n = this.currentToken;
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.COMMENT_END_DASH;
                break
            }
        case U.LESS_THAN_SIGN:
            {
                n.data += "<",
                this.state = W.COMMENT_LESS_THAN_SIGN;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.data += Lt;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInComment),
                this.emitCurrentComment(n),
                this._emitEOFToken();
                break
            }
        default:
            n.data += String.fromCodePoint(e)
        }
    }
    _stateCommentLessThanSign(e) {
        const n = this.currentToken;
        switch (e) {
        case U.EXCLAMATION_MARK:
            {
                n.data += "!",
                this.state = W.COMMENT_LESS_THAN_SIGN_BANG;
                break
            }
        case U.LESS_THAN_SIGN:
            {
                n.data += "<";
                break
            }
        default:
            this.state = W.COMMENT,
            this._stateComment(e)
        }
    }
    _stateCommentLessThanSignBang(e) {
        e === U.HYPHEN_MINUS ? this.state = W.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = W.COMMENT,
        this._stateComment(e))
    }
    _stateCommentLessThanSignBangDash(e) {
        e === U.HYPHEN_MINUS ? this.state = W.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = W.COMMENT_END_DASH,
        this._stateCommentEndDash(e))
    }
    _stateCommentLessThanSignBangDashDash(e) {
        e !== U.GREATER_THAN_SIGN && e !== U.EOF && this._err(ue.nestedComment),
        this.state = W.COMMENT_END,
        this._stateCommentEnd(e)
    }
    _stateCommentEndDash(e) {
        const n = this.currentToken;
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                this.state = W.COMMENT_END;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInComment),
                this.emitCurrentComment(n),
                this._emitEOFToken();
                break
            }
        default:
            n.data += "-",
            this.state = W.COMMENT,
            this._stateComment(e)
        }
    }
    _stateCommentEnd(e) {
        const n = this.currentToken;
        switch (e) {
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentComment(n);
                break
            }
        case U.EXCLAMATION_MARK:
            {
                this.state = W.COMMENT_END_BANG;
                break
            }
        case U.HYPHEN_MINUS:
            {
                n.data += "-";
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInComment),
                this.emitCurrentComment(n),
                this._emitEOFToken();
                break
            }
        default:
            n.data += "--",
            this.state = W.COMMENT,
            this._stateComment(e)
        }
    }
    _stateCommentEndBang(e) {
        const n = this.currentToken;
        switch (e) {
        case U.HYPHEN_MINUS:
            {
                n.data += "--!",
                this.state = W.COMMENT_END_DASH;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.incorrectlyClosedComment),
                this.state = W.DATA,
                this.emitCurrentComment(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInComment),
                this.emitCurrentComment(n),
                this._emitEOFToken();
                break
            }
        default:
            n.data += "--!",
            this.state = W.COMMENT,
            this._stateComment(e)
        }
    }
    _stateDoctype(e) {
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this.state = W.BEFORE_DOCTYPE_NAME;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.BEFORE_DOCTYPE_NAME,
                this._stateBeforeDoctypeName(e);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                this._createDoctypeToken(null);
                const n = this.currentToken;
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingWhitespaceBeforeDoctypeName),
            this.state = W.BEFORE_DOCTYPE_NAME,
            this._stateBeforeDoctypeName(e)
        }
    }
    _stateBeforeDoctypeName(e) {
        if (Cc(e))
            this._createDoctypeToken(String.fromCharCode(Sd(e))),
            this.state = W.DOCTYPE_NAME;
        else
            switch (e) {
            case U.SPACE:
            case U.LINE_FEED:
            case U.TABULATION:
            case U.FORM_FEED:
                break;
            case U.NULL:
                {
                    this._err(ue.unexpectedNullCharacter),
                    this._createDoctypeToken(Lt),
                    this.state = W.DOCTYPE_NAME;
                    break
                }
            case U.GREATER_THAN_SIGN:
                {
                    this._err(ue.missingDoctypeName),
                    this._createDoctypeToken(null);
                    const n = this.currentToken;
                    n.forceQuirks = !0,
                    this.emitCurrentDoctype(n),
                    this.state = W.DATA;
                    break
                }
            case U.EOF:
                {
                    this._err(ue.eofInDoctype),
                    this._createDoctypeToken(null);
                    const n = this.currentToken;
                    n.forceQuirks = !0,
                    this.emitCurrentDoctype(n),
                    this._emitEOFToken();
                    break
                }
            default:
                this._createDoctypeToken(String.fromCodePoint(e)),
                this.state = W.DOCTYPE_NAME
            }
    }
    _stateDoctypeName(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this.state = W.AFTER_DOCTYPE_NAME;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.name += Lt;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            n.name += String.fromCodePoint(Cc(e) ? Sd(e) : e)
        }
    }
    _stateAfterDoctypeName(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._consumeSequenceIfMatch(qn.PUBLIC, !1) ? this.state = W.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(qn.SYSTEM, !1) ? this.state = W.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(ue.invalidCharacterSequenceAfterDoctypeName),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e))
        }
    }
    _stateAfterDoctypePublicKeyword(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this.state = W.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
                break
            }
        case U.QUOTATION_MARK:
            {
                this._err(ue.missingWhitespaceAfterDoctypePublicKeyword),
                n.publicId = "",
                this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                this._err(ue.missingWhitespaceAfterDoctypePublicKeyword),
                n.publicId = "",
                this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.missingDoctypePublicIdentifier),
                n.forceQuirks = !0,
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingQuoteBeforeDoctypePublicIdentifier),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateBeforeDoctypePublicIdentifier(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.QUOTATION_MARK:
            {
                n.publicId = "",
                this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                n.publicId = "",
                this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.missingDoctypePublicIdentifier),
                n.forceQuirks = !0,
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingQuoteBeforeDoctypePublicIdentifier),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateDoctypePublicIdentifierDoubleQuoted(e) {
        const n = this.currentToken;
        switch (e) {
        case U.QUOTATION_MARK:
            {
                this.state = W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.publicId += Lt;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.abruptDoctypePublicIdentifier),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            n.publicId += String.fromCodePoint(e)
        }
    }
    _stateDoctypePublicIdentifierSingleQuoted(e) {
        const n = this.currentToken;
        switch (e) {
        case U.APOSTROPHE:
            {
                this.state = W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.publicId += Lt;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.abruptDoctypePublicIdentifier),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            n.publicId += String.fromCodePoint(e)
        }
    }
    _stateAfterDoctypePublicIdentifier(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this.state = W.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.QUOTATION_MARK:
            {
                this._err(ue.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                this._err(ue.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingQuoteBeforeDoctypeSystemIdentifier),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.GREATER_THAN_SIGN:
            {
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.QUOTATION_MARK:
            {
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingQuoteBeforeDoctypeSystemIdentifier),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateAfterDoctypeSystemKeyword(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            {
                this.state = W.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
                break
            }
        case U.QUOTATION_MARK:
            {
                this._err(ue.missingWhitespaceAfterDoctypeSystemKeyword),
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                this._err(ue.missingWhitespaceAfterDoctypeSystemKeyword),
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.missingDoctypeSystemIdentifier),
                n.forceQuirks = !0,
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingQuoteBeforeDoctypeSystemIdentifier),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateBeforeDoctypeSystemIdentifier(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.QUOTATION_MARK:
            {
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break
            }
        case U.APOSTROPHE:
            {
                n.systemId = "",
                this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.missingDoctypeSystemIdentifier),
                n.forceQuirks = !0,
                this.state = W.DATA,
                this.emitCurrentDoctype(n);
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.missingQuoteBeforeDoctypeSystemIdentifier),
            n.forceQuirks = !0,
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateDoctypeSystemIdentifierDoubleQuoted(e) {
        const n = this.currentToken;
        switch (e) {
        case U.QUOTATION_MARK:
            {
                this.state = W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.systemId += Lt;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.abruptDoctypeSystemIdentifier),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            n.systemId += String.fromCodePoint(e)
        }
    }
    _stateDoctypeSystemIdentifierSingleQuoted(e) {
        const n = this.currentToken;
        switch (e) {
        case U.APOSTROPHE:
            {
                this.state = W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter),
                n.systemId += Lt;
                break
            }
        case U.GREATER_THAN_SIGN:
            {
                this._err(ue.abruptDoctypeSystemIdentifier),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            n.systemId += String.fromCodePoint(e)
        }
    }
    _stateAfterDoctypeSystemIdentifier(e) {
        const n = this.currentToken;
        switch (e) {
        case U.SPACE:
        case U.LINE_FEED:
        case U.TABULATION:
        case U.FORM_FEED:
            break;
        case U.GREATER_THAN_SIGN:
            {
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInDoctype),
                n.forceQuirks = !0,
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        default:
            this._err(ue.unexpectedCharacterAfterDoctypeSystemIdentifier),
            this.state = W.BOGUS_DOCTYPE,
            this._stateBogusDoctype(e)
        }
    }
    _stateBogusDoctype(e) {
        const n = this.currentToken;
        switch (e) {
        case U.GREATER_THAN_SIGN:
            {
                this.emitCurrentDoctype(n),
                this.state = W.DATA;
                break
            }
        case U.NULL:
            {
                this._err(ue.unexpectedNullCharacter);
                break
            }
        case U.EOF:
            {
                this.emitCurrentDoctype(n),
                this._emitEOFToken();
                break
            }
        }
    }
    _stateCdataSection(e) {
        switch (e) {
        case U.RIGHT_SQUARE_BRACKET:
            {
                this.state = W.CDATA_SECTION_BRACKET;
                break
            }
        case U.EOF:
            {
                this._err(ue.eofInCdata),
                this._emitEOFToken();
                break
            }
        default:
            this._emitCodePoint(e)
        }
    }
    _stateCdataSectionBracket(e) {
        e === U.RIGHT_SQUARE_BRACKET ? this.state = W.CDATA_SECTION_END : (this._emitChars("]"),
        this.state = W.CDATA_SECTION,
        this._stateCdataSection(e))
    }
    _stateCdataSectionEnd(e) {
        switch (e) {
        case U.GREATER_THAN_SIGN:
            {
                this.state = W.DATA;
                break
            }
        case U.RIGHT_SQUARE_BRACKET:
            {
                this._emitChars("]");
                break
            }
        default:
            this._emitChars("]]"),
            this.state = W.CDATA_SECTION,
            this._stateCdataSection(e)
        }
    }
    _stateCharacterReference(e) {
        e === U.NUMBER_SIGN ? this.state = W.NUMERIC_CHARACTER_REFERENCE : ib(e) ? (this.state = W.NAMED_CHARACTER_REFERENCE,
        this._stateNamedCharacterReference(e)) : (this._flushCodePointConsumedAsCharacterReference(U.AMPERSAND),
        this._reconsumeInState(this.returnState, e))
    }
    _stateNamedCharacterReference(e) {
        const n = this._matchNamedCharacterReference(e);
        if (!this._ensureHibernation())
            if (n) {
                for (let r = 0; r < n.length; r++)
                    this._flushCodePointConsumedAsCharacterReference(n[r]);
                this.state = this.returnState
            } else
                this._flushCodePointConsumedAsCharacterReference(U.AMPERSAND),
                this.state = W.AMBIGUOUS_AMPERSAND
    }
    _stateAmbiguousAmpersand(e) {
        ib(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === U.SEMICOLON && this._err(ue.unknownNamedCharacterReference),
        this._reconsumeInState(this.returnState, e))
    }
    _stateNumericCharacterReference(e) {
        this.charRefCode = 0,
        e === U.LATIN_SMALL_X || e === U.LATIN_CAPITAL_X ? this.state = W.HEXADEMICAL_CHARACTER_REFERENCE_START : Wc(e) ? (this.state = W.DECIMAL_CHARACTER_REFERENCE,
        this._stateDecimalCharacterReference(e)) : (this._err(ue.absenceOfDigitsInNumericCharacterReference),
        this._flushCodePointConsumedAsCharacterReference(U.AMPERSAND),
        this._flushCodePointConsumedAsCharacterReference(U.NUMBER_SIGN),
        this._reconsumeInState(this.returnState, e))
    }
    _stateHexademicalCharacterReferenceStart(e) {
        bQ(e) ? (this.state = W.HEXADEMICAL_CHARACTER_REFERENCE,
        this._stateHexademicalCharacterReference(e)) : (this._err(ue.absenceOfDigitsInNumericCharacterReference),
        this._flushCodePointConsumedAsCharacterReference(U.AMPERSAND),
        this._flushCodePointConsumedAsCharacterReference(U.NUMBER_SIGN),
        this._unconsume(2),
        this.state = this.returnState)
    }
    _stateHexademicalCharacterReference(e) {
        YP(e) ? this.charRefCode = this.charRefCode * 16 + e - 55 : XP(e) ? this.charRefCode = this.charRefCode * 16 + e - 87 : Wc(e) ? this.charRefCode = this.charRefCode * 16 + e - 48 : e === U.SEMICOLON ? this.state = W.NUMERIC_CHARACTER_REFERENCE_END : (this._err(ue.missingSemicolonAfterCharacterReference),
        this.state = W.NUMERIC_CHARACTER_REFERENCE_END,
        this._stateNumericCharacterReferenceEnd(e))
    }
    _stateDecimalCharacterReference(e) {
        Wc(e) ? this.charRefCode = this.charRefCode * 10 + e - 48 : e === U.SEMICOLON ? this.state = W.NUMERIC_CHARACTER_REFERENCE_END : (this._err(ue.missingSemicolonAfterCharacterReference),
        this.state = W.NUMERIC_CHARACTER_REFERENCE_END,
        this._stateNumericCharacterReferenceEnd(e))
    }
    _stateNumericCharacterReferenceEnd(e) {
        if (this.charRefCode === U.NULL)
            this._err(ue.nullCharacterReference),
            this.charRefCode = U.REPLACEMENT_CHARACTER;
        else if (this.charRefCode > 1114111)
            this._err(ue.characterReferenceOutsideUnicodeRange),
            this.charRefCode = U.REPLACEMENT_CHARACTER;
        else if (VP(this.charRefCode))
            this._err(ue.surrogateCharacterReference),
            this.charRefCode = U.REPLACEMENT_CHARACTER;
        else if (zP(this.charRefCode))
            this._err(ue.noncharacterCharacterReference);
        else if ($P(this.charRefCode) || this.charRefCode === U.CARRIAGE_RETURN) {
            this._err(ue.controlCharacterReference);
            const n = gQ.get(this.charRefCode);
            n !== void 0 && (this.charRefCode = n)
        }
        this._flushCodePointConsumedAsCharacterReference(this.charRefCode),
        this._reconsumeInState(this.returnState, e)
    }
}
const JP = new Set([T.DD, T.DT, T.LI, T.OPTGROUP, T.OPTION, T.P, T.RB, T.RP, T.RT, T.RTC])
  , Dw = new Set([...JP, T.CAPTION, T.COLGROUP, T.TBODY, T.TD, T.TFOOT, T.TH, T.THEAD, T.TR])
  , wd = new Map([[T.APPLET, fe.HTML], [T.CAPTION, fe.HTML], [T.HTML, fe.HTML], [T.MARQUEE, fe.HTML], [T.OBJECT, fe.HTML], [T.TABLE, fe.HTML], [T.TD, fe.HTML], [T.TEMPLATE, fe.HTML], [T.TH, fe.HTML], [T.ANNOTATION_XML, fe.MATHML], [T.MI, fe.MATHML], [T.MN, fe.MATHML], [T.MO, fe.MATHML], [T.MS, fe.MATHML], [T.MTEXT, fe.MATHML], [T.DESC, fe.SVG], [T.FOREIGN_OBJECT, fe.SVG], [T.TITLE, fe.SVG]])
  , xQ = [T.H1, T.H2, T.H3, T.H4, T.H5, T.H6]
  , EQ = [T.TR, T.TEMPLATE, T.HTML]
  , SQ = [T.TBODY, T.TFOOT, T.THEAD, T.TEMPLATE, T.HTML]
  , wQ = [T.TABLE, T.TEMPLATE, T.HTML]
  , CQ = [T.TD, T.TH];
class TQ {
    get currentTmplContentOrNode() {
        return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current
    }
    constructor(e, n, r) {
        this.treeAdapter = n,
        this.handler = r,
        this.items = [],
        this.tagIDs = [],
        this.stackTop = -1,
        this.tmplCount = 0,
        this.currentTagId = T.UNKNOWN,
        this.current = e
    }
    _indexOf(e) {
        return this.items.lastIndexOf(e, this.stackTop)
    }
    _isInTemplate() {
        return this.currentTagId === T.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === fe.HTML
    }
    _updateCurrentElement() {
        this.current = this.items[this.stackTop],
        this.currentTagId = this.tagIDs[this.stackTop]
    }
    push(e, n) {
        this.stackTop++,
        this.items[this.stackTop] = e,
        this.current = e,
        this.tagIDs[this.stackTop] = n,
        this.currentTagId = n,
        this._isInTemplate() && this.tmplCount++,
        this.handler.onItemPush(e, n, !0)
    }
    pop() {
        const e = this.current;
        this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--,
        this.stackTop--,
        this._updateCurrentElement(),
        this.handler.onItemPop(e, !0)
    }
    replace(e, n) {
        const r = this._indexOf(e);
        this.items[r] = n,
        r === this.stackTop && (this.current = n)
    }
    insertAfter(e, n, r) {
        const i = this._indexOf(e) + 1;
        this.items.splice(i, 0, n),
        this.tagIDs.splice(i, 0, r),
        this.stackTop++,
        i === this.stackTop && this._updateCurrentElement(),
        this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop)
    }
    popUntilTagNamePopped(e) {
        let n = this.stackTop + 1;
        do
            n = this.tagIDs.lastIndexOf(e, n - 1);
        while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== fe.HTML);
        this.shortenToLength(n < 0 ? 0 : n)
    }
    shortenToLength(e) {
        for (; this.stackTop >= e; ) {
            const n = this.current;
            this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1),
            this.stackTop--,
            this._updateCurrentElement(),
            this.handler.onItemPop(n, this.stackTop < e)
        }
    }
    popUntilElementPopped(e) {
        const n = this._indexOf(e);
        this.shortenToLength(n < 0 ? 0 : n)
    }
    popUntilPopped(e, n) {
        const r = this._indexOfTagNames(e, n);
        this.shortenToLength(r < 0 ? 0 : r)
    }
    popUntilNumberedHeaderPopped() {
        this.popUntilPopped(xQ, fe.HTML)
    }
    popUntilTableCellPopped() {
        this.popUntilPopped(CQ, fe.HTML)
    }
    popAllUpToHtmlElement() {
        this.tmplCount = 0,
        this.shortenToLength(1)
    }
    _indexOfTagNames(e, n) {
        for (let r = this.stackTop; r >= 0; r--)
            if (e.includes(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
                return r;
        return -1
    }
    clearBackTo(e, n) {
        const r = this._indexOfTagNames(e, n);
        this.shortenToLength(r + 1)
    }
    clearBackToTableContext() {
        this.clearBackTo(wQ, fe.HTML)
    }
    clearBackToTableBodyContext() {
        this.clearBackTo(SQ, fe.HTML)
    }
    clearBackToTableRowContext() {
        this.clearBackTo(EQ, fe.HTML)
    }
    remove(e) {
        const n = this._indexOf(e);
        n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1),
        this.tagIDs.splice(n, 1),
        this.stackTop--,
        this._updateCurrentElement(),
        this.handler.onItemPop(e, !1)))
    }
    tryPeekProperlyNestedBodyElement() {
        return this.stackTop >= 1 && this.tagIDs[1] === T.BODY ? this.items[1] : null
    }
    contains(e) {
        return this._indexOf(e) > -1
    }
    getCommonAncestor(e) {
        const n = this._indexOf(e) - 1;
        return n >= 0 ? this.items[n] : null
    }
    isRootHtmlElementCurrent() {
        return this.stackTop === 0 && this.tagIDs[0] === T.HTML
    }
    hasInScope(e) {
        for (let n = this.stackTop; n >= 0; n--) {
            const r = this.tagIDs[n]
              , i = this.treeAdapter.getNamespaceURI(this.items[n]);
            if (r === e && i === fe.HTML)
                return !0;
            if (wd.get(r) === i)
                return !1
        }
        return !0
    }
    hasNumberedHeaderInScope() {
        for (let e = this.stackTop; e >= 0; e--) {
            const n = this.tagIDs[e]
              , r = this.treeAdapter.getNamespaceURI(this.items[e]);
            if (KP(n) && r === fe.HTML)
                return !0;
            if (wd.get(n) === r)
                return !1
        }
        return !0
    }
    hasInListItemScope(e) {
        for (let n = this.stackTop; n >= 0; n--) {
            const r = this.tagIDs[n]
              , i = this.treeAdapter.getNamespaceURI(this.items[n]);
            if (r === e && i === fe.HTML)
                return !0;
            if ((r === T.UL || r === T.OL) && i === fe.HTML || wd.get(r) === i)
                return !1
        }
        return !0
    }
    hasInButtonScope(e) {
        for (let n = this.stackTop; n >= 0; n--) {
            const r = this.tagIDs[n]
              , i = this.treeAdapter.getNamespaceURI(this.items[n]);
            if (r === e && i === fe.HTML)
                return !0;
            if (r === T.BUTTON && i === fe.HTML || wd.get(r) === i)
                return !1
        }
        return !0
    }
    hasInTableScope(e) {
        for (let n = this.stackTop; n >= 0; n--) {
            const r = this.tagIDs[n];
            if (this.treeAdapter.getNamespaceURI(this.items[n]) === fe.HTML) {
                if (r === e)
                    return !0;
                if (r === T.TABLE || r === T.TEMPLATE || r === T.HTML)
                    return !1
            }
        }
        return !0
    }
    hasTableBodyContextInTableScope() {
        for (let e = this.stackTop; e >= 0; e--) {
            const n = this.tagIDs[e];
            if (this.treeAdapter.getNamespaceURI(this.items[e]) === fe.HTML) {
                if (n === T.TBODY || n === T.THEAD || n === T.TFOOT)
                    return !0;
                if (n === T.TABLE || n === T.HTML)
                    return !1
            }
        }
        return !0
    }
    hasInSelectScope(e) {
        for (let n = this.stackTop; n >= 0; n--) {
            const r = this.tagIDs[n];
            if (this.treeAdapter.getNamespaceURI(this.items[n]) === fe.HTML) {
                if (r === e)
                    return !0;
                if (r !== T.OPTION && r !== T.OPTGROUP)
                    return !1
            }
        }
        return !0
    }
    generateImpliedEndTags() {
        for (; JP.has(this.currentTagId); )
            this.pop()
    }
    generateImpliedEndTagsThoroughly() {
        for (; Dw.has(this.currentTagId); )
            this.pop()
    }
    generateImpliedEndTagsWithExclusion(e) {
        for (; this.currentTagId !== e && Dw.has(this.currentTagId); )
            this.pop()
    }
}
const u0 = 3;
var zr;
(function(t) {
    t[t.Marker = 0] = "Marker",
    t[t.Element = 1] = "Element"
}
)(zr = zr || (zr = {}));
const Lw = {
    type: zr.Marker
};
class AQ {
    constructor(e) {
        this.treeAdapter = e,
        this.entries = [],
        this.bookmark = null
    }
    _getNoahArkConditionCandidates(e, n) {
        const r = []
          , i = n.length
          , s = this.treeAdapter.getTagName(e)
          , o = this.treeAdapter.getNamespaceURI(e);
        for (let a = 0; a < this.entries.length; a++) {
            const l = this.entries[a];
            if (l.type === zr.Marker)
                break;
            const {element: c} = l;
            if (this.treeAdapter.getTagName(c) === s && this.treeAdapter.getNamespaceURI(c) === o) {
                const u = this.treeAdapter.getAttrList(c);
                u.length === i && r.push({
                    idx: a,
                    attrs: u
                })
            }
        }
        return r
    }
    _ensureNoahArkCondition(e) {
        if (this.entries.length < u0)
            return;
        const n = this.treeAdapter.getAttrList(e)
          , r = this._getNoahArkConditionCandidates(e, n);
        if (r.length < u0)
            return;
        const i = new Map(n.map(o => [o.name, o.value]));
        let s = 0;
        for (let o = 0; o < r.length; o++) {
            const a = r[o];
            a.attrs.every(l => i.get(l.name) === l.value) && (s += 1,
            s >= u0 && this.entries.splice(a.idx, 1))
        }
    }
    insertMarker() {
        this.entries.unshift(Lw)
    }
    pushElement(e, n) {
        this._ensureNoahArkCondition(e),
        this.entries.unshift({
            type: zr.Element,
            element: e,
            token: n
        })
    }
    insertElementAfterBookmark(e, n) {
        const r = this.entries.indexOf(this.bookmark);
        this.entries.splice(r, 0, {
            type: zr.Element,
            element: e,
            token: n
        })
    }
    removeEntry(e) {
        const n = this.entries.indexOf(e);
        n >= 0 && this.entries.splice(n, 1)
    }
    clearToLastMarker() {
        const e = this.entries.indexOf(Lw);
        e >= 0 ? this.entries.splice(0, e + 1) : this.entries.length = 0
    }
    getElementEntryInScopeWithTagName(e) {
        const n = this.entries.find(r => r.type === zr.Marker || this.treeAdapter.getTagName(r.element) === e);
        return n && n.type === zr.Element ? n : null
    }
    getElementEntry(e) {
        return this.entries.find(n => n.type === zr.Element && n.element === e)
    }
}
function Ow(t) {
    return {
        nodeName: "#text",
        value: t,
        parentNode: null
    }
}
const Va = {
    createDocument() {
        return {
            nodeName: "#document",
            mode: ur.NO_QUIRKS,
            childNodes: []
        }
    },
    createDocumentFragment() {
        return {
            nodeName: "#document-fragment",
            childNodes: []
        }
    },
    createElement(t, e, n) {
        return {
            nodeName: t,
            tagName: t,
            attrs: n,
            namespaceURI: e,
            childNodes: [],
            parentNode: null
        }
    },
    createCommentNode(t) {
        return {
            nodeName: "#comment",
            data: t,
            parentNode: null
        }
    },
    appendChild(t, e) {
        t.childNodes.push(e),
        e.parentNode = t
    },
    insertBefore(t, e, n) {
        const r = t.childNodes.indexOf(n);
        t.childNodes.splice(r, 0, e),
        e.parentNode = t
    },
    setTemplateContent(t, e) {
        t.content = e
    },
    getTemplateContent(t) {
        return t.content
    },
    setDocumentType(t, e, n, r) {
        const i = t.childNodes.find(s => s.nodeName === "#documentType");
        if (i)
            i.name = e,
            i.publicId = n,
            i.systemId = r;
        else {
            const s = {
                nodeName: "#documentType",
                name: e,
                publicId: n,
                systemId: r,
                parentNode: null
            };
            Va.appendChild(t, s)
        }
    },
    setDocumentMode(t, e) {
        t.mode = e
    },
    getDocumentMode(t) {
        return t.mode
    },
    detachNode(t) {
        if (t.parentNode) {
            const e = t.parentNode.childNodes.indexOf(t);
            t.parentNode.childNodes.splice(e, 1),
            t.parentNode = null
        }
    },
    insertText(t, e) {
        if (t.childNodes.length > 0) {
            const n = t.childNodes[t.childNodes.length - 1];
            if (Va.isTextNode(n)) {
                n.value += e;
                return
            }
        }
        Va.appendChild(t, Ow(e))
    },
    insertTextBefore(t, e, n) {
        const r = t.childNodes[t.childNodes.indexOf(n) - 1];
        r && Va.isTextNode(r) ? r.value += e : Va.insertBefore(t, Ow(e), n)
    },
    adoptAttributes(t, e) {
        const n = new Set(t.attrs.map(r => r.name));
        for (let r = 0; r < e.length; r++)
            n.has(e[r].name) || t.attrs.push(e[r])
    },
    getFirstChild(t) {
        return t.childNodes[0]
    },
    getChildNodes(t) {
        return t.childNodes
    },
    getParentNode(t) {
        return t.parentNode
    },
    getAttrList(t) {
        return t.attrs
    },
    getTagName(t) {
        return t.tagName
    },
    getNamespaceURI(t) {
        return t.namespaceURI
    },
    getTextNodeContent(t) {
        return t.value
    },
    getCommentNodeContent(t) {
        return t.data
    },
    getDocumentTypeNodeName(t) {
        return t.name
    },
    getDocumentTypeNodePublicId(t) {
        return t.publicId
    },
    getDocumentTypeNodeSystemId(t) {
        return t.systemId
    },
    isTextNode(t) {
        return t.nodeName === "#text"
    },
    isCommentNode(t) {
        return t.nodeName === "#comment"
    },
    isDocumentTypeNode(t) {
        return t.nodeName === "#documentType"
    },
    isElementNode(t) {
        return Object.prototype.hasOwnProperty.call(t, "tagName")
    },
    setNodeSourceCodeLocation(t, e) {
        t.sourceCodeLocation = e
    },
    getNodeSourceCodeLocation(t) {
        return t.sourceCodeLocation
    },
    updateNodeSourceCodeLocation(t, e) {
        t.sourceCodeLocation = {
            ...t.sourceCodeLocation,
            ...e
        }
    }
}
  , ZP = "html"
  , kQ = "about:legacy-compat"
  , RQ = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"
  , eD = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"]
  , IQ = [...eD, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]
  , PQ = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"])
  , tD = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"]
  , DQ = [...tD, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"];
function Nw(t, e) {
    return e.some(n => t.startsWith(n))
}
function LQ(t) {
    return t.name === ZP && t.publicId === null && (t.systemId === null || t.systemId === kQ)
}
function OQ(t) {
    if (t.name !== ZP)
        return ur.QUIRKS;
    const {systemId: e} = t;
    if (e && e.toLowerCase() === RQ)
        return ur.QUIRKS;
    let {publicId: n} = t;
    if (n !== null) {
        if (n = n.toLowerCase(),
        PQ.has(n))
            return ur.QUIRKS;
        let r = e === null ? IQ : eD;
        if (Nw(n, r))
            return ur.QUIRKS;
        if (r = e === null ? tD : DQ,
        Nw(n, r))
            return ur.LIMITED_QUIRKS
    }
    return ur.NO_QUIRKS
}
const Mw = {
    TEXT_HTML: "text/html",
    APPLICATION_XML: "application/xhtml+xml"
}
  , NQ = "definitionurl"
  , MQ = "definitionURL"
  , BQ = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(t => [t.toLowerCase(), t]))
  , FQ = new Map([["xlink:actuate", {
    prefix: "xlink",
    name: "actuate",
    namespace: fe.XLINK
}], ["xlink:arcrole", {
    prefix: "xlink",
    name: "arcrole",
    namespace: fe.XLINK
}], ["xlink:href", {
    prefix: "xlink",
    name: "href",
    namespace: fe.XLINK
}], ["xlink:role", {
    prefix: "xlink",
    name: "role",
    namespace: fe.XLINK
}], ["xlink:show", {
    prefix: "xlink",
    name: "show",
    namespace: fe.XLINK
}], ["xlink:title", {
    prefix: "xlink",
    name: "title",
    namespace: fe.XLINK
}], ["xlink:type", {
    prefix: "xlink",
    name: "type",
    namespace: fe.XLINK
}], ["xml:base", {
    prefix: "xml",
    name: "base",
    namespace: fe.XML
}], ["xml:lang", {
    prefix: "xml",
    name: "lang",
    namespace: fe.XML
}], ["xml:space", {
    prefix: "xml",
    name: "space",
    namespace: fe.XML
}], ["xmlns", {
    prefix: "",
    name: "xmlns",
    namespace: fe.XMLNS
}], ["xmlns:xlink", {
    prefix: "xmlns",
    name: "xlink",
    namespace: fe.XMLNS
}]])
  , jQ = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(t => [t.toLowerCase(), t]))
  , HQ = new Set([T.B, T.BIG, T.BLOCKQUOTE, T.BODY, T.BR, T.CENTER, T.CODE, T.DD, T.DIV, T.DL, T.DT, T.EM, T.EMBED, T.H1, T.H2, T.H3, T.H4, T.H5, T.H6, T.HEAD, T.HR, T.I, T.IMG, T.LI, T.LISTING, T.MENU, T.META, T.NOBR, T.OL, T.P, T.PRE, T.RUBY, T.S, T.SMALL, T.SPAN, T.STRONG, T.STRIKE, T.SUB, T.SUP, T.TABLE, T.TT, T.U, T.UL, T.VAR]);
function UQ(t) {
    const e = t.tagID;
    return e === T.FONT && t.attrs.some( ({name: r}) => r === Ls.COLOR || r === Ls.SIZE || r === Ls.FACE) || HQ.has(e)
}
function nD(t) {
    for (let e = 0; e < t.attrs.length; e++)
        if (t.attrs[e].name === NQ) {
            t.attrs[e].name = MQ;
            break
        }
}
function rD(t) {
    for (let e = 0; e < t.attrs.length; e++) {
        const n = BQ.get(t.attrs[e].name);
        n != null && (t.attrs[e].name = n)
    }
}
function Jv(t) {
    for (let e = 0; e < t.attrs.length; e++) {
        const n = FQ.get(t.attrs[e].name);
        n && (t.attrs[e].prefix = n.prefix,
        t.attrs[e].name = n.name,
        t.attrs[e].namespace = n.namespace)
    }
}
function VQ(t) {
    const e = jQ.get(t.tagName);
    e != null && (t.tagName = e,
    t.tagID = Gl(t.tagName))
}
function $Q(t, e) {
    return e === fe.MATHML && (t === T.MI || t === T.MO || t === T.MN || t === T.MS || t === T.MTEXT)
}
function zQ(t, e, n) {
    if (e === fe.MATHML && t === T.ANNOTATION_XML) {
        for (let r = 0; r < n.length; r++)
            if (n[r].name === Ls.ENCODING) {
                const i = n[r].value.toLowerCase();
                return i === Mw.TEXT_HTML || i === Mw.APPLICATION_XML
            }
    }
    return e === fe.SVG && (t === T.FOREIGN_OBJECT || t === T.DESC || t === T.TITLE)
}
function WQ(t, e, n, r) {
    return (!r || r === fe.HTML) && zQ(t, e, n) || (!r || r === fe.MATHML) && $Q(t, e)
}
const GQ = "hidden"
  , qQ = 8
  , KQ = 3;
var X;
(function(t) {
    t[t.INITIAL = 0] = "INITIAL",
    t[t.BEFORE_HTML = 1] = "BEFORE_HTML",
    t[t.BEFORE_HEAD = 2] = "BEFORE_HEAD",
    t[t.IN_HEAD = 3] = "IN_HEAD",
    t[t.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT",
    t[t.AFTER_HEAD = 5] = "AFTER_HEAD",
    t[t.IN_BODY = 6] = "IN_BODY",
    t[t.TEXT = 7] = "TEXT",
    t[t.IN_TABLE = 8] = "IN_TABLE",
    t[t.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT",
    t[t.IN_CAPTION = 10] = "IN_CAPTION",
    t[t.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP",
    t[t.IN_TABLE_BODY = 12] = "IN_TABLE_BODY",
    t[t.IN_ROW = 13] = "IN_ROW",
    t[t.IN_CELL = 14] = "IN_CELL",
    t[t.IN_SELECT = 15] = "IN_SELECT",
    t[t.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE",
    t[t.IN_TEMPLATE = 17] = "IN_TEMPLATE",
    t[t.AFTER_BODY = 18] = "AFTER_BODY",
    t[t.IN_FRAMESET = 19] = "IN_FRAMESET",
    t[t.AFTER_FRAMESET = 20] = "AFTER_FRAMESET",
    t[t.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY",
    t[t.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET"
}
)(X || (X = {}));
const YQ = {
    startLine: -1,
    startCol: -1,
    startOffset: -1,
    endLine: -1,
    endCol: -1,
    endOffset: -1
}
  , iD = new Set([T.TABLE, T.TBODY, T.TFOOT, T.THEAD, T.TR])
  , Bw = {
    scriptingEnabled: !0,
    sourceCodeLocationInfo: !1,
    treeAdapter: Va,
    onParseError: null
};
let Fw = class {
    constructor(e, n, r=null, i=null) {
        this.fragmentContext = r,
        this.scriptHandler = i,
        this.currentToken = null,
        this.stopped = !1,
        this.insertionMode = X.INITIAL,
        this.originalInsertionMode = X.INITIAL,
        this.headElement = null,
        this.formElement = null,
        this.currentNotInHTML = !1,
        this.tmplInsertionModeStack = [],
        this.pendingCharacterTokens = [],
        this.hasNonWhitespacePendingCharacterToken = !1,
        this.framesetOk = !0,
        this.skipNextNewLine = !1,
        this.fosterParentingEnabled = !1,
        this.options = {
            ...Bw,
            ...e
        },
        this.treeAdapter = this.options.treeAdapter,
        this.onParseError = this.options.onParseError,
        this.onParseError && (this.options.sourceCodeLocationInfo = !0),
        this.document = n ?? this.treeAdapter.createDocument(),
        this.tokenizer = new vQ(this.options,this),
        this.activeFormattingElements = new AQ(this.treeAdapter),
        this.fragmentContextID = r ? Gl(this.treeAdapter.getTagName(r)) : T.UNKNOWN,
        this._setContextModes(r ?? this.document, this.fragmentContextID),
        this.openElements = new TQ(this.document,this.treeAdapter,this)
    }
    static parse(e, n) {
        const r = new this(n);
        return r.tokenizer.write(e, !0),
        r.document
    }
    static getFragmentParser(e, n) {
        const r = {
            ...Bw,
            ...n
        };
        e ?? (e = r.treeAdapter.createElement(ie.TEMPLATE, fe.HTML, []));
        const i = r.treeAdapter.createElement("documentmock", fe.HTML, [])
          , s = new this(r,i,e);
        return s.fragmentContextID === T.TEMPLATE && s.tmplInsertionModeStack.unshift(X.IN_TEMPLATE),
        s._initTokenizerForFragmentParsing(),
        s._insertFakeRootElement(),
        s._resetInsertionMode(),
        s._findFormInFragmentContext(),
        s
    }
    getFragment() {
        const e = this.treeAdapter.getFirstChild(this.document)
          , n = this.treeAdapter.createDocumentFragment();
        return this._adoptNodes(e, n),
        n
    }
    _err(e, n, r) {
        var i;
        if (!this.onParseError)
            return;
        const s = (i = e.location) !== null && i !== void 0 ? i : YQ
          , o = {
            code: n,
            startLine: s.startLine,
            startCol: s.startCol,
            startOffset: s.startOffset,
            endLine: r ? s.startLine : s.endLine,
            endCol: r ? s.startCol : s.endCol,
            endOffset: r ? s.startOffset : s.endOffset
        };
        this.onParseError(o)
    }
    onItemPush(e, n, r) {
        var i, s;
        (s = (i = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(i, e),
        r && this.openElements.stackTop > 0 && this._setContextModes(e, n)
    }
    onItemPop(e, n) {
        var r, i;
        if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken),
        (i = (r = this.treeAdapter).onItemPop) === null || i === void 0 || i.call(r, e, this.openElements.current),
        n) {
            let s, o;
            this.openElements.stackTop === 0 && this.fragmentContext ? (s = this.fragmentContext,
            o = this.fragmentContextID) : {current: s, currentTagId: o} = this.openElements,
            this._setContextModes(s, o)
        }
    }
    _setContextModes(e, n) {
        const r = e === this.document || this.treeAdapter.getNamespaceURI(e) === fe.HTML;
        this.currentNotInHTML = !r,
        this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, e)
    }
    _switchToTextParsing(e, n) {
        this._insertElement(e, fe.HTML),
        this.tokenizer.state = n,
        this.originalInsertionMode = this.insertionMode,
        this.insertionMode = X.TEXT
    }
    switchToPlaintextParsing() {
        this.insertionMode = X.TEXT,
        this.originalInsertionMode = X.IN_BODY,
        this.tokenizer.state = Vt.PLAINTEXT
    }
    _getAdjustedCurrentElement() {
        return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current
    }
    _findFormInFragmentContext() {
        let e = this.fragmentContext;
        for (; e; ) {
            if (this.treeAdapter.getTagName(e) === ie.FORM) {
                this.formElement = e;
                break
            }
            e = this.treeAdapter.getParentNode(e)
        }
    }
    _initTokenizerForFragmentParsing() {
        if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== fe.HTML))
            switch (this.fragmentContextID) {
            case T.TITLE:
            case T.TEXTAREA:
                {
                    this.tokenizer.state = Vt.RCDATA;
                    break
                }
            case T.STYLE:
            case T.XMP:
            case T.IFRAME:
            case T.NOEMBED:
            case T.NOFRAMES:
            case T.NOSCRIPT:
                {
                    this.tokenizer.state = Vt.RAWTEXT;
                    break
                }
            case T.SCRIPT:
                {
                    this.tokenizer.state = Vt.SCRIPT_DATA;
                    break
                }
            case T.PLAINTEXT:
                {
                    this.tokenizer.state = Vt.PLAINTEXT;
                    break
                }
            }
    }
    _setDocumentType(e) {
        const n = e.name || ""
          , r = e.publicId || ""
          , i = e.systemId || "";
        if (this.treeAdapter.setDocumentType(this.document, n, r, i),
        e.location) {
            const o = this.treeAdapter.getChildNodes(this.document).find(a => this.treeAdapter.isDocumentTypeNode(a));
            o && this.treeAdapter.setNodeSourceCodeLocation(o, e.location)
        }
    }
    _attachElementToTree(e, n) {
        if (this.options.sourceCodeLocationInfo) {
            const r = n && {
                ...n,
                startTag: n
            };
            this.treeAdapter.setNodeSourceCodeLocation(e, r)
        }
        if (this._shouldFosterParentOnInsertion())
            this._fosterParentElement(e);
        else {
            const r = this.openElements.currentTmplContentOrNode;
            this.treeAdapter.appendChild(r, e)
        }
    }
    _appendElement(e, n) {
        const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
        this._attachElementToTree(r, e.location)
    }
    _insertElement(e, n) {
        const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
        this._attachElementToTree(r, e.location),
        this.openElements.push(r, e.tagID)
    }
    _insertFakeElement(e, n) {
        const r = this.treeAdapter.createElement(e, fe.HTML, []);
        this._attachElementToTree(r, null),
        this.openElements.push(r, n)
    }
    _insertTemplate(e) {
        const n = this.treeAdapter.createElement(e.tagName, fe.HTML, e.attrs)
          , r = this.treeAdapter.createDocumentFragment();
        this.treeAdapter.setTemplateContent(n, r),
        this._attachElementToTree(n, e.location),
        this.openElements.push(n, e.tagID),
        this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null)
    }
    _insertFakeRootElement() {
        const e = this.treeAdapter.createElement(ie.HTML, fe.HTML, []);
        this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null),
        this.treeAdapter.appendChild(this.openElements.current, e),
        this.openElements.push(e, T.HTML)
    }
    _appendCommentNode(e, n) {
        const r = this.treeAdapter.createCommentNode(e.data);
        this.treeAdapter.appendChild(n, r),
        this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, e.location)
    }
    _insertCharacters(e) {
        let n, r;
        if (this._shouldFosterParentOnInsertion() ? ({parent: n, beforeElement: r} = this._findFosterParentingLocation(),
        r ? this.treeAdapter.insertTextBefore(n, e.chars, r) : this.treeAdapter.insertText(n, e.chars)) : (n = this.openElements.currentTmplContentOrNode,
        this.treeAdapter.insertText(n, e.chars)),
        !e.location)
            return;
        const i = this.treeAdapter.getChildNodes(n)
          , s = r ? i.lastIndexOf(r) : i.length
          , o = i[s - 1];
        if (this.treeAdapter.getNodeSourceCodeLocation(o)) {
            const {endLine: l, endCol: c, endOffset: u} = e.location;
            this.treeAdapter.updateNodeSourceCodeLocation(o, {
                endLine: l,
                endCol: c,
                endOffset: u
            })
        } else
            this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(o, e.location)
    }
    _adoptNodes(e, n) {
        for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
            this.treeAdapter.detachNode(r),
            this.treeAdapter.appendChild(n, r)
    }
    _setEndLocation(e, n) {
        if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
            const r = n.location
              , i = this.treeAdapter.getTagName(e)
              , s = n.type === tt.END_TAG && i === n.tagName ? {
                endTag: {
                    ...r
                },
                endLine: r.endLine,
                endCol: r.endCol,
                endOffset: r.endOffset
            } : {
                endLine: r.startLine,
                endCol: r.startCol,
                endOffset: r.startOffset
            };
            this.treeAdapter.updateNodeSourceCodeLocation(e, s)
        }
    }
    shouldProcessStartTagTokenInForeignContent(e) {
        if (!this.currentNotInHTML)
            return !1;
        let n, r;
        return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext,
        r = this.fragmentContextID) : {current: n, currentTagId: r} = this.openElements,
        e.tagID === T.SVG && this.treeAdapter.getTagName(n) === ie.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === fe.MATHML ? !1 : this.tokenizer.inForeignNode || (e.tagID === T.MGLYPH || e.tagID === T.MALIGNMARK) && !this._isIntegrationPoint(r, n, fe.HTML)
    }
    _processToken(e) {
        switch (e.type) {
        case tt.CHARACTER:
            {
                this.onCharacter(e);
                break
            }
        case tt.NULL_CHARACTER:
            {
                this.onNullCharacter(e);
                break
            }
        case tt.COMMENT:
            {
                this.onComment(e);
                break
            }
        case tt.DOCTYPE:
            {
                this.onDoctype(e);
                break
            }
        case tt.START_TAG:
            {
                this._processStartTag(e);
                break
            }
        case tt.END_TAG:
            {
                this.onEndTag(e);
                break
            }
        case tt.EOF:
            {
                this.onEof(e);
                break
            }
        case tt.WHITESPACE_CHARACTER:
            {
                this.onWhitespaceCharacter(e);
                break
            }
        }
    }
    _isIntegrationPoint(e, n, r) {
        const i = this.treeAdapter.getNamespaceURI(n)
          , s = this.treeAdapter.getAttrList(n);
        return WQ(e, i, s, r)
    }
    _reconstructActiveFormattingElements() {
        const e = this.activeFormattingElements.entries.length;
        if (e) {
            const n = this.activeFormattingElements.entries.findIndex(i => i.type === zr.Marker || this.openElements.contains(i.element))
              , r = n < 0 ? e - 1 : n - 1;
            for (let i = r; i >= 0; i--) {
                const s = this.activeFormattingElements.entries[i];
                this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)),
                s.element = this.openElements.current
            }
        }
    }
    _closeTableCell() {
        this.openElements.generateImpliedEndTags(),
        this.openElements.popUntilTableCellPopped(),
        this.activeFormattingElements.clearToLastMarker(),
        this.insertionMode = X.IN_ROW
    }
    _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion(T.P),
        this.openElements.popUntilTagNamePopped(T.P)
    }
    _resetInsertionMode() {
        for (let e = this.openElements.stackTop; e >= 0; e--)
            switch (e === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
            case T.TR:
                {
                    this.insertionMode = X.IN_ROW;
                    return
                }
            case T.TBODY:
            case T.THEAD:
            case T.TFOOT:
                {
                    this.insertionMode = X.IN_TABLE_BODY;
                    return
                }
            case T.CAPTION:
                {
                    this.insertionMode = X.IN_CAPTION;
                    return
                }
            case T.COLGROUP:
                {
                    this.insertionMode = X.IN_COLUMN_GROUP;
                    return
                }
            case T.TABLE:
                {
                    this.insertionMode = X.IN_TABLE;
                    return
                }
            case T.BODY:
                {
                    this.insertionMode = X.IN_BODY;
                    return
                }
            case T.FRAMESET:
                {
                    this.insertionMode = X.IN_FRAMESET;
                    return
                }
            case T.SELECT:
                {
                    this._resetInsertionModeForSelect(e);
                    return
                }
            case T.TEMPLATE:
                {
                    this.insertionMode = this.tmplInsertionModeStack[0];
                    return
                }
            case T.HTML:
                {
                    this.insertionMode = this.headElement ? X.AFTER_HEAD : X.BEFORE_HEAD;
                    return
                }
            case T.TD:
            case T.TH:
                {
                    if (e > 0) {
                        this.insertionMode = X.IN_CELL;
                        return
                    }
                    break
                }
            case T.HEAD:
                {
                    if (e > 0) {
                        this.insertionMode = X.IN_HEAD;
                        return
                    }
                    break
                }
            }
        this.insertionMode = X.IN_BODY
    }
    _resetInsertionModeForSelect(e) {
        if (e > 0)
            for (let n = e - 1; n > 0; n--) {
                const r = this.openElements.tagIDs[n];
                if (r === T.TEMPLATE)
                    break;
                if (r === T.TABLE) {
                    this.insertionMode = X.IN_SELECT_IN_TABLE;
                    return
                }
            }
        this.insertionMode = X.IN_SELECT
    }
    _isElementCausesFosterParenting(e) {
        return iD.has(e)
    }
    _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId)
    }
    _findFosterParentingLocation() {
        for (let e = this.openElements.stackTop; e >= 0; e--) {
            const n = this.openElements.items[e];
            switch (this.openElements.tagIDs[e]) {
            case T.TEMPLATE:
                {
                    if (this.treeAdapter.getNamespaceURI(n) === fe.HTML)
                        return {
                            parent: this.treeAdapter.getTemplateContent(n),
                            beforeElement: null
                        };
                    break
                }
            case T.TABLE:
                {
                    const r = this.treeAdapter.getParentNode(n);
                    return r ? {
                        parent: r,
                        beforeElement: n
                    } : {
                        parent: this.openElements.items[e - 1],
                        beforeElement: null
                    }
                }
            }
        }
        return {
            parent: this.openElements.items[0],
            beforeElement: null
        }
    }
    _fosterParentElement(e) {
        const n = this._findFosterParentingLocation();
        n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e)
    }
    _isSpecialElement(e, n) {
        const r = this.treeAdapter.getNamespaceURI(e);
        return mQ[r].has(n)
    }
    onCharacter(e) {
        if (this.skipNextNewLine = !1,
        this.tokenizer.inForeignNode) {
            CZ(this, e);
            return
        }
        switch (this.insertionMode) {
        case X.INITIAL:
            {
                oc(this, e);
                break
            }
        case X.BEFORE_HTML:
            {
                Gc(this, e);
                break
            }
        case X.BEFORE_HEAD:
            {
                qc(this, e);
                break
            }
        case X.IN_HEAD:
            {
                Kc(this, e);
                break
            }
        case X.IN_HEAD_NO_SCRIPT:
            {
                Yc(this, e);
                break
            }
        case X.AFTER_HEAD:
            {
                Xc(this, e);
                break
            }
        case X.IN_BODY:
        case X.IN_CAPTION:
        case X.IN_CELL:
        case X.IN_TEMPLATE:
            {
                oD(this, e);
                break
            }
        case X.TEXT:
        case X.IN_SELECT:
        case X.IN_SELECT_IN_TABLE:
            {
                this._insertCharacters(e);
                break
            }
        case X.IN_TABLE:
        case X.IN_TABLE_BODY:
        case X.IN_ROW:
            {
                h0(this, e);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                dD(this, e);
                break
            }
        case X.IN_COLUMN_GROUP:
            {
                _p(this, e);
                break
            }
        case X.AFTER_BODY:
            {
                bp(this, e);
                break
            }
        case X.AFTER_AFTER_BODY:
            {
                xf(this, e);
                break
            }
        }
    }
    onNullCharacter(e) {
        if (this.skipNextNewLine = !1,
        this.tokenizer.inForeignNode) {
            wZ(this, e);
            return
        }
        switch (this.insertionMode) {
        case X.INITIAL:
            {
                oc(this, e);
                break
            }
        case X.BEFORE_HTML:
            {
                Gc(this, e);
                break
            }
        case X.BEFORE_HEAD:
            {
                qc(this, e);
                break
            }
        case X.IN_HEAD:
            {
                Kc(this, e);
                break
            }
        case X.IN_HEAD_NO_SCRIPT:
            {
                Yc(this, e);
                break
            }
        case X.AFTER_HEAD:
            {
                Xc(this, e);
                break
            }
        case X.TEXT:
            {
                this._insertCharacters(e);
                break
            }
        case X.IN_TABLE:
        case X.IN_TABLE_BODY:
        case X.IN_ROW:
            {
                h0(this, e);
                break
            }
        case X.IN_COLUMN_GROUP:
            {
                _p(this, e);
                break
            }
        case X.AFTER_BODY:
            {
                bp(this, e);
                break
            }
        case X.AFTER_AFTER_BODY:
            {
                xf(this, e);
                break
            }
        }
    }
    onComment(e) {
        if (this.skipNextNewLine = !1,
        this.currentNotInHTML) {
            sb(this, e);
            return
        }
        switch (this.insertionMode) {
        case X.INITIAL:
        case X.BEFORE_HTML:
        case X.BEFORE_HEAD:
        case X.IN_HEAD:
        case X.IN_HEAD_NO_SCRIPT:
        case X.AFTER_HEAD:
        case X.IN_BODY:
        case X.IN_TABLE:
        case X.IN_CAPTION:
        case X.IN_COLUMN_GROUP:
        case X.IN_TABLE_BODY:
        case X.IN_ROW:
        case X.IN_CELL:
        case X.IN_SELECT:
        case X.IN_SELECT_IN_TABLE:
        case X.IN_TEMPLATE:
        case X.IN_FRAMESET:
        case X.AFTER_FRAMESET:
            {
                sb(this, e);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                ac(this, e);
                break
            }
        case X.AFTER_BODY:
            {
                nJ(this, e);
                break
            }
        case X.AFTER_AFTER_BODY:
        case X.AFTER_AFTER_FRAMESET:
            {
                rJ(this, e);
                break
            }
        }
    }
    onDoctype(e) {
        switch (this.skipNextNewLine = !1,
        this.insertionMode) {
        case X.INITIAL:
            {
                iJ(this, e);
                break
            }
        case X.BEFORE_HEAD:
        case X.IN_HEAD:
        case X.IN_HEAD_NO_SCRIPT:
        case X.AFTER_HEAD:
            {
                this._err(e, ue.misplacedDoctype);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                ac(this, e);
                break
            }
        }
    }
    onStartTag(e) {
        this.skipNextNewLine = !1,
        this.currentToken = e,
        this._processStartTag(e),
        e.selfClosing && !e.ackSelfClosing && this._err(e, ue.nonVoidHtmlElementStartTagWithTrailingSolidus)
    }
    _processStartTag(e) {
        this.shouldProcessStartTagTokenInForeignContent(e) ? TZ(this, e) : this._startTagOutsideForeignContent(e)
    }
    _startTagOutsideForeignContent(e) {
        switch (this.insertionMode) {
        case X.INITIAL:
            {
                oc(this, e);
                break
            }
        case X.BEFORE_HTML:
            {
                sJ(this, e);
                break
            }
        case X.BEFORE_HEAD:
            {
                aJ(this, e);
                break
            }
        case X.IN_HEAD:
            {
                ii(this, e);
                break
            }
        case X.IN_HEAD_NO_SCRIPT:
            {
                uJ(this, e);
                break
            }
        case X.AFTER_HEAD:
            {
                dJ(this, e);
                break
            }
        case X.IN_BODY:
            {
                Nn(this, e);
                break
            }
        case X.IN_TABLE:
            {
                Il(this, e);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                ac(this, e);
                break
            }
        case X.IN_CAPTION:
            {
                lZ(this, e);
                break
            }
        case X.IN_COLUMN_GROUP:
            {
                t1(this, e);
                break
            }
        case X.IN_TABLE_BODY:
            {
                Hm(this, e);
                break
            }
        case X.IN_ROW:
            {
                Um(this, e);
                break
            }
        case X.IN_CELL:
            {
                hZ(this, e);
                break
            }
        case X.IN_SELECT:
            {
                mD(this, e);
                break
            }
        case X.IN_SELECT_IN_TABLE:
            {
                fZ(this, e);
                break
            }
        case X.IN_TEMPLATE:
            {
                mZ(this, e);
                break
            }
        case X.AFTER_BODY:
            {
                _Z(this, e);
                break
            }
        case X.IN_FRAMESET:
            {
                bZ(this, e);
                break
            }
        case X.AFTER_FRAMESET:
            {
                vZ(this, e);
                break
            }
        case X.AFTER_AFTER_BODY:
            {
                EZ(this, e);
                break
            }
        case X.AFTER_AFTER_FRAMESET:
            {
                SZ(this, e);
                break
            }
        }
    }
    onEndTag(e) {
        this.skipNextNewLine = !1,
        this.currentToken = e,
        this.currentNotInHTML ? AZ(this, e) : this._endTagOutsideForeignContent(e)
    }
    _endTagOutsideForeignContent(e) {
        switch (this.insertionMode) {
        case X.INITIAL:
            {
                oc(this, e);
                break
            }
        case X.BEFORE_HTML:
            {
                oJ(this, e);
                break
            }
        case X.BEFORE_HEAD:
            {
                lJ(this, e);
                break
            }
        case X.IN_HEAD:
            {
                cJ(this, e);
                break
            }
        case X.IN_HEAD_NO_SCRIPT:
            {
                hJ(this, e);
                break
            }
        case X.AFTER_HEAD:
            {
                fJ(this, e);
                break
            }
        case X.IN_BODY:
            {
                jm(this, e);
                break
            }
        case X.TEXT:
            {
                JJ(this, e);
                break
            }
        case X.IN_TABLE:
            {
                Nu(this, e);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                ac(this, e);
                break
            }
        case X.IN_CAPTION:
            {
                cZ(this, e);
                break
            }
        case X.IN_COLUMN_GROUP:
            {
                uZ(this, e);
                break
            }
        case X.IN_TABLE_BODY:
            {
                ob(this, e);
                break
            }
        case X.IN_ROW:
            {
                pD(this, e);
                break
            }
        case X.IN_CELL:
            {
                dZ(this, e);
                break
            }
        case X.IN_SELECT:
            {
                gD(this, e);
                break
            }
        case X.IN_SELECT_IN_TABLE:
            {
                pZ(this, e);
                break
            }
        case X.IN_TEMPLATE:
            {
                gZ(this, e);
                break
            }
        case X.AFTER_BODY:
            {
                bD(this, e);
                break
            }
        case X.IN_FRAMESET:
            {
                yZ(this, e);
                break
            }
        case X.AFTER_FRAMESET:
            {
                xZ(this, e);
                break
            }
        case X.AFTER_AFTER_BODY:
            {
                xf(this, e);
                break
            }
        }
    }
    onEof(e) {
        switch (this.insertionMode) {
        case X.INITIAL:
            {
                oc(this, e);
                break
            }
        case X.BEFORE_HTML:
            {
                Gc(this, e);
                break
            }
        case X.BEFORE_HEAD:
            {
                qc(this, e);
                break
            }
        case X.IN_HEAD:
            {
                Kc(this, e);
                break
            }
        case X.IN_HEAD_NO_SCRIPT:
            {
                Yc(this, e);
                break
            }
        case X.AFTER_HEAD:
            {
                Xc(this, e);
                break
            }
        case X.IN_BODY:
        case X.IN_TABLE:
        case X.IN_CAPTION:
        case X.IN_COLUMN_GROUP:
        case X.IN_TABLE_BODY:
        case X.IN_ROW:
        case X.IN_CELL:
        case X.IN_SELECT:
        case X.IN_SELECT_IN_TABLE:
            {
                uD(this, e);
                break
            }
        case X.TEXT:
            {
                ZJ(this, e);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                ac(this, e);
                break
            }
        case X.IN_TEMPLATE:
            {
                _D(this, e);
                break
            }
        case X.AFTER_BODY:
        case X.IN_FRAMESET:
        case X.AFTER_FRAMESET:
        case X.AFTER_AFTER_BODY:
        case X.AFTER_AFTER_FRAMESET:
            {
                e1(this, e);
                break
            }
        }
    }
    onWhitespaceCharacter(e) {
        if (this.skipNextNewLine && (this.skipNextNewLine = !1,
        e.chars.charCodeAt(0) === U.LINE_FEED)) {
            if (e.chars.length === 1)
                return;
            e.chars = e.chars.substr(1)
        }
        if (this.tokenizer.inForeignNode) {
            this._insertCharacters(e);
            return
        }
        switch (this.insertionMode) {
        case X.IN_HEAD:
        case X.IN_HEAD_NO_SCRIPT:
        case X.AFTER_HEAD:
        case X.TEXT:
        case X.IN_COLUMN_GROUP:
        case X.IN_SELECT:
        case X.IN_SELECT_IN_TABLE:
        case X.IN_FRAMESET:
        case X.AFTER_FRAMESET:
            {
                this._insertCharacters(e);
                break
            }
        case X.IN_BODY:
        case X.IN_CAPTION:
        case X.IN_CELL:
        case X.IN_TEMPLATE:
        case X.AFTER_BODY:
        case X.AFTER_AFTER_BODY:
        case X.AFTER_AFTER_FRAMESET:
            {
                sD(this, e);
                break
            }
        case X.IN_TABLE:
        case X.IN_TABLE_BODY:
        case X.IN_ROW:
            {
                h0(this, e);
                break
            }
        case X.IN_TABLE_TEXT:
            {
                hD(this, e);
                break
            }
        }
    }
}
;
function XQ(t, e) {
    let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
    return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagID) || (n = null) : (t.activeFormattingElements.removeEntry(n),
    n = null) : cD(t, e),
    n
}
function QQ(t, e) {
    let n = null
      , r = t.openElements.stackTop;
    for (; r >= 0; r--) {
        const i = t.openElements.items[r];
        if (i === e.element)
            break;
        t._isSpecialElement(i, t.openElements.tagIDs[r]) && (n = i)
    }
    return n || (t.openElements.shortenToLength(r < 0 ? 0 : r),
    t.activeFormattingElements.removeEntry(e)),
    n
}
function JQ(t, e, n) {
    let r = e
      , i = t.openElements.getCommonAncestor(e);
    for (let s = 0, o = i; o !== n; s++,
    o = i) {
        i = t.openElements.getCommonAncestor(o);
        const a = t.activeFormattingElements.getElementEntry(o)
          , l = a && s >= KQ;
        !a || l ? (l && t.activeFormattingElements.removeEntry(a),
        t.openElements.remove(o)) : (o = ZQ(t, a),
        r === e && (t.activeFormattingElements.bookmark = a),
        t.treeAdapter.detachNode(r),
        t.treeAdapter.appendChild(o, r),
        r = o)
    }
    return r
}
function ZQ(t, e) {
    const n = t.treeAdapter.getNamespaceURI(e.element)
      , r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
    return t.openElements.replace(e.element, r),
    e.element = r,
    r
}
function eJ(t, e, n) {
    const r = t.treeAdapter.getTagName(e)
      , i = Gl(r);
    if (t._isElementCausesFosterParenting(i))
        t._fosterParentElement(n);
    else {
        const s = t.treeAdapter.getNamespaceURI(e);
        i === T.TEMPLATE && s === fe.HTML && (e = t.treeAdapter.getTemplateContent(e)),
        t.treeAdapter.appendChild(e, n)
    }
}
function tJ(t, e, n) {
    const r = t.treeAdapter.getNamespaceURI(n.element)
      , {token: i} = n
      , s = t.treeAdapter.createElement(i.tagName, r, i.attrs);
    t._adoptNodes(e, s),
    t.treeAdapter.appendChild(e, s),
    t.activeFormattingElements.insertElementAfterBookmark(s, i),
    t.activeFormattingElements.removeEntry(n),
    t.openElements.remove(n.element),
    t.openElements.insertAfter(e, s, i.tagID)
}
function Zv(t, e) {
    for (let n = 0; n < qQ; n++) {
        const r = XQ(t, e);
        if (!r)
            break;
        const i = QQ(t, r);
        if (!i)
            break;
        t.activeFormattingElements.bookmark = r;
        const s = JQ(t, i, r.element)
          , o = t.openElements.getCommonAncestor(r.element);
        t.treeAdapter.detachNode(s),
        o && eJ(t, o, s),
        tJ(t, i, r)
    }
}
function sb(t, e) {
    t._appendCommentNode(e, t.openElements.currentTmplContentOrNode)
}
function nJ(t, e) {
    t._appendCommentNode(e, t.openElements.items[0])
}
function rJ(t, e) {
    t._appendCommentNode(e, t.document)
}
function e1(t, e) {
    if (t.stopped = !0,
    e.location) {
        const n = t.fragmentContext ? 0 : 2;
        for (let r = t.openElements.stackTop; r >= n; r--)
            t._setEndLocation(t.openElements.items[r], e);
        if (!t.fragmentContext && t.openElements.stackTop >= 0) {
            const r = t.openElements.items[0]
              , i = t.treeAdapter.getNodeSourceCodeLocation(r);
            if (i && !i.endTag && (t._setEndLocation(r, e),
            t.openElements.stackTop >= 1)) {
                const s = t.openElements.items[1]
                  , o = t.treeAdapter.getNodeSourceCodeLocation(s);
                o && !o.endTag && t._setEndLocation(s, e)
            }
        }
    }
}
function iJ(t, e) {
    t._setDocumentType(e);
    const n = e.forceQuirks ? ur.QUIRKS : OQ(e);
    LQ(e) || t._err(e, ue.nonConformingDoctype),
    t.treeAdapter.setDocumentMode(t.document, n),
    t.insertionMode = X.BEFORE_HTML
}
function oc(t, e) {
    t._err(e, ue.missingDoctype, !0),
    t.treeAdapter.setDocumentMode(t.document, ur.QUIRKS),
    t.insertionMode = X.BEFORE_HTML,
    t._processToken(e)
}
function sJ(t, e) {
    e.tagID === T.HTML ? (t._insertElement(e, fe.HTML),
    t.insertionMode = X.BEFORE_HEAD) : Gc(t, e)
}
function oJ(t, e) {
    const n = e.tagID;
    (n === T.HTML || n === T.HEAD || n === T.BODY || n === T.BR) && Gc(t, e)
}
function Gc(t, e) {
    t._insertFakeRootElement(),
    t.insertionMode = X.BEFORE_HEAD,
    t._processToken(e)
}
function aJ(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.HEAD:
        {
            t._insertElement(e, fe.HTML),
            t.headElement = t.openElements.current,
            t.insertionMode = X.IN_HEAD;
            break
        }
    default:
        qc(t, e)
    }
}
function lJ(t, e) {
    const n = e.tagID;
    n === T.HEAD || n === T.BODY || n === T.HTML || n === T.BR ? qc(t, e) : t._err(e, ue.endTagWithoutMatchingOpenElement)
}
function qc(t, e) {
    t._insertFakeElement(ie.HEAD, T.HEAD),
    t.headElement = t.openElements.current,
    t.insertionMode = X.IN_HEAD,
    t._processToken(e)
}
function ii(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.BASE:
    case T.BASEFONT:
    case T.BGSOUND:
    case T.LINK:
    case T.META:
        {
            t._appendElement(e, fe.HTML),
            e.ackSelfClosing = !0;
            break
        }
    case T.TITLE:
        {
            t._switchToTextParsing(e, Vt.RCDATA);
            break
        }
    case T.NOSCRIPT:
        {
            t.options.scriptingEnabled ? t._switchToTextParsing(e, Vt.RAWTEXT) : (t._insertElement(e, fe.HTML),
            t.insertionMode = X.IN_HEAD_NO_SCRIPT);
            break
        }
    case T.NOFRAMES:
    case T.STYLE:
        {
            t._switchToTextParsing(e, Vt.RAWTEXT);
            break
        }
    case T.SCRIPT:
        {
            t._switchToTextParsing(e, Vt.SCRIPT_DATA);
            break
        }
    case T.TEMPLATE:
        {
            t._insertTemplate(e),
            t.activeFormattingElements.insertMarker(),
            t.framesetOk = !1,
            t.insertionMode = X.IN_TEMPLATE,
            t.tmplInsertionModeStack.unshift(X.IN_TEMPLATE);
            break
        }
    case T.HEAD:
        {
            t._err(e, ue.misplacedStartTagForHeadElement);
            break
        }
    default:
        Kc(t, e)
    }
}
function cJ(t, e) {
    switch (e.tagID) {
    case T.HEAD:
        {
            t.openElements.pop(),
            t.insertionMode = X.AFTER_HEAD;
            break
        }
    case T.BODY:
    case T.BR:
    case T.HTML:
        {
            Kc(t, e);
            break
        }
    case T.TEMPLATE:
        {
            Ea(t, e);
            break
        }
    default:
        t._err(e, ue.endTagWithoutMatchingOpenElement)
    }
}
function Ea(t, e) {
    t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(),
    t.openElements.currentTagId !== T.TEMPLATE && t._err(e, ue.closingOfElementWithOpenChildElements),
    t.openElements.popUntilTagNamePopped(T.TEMPLATE),
    t.activeFormattingElements.clearToLastMarker(),
    t.tmplInsertionModeStack.shift(),
    t._resetInsertionMode()) : t._err(e, ue.endTagWithoutMatchingOpenElement)
}
function Kc(t, e) {
    t.openElements.pop(),
    t.insertionMode = X.AFTER_HEAD,
    t._processToken(e)
}
function uJ(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.BASEFONT:
    case T.BGSOUND:
    case T.HEAD:
    case T.LINK:
    case T.META:
    case T.NOFRAMES:
    case T.STYLE:
        {
            ii(t, e);
            break
        }
    case T.NOSCRIPT:
        {
            t._err(e, ue.nestedNoscriptInHead);
            break
        }
    default:
        Yc(t, e)
    }
}
function hJ(t, e) {
    switch (e.tagID) {
    case T.NOSCRIPT:
        {
            t.openElements.pop(),
            t.insertionMode = X.IN_HEAD;
            break
        }
    case T.BR:
        {
            Yc(t, e);
            break
        }
    default:
        t._err(e, ue.endTagWithoutMatchingOpenElement)
    }
}
function Yc(t, e) {
    const n = e.type === tt.EOF ? ue.openElementsLeftAfterEof : ue.disallowedContentInNoscriptInHead;
    t._err(e, n),
    t.openElements.pop(),
    t.insertionMode = X.IN_HEAD,
    t._processToken(e)
}
function dJ(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.BODY:
        {
            t._insertElement(e, fe.HTML),
            t.framesetOk = !1,
            t.insertionMode = X.IN_BODY;
            break
        }
    case T.FRAMESET:
        {
            t._insertElement(e, fe.HTML),
            t.insertionMode = X.IN_FRAMESET;
            break
        }
    case T.BASE:
    case T.BASEFONT:
    case T.BGSOUND:
    case T.LINK:
    case T.META:
    case T.NOFRAMES:
    case T.SCRIPT:
    case T.STYLE:
    case T.TEMPLATE:
    case T.TITLE:
        {
            t._err(e, ue.abandonedHeadElementChild),
            t.openElements.push(t.headElement, T.HEAD),
            ii(t, e),
            t.openElements.remove(t.headElement);
            break
        }
    case T.HEAD:
        {
            t._err(e, ue.misplacedStartTagForHeadElement);
            break
        }
    default:
        Xc(t, e)
    }
}
function fJ(t, e) {
    switch (e.tagID) {
    case T.BODY:
    case T.HTML:
    case T.BR:
        {
            Xc(t, e);
            break
        }
    case T.TEMPLATE:
        {
            Ea(t, e);
            break
        }
    default:
        t._err(e, ue.endTagWithoutMatchingOpenElement)
    }
}
function Xc(t, e) {
    t._insertFakeElement(ie.BODY, T.BODY),
    t.insertionMode = X.IN_BODY,
    Fm(t, e)
}
function Fm(t, e) {
    switch (e.type) {
    case tt.CHARACTER:
        {
            oD(t, e);
            break
        }
    case tt.WHITESPACE_CHARACTER:
        {
            sD(t, e);
            break
        }
    case tt.COMMENT:
        {
            sb(t, e);
            break
        }
    case tt.START_TAG:
        {
            Nn(t, e);
            break
        }
    case tt.END_TAG:
        {
            jm(t, e);
            break
        }
    case tt.EOF:
        {
            uD(t, e);
            break
        }
    }
}
function sD(t, e) {
    t._reconstructActiveFormattingElements(),
    t._insertCharacters(e)
}
function oD(t, e) {
    t._reconstructActiveFormattingElements(),
    t._insertCharacters(e),
    t.framesetOk = !1
}
function pJ(t, e) {
    t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs)
}
function mJ(t, e) {
    const n = t.openElements.tryPeekProperlyNestedBodyElement();
    n && t.openElements.tmplCount === 0 && (t.framesetOk = !1,
    t.treeAdapter.adoptAttributes(n, e.attrs))
}
function gJ(t, e) {
    const n = t.openElements.tryPeekProperlyNestedBodyElement();
    t.framesetOk && n && (t.treeAdapter.detachNode(n),
    t.openElements.popAllUpToHtmlElement(),
    t._insertElement(e, fe.HTML),
    t.insertionMode = X.IN_FRAMESET)
}
function _J(t, e) {
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._insertElement(e, fe.HTML)
}
function bJ(t, e) {
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    KP(t.openElements.currentTagId) && t.openElements.pop(),
    t._insertElement(e, fe.HTML)
}
function yJ(t, e) {
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._insertElement(e, fe.HTML),
    t.skipNextNewLine = !0,
    t.framesetOk = !1
}
function vJ(t, e) {
    const n = t.openElements.tmplCount > 0;
    (!t.formElement || n) && (t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._insertElement(e, fe.HTML),
    n || (t.formElement = t.openElements.current))
}
function xJ(t, e) {
    t.framesetOk = !1;
    const n = e.tagID;
    for (let r = t.openElements.stackTop; r >= 0; r--) {
        const i = t.openElements.tagIDs[r];
        if (n === T.LI && i === T.LI || (n === T.DD || n === T.DT) && (i === T.DD || i === T.DT)) {
            t.openElements.generateImpliedEndTagsWithExclusion(i),
            t.openElements.popUntilTagNamePopped(i);
            break
        }
        if (i !== T.ADDRESS && i !== T.DIV && i !== T.P && t._isSpecialElement(t.openElements.items[r], i))
            break
    }
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._insertElement(e, fe.HTML)
}
function EJ(t, e) {
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._insertElement(e, fe.HTML),
    t.tokenizer.state = Vt.PLAINTEXT
}
function SJ(t, e) {
    t.openElements.hasInScope(T.BUTTON) && (t.openElements.generateImpliedEndTags(),
    t.openElements.popUntilTagNamePopped(T.BUTTON)),
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML),
    t.framesetOk = !1
}
function wJ(t, e) {
    const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(ie.A);
    n && (Zv(t, e),
    t.openElements.remove(n.element),
    t.activeFormattingElements.removeEntry(n)),
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML),
    t.activeFormattingElements.pushElement(t.openElements.current, e)
}
function CJ(t, e) {
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML),
    t.activeFormattingElements.pushElement(t.openElements.current, e)
}
function TJ(t, e) {
    t._reconstructActiveFormattingElements(),
    t.openElements.hasInScope(T.NOBR) && (Zv(t, e),
    t._reconstructActiveFormattingElements()),
    t._insertElement(e, fe.HTML),
    t.activeFormattingElements.pushElement(t.openElements.current, e)
}
function AJ(t, e) {
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML),
    t.activeFormattingElements.insertMarker(),
    t.framesetOk = !1
}
function kJ(t, e) {
    t.treeAdapter.getDocumentMode(t.document) !== ur.QUIRKS && t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._insertElement(e, fe.HTML),
    t.framesetOk = !1,
    t.insertionMode = X.IN_TABLE
}
function aD(t, e) {
    t._reconstructActiveFormattingElements(),
    t._appendElement(e, fe.HTML),
    t.framesetOk = !1,
    e.ackSelfClosing = !0
}
function lD(t) {
    const e = WP(t, Ls.TYPE);
    return e != null && e.toLowerCase() === GQ
}
function RJ(t, e) {
    t._reconstructActiveFormattingElements(),
    t._appendElement(e, fe.HTML),
    lD(e) || (t.framesetOk = !1),
    e.ackSelfClosing = !0
}
function IJ(t, e) {
    t._appendElement(e, fe.HTML),
    e.ackSelfClosing = !0
}
function PJ(t, e) {
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._appendElement(e, fe.HTML),
    t.framesetOk = !1,
    e.ackSelfClosing = !0
}
function DJ(t, e) {
    e.tagName = ie.IMG,
    e.tagID = T.IMG,
    aD(t, e)
}
function LJ(t, e) {
    t._insertElement(e, fe.HTML),
    t.skipNextNewLine = !0,
    t.tokenizer.state = Vt.RCDATA,
    t.originalInsertionMode = t.insertionMode,
    t.framesetOk = !1,
    t.insertionMode = X.TEXT
}
function OJ(t, e) {
    t.openElements.hasInButtonScope(T.P) && t._closePElement(),
    t._reconstructActiveFormattingElements(),
    t.framesetOk = !1,
    t._switchToTextParsing(e, Vt.RAWTEXT)
}
function NJ(t, e) {
    t.framesetOk = !1,
    t._switchToTextParsing(e, Vt.RAWTEXT)
}
function jw(t, e) {
    t._switchToTextParsing(e, Vt.RAWTEXT)
}
function MJ(t, e) {
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML),
    t.framesetOk = !1,
    t.insertionMode = t.insertionMode === X.IN_TABLE || t.insertionMode === X.IN_CAPTION || t.insertionMode === X.IN_TABLE_BODY || t.insertionMode === X.IN_ROW || t.insertionMode === X.IN_CELL ? X.IN_SELECT_IN_TABLE : X.IN_SELECT
}
function BJ(t, e) {
    t.openElements.currentTagId === T.OPTION && t.openElements.pop(),
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML)
}
function FJ(t, e) {
    t.openElements.hasInScope(T.RUBY) && t.openElements.generateImpliedEndTags(),
    t._insertElement(e, fe.HTML)
}
function jJ(t, e) {
    t.openElements.hasInScope(T.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(T.RTC),
    t._insertElement(e, fe.HTML)
}
function HJ(t, e) {
    t._reconstructActiveFormattingElements(),
    nD(e),
    Jv(e),
    e.selfClosing ? t._appendElement(e, fe.MATHML) : t._insertElement(e, fe.MATHML),
    e.ackSelfClosing = !0
}
function UJ(t, e) {
    t._reconstructActiveFormattingElements(),
    rD(e),
    Jv(e),
    e.selfClosing ? t._appendElement(e, fe.SVG) : t._insertElement(e, fe.SVG),
    e.ackSelfClosing = !0
}
function Hw(t, e) {
    t._reconstructActiveFormattingElements(),
    t._insertElement(e, fe.HTML)
}
function Nn(t, e) {
    switch (e.tagID) {
    case T.I:
    case T.S:
    case T.B:
    case T.U:
    case T.EM:
    case T.TT:
    case T.BIG:
    case T.CODE:
    case T.FONT:
    case T.SMALL:
    case T.STRIKE:
    case T.STRONG:
        {
            CJ(t, e);
            break
        }
    case T.A:
        {
            wJ(t, e);
            break
        }
    case T.H1:
    case T.H2:
    case T.H3:
    case T.H4:
    case T.H5:
    case T.H6:
        {
            bJ(t, e);
            break
        }
    case T.P:
    case T.DL:
    case T.OL:
    case T.UL:
    case T.DIV:
    case T.DIR:
    case T.NAV:
    case T.MAIN:
    case T.MENU:
    case T.ASIDE:
    case T.CENTER:
    case T.FIGURE:
    case T.FOOTER:
    case T.HEADER:
    case T.HGROUP:
    case T.DIALOG:
    case T.DETAILS:
    case T.ADDRESS:
    case T.ARTICLE:
    case T.SECTION:
    case T.SUMMARY:
    case T.FIELDSET:
    case T.BLOCKQUOTE:
    case T.FIGCAPTION:
        {
            _J(t, e);
            break
        }
    case T.LI:
    case T.DD:
    case T.DT:
        {
            xJ(t, e);
            break
        }
    case T.BR:
    case T.IMG:
    case T.WBR:
    case T.AREA:
    case T.EMBED:
    case T.KEYGEN:
        {
            aD(t, e);
            break
        }
    case T.HR:
        {
            PJ(t, e);
            break
        }
    case T.RB:
    case T.RTC:
        {
            FJ(t, e);
            break
        }
    case T.RT:
    case T.RP:
        {
            jJ(t, e);
            break
        }
    case T.PRE:
    case T.LISTING:
        {
            yJ(t, e);
            break
        }
    case T.XMP:
        {
            OJ(t, e);
            break
        }
    case T.SVG:
        {
            UJ(t, e);
            break
        }
    case T.HTML:
        {
            pJ(t, e);
            break
        }
    case T.BASE:
    case T.LINK:
    case T.META:
    case T.STYLE:
    case T.TITLE:
    case T.SCRIPT:
    case T.BGSOUND:
    case T.BASEFONT:
    case T.TEMPLATE:
        {
            ii(t, e);
            break
        }
    case T.BODY:
        {
            mJ(t, e);
            break
        }
    case T.FORM:
        {
            vJ(t, e);
            break
        }
    case T.NOBR:
        {
            TJ(t, e);
            break
        }
    case T.MATH:
        {
            HJ(t, e);
            break
        }
    case T.TABLE:
        {
            kJ(t, e);
            break
        }
    case T.INPUT:
        {
            RJ(t, e);
            break
        }
    case T.PARAM:
    case T.TRACK:
    case T.SOURCE:
        {
            IJ(t, e);
            break
        }
    case T.IMAGE:
        {
            DJ(t, e);
            break
        }
    case T.BUTTON:
        {
            SJ(t, e);
            break
        }
    case T.APPLET:
    case T.OBJECT:
    case T.MARQUEE:
        {
            AJ(t, e);
            break
        }
    case T.IFRAME:
        {
            NJ(t, e);
            break
        }
    case T.SELECT:
        {
            MJ(t, e);
            break
        }
    case T.OPTION:
    case T.OPTGROUP:
        {
            BJ(t, e);
            break
        }
    case T.NOEMBED:
        {
            jw(t, e);
            break
        }
    case T.FRAMESET:
        {
            gJ(t, e);
            break
        }
    case T.TEXTAREA:
        {
            LJ(t, e);
            break
        }
    case T.NOSCRIPT:
        {
            t.options.scriptingEnabled ? jw(t, e) : Hw(t, e);
            break
        }
    case T.PLAINTEXT:
        {
            EJ(t, e);
            break
        }
    case T.COL:
    case T.TH:
    case T.TD:
    case T.TR:
    case T.HEAD:
    case T.FRAME:
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
    case T.CAPTION:
    case T.COLGROUP:
        break;
    default:
        Hw(t, e)
    }
}
function VJ(t, e) {
    if (t.openElements.hasInScope(T.BODY) && (t.insertionMode = X.AFTER_BODY,
    t.options.sourceCodeLocationInfo)) {
        const n = t.openElements.tryPeekProperlyNestedBodyElement();
        n && t._setEndLocation(n, e)
    }
}
function $J(t, e) {
    t.openElements.hasInScope(T.BODY) && (t.insertionMode = X.AFTER_BODY,
    bD(t, e))
}
function zJ(t, e) {
    const n = e.tagID;
    t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(),
    t.openElements.popUntilTagNamePopped(n))
}
function WJ(t) {
    const e = t.openElements.tmplCount > 0
      , {formElement: n} = t;
    e || (t.formElement = null),
    (n || e) && t.openElements.hasInScope(T.FORM) && (t.openElements.generateImpliedEndTags(),
    e ? t.openElements.popUntilTagNamePopped(T.FORM) : n && t.openElements.remove(n))
}
function GJ(t) {
    t.openElements.hasInButtonScope(T.P) || t._insertFakeElement(ie.P, T.P),
    t._closePElement()
}
function qJ(t) {
    t.openElements.hasInListItemScope(T.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(T.LI),
    t.openElements.popUntilTagNamePopped(T.LI))
}
function KJ(t, e) {
    const n = e.tagID;
    t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n),
    t.openElements.popUntilTagNamePopped(n))
}
function YJ(t) {
    t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(),
    t.openElements.popUntilNumberedHeaderPopped())
}
function XJ(t, e) {
    const n = e.tagID;
    t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(),
    t.openElements.popUntilTagNamePopped(n),
    t.activeFormattingElements.clearToLastMarker())
}
function QJ(t) {
    t._reconstructActiveFormattingElements(),
    t._insertFakeElement(ie.BR, T.BR),
    t.openElements.pop(),
    t.framesetOk = !1
}
function cD(t, e) {
    const n = e.tagName
      , r = e.tagID;
    for (let i = t.openElements.stackTop; i > 0; i--) {
        const s = t.openElements.items[i]
          , o = t.openElements.tagIDs[i];
        if (r === o && (r !== T.UNKNOWN || t.treeAdapter.getTagName(s) === n)) {
            t.openElements.generateImpliedEndTagsWithExclusion(r),
            t.openElements.stackTop >= i && t.openElements.shortenToLength(i);
            break
        }
        if (t._isSpecialElement(s, o))
            break
    }
}
function jm(t, e) {
    switch (e.tagID) {
    case T.A:
    case T.B:
    case T.I:
    case T.S:
    case T.U:
    case T.EM:
    case T.TT:
    case T.BIG:
    case T.CODE:
    case T.FONT:
    case T.NOBR:
    case T.SMALL:
    case T.STRIKE:
    case T.STRONG:
        {
            Zv(t, e);
            break
        }
    case T.P:
        {
            GJ(t);
            break
        }
    case T.DL:
    case T.UL:
    case T.OL:
    case T.DIR:
    case T.DIV:
    case T.NAV:
    case T.PRE:
    case T.MAIN:
    case T.MENU:
    case T.ASIDE:
    case T.BUTTON:
    case T.CENTER:
    case T.FIGURE:
    case T.FOOTER:
    case T.HEADER:
    case T.HGROUP:
    case T.DIALOG:
    case T.ADDRESS:
    case T.ARTICLE:
    case T.DETAILS:
    case T.SECTION:
    case T.SUMMARY:
    case T.LISTING:
    case T.FIELDSET:
    case T.BLOCKQUOTE:
    case T.FIGCAPTION:
        {
            zJ(t, e);
            break
        }
    case T.LI:
        {
            qJ(t);
            break
        }
    case T.DD:
    case T.DT:
        {
            KJ(t, e);
            break
        }
    case T.H1:
    case T.H2:
    case T.H3:
    case T.H4:
    case T.H5:
    case T.H6:
        {
            YJ(t);
            break
        }
    case T.BR:
        {
            QJ(t);
            break
        }
    case T.BODY:
        {
            VJ(t, e);
            break
        }
    case T.HTML:
        {
            $J(t, e);
            break
        }
    case T.FORM:
        {
            WJ(t);
            break
        }
    case T.APPLET:
    case T.OBJECT:
    case T.MARQUEE:
        {
            XJ(t, e);
            break
        }
    case T.TEMPLATE:
        {
            Ea(t, e);
            break
        }
    default:
        cD(t, e)
    }
}
function uD(t, e) {
    t.tmplInsertionModeStack.length > 0 ? _D(t, e) : e1(t, e)
}
function JJ(t, e) {
    var n;
    e.tagID === T.SCRIPT && ((n = t.scriptHandler) === null || n === void 0 || n.call(t, t.openElements.current)),
    t.openElements.pop(),
    t.insertionMode = t.originalInsertionMode
}
function ZJ(t, e) {
    t._err(e, ue.eofInElementThatCanContainOnlyText),
    t.openElements.pop(),
    t.insertionMode = t.originalInsertionMode,
    t.onEof(e)
}
function h0(t, e) {
    if (iD.has(t.openElements.currentTagId))
        switch (t.pendingCharacterTokens.length = 0,
        t.hasNonWhitespacePendingCharacterToken = !1,
        t.originalInsertionMode = t.insertionMode,
        t.insertionMode = X.IN_TABLE_TEXT,
        e.type) {
        case tt.CHARACTER:
            {
                dD(t, e);
                break
            }
        case tt.WHITESPACE_CHARACTER:
            {
                hD(t, e);
                break
            }
        }
    else
        Vh(t, e)
}
function eZ(t, e) {
    t.openElements.clearBackToTableContext(),
    t.activeFormattingElements.insertMarker(),
    t._insertElement(e, fe.HTML),
    t.insertionMode = X.IN_CAPTION
}
function tZ(t, e) {
    t.openElements.clearBackToTableContext(),
    t._insertElement(e, fe.HTML),
    t.insertionMode = X.IN_COLUMN_GROUP
}
function nZ(t, e) {
    t.openElements.clearBackToTableContext(),
    t._insertFakeElement(ie.COLGROUP, T.COLGROUP),
    t.insertionMode = X.IN_COLUMN_GROUP,
    t1(t, e)
}
function rZ(t, e) {
    t.openElements.clearBackToTableContext(),
    t._insertElement(e, fe.HTML),
    t.insertionMode = X.IN_TABLE_BODY
}
function iZ(t, e) {
    t.openElements.clearBackToTableContext(),
    t._insertFakeElement(ie.TBODY, T.TBODY),
    t.insertionMode = X.IN_TABLE_BODY,
    Hm(t, e)
}
function sZ(t, e) {
    t.openElements.hasInTableScope(T.TABLE) && (t.openElements.popUntilTagNamePopped(T.TABLE),
    t._resetInsertionMode(),
    t._processStartTag(e))
}
function oZ(t, e) {
    lD(e) ? t._appendElement(e, fe.HTML) : Vh(t, e),
    e.ackSelfClosing = !0
}
function aZ(t, e) {
    !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, fe.HTML),
    t.formElement = t.openElements.current,
    t.openElements.pop())
}
function Il(t, e) {
    switch (e.tagID) {
    case T.TD:
    case T.TH:
    case T.TR:
        {
            iZ(t, e);
            break
        }
    case T.STYLE:
    case T.SCRIPT:
    case T.TEMPLATE:
        {
            ii(t, e);
            break
        }
    case T.COL:
        {
            nZ(t, e);
            break
        }
    case T.FORM:
        {
            aZ(t, e);
            break
        }
    case T.TABLE:
        {
            sZ(t, e);
            break
        }
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
        {
            rZ(t, e);
            break
        }
    case T.INPUT:
        {
            oZ(t, e);
            break
        }
    case T.CAPTION:
        {
            eZ(t, e);
            break
        }
    case T.COLGROUP:
        {
            tZ(t, e);
            break
        }
    default:
        Vh(t, e)
    }
}
function Nu(t, e) {
    switch (e.tagID) {
    case T.TABLE:
        {
            t.openElements.hasInTableScope(T.TABLE) && (t.openElements.popUntilTagNamePopped(T.TABLE),
            t._resetInsertionMode());
            break
        }
    case T.TEMPLATE:
        {
            Ea(t, e);
            break
        }
    case T.BODY:
    case T.CAPTION:
    case T.COL:
    case T.COLGROUP:
    case T.HTML:
    case T.TBODY:
    case T.TD:
    case T.TFOOT:
    case T.TH:
    case T.THEAD:
    case T.TR:
        break;
    default:
        Vh(t, e)
    }
}
function Vh(t, e) {
    const n = t.fosterParentingEnabled;
    t.fosterParentingEnabled = !0,
    Fm(t, e),
    t.fosterParentingEnabled = n
}
function hD(t, e) {
    t.pendingCharacterTokens.push(e)
}
function dD(t, e) {
    t.pendingCharacterTokens.push(e),
    t.hasNonWhitespacePendingCharacterToken = !0
}
function ac(t, e) {
    let n = 0;
    if (t.hasNonWhitespacePendingCharacterToken)
        for (; n < t.pendingCharacterTokens.length; n++)
            Vh(t, t.pendingCharacterTokens[n]);
    else
        for (; n < t.pendingCharacterTokens.length; n++)
            t._insertCharacters(t.pendingCharacterTokens[n]);
    t.insertionMode = t.originalInsertionMode,
    t._processToken(e)
}
const fD = new Set([T.CAPTION, T.COL, T.COLGROUP, T.TBODY, T.TD, T.TFOOT, T.TH, T.THEAD, T.TR]);
function lZ(t, e) {
    const n = e.tagID;
    fD.has(n) ? t.openElements.hasInTableScope(T.CAPTION) && (t.openElements.generateImpliedEndTags(),
    t.openElements.popUntilTagNamePopped(T.CAPTION),
    t.activeFormattingElements.clearToLastMarker(),
    t.insertionMode = X.IN_TABLE,
    Il(t, e)) : Nn(t, e)
}
function cZ(t, e) {
    const n = e.tagID;
    switch (n) {
    case T.CAPTION:
    case T.TABLE:
        {
            t.openElements.hasInTableScope(T.CAPTION) && (t.openElements.generateImpliedEndTags(),
            t.openElements.popUntilTagNamePopped(T.CAPTION),
            t.activeFormattingElements.clearToLastMarker(),
            t.insertionMode = X.IN_TABLE,
            n === T.TABLE && Nu(t, e));
            break
        }
    case T.BODY:
    case T.COL:
    case T.COLGROUP:
    case T.HTML:
    case T.TBODY:
    case T.TD:
    case T.TFOOT:
    case T.TH:
    case T.THEAD:
    case T.TR:
        break;
    default:
        jm(t, e)
    }
}
function t1(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.COL:
        {
            t._appendElement(e, fe.HTML),
            e.ackSelfClosing = !0;
            break
        }
    case T.TEMPLATE:
        {
            ii(t, e);
            break
        }
    default:
        _p(t, e)
    }
}
function uZ(t, e) {
    switch (e.tagID) {
    case T.COLGROUP:
        {
            t.openElements.currentTagId === T.COLGROUP && (t.openElements.pop(),
            t.insertionMode = X.IN_TABLE);
            break
        }
    case T.TEMPLATE:
        {
            Ea(t, e);
            break
        }
    case T.COL:
        break;
    default:
        _p(t, e)
    }
}
function _p(t, e) {
    t.openElements.currentTagId === T.COLGROUP && (t.openElements.pop(),
    t.insertionMode = X.IN_TABLE,
    t._processToken(e))
}
function Hm(t, e) {
    switch (e.tagID) {
    case T.TR:
        {
            t.openElements.clearBackToTableBodyContext(),
            t._insertElement(e, fe.HTML),
            t.insertionMode = X.IN_ROW;
            break
        }
    case T.TH:
    case T.TD:
        {
            t.openElements.clearBackToTableBodyContext(),
            t._insertFakeElement(ie.TR, T.TR),
            t.insertionMode = X.IN_ROW,
            Um(t, e);
            break
        }
    case T.CAPTION:
    case T.COL:
    case T.COLGROUP:
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
        {
            t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE,
            Il(t, e));
            break
        }
    default:
        Il(t, e)
    }
}
function ob(t, e) {
    const n = e.tagID;
    switch (e.tagID) {
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
        {
            t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE);
            break
        }
    case T.TABLE:
        {
            t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE,
            Nu(t, e));
            break
        }
    case T.BODY:
    case T.CAPTION:
    case T.COL:
    case T.COLGROUP:
    case T.HTML:
    case T.TD:
    case T.TH:
    case T.TR:
        break;
    default:
        Nu(t, e)
    }
}
function Um(t, e) {
    switch (e.tagID) {
    case T.TH:
    case T.TD:
        {
            t.openElements.clearBackToTableRowContext(),
            t._insertElement(e, fe.HTML),
            t.insertionMode = X.IN_CELL,
            t.activeFormattingElements.insertMarker();
            break
        }
    case T.CAPTION:
    case T.COL:
    case T.COLGROUP:
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
    case T.TR:
        {
            t.openElements.hasInTableScope(T.TR) && (t.openElements.clearBackToTableRowContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE_BODY,
            Hm(t, e));
            break
        }
    default:
        Il(t, e)
    }
}
function pD(t, e) {
    switch (e.tagID) {
    case T.TR:
        {
            t.openElements.hasInTableScope(T.TR) && (t.openElements.clearBackToTableRowContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE_BODY);
            break
        }
    case T.TABLE:
        {
            t.openElements.hasInTableScope(T.TR) && (t.openElements.clearBackToTableRowContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE_BODY,
            ob(t, e));
            break
        }
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
        {
            (t.openElements.hasInTableScope(e.tagID) || t.openElements.hasInTableScope(T.TR)) && (t.openElements.clearBackToTableRowContext(),
            t.openElements.pop(),
            t.insertionMode = X.IN_TABLE_BODY,
            ob(t, e));
            break
        }
    case T.BODY:
    case T.CAPTION:
    case T.COL:
    case T.COLGROUP:
    case T.HTML:
    case T.TD:
    case T.TH:
        break;
    default:
        Nu(t, e)
    }
}
function hZ(t, e) {
    const n = e.tagID;
    fD.has(n) ? (t.openElements.hasInTableScope(T.TD) || t.openElements.hasInTableScope(T.TH)) && (t._closeTableCell(),
    Um(t, e)) : Nn(t, e)
}
function dZ(t, e) {
    const n = e.tagID;
    switch (n) {
    case T.TD:
    case T.TH:
        {
            t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(),
            t.openElements.popUntilTagNamePopped(n),
            t.activeFormattingElements.clearToLastMarker(),
            t.insertionMode = X.IN_ROW);
            break
        }
    case T.TABLE:
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
    case T.TR:
        {
            t.openElements.hasInTableScope(n) && (t._closeTableCell(),
            pD(t, e));
            break
        }
    case T.BODY:
    case T.CAPTION:
    case T.COL:
    case T.COLGROUP:
    case T.HTML:
        break;
    default:
        jm(t, e)
    }
}
function mD(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.OPTION:
        {
            t.openElements.currentTagId === T.OPTION && t.openElements.pop(),
            t._insertElement(e, fe.HTML);
            break
        }
    case T.OPTGROUP:
        {
            t.openElements.currentTagId === T.OPTION && t.openElements.pop(),
            t.openElements.currentTagId === T.OPTGROUP && t.openElements.pop(),
            t._insertElement(e, fe.HTML);
            break
        }
    case T.INPUT:
    case T.KEYGEN:
    case T.TEXTAREA:
    case T.SELECT:
        {
            t.openElements.hasInSelectScope(T.SELECT) && (t.openElements.popUntilTagNamePopped(T.SELECT),
            t._resetInsertionMode(),
            e.tagID !== T.SELECT && t._processStartTag(e));
            break
        }
    case T.SCRIPT:
    case T.TEMPLATE:
        {
            ii(t, e);
            break
        }
    }
}
function gD(t, e) {
    switch (e.tagID) {
    case T.OPTGROUP:
        {
            t.openElements.stackTop > 0 && t.openElements.currentTagId === T.OPTION && t.openElements.tagIDs[t.openElements.stackTop - 1] === T.OPTGROUP && t.openElements.pop(),
            t.openElements.currentTagId === T.OPTGROUP && t.openElements.pop();
            break
        }
    case T.OPTION:
        {
            t.openElements.currentTagId === T.OPTION && t.openElements.pop();
            break
        }
    case T.SELECT:
        {
            t.openElements.hasInSelectScope(T.SELECT) && (t.openElements.popUntilTagNamePopped(T.SELECT),
            t._resetInsertionMode());
            break
        }
    case T.TEMPLATE:
        {
            Ea(t, e);
            break
        }
    }
}
function fZ(t, e) {
    const n = e.tagID;
    n === T.CAPTION || n === T.TABLE || n === T.TBODY || n === T.TFOOT || n === T.THEAD || n === T.TR || n === T.TD || n === T.TH ? (t.openElements.popUntilTagNamePopped(T.SELECT),
    t._resetInsertionMode(),
    t._processStartTag(e)) : mD(t, e)
}
function pZ(t, e) {
    const n = e.tagID;
    n === T.CAPTION || n === T.TABLE || n === T.TBODY || n === T.TFOOT || n === T.THEAD || n === T.TR || n === T.TD || n === T.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(T.SELECT),
    t._resetInsertionMode(),
    t.onEndTag(e)) : gD(t, e)
}
function mZ(t, e) {
    switch (e.tagID) {
    case T.BASE:
    case T.BASEFONT:
    case T.BGSOUND:
    case T.LINK:
    case T.META:
    case T.NOFRAMES:
    case T.SCRIPT:
    case T.STYLE:
    case T.TEMPLATE:
    case T.TITLE:
        {
            ii(t, e);
            break
        }
    case T.CAPTION:
    case T.COLGROUP:
    case T.TBODY:
    case T.TFOOT:
    case T.THEAD:
        {
            t.tmplInsertionModeStack[0] = X.IN_TABLE,
            t.insertionMode = X.IN_TABLE,
            Il(t, e);
            break
        }
    case T.COL:
        {
            t.tmplInsertionModeStack[0] = X.IN_COLUMN_GROUP,
            t.insertionMode = X.IN_COLUMN_GROUP,
            t1(t, e);
            break
        }
    case T.TR:
        {
            t.tmplInsertionModeStack[0] = X.IN_TABLE_BODY,
            t.insertionMode = X.IN_TABLE_BODY,
            Hm(t, e);
            break
        }
    case T.TD:
    case T.TH:
        {
            t.tmplInsertionModeStack[0] = X.IN_ROW,
            t.insertionMode = X.IN_ROW,
            Um(t, e);
            break
        }
    default:
        t.tmplInsertionModeStack[0] = X.IN_BODY,
        t.insertionMode = X.IN_BODY,
        Nn(t, e)
    }
}
function gZ(t, e) {
    e.tagID === T.TEMPLATE && Ea(t, e)
}
function _D(t, e) {
    t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(T.TEMPLATE),
    t.activeFormattingElements.clearToLastMarker(),
    t.tmplInsertionModeStack.shift(),
    t._resetInsertionMode(),
    t.onEof(e)) : e1(t, e)
}
function _Z(t, e) {
    e.tagID === T.HTML ? Nn(t, e) : bp(t, e)
}
function bD(t, e) {
    var n;
    if (e.tagID === T.HTML) {
        if (t.fragmentContext || (t.insertionMode = X.AFTER_AFTER_BODY),
        t.options.sourceCodeLocationInfo && t.openElements.tagIDs[0] === T.HTML) {
            t._setEndLocation(t.openElements.items[0], e);
            const r = t.openElements.items[1];
            r && !(!((n = t.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && t._setEndLocation(r, e)
        }
    } else
        bp(t, e)
}
function bp(t, e) {
    t.insertionMode = X.IN_BODY,
    Fm(t, e)
}
function bZ(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.FRAMESET:
        {
            t._insertElement(e, fe.HTML);
            break
        }
    case T.FRAME:
        {
            t._appendElement(e, fe.HTML),
            e.ackSelfClosing = !0;
            break
        }
    case T.NOFRAMES:
        {
            ii(t, e);
            break
        }
    }
}
function yZ(t, e) {
    e.tagID === T.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(),
    !t.fragmentContext && t.openElements.currentTagId !== T.FRAMESET && (t.insertionMode = X.AFTER_FRAMESET))
}
function vZ(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.NOFRAMES:
        {
            ii(t, e);
            break
        }
    }
}
function xZ(t, e) {
    e.tagID === T.HTML && (t.insertionMode = X.AFTER_AFTER_FRAMESET)
}
function EZ(t, e) {
    e.tagID === T.HTML ? Nn(t, e) : xf(t, e)
}
function xf(t, e) {
    t.insertionMode = X.IN_BODY,
    Fm(t, e)
}
function SZ(t, e) {
    switch (e.tagID) {
    case T.HTML:
        {
            Nn(t, e);
            break
        }
    case T.NOFRAMES:
        {
            ii(t, e);
            break
        }
    }
}
function wZ(t, e) {
    e.chars = Lt,
    t._insertCharacters(e)
}
function CZ(t, e) {
    t._insertCharacters(e),
    t.framesetOk = !1
}
function yD(t) {
    for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== fe.HTML && !t._isIntegrationPoint(t.openElements.currentTagId, t.openElements.current); )
        t.openElements.pop()
}
function TZ(t, e) {
    if (UQ(e))
        yD(t),
        t._startTagOutsideForeignContent(e);
    else {
        const n = t._getAdjustedCurrentElement()
          , r = t.treeAdapter.getNamespaceURI(n);
        r === fe.MATHML ? nD(e) : r === fe.SVG && (VQ(e),
        rD(e)),
        Jv(e),
        e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r),
        e.ackSelfClosing = !0
    }
}
function AZ(t, e) {
    if (e.tagID === T.P || e.tagID === T.BR) {
        yD(t),
        t._endTagOutsideForeignContent(e);
        return
    }
    for (let n = t.openElements.stackTop; n > 0; n--) {
        const r = t.openElements.items[n];
        if (t.treeAdapter.getNamespaceURI(r) === fe.HTML) {
            t._endTagOutsideForeignContent(e);
            break
        }
        const i = t.treeAdapter.getTagName(r);
        if (i.toLowerCase() === e.tagName) {
            e.tagName = i,
            t.openElements.shortenToLength(n);
            break
        }
    }
}
ie.AREA,
ie.BASE,
ie.BASEFONT,
ie.BGSOUND,
ie.BR,
ie.COL,
ie.EMBED,
ie.FRAME,
ie.HR,
ie.IMG,
ie.INPUT,
ie.KEYGEN,
ie.LINK,
ie.META,
ie.PARAM,
ie.SOURCE,
ie.TRACK,
ie.WBR;
const kZ = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"])
  , Uw = {
    sourceCodeLocationInfo: !0,
    scriptingEnabled: !1
};
function vD(t, e) {
    const n = FZ(t)
      , r = HP("type", {
        handlers: {
            root: RZ,
            element: IZ,
            text: PZ,
            comment: ED,
            doctype: DZ,
            raw: OZ
        },
        unknown: NZ
    })
      , i = {
        parser: n ? new Fw(Uw) : Fw.getFragmentParser(void 0, Uw),
        handle(a) {
            r(a, i)
        },
        stitches: !1,
        options: e || {}
    };
    r(t, i),
    ql(i, Oi());
    const s = n ? i.parser.document : i.parser.getFragment()
      , o = HX(s, {
        file: i.options.file
    });
    return i.stitches && Mh(o, "comment", function(a, l, c) {
        const u = a;
        if (u.value.stitch && c && l !== void 0) {
            const h = c.children;
            return h[l] = u.value.stitch,
            l
        }
    }),
    o.type === "root" && o.children.length === 1 && o.children[0].type === t.type ? o.children[0] : o
}
function xD(t, e) {
    let n = -1;
    if (t)
        for (; ++n < t.length; )
            e.handle(t[n])
}
function RZ(t, e) {
    xD(t.children, e)
}
function IZ(t, e) {
    MZ(t, e),
    xD(t.children, e),
    BZ(t, e)
}
function PZ(t, e) {
    e.parser.tokenizer.state > 4 && (e.parser.tokenizer.state = 0);
    const n = {
        type: tt.CHARACTER,
        chars: t.value,
        location: $h(t)
    };
    ql(e, Oi(t)),
    e.parser.currentToken = n,
    e.parser._processToken(e.parser.currentToken)
}
function DZ(t, e) {
    const n = {
        type: tt.DOCTYPE,
        name: "html",
        forceQuirks: !1,
        publicId: "",
        systemId: "",
        location: $h(t)
    };
    ql(e, Oi(t)),
    e.parser.currentToken = n,
    e.parser._processToken(e.parser.currentToken)
}
function LZ(t, e) {
    e.stitches = !0;
    const n = jZ(t);
    if ("children"in t && "children"in n) {
        const r = vD({
            type: "root",
            children: t.children
        }, e.options);
        n.children = r.children
    }
    ED({
        type: "comment",
        value: {
            stitch: n
        }
    }, e)
}
function ED(t, e) {
    const n = t.value
      , r = {
        type: tt.COMMENT,
        data: n,
        location: $h(t)
    };
    ql(e, Oi(t)),
    e.parser.currentToken = r,
    e.parser._processToken(e.parser.currentToken)
}
function OZ(t, e) {
    if (e.parser.tokenizer.preprocessor.html = "",
    e.parser.tokenizer.preprocessor.pos = -1,
    e.parser.tokenizer.preprocessor.lastGapPos = -2,
    e.parser.tokenizer.preprocessor.gapStack = [],
    e.parser.tokenizer.preprocessor.skipNextNewLine = !1,
    e.parser.tokenizer.preprocessor.lastChunkWritten = !1,
    e.parser.tokenizer.preprocessor.endOfChunkHit = !1,
    e.parser.tokenizer.preprocessor.isEol = !1,
    SD(e, Oi(t)),
    e.parser.tokenizer.write(t.value, !1),
    e.parser.tokenizer._runParsingLoop(),
    e.parser.tokenizer.state === 72 || e.parser.tokenizer.state === 78) {
        e.parser.tokenizer.preprocessor.lastChunkWritten = !0;
        const n = e.parser.tokenizer._consume();
        e.parser.tokenizer._callState(n)
    }
}
function NZ(t, e) {
    const n = t;
    if (e.options.passThrough && e.options.passThrough.includes(n.type))
        LZ(n, e);
    else {
        let r = "";
        throw kZ.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"),
        new Error("Cannot compile `" + n.type + "` node" + r)
    }
}
function ql(t, e) {
    SD(t, e);
    const n = t.parser.tokenizer.currentCharacterToken;
    n && n.location && (n.location.endLine = t.parser.tokenizer.preprocessor.line,
    n.location.endCol = t.parser.tokenizer.preprocessor.col + 1,
    n.location.endOffset = t.parser.tokenizer.preprocessor.offset + 1,
    t.parser.currentToken = n,
    t.parser._processToken(t.parser.currentToken)),
    t.parser.tokenizer.paused = !1,
    t.parser.tokenizer.inLoop = !1,
    t.parser.tokenizer.active = !1,
    t.parser.tokenizer.returnState = Vt.DATA,
    t.parser.tokenizer.charRefCode = -1,
    t.parser.tokenizer.consumedAfterSnapshot = -1,
    t.parser.tokenizer.currentLocation = null,
    t.parser.tokenizer.currentCharacterToken = null,
    t.parser.tokenizer.currentToken = null,
    t.parser.tokenizer.currentAttr = {
        name: "",
        value: ""
    }
}
function SD(t, e) {
    if (e && e.offset !== void 0) {
        const n = {
            startLine: e.line,
            startCol: e.column,
            startOffset: e.offset,
            endLine: -1,
            endCol: -1,
            endOffset: -1
        };
        t.parser.tokenizer.preprocessor.lineStartPos = -e.column + 1,
        t.parser.tokenizer.preprocessor.droppedBufferSize = e.offset,
        t.parser.tokenizer.preprocessor.line = e.line,
        t.parser.tokenizer.currentLocation = n
    }
}
function MZ(t, e) {
    const n = t.tagName.toLowerCase();
    if (e.parser.tokenizer.state === Vt.PLAINTEXT)
        return;
    ql(e, Oi(t));
    const r = e.parser.openElements.current;
    let i = "namespaceURI"in r ? r.namespaceURI : Ro.html;
    i === Ro.html && n === "svg" && (i = Ro.svg);
    const s = WX({
        ...t,
        children: []
    }, {
        space: i === Ro.svg ? "svg" : "html"
    })
      , o = {
        type: tt.START_TAG,
        tagName: n,
        tagID: Gl(n),
        selfClosing: !1,
        ackSelfClosing: !1,
        attrs: "attrs"in s ? s.attrs : [],
        location: $h(t)
    };
    e.parser.currentToken = o,
    e.parser._processToken(e.parser.currentToken),
    e.parser.tokenizer.lastStartTagName = n
}
function BZ(t, e) {
    const n = t.tagName.toLowerCase();
    if (!e.parser.tokenizer.inForeignNode && ZX.includes(n) || e.parser.tokenizer.state === Vt.PLAINTEXT)
        return;
    ql(e, Tm(t));
    const r = {
        type: tt.END_TAG,
        tagName: n,
        tagID: Gl(n),
        selfClosing: !1,
        ackSelfClosing: !1,
        attrs: [],
        location: $h(t)
    };
    e.parser.currentToken = r,
    e.parser._processToken(e.parser.currentToken),
    n === e.parser.tokenizer.lastStartTagName && (e.parser.tokenizer.state === Vt.RCDATA || e.parser.tokenizer.state === Vt.RAWTEXT || e.parser.tokenizer.state === Vt.SCRIPT_DATA) && (e.parser.tokenizer.state = Vt.DATA)
}
function FZ(t) {
    const e = t.type === "root" ? t.children[0] : t;
    return !!(e && (e.type === "doctype" || e.type === "element" && e.tagName.toLowerCase() === "html"))
}
function $h(t) {
    const e = Oi(t) || {
        line: void 0,
        column: void 0,
        offset: void 0
    }
      , n = Tm(t) || {
        line: void 0,
        column: void 0,
        offset: void 0
    };
    return {
        startLine: e.line,
        startCol: e.column,
        startOffset: e.offset,
        endLine: n.line,
        endCol: n.column,
        endOffset: n.offset
    }
}
function jZ(t) {
    return "children"in t ? Xo({
        ...t,
        children: []
    }) : Xo(t)
}
function HZ(t) {
    return function(e, n) {
        return vD(e, {
            ...t,
            file: n
        })
    }
}
const mo = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"]
  , Za = {
    ancestors: {
        tbody: ["table"],
        td: ["table"],
        th: ["table"],
        thead: ["table"],
        tfoot: ["table"],
        tr: ["table"]
    },
    attributes: {
        a: [...mo, "dataFootnoteBackref", "dataFootnoteRef", ["className", "data-footnote-backref"], "href"],
        blockquote: ["cite"],
        code: [["className", /^language-./]],
        del: ["cite"],
        div: ["itemScope", "itemType"],
        dl: [...mo],
        h2: [["className", "sr-only"]],
        img: [...mo, "longDesc", "src"],
        input: [["disabled", !0], ["type", "checkbox"]],
        ins: ["cite"],
        li: [["className", "task-list-item"]],
        ol: [...mo, ["className", "contains-task-list"]],
        q: ["cite"],
        section: ["dataFootnotes", ["className", "footnotes"]],
        source: ["srcSet"],
        summary: [...mo],
        table: [...mo],
        ul: [...mo, ["className", "contains-task-list"]],
        "*": ["abbr", "accept", "acceptCharset", "accessKey", "action", "align", "alt", "axis", "border", "cellPadding", "cellSpacing", "char", "charOff", "charSet", "checked", "clear", "colSpan", "color", "cols", "compact", "coords", "dateTime", "dir", "encType", "frame", "hSpace", "headers", "height", "hrefLang", "htmlFor", "id", "isMap", "itemProp", "label", "lang", "maxLength", "media", "method", "multiple", "name", "noHref", "noShade", "noWrap", "open", "prompt", "readOnly", "rev", "rowSpan", "rows", "rules", "scope", "selected", "shape", "size", "span", "start", "summary", "tabIndex", "title", "useMap", "vAlign", "value", "width"]
    },
    clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
    clobberPrefix: "user-content-",
    protocols: {
        cite: ["http", "https"],
        href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
        longDesc: ["http", "https"],
        src: ["http", "https"]
    },
    required: {
        input: {
            disabled: !0,
            type: "checkbox"
        }
    },
    strip: ["script"],
    tagNames: ["a", "b", "blockquote", "br", "code", "dd", "del", "details", "div", "dl", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "input", "ins", "kbd", "li", "ol", "p", "picture", "pre", "q", "rp", "rt", "ruby", "s", "samp", "section", "source", "span", "strike", "strong", "sub", "summary", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "tt", "ul", "var"]
}
  , Es = {}.hasOwnProperty;
function UZ(t, e) {
    let n = {
        type: "root",
        children: []
    };
    const r = {
        schema: e ? {
            ...Za,
            ...e
        } : Za,
        stack: []
    }
      , i = wD(r, t);
    return i && (Array.isArray(i) ? i.length === 1 ? n = i[0] : n.children = i : n = i),
    n
}
function wD(t, e) {
    if (e && typeof e == "object") {
        const n = e;
        switch (typeof n.type == "string" ? n.type : "") {
        case "comment":
            return VZ(t, n);
        case "doctype":
            return $Z(t, n);
        case "element":
            return zZ(t, n);
        case "root":
            return WZ(t, n);
        case "text":
            return GZ(t, n)
        }
    }
}
function VZ(t, e) {
    if (t.schema.allowComments) {
        const n = typeof e.value == "string" ? e.value : ""
          , r = n.indexOf("-->")
          , s = {
            type: "comment",
            value: r < 0 ? n : n.slice(0, r)
        };
        return zh(s, e),
        s
    }
}
function $Z(t, e) {
    if (t.schema.allowDoctypes) {
        const n = {
            type: "doctype"
        };
        return zh(n, e),
        n
    }
}
function zZ(t, e) {
    const n = typeof e.tagName == "string" ? e.tagName : "";
    t.stack.push(n);
    const r = CD(t, e.children)
      , i = qZ(t, e.properties);
    t.stack.pop();
    let s = !1;
    if (n && n !== "*" && (!t.schema.tagNames || t.schema.tagNames.includes(n)) && (s = !0,
    t.schema.ancestors && Es.call(t.schema.ancestors, n))) {
        const a = t.schema.ancestors[n];
        let l = -1;
        for (s = !1; ++l < a.length; )
            t.stack.includes(a[l]) && (s = !0)
    }
    if (!s)
        return t.schema.strip && !t.schema.strip.includes(n) ? r : void 0;
    const o = {
        type: "element",
        tagName: n,
        properties: i,
        children: r
    };
    return zh(o, e),
    o
}
function WZ(t, e) {
    const r = {
        type: "root",
        children: CD(t, e.children)
    };
    return zh(r, e),
    r
}
function GZ(t, e) {
    const r = {
        type: "text",
        value: typeof e.value == "string" ? e.value : ""
    };
    return zh(r, e),
    r
}
function CD(t, e) {
    const n = [];
    if (Array.isArray(e)) {
        const r = e;
        let i = -1;
        for (; ++i < r.length; ) {
            const s = wD(t, r[i]);
            s && (Array.isArray(s) ? n.push(...s) : n.push(s))
        }
    }
    return n
}
function qZ(t, e) {
    const n = t.stack[t.stack.length - 1]
      , r = t.schema.attributes
      , i = t.schema.required
      , s = r && Es.call(r, n) ? r[n] : void 0
      , o = r && Es.call(r, "*") ? r["*"] : void 0
      , a = e && typeof e == "object" ? e : {}
      , l = {};
    let c;
    for (c in a)
        if (Es.call(a, c)) {
            const u = a[c];
            let h = Vw(t, $w(s, c), c, u);
            h == null && (h = Vw(t, $w(o, c), c, u)),
            h != null && (l[c] = h)
        }
    if (i && Es.call(i, n)) {
        const u = i[n];
        for (c in u)
            Es.call(u, c) && !Es.call(l, c) && (l[c] = u[c])
    }
    return l
}
function Vw(t, e, n, r) {
    return e ? Array.isArray(r) ? KZ(t, e, n, r) : TD(t, e, n, r) : void 0
}
function KZ(t, e, n, r) {
    let i = -1;
    const s = [];
    for (; ++i < r.length; ) {
        const o = TD(t, e, n, r[i]);
        (typeof o == "number" || typeof o == "string") && s.push(o)
    }
    return s
}
function TD(t, e, n, r) {
    if (!(typeof r != "boolean" && typeof r != "number" && typeof r != "string") && YZ(t, n, r)) {
        if (typeof e == "object" && e.length > 1) {
            let i = !1
              , s = 0;
            for (; ++s < e.length; ) {
                const o = e[s];
                if (o && typeof o == "object" && "flags"in o) {
                    if (o.test(String(r))) {
                        i = !0;
                        break
                    }
                } else if (o === r) {
                    i = !0;
                    break
                }
            }
            if (!i)
                return
        }
        return t.schema.clobber && t.schema.clobberPrefix && t.schema.clobber.includes(n) ? t.schema.clobberPrefix + r : r
    }
}
function YZ(t, e, n) {
    const r = t.schema.protocols && Es.call(t.schema.protocols, e) ? t.schema.protocols[e] : void 0;
    if (!r || r.length === 0)
        return !0;
    const i = String(n)
      , s = i.indexOf(":")
      , o = i.indexOf("?")
      , a = i.indexOf("#")
      , l = i.indexOf("/");
    if (s < 0 || l > -1 && s > l || o > -1 && s > o || a > -1 && s > a)
        return !0;
    let c = -1;
    for (; ++c < r.length; ) {
        const u = r[c];
        if (s === u.length && i.slice(0, u.length) === u)
            return !0
    }
    return !1
}
function zh(t, e) {
    const n = U2(e);
    e.data && (t.data = Xo(e.data)),
    n && (t.position = n)
}
function $w(t, e) {
    let n, r = -1;
    if (t)
        for (; ++r < t.length; ) {
            const i = t[r]
              , s = typeof i == "string" ? i : i[0];
            if (s === e)
                return i;
            s === "data*" && (n = i)
        }
    if (e.length > 4 && e.slice(0, 4).toLowerCase() === "data")
        return n
}
function XZ(t) {
    return function(e) {
        return UZ(e, t)
    }
}
function zw(t, e) {
    const n = String(t);
    if (typeof e != "string")
        throw new TypeError("Expected character");
    let r = 0
      , i = n.indexOf(e);
    for (; i !== -1; )
        r++,
        i = n.indexOf(e, i + e.length);
    return r
}
function QZ(t) {
    if (typeof t != "string")
        throw new TypeError("Expected a string");
    return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
}
function JZ(t, e, n) {
    const i = Im((n || {}).ignore || [])
      , s = ZZ(e);
    let o = -1;
    for (; ++o < s.length; )
        fI(t, "text", a);
    function a(c, u) {
        let h = -1, d;
        for (; ++h < u.length; ) {
            const f = u[h]
              , g = d ? d.children : void 0;
            if (i(f, g ? g.indexOf(f) : void 0, d))
                return;
            d = f
        }
        if (d)
            return l(c, u)
    }
    function l(c, u) {
        const h = u[u.length - 1]
          , d = s[o][0]
          , f = s[o][1];
        let g = 0;
        const m = h.children.indexOf(c);
        let p = !1
          , b = [];
        d.lastIndex = 0;
        let y = d.exec(c.value);
        for (; y; ) {
            const x = y.index
              , E = {
                index: y.index,
                input: y.input,
                stack: [...u, c]
            };
            let w = f(...y, E);
            if (typeof w == "string" && (w = w.length > 0 ? {
                type: "text",
                value: w
            } : void 0),
            w === !1 ? d.lastIndex = x + 1 : (g !== x && b.push({
                type: "text",
                value: c.value.slice(g, x)
            }),
            Array.isArray(w) ? b.push(...w) : w && b.push(w),
            g = x + y[0].length,
            p = !0),
            !d.global)
                break;
            y = d.exec(c.value)
        }
        return p ? (g < c.value.length && b.push({
            type: "text",
            value: c.value.slice(g)
        }),
        h.children.splice(m, 1, ...b)) : b = [c],
        m + b.length
    }
}
function ZZ(t) {
    const e = [];
    if (!Array.isArray(t))
        throw new TypeError("Expected find and replace tuple or list of tuples");
    const n = !t[0] || Array.isArray(t[0]) ? t : [t];
    let r = -1;
    for (; ++r < n.length; ) {
        const i = n[r];
        e.push([eee(i[0]), tee(i[1])])
    }
    return e
}
function eee(t) {
    return typeof t == "string" ? new RegExp(QZ(t),"g") : t
}
function tee(t) {
    return typeof t == "function" ? t : function() {
        return t
    }
}
const d0 = "phrasing"
  , f0 = ["autolink", "link", "image", "label"];
function nee() {
    return {
        transforms: [cee],
        enter: {
            literalAutolink: iee,
            literalAutolinkEmail: p0,
            literalAutolinkHttp: p0,
            literalAutolinkWww: p0
        },
        exit: {
            literalAutolink: lee,
            literalAutolinkEmail: aee,
            literalAutolinkHttp: see,
            literalAutolinkWww: oee
        }
    }
}
function ree() {
    return {
        unsafe: [{
            character: "@",
            before: "[+\\-.\\w]",
            after: "[\\-.\\w]",
            inConstruct: d0,
            notInConstruct: f0
        }, {
            character: ".",
            before: "[Ww]",
            after: "[\\-.\\w]",
            inConstruct: d0,
            notInConstruct: f0
        }, {
            character: ":",
            before: "[ps]",
            after: "\\/",
            inConstruct: d0,
            notInConstruct: f0
        }]
    }
}
function iee(t) {
    this.enter({
        type: "link",
        title: null,
        url: "",
        children: []
    }, t)
}
function p0(t) {
    this.config.enter.autolinkProtocol.call(this, t)
}
function see(t) {
    this.config.exit.autolinkProtocol.call(this, t)
}
function oee(t) {
    this.config.exit.data.call(this, t);
    const e = this.stack[this.stack.length - 1];
    e.type,
    e.url = "http://" + this.sliceSerialize(t)
}
function aee(t) {
    this.config.exit.autolinkEmail.call(this, t)
}
function lee(t) {
    this.exit(t)
}
function cee(t) {
    JZ(t, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, uee], [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, hee]], {
        ignore: ["link", "linkReference"]
    })
}
function uee(t, e, n, r, i) {
    let s = "";
    if (!AD(i) || (/^w/i.test(e) && (n = e + n,
    e = "",
    s = "http://"),
    !dee(n)))
        return !1;
    const o = fee(n + r);
    if (!o[0])
        return !1;
    const a = {
        type: "link",
        title: null,
        url: s + e + o[0],
        children: [{
            type: "text",
            value: e + o[0]
        }]
    };
    return o[1] ? [a, {
        type: "text",
        value: o[1]
    }] : a
}
function hee(t, e, n, r) {
    return !AD(r, !0) || /[-\d_]$/.test(n) ? !1 : {
        type: "link",
        title: null,
        url: "mailto:" + e + "@" + n,
        children: [{
            type: "text",
            value: e + "@" + n
        }]
    }
}
function dee(t) {
    const e = t.split(".");
    return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])))
}
function fee(t) {
    const e = /[!"&'),.:;<>?\]}]+$/.exec(t);
    if (!e)
        return [t, void 0];
    t = t.slice(0, e.index);
    let n = e[0]
      , r = n.indexOf(")");
    const i = zw(t, "(");
    let s = zw(t, ")");
    for (; r !== -1 && i > s; )
        t += n.slice(0, r + 1),
        n = n.slice(r + 1),
        r = n.indexOf(")"),
        s++;
    return [t, n]
}
function AD(t, e) {
    const n = t.input.charCodeAt(t.index - 1);
    return (t.index === 0 || Yo(n) || Am(n)) && (!e || n !== 47)
}
kD.peek = wee;
function pee() {
    return {
        enter: {
            gfmFootnoteDefinition: gee,
            gfmFootnoteDefinitionLabelString: _ee,
            gfmFootnoteCall: vee,
            gfmFootnoteCallString: xee
        },
        exit: {
            gfmFootnoteDefinition: yee,
            gfmFootnoteDefinitionLabelString: bee,
            gfmFootnoteCall: See,
            gfmFootnoteCallString: Eee
        }
    }
}
function mee() {
    return {
        unsafe: [{
            character: "[",
            inConstruct: ["phrasing", "label", "reference"]
        }],
        handlers: {
            footnoteDefinition: Cee,
            footnoteReference: kD
        }
    }
}
function gee(t) {
    this.enter({
        type: "footnoteDefinition",
        identifier: "",
        label: "",
        children: []
    }, t)
}
function _ee() {
    this.buffer()
}
function bee(t) {
    const e = this.resume()
      , n = this.stack[this.stack.length - 1];
    n.type,
    n.label = e,
    n.identifier = Xr(this.sliceSerialize(t)).toLowerCase()
}
function yee(t) {
    this.exit(t)
}
function vee(t) {
    this.enter({
        type: "footnoteReference",
        identifier: "",
        label: ""
    }, t)
}
function xee() {
    this.buffer()
}
function Eee(t) {
    const e = this.resume()
      , n = this.stack[this.stack.length - 1];
    n.type,
    n.label = e,
    n.identifier = Xr(this.sliceSerialize(t)).toLowerCase()
}
function See(t) {
    this.exit(t)
}
function kD(t, e, n, r) {
    const i = n.createTracker(r);
    let s = i.move("[^");
    const o = n.enter("footnoteReference")
      , a = n.enter("reference");
    return s += i.move(n.safe(n.associationId(t), {
        ...i.current(),
        before: s,
        after: "]"
    })),
    a(),
    o(),
    s += i.move("]"),
    s
}
function wee() {
    return "["
}
function Cee(t, e, n, r) {
    const i = n.createTracker(r);
    let s = i.move("[^");
    const o = n.enter("footnoteDefinition")
      , a = n.enter("label");
    return s += i.move(n.safe(n.associationId(t), {
        ...i.current(),
        before: s,
        after: "]"
    })),
    a(),
    s += i.move("]:" + (t.children && t.children.length > 0 ? " " : "")),
    i.shift(4),
    s += i.move(n.indentLines(n.containerFlow(t, i.current()), Tee)),
    o(),
    s
}
function Tee(t, e, n) {
    return e === 0 ? t : (n ? "" : "    ") + t
}
const Aee = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
RD.peek = Dee;
function kee() {
    return {
        canContainEols: ["delete"],
        enter: {
            strikethrough: Iee
        },
        exit: {
            strikethrough: Pee
        }
    }
}
function Ree() {
    return {
        unsafe: [{
            character: "~",
            inConstruct: "phrasing",
            notInConstruct: Aee
        }],
        handlers: {
            delete: RD
        }
    }
}
function Iee(t) {
    this.enter({
        type: "delete",
        children: []
    }, t)
}
function Pee(t) {
    this.exit(t)
}
function RD(t, e, n, r) {
    const i = n.createTracker(r)
      , s = n.enter("strikethrough");
    let o = i.move("~~");
    return o += n.containerPhrasing(t, {
        ...i.current(),
        before: o,
        after: "~"
    }),
    o += i.move("~~"),
    s(),
    o
}
function Dee() {
    return "~"
}
function Lee(t, e={}) {
    const n = (e.align || []).concat()
      , r = e.stringLength || Nee
      , i = []
      , s = []
      , o = []
      , a = [];
    let l = 0
      , c = -1;
    for (; ++c < t.length; ) {
        const g = []
          , _ = [];
        let m = -1;
        for (t[c].length > l && (l = t[c].length); ++m < t[c].length; ) {
            const p = Oee(t[c][m]);
            if (e.alignDelimiters !== !1) {
                const b = r(p);
                _[m] = b,
                (a[m] === void 0 || b > a[m]) && (a[m] = b)
            }
            g.push(p)
        }
        s[c] = g,
        o[c] = _
    }
    let u = -1;
    if (typeof n == "object" && "length"in n)
        for (; ++u < l; )
            i[u] = Ww(n[u]);
    else {
        const g = Ww(n);
        for (; ++u < l; )
            i[u] = g
    }
    u = -1;
    const h = []
      , d = [];
    for (; ++u < l; ) {
        const g = i[u];
        let _ = ""
          , m = "";
        g === 99 ? (_ = ":",
        m = ":") : g === 108 ? _ = ":" : g === 114 && (m = ":");
        let p = e.alignDelimiters === !1 ? 1 : Math.max(1, a[u] - _.length - m.length);
        const b = _ + "-".repeat(p) + m;
        e.alignDelimiters !== !1 && (p = _.length + p + m.length,
        p > a[u] && (a[u] = p),
        d[u] = p),
        h[u] = b
    }
    s.splice(1, 0, h),
    o.splice(1, 0, d),
    c = -1;
    const f = [];
    for (; ++c < s.length; ) {
        const g = s[c]
          , _ = o[c];
        u = -1;
        const m = [];
        for (; ++u < l; ) {
            const p = g[u] || "";
            let b = ""
              , y = "";
            if (e.alignDelimiters !== !1) {
                const x = a[u] - (_[u] || 0)
                  , E = i[u];
                E === 114 ? b = " ".repeat(x) : E === 99 ? x % 2 ? (b = " ".repeat(x / 2 + .5),
                y = " ".repeat(x / 2 - .5)) : (b = " ".repeat(x / 2),
                y = b) : y = " ".repeat(x)
            }
            e.delimiterStart !== !1 && !u && m.push("|"),
            e.padding !== !1 && !(e.alignDelimiters === !1 && p === "") && (e.delimiterStart !== !1 || u) && m.push(" "),
            e.alignDelimiters !== !1 && m.push(b),
            m.push(p),
            e.alignDelimiters !== !1 && m.push(y),
            e.padding !== !1 && m.push(" "),
            (e.delimiterEnd !== !1 || u !== l - 1) && m.push("|")
        }
        f.push(e.delimiterEnd === !1 ? m.join("").replace(/ +$/, "") : m.join(""))
    }
    return f.join(`
`)
}
function Oee(t) {
    return t == null ? "" : String(t)
}
function Nee(t) {
    return t.length
}
function Ww(t) {
    const e = typeof t == "string" ? t.codePointAt(0) : 0;
    return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0
}
function Mee(t, e, n, r) {
    const i = n.enter("blockquote")
      , s = n.createTracker(r);
    s.move("> "),
    s.shift(2);
    const o = n.indentLines(n.containerFlow(t, s.current()), Bee);
    return i(),
    o
}
function Bee(t, e, n) {
    return ">" + (n ? "" : " ") + t
}
function Fee(t, e) {
    return Gw(t, e.inConstruct, !0) && !Gw(t, e.notInConstruct, !1)
}
function Gw(t, e, n) {
    if (typeof e == "string" && (e = [e]),
    !e || e.length === 0)
        return n;
    let r = -1;
    for (; ++r < e.length; )
        if (t.includes(e[r]))
            return !0;
    return !1
}
function qw(t, e, n, r) {
    let i = -1;
    for (; ++i < n.unsafe.length; )
        if (n.unsafe[i].character === `
` && Fee(n.stack, n.unsafe[i]))
            return /[ \t]/.test(r.before) ? "" : " ";
    return `\\
`
}
function jee(t, e) {
    const n = String(t);
    let r = n.indexOf(e)
      , i = r
      , s = 0
      , o = 0;
    if (typeof e != "string")
        throw new TypeError("Expected substring");
    for (; r !== -1; )
        r === i ? ++s > o && (o = s) : s = 1,
        i = r + e.length,
        r = n.indexOf(e, i);
    return o
}
function Hee(t, e) {
    return !!(e.options.fences === !1 && t.value && !t.lang && /[^ \r\n]/.test(t.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value))
}
function Uee(t) {
    const e = t.options.fence || "`";
    if (e !== "`" && e !== "~")
        throw new Error("Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`");
    return e
}
function Vee(t, e, n, r) {
    const i = Uee(n)
      , s = t.value || ""
      , o = i === "`" ? "GraveAccent" : "Tilde";
    if (Hee(t, n)) {
        const h = n.enter("codeIndented")
          , d = n.indentLines(s, $ee);
        return h(),
        d
    }
    const a = n.createTracker(r)
      , l = i.repeat(Math.max(jee(s, i) + 1, 3))
      , c = n.enter("codeFenced");
    let u = a.move(l);
    if (t.lang) {
        const h = n.enter(`codeFencedLang${o}`);
        u += a.move(n.safe(t.lang, {
            before: u,
            after: " ",
            encode: ["`"],
            ...a.current()
        })),
        h()
    }
    if (t.lang && t.meta) {
        const h = n.enter(`codeFencedMeta${o}`);
        u += a.move(" "),
        u += a.move(n.safe(t.meta, {
            before: u,
            after: `
`,
            encode: ["`"],
            ...a.current()
        })),
        h()
    }
    return u += a.move(`
`),
    s && (u += a.move(s + `
`)),
    u += a.move(l),
    c(),
    u
}
function $ee(t, e, n) {
    return (n ? "" : "    ") + t
}
function n1(t) {
    const e = t.options.quote || '"';
    if (e !== '"' && e !== "'")
        throw new Error("Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`");
    return e
}
function zee(t, e, n, r) {
    const i = n1(n)
      , s = i === '"' ? "Quote" : "Apostrophe"
      , o = n.enter("definition");
    let a = n.enter("label");
    const l = n.createTracker(r);
    let c = l.move("[");
    return c += l.move(n.safe(n.associationId(t), {
        before: c,
        after: "]",
        ...l.current()
    })),
    c += l.move("]: "),
    a(),
    !t.url || /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"),
    c += l.move("<"),
    c += l.move(n.safe(t.url, {
        before: c,
        after: ">",
        ...l.current()
    })),
    c += l.move(">")) : (a = n.enter("destinationRaw"),
    c += l.move(n.safe(t.url, {
        before: c,
        after: t.title ? " " : `
`,
        ...l.current()
    }))),
    a(),
    t.title && (a = n.enter(`title${s}`),
    c += l.move(" " + i),
    c += l.move(n.safe(t.title, {
        before: c,
        after: i,
        ...l.current()
    })),
    c += l.move(i),
    a()),
    o(),
    c
}
function Wee(t) {
    const e = t.options.emphasis || "*";
    if (e !== "*" && e !== "_")
        throw new Error("Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`");
    return e
}
ID.peek = Gee;
function ID(t, e, n, r) {
    const i = Wee(n)
      , s = n.enter("emphasis")
      , o = n.createTracker(r);
    let a = o.move(i);
    return a += o.move(n.containerPhrasing(t, {
        before: a,
        after: i,
        ...o.current()
    })),
    a += o.move(i),
    s(),
    a
}
function Gee(t, e, n) {
    return n.options.emphasis || "*"
}
function qee(t, e) {
    let n = !1;
    return Mh(t, function(r) {
        if ("value"in r && /\r?\n|\r/.test(r.value) || r.type === "break")
            return n = !0,
            j_
    }),
    !!((!t.depth || t.depth < 3) && kv(t) && (e.options.setext || n))
}
function Kee(t, e, n, r) {
    const i = Math.max(Math.min(6, t.depth || 1), 1)
      , s = n.createTracker(r);
    if (qee(t, n)) {
        const u = n.enter("headingSetext")
          , h = n.enter("phrasing")
          , d = n.containerPhrasing(t, {
            ...s.current(),
            before: `
`,
            after: `
`
        });
        return h(),
        u(),
        d + `
` + (i === 1 ? "=" : "-").repeat(d.length - (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1))
    }
    const o = "#".repeat(i)
      , a = n.enter("headingAtx")
      , l = n.enter("phrasing");
    s.move(o + " ");
    let c = n.containerPhrasing(t, {
        before: "# ",
        after: `
`,
        ...s.current()
    });
    return /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)),
    c = c ? o + " " + c : o,
    n.options.closeAtx && (c += " " + o),
    l(),
    a(),
    c
}
PD.peek = Yee;
function PD(t) {
    return t.value || ""
}
function Yee() {
    return "<"
}
DD.peek = Xee;
function DD(t, e, n, r) {
    const i = n1(n)
      , s = i === '"' ? "Quote" : "Apostrophe"
      , o = n.enter("image");
    let a = n.enter("label");
    const l = n.createTracker(r);
    let c = l.move("![");
    return c += l.move(n.safe(t.alt, {
        before: c,
        after: "]",
        ...l.current()
    })),
    c += l.move("]("),
    a(),
    !t.url && t.title || /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"),
    c += l.move("<"),
    c += l.move(n.safe(t.url, {
        before: c,
        after: ">",
        ...l.current()
    })),
    c += l.move(">")) : (a = n.enter("destinationRaw"),
    c += l.move(n.safe(t.url, {
        before: c,
        after: t.title ? " " : ")",
        ...l.current()
    }))),
    a(),
    t.title && (a = n.enter(`title${s}`),
    c += l.move(" " + i),
    c += l.move(n.safe(t.title, {
        before: c,
        after: i,
        ...l.current()
    })),
    c += l.move(i),
    a()),
    c += l.move(")"),
    o(),
    c
}
function Xee() {
    return "!"
}
LD.peek = Qee;
function LD(t, e, n, r) {
    const i = t.referenceType
      , s = n.enter("imageReference");
    let o = n.enter("label");
    const a = n.createTracker(r);
    let l = a.move("![");
    const c = n.safe(t.alt, {
        before: l,
        after: "]",
        ...a.current()
    });
    l += a.move(c + "]["),
    o();
    const u = n.stack;
    n.stack = [],
    o = n.enter("reference");
    const h = n.safe(n.associationId(t), {
        before: l,
        after: "]",
        ...a.current()
    });
    return o(),
    n.stack = u,
    s(),
    i === "full" || !c || c !== h ? l += a.move(h + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"),
    l
}
function Qee() {
    return "!"
}
OD.peek = Jee;
function OD(t, e, n) {
    let r = t.value || ""
      , i = "`"
      , s = -1;
    for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
        i += "`";
    for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
        const o = n.unsafe[s]
          , a = n.compilePattern(o);
        let l;
        if (o.atBreak)
            for (; l = a.exec(r); ) {
                let c = l.index;
                r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--,
                r = r.slice(0, c) + " " + r.slice(l.index + 1)
            }
    }
    return i + r + i
}
function Jee() {
    return "`"
}
function ND(t, e) {
    const n = kv(t);
    return !!(!e.options.resourceLink && t.url && !t.title && t.children && t.children.length === 1 && t.children[0].type === "text" && (n === t.url || "mailto:" + n === t.url) && /^[a-z][a-z+.-]+:/i.test(t.url) && !/[\0- <>\u007F]/.test(t.url))
}
MD.peek = Zee;
function MD(t, e, n, r) {
    const i = n1(n)
      , s = i === '"' ? "Quote" : "Apostrophe"
      , o = n.createTracker(r);
    let a, l;
    if (ND(t, n)) {
        const u = n.stack;
        n.stack = [],
        a = n.enter("autolink");
        let h = o.move("<");
        return h += o.move(n.containerPhrasing(t, {
            before: h,
            after: ">",
            ...o.current()
        })),
        h += o.move(">"),
        a(),
        n.stack = u,
        h
    }
    a = n.enter("link"),
    l = n.enter("label");
    let c = o.move("[");
    return c += o.move(n.containerPhrasing(t, {
        before: c,
        after: "](",
        ...o.current()
    })),
    c += o.move("]("),
    l(),
    !t.url && t.title || /[\0- \u007F]/.test(t.url) ? (l = n.enter("destinationLiteral"),
    c += o.move("<"),
    c += o.move(n.safe(t.url, {
        before: c,
        after: ">",
        ...o.current()
    })),
    c += o.move(">")) : (l = n.enter("destinationRaw"),
    c += o.move(n.safe(t.url, {
        before: c,
        after: t.title ? " " : ")",
        ...o.current()
    }))),
    l(),
    t.title && (l = n.enter(`title${s}`),
    c += o.move(" " + i),
    c += o.move(n.safe(t.title, {
        before: c,
        after: i,
        ...o.current()
    })),
    c += o.move(i),
    l()),
    c += o.move(")"),
    a(),
    c
}
function Zee(t, e, n) {
    return ND(t, n) ? "<" : "["
}
BD.peek = ete;
function BD(t, e, n, r) {
    const i = t.referenceType
      , s = n.enter("linkReference");
    let o = n.enter("label");
    const a = n.createTracker(r);
    let l = a.move("[");
    const c = n.containerPhrasing(t, {
        before: l,
        after: "]",
        ...a.current()
    });
    l += a.move(c + "]["),
    o();
    const u = n.stack;
    n.stack = [],
    o = n.enter("reference");
    const h = n.safe(n.associationId(t), {
        before: l,
        after: "]",
        ...a.current()
    });
    return o(),
    n.stack = u,
    s(),
    i === "full" || !c || c !== h ? l += a.move(h + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"),
    l
}
function ete() {
    return "["
}
function r1(t) {
    const e = t.options.bullet || "*";
    if (e !== "*" && e !== "+" && e !== "-")
        throw new Error("Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`");
    return e
}
function tte(t) {
    const e = r1(t)
      , n = t.options.bulletOther;
    if (!n)
        return e === "*" ? "-" : "*";
    if (n !== "*" && n !== "+" && n !== "-")
        throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
    if (n === e)
        throw new Error("Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different");
    return n
}
function nte(t) {
    const e = t.options.bulletOrdered || ".";
    if (e !== "." && e !== ")")
        throw new Error("Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`");
    return e
}
function FD(t) {
    const e = t.options.rule || "*";
    if (e !== "*" && e !== "-" && e !== "_")
        throw new Error("Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`");
    return e
}
function rte(t, e, n, r) {
    const i = n.enter("list")
      , s = n.bulletCurrent;
    let o = t.ordered ? nte(n) : r1(n);
    const a = t.ordered ? o === "." ? ")" : "." : tte(n);
    let l = e && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
    if (!t.ordered) {
        const u = t.children ? t.children[0] : void 0;
        if ((o === "*" || o === "-") && u && (!u.children || !u.children[0]) && n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0),
        FD(n) === o && u) {
            let h = -1;
            for (; ++h < t.children.length; ) {
                const d = t.children[h];
                if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
                    l = !0;
                    break
                }
            }
        }
    }
    l && (o = a),
    n.bulletCurrent = o;
    const c = n.containerFlow(t, r);
    return n.bulletLastUsed = o,
    n.bulletCurrent = s,
    i(),
    c
}
function ite(t) {
    const e = t.options.listItemIndent || "one";
    if (e !== "tab" && e !== "one" && e !== "mixed")
        throw new Error("Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
    return e
}
function ste(t, e, n, r) {
    const i = ite(n);
    let s = n.bulletCurrent || r1(n);
    e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
    let o = s.length + 1;
    (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (o = Math.ceil(o / 4) * 4);
    const a = n.createTracker(r);
    a.move(s + " ".repeat(o - s.length)),
    a.shift(o);
    const l = n.enter("listItem")
      , c = n.indentLines(n.containerFlow(t, a.current()), u);
    return l(),
    c;
    function u(h, d, f) {
        return d ? (f ? "" : " ".repeat(o)) + h : (f ? s : s + " ".repeat(o - s.length)) + h
    }
}
function ote(t, e, n, r) {
    const i = n.enter("paragraph")
      , s = n.enter("phrasing")
      , o = n.containerPhrasing(t, r);
    return s(),
    i(),
    o
}
const ate = Im(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]);
function lte(t, e, n, r) {
    return (t.children.some(function(o) {
        return ate(o)
    }) ? n.containerPhrasing : n.containerFlow).call(n, t, r)
}
function cte(t) {
    const e = t.options.strong || "*";
    if (e !== "*" && e !== "_")
        throw new Error("Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`");
    return e
}
jD.peek = ute;
function jD(t, e, n, r) {
    const i = cte(n)
      , s = n.enter("strong")
      , o = n.createTracker(r);
    let a = o.move(i + i);
    return a += o.move(n.containerPhrasing(t, {
        before: a,
        after: i,
        ...o.current()
    })),
    a += o.move(i + i),
    s(),
    a
}
function ute(t, e, n) {
    return n.options.strong || "*"
}
function hte(t, e, n, r) {
    return n.safe(t.value, r)
}
function dte(t) {
    const e = t.options.ruleRepetition || 3;
    if (e < 3)
        throw new Error("Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more");
    return e
}
function fte(t, e, n) {
    const r = (FD(n) + (n.options.ruleSpaces ? " " : "")).repeat(dte(n));
    return n.options.ruleSpaces ? r.slice(0, -1) : r
}
const HD = {
    blockquote: Mee,
    break: qw,
    code: Vee,
    definition: zee,
    emphasis: ID,
    hardBreak: qw,
    heading: Kee,
    html: PD,
    image: DD,
    imageReference: LD,
    inlineCode: OD,
    link: MD,
    linkReference: BD,
    list: rte,
    listItem: ste,
    paragraph: ote,
    root: lte,
    strong: jD,
    text: hte,
    thematicBreak: fte
};
function pte() {
    return {
        enter: {
            table: mte,
            tableData: Kw,
            tableHeader: Kw,
            tableRow: _te
        },
        exit: {
            codeText: bte,
            table: gte,
            tableData: m0,
            tableHeader: m0,
            tableRow: m0
        }
    }
}
function mte(t) {
    const e = t._align;
    this.enter({
        type: "table",
        align: e.map(function(n) {
            return n === "none" ? null : n
        }),
        children: []
    }, t),
    this.data.inTable = !0
}
function gte(t) {
    this.exit(t),
    this.data.inTable = void 0
}
function _te(t) {
    this.enter({
        type: "tableRow",
        children: []
    }, t)
}
function m0(t) {
    this.exit(t)
}
function Kw(t) {
    this.enter({
        type: "tableCell",
        children: []
    }, t)
}
function bte(t) {
    let e = this.resume();
    this.data.inTable && (e = e.replace(/\\([\\|])/g, yte));
    const n = this.stack[this.stack.length - 1];
    n.type,
    n.value = e,
    this.exit(t)
}
function yte(t, e) {
    return e === "|" ? e : t
}
function vte(t) {
    const e = t || {}
      , n = e.tableCellPadding
      , r = e.tablePipeAlign
      , i = e.stringLength
      , s = n ? " " : "|";
    return {
        unsafe: [{
            character: "\r",
            inConstruct: "tableCell"
        }, {
            character: `
`,
            inConstruct: "tableCell"
        }, {
            atBreak: !0,
            character: "|",
            after: "[	 :-]"
        }, {
            character: "|",
            inConstruct: "tableCell"
        }, {
            atBreak: !0,
            character: ":",
            after: "-"
        }, {
            atBreak: !0,
            character: "-",
            after: "[:|-]"
        }],
        handlers: {
            inlineCode: d,
            table: o,
            tableCell: l,
            tableRow: a
        }
    };
    function o(f, g, _, m) {
        return c(u(f, _, m), f.align)
    }
    function a(f, g, _, m) {
        const p = h(f, _, m)
          , b = c([p]);
        return b.slice(0, b.indexOf(`
`))
    }
    function l(f, g, _, m) {
        const p = _.enter("tableCell")
          , b = _.enter("phrasing")
          , y = _.containerPhrasing(f, {
            ...m,
            before: s,
            after: s
        });
        return b(),
        p(),
        y
    }
    function c(f, g) {
        return Lee(f, {
            align: g,
            alignDelimiters: r,
            padding: n,
            stringLength: i
        })
    }
    function u(f, g, _) {
        const m = f.children;
        let p = -1;
        const b = []
          , y = g.enter("table");
        for (; ++p < m.length; )
            b[p] = h(m[p], g, _);
        return y(),
        b
    }
    function h(f, g, _) {
        const m = f.children;
        let p = -1;
        const b = []
          , y = g.enter("tableRow");
        for (; ++p < m.length; )
            b[p] = l(m[p], f, g, _);
        return y(),
        b
    }
    function d(f, g, _) {
        let m = HD.inlineCode(f, g, _);
        return _.stack.includes("tableCell") && (m = m.replace(/\|/g, "\\$&")),
        m
    }
}
function xte() {
    return {
        exit: {
            taskListCheckValueChecked: Yw,
            taskListCheckValueUnchecked: Yw,
            paragraph: Ste
        }
    }
}
function Ete() {
    return {
        unsafe: [{
            atBreak: !0,
            character: "-",
            after: "[:|-]"
        }],
        handlers: {
            listItem: wte
        }
    }
}
function Yw(t) {
    const e = this.stack[this.stack.length - 2];
    e.type,
    e.checked = t.type === "taskListCheckValueChecked"
}
function Ste(t) {
    const e = this.stack[this.stack.length - 2];
    if (e && e.type === "listItem" && typeof e.checked == "boolean") {
        const n = this.stack[this.stack.length - 1];
        n.type;
        const r = n.children[0];
        if (r && r.type === "text") {
            const i = e.children;
            let s = -1, o;
            for (; ++s < i.length; ) {
                const a = i[s];
                if (a.type === "paragraph") {
                    o = a;
                    break
                }
            }
            o === n && (r.value = r.value.slice(1),
            r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++,
            r.position.start.offset++,
            n.position.start = Object.assign({}, r.position.start)))
        }
    }
    this.exit(t)
}
function wte(t, e, n, r) {
    const i = t.children[0]
      , s = typeof t.checked == "boolean" && i && i.type === "paragraph"
      , o = "[" + (t.checked ? "x" : " ") + "] "
      , a = n.createTracker(r);
    s && a.move(o);
    let l = HD.listItem(t, e, n, {
        ...r,
        ...a.current()
    });
    return s && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)),
    l;
    function c(u) {
        return u + o
    }
}
function Cte() {
    return [nee(), pee(), kee(), pte(), xte()]
}
function Tte(t) {
    return {
        extensions: [ree(), mee(), Ree(), vte(t), Ete()]
    }
}
const Ate = {
    tokenize: Lte,
    partial: !0
}
  , UD = {
    tokenize: Ote,
    partial: !0
}
  , VD = {
    tokenize: Nte,
    partial: !0
}
  , $D = {
    tokenize: Mte,
    partial: !0
}
  , kte = {
    tokenize: Bte,
    partial: !0
}
  , zD = {
    tokenize: Pte,
    previous: GD
}
  , WD = {
    tokenize: Dte,
    previous: qD
}
  , ds = {
    tokenize: Ite,
    previous: KD
}
  , Ni = {};
function Rte() {
    return {
        text: Ni
    }
}
let go = 48;
for (; go < 123; )
    Ni[go] = ds,
    go++,
    go === 58 ? go = 65 : go === 91 && (go = 97);
Ni[43] = ds;
Ni[45] = ds;
Ni[46] = ds;
Ni[95] = ds;
Ni[72] = [ds, WD];
Ni[104] = [ds, WD];
Ni[87] = [ds, zD];
Ni[119] = [ds, zD];
function Ite(t, e, n) {
    const r = this;
    let i, s;
    return o;
    function o(h) {
        return !ab(h) || !KD.call(r, r.previous) || i1(r.events) ? n(h) : (t.enter("literalAutolink"),
        t.enter("literalAutolinkEmail"),
        a(h))
    }
    function a(h) {
        return ab(h) ? (t.consume(h),
        a) : h === 64 ? (t.consume(h),
        l) : n(h)
    }
    function l(h) {
        return h === 46 ? t.check(kte, u, c)(h) : h === 45 || h === 95 || In(h) ? (s = !0,
        t.consume(h),
        l) : u(h)
    }
    function c(h) {
        return t.consume(h),
        i = !0,
        l
    }
    function u(h) {
        return s && i && jn(r.previous) ? (t.exit("literalAutolinkEmail"),
        t.exit("literalAutolink"),
        e(h)) : n(h)
    }
}
function Pte(t, e, n) {
    const r = this;
    return i;
    function i(o) {
        return o !== 87 && o !== 119 || !GD.call(r, r.previous) || i1(r.events) ? n(o) : (t.enter("literalAutolink"),
        t.enter("literalAutolinkWww"),
        t.check(Ate, t.attempt(UD, t.attempt(VD, s), n), n)(o))
    }
    function s(o) {
        return t.exit("literalAutolinkWww"),
        t.exit("literalAutolink"),
        e(o)
    }
}
function Dte(t, e, n) {
    const r = this;
    let i = ""
      , s = !1;
    return o;
    function o(h) {
        return (h === 72 || h === 104) && qD.call(r, r.previous) && !i1(r.events) ? (t.enter("literalAutolink"),
        t.enter("literalAutolinkHttp"),
        i += String.fromCodePoint(h),
        t.consume(h),
        a) : n(h)
    }
    function a(h) {
        if (jn(h) && i.length < 5)
            return i += String.fromCodePoint(h),
            t.consume(h),
            a;
        if (h === 58) {
            const d = i.toLowerCase();
            if (d === "http" || d === "https")
                return t.consume(h),
                l
        }
        return n(h)
    }
    function l(h) {
        return h === 47 ? (t.consume(h),
        s ? c : (s = !0,
        l)) : n(h)
    }
    function c(h) {
        return h === null || qf(h) || At(h) || Yo(h) || Am(h) ? n(h) : t.attempt(UD, t.attempt(VD, u), n)(h)
    }
    function u(h) {
        return t.exit("literalAutolinkHttp"),
        t.exit("literalAutolink"),
        e(h)
    }
}
function Lte(t, e, n) {
    let r = 0;
    return i;
    function i(o) {
        return (o === 87 || o === 119) && r < 3 ? (r++,
        t.consume(o),
        i) : o === 46 && r === 3 ? (t.consume(o),
        s) : n(o)
    }
    function s(o) {
        return o === null ? n(o) : e(o)
    }
}
function Ote(t, e, n) {
    let r, i, s;
    return o;
    function o(c) {
        return c === 46 || c === 95 ? t.check($D, l, a)(c) : c === null || At(c) || Yo(c) || c !== 45 && Am(c) ? l(c) : (s = !0,
        t.consume(c),
        o)
    }
    function a(c) {
        return c === 95 ? r = !0 : (i = r,
        r = void 0),
        t.consume(c),
        o
    }
    function l(c) {
        return i || r || !s ? n(c) : e(c)
    }
}
function Nte(t, e) {
    let n = 0
      , r = 0;
    return i;
    function i(o) {
        return o === 40 ? (n++,
        t.consume(o),
        i) : o === 41 && r < n ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? t.check($D, e, s)(o) : o === null || At(o) || Yo(o) ? e(o) : (t.consume(o),
        i)
    }
    function s(o) {
        return o === 41 && r++,
        t.consume(o),
        i
    }
}
function Mte(t, e, n) {
    return r;
    function r(a) {
        return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (t.consume(a),
        r) : a === 38 ? (t.consume(a),
        s) : a === 93 ? (t.consume(a),
        i) : a === 60 || a === null || At(a) || Yo(a) ? e(a) : n(a)
    }
    function i(a) {
        return a === null || a === 40 || a === 91 || At(a) || Yo(a) ? e(a) : r(a)
    }
    function s(a) {
        return jn(a) ? o(a) : n(a)
    }
    function o(a) {
        return a === 59 ? (t.consume(a),
        r) : jn(a) ? (t.consume(a),
        o) : n(a)
    }
}
function Bte(t, e, n) {
    return r;
    function r(s) {
        return t.consume(s),
        i
    }
    function i(s) {
        return In(s) ? n(s) : e(s)
    }
}
function GD(t) {
    return t === null || t === 40 || t === 42 || t === 95 || t === 91 || t === 93 || t === 126 || At(t)
}
function qD(t) {
    return !jn(t)
}
function KD(t) {
    return !(t === 47 || ab(t))
}
function ab(t) {
    return t === 43 || t === 45 || t === 46 || t === 95 || In(t)
}
function i1(t) {
    let e = t.length
      , n = !1;
    for (; e--; ) {
        const r = t[e][1];
        if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
            n = !0;
            break
        }
        if (r._gfmAutolinkLiteralWalkedInto) {
            n = !1;
            break
        }
    }
    return t.length > 0 && !n && (t[t.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0),
    n
}
const Fte = {
    tokenize: Gte,
    partial: !0
};
function jte() {
    return {
        document: {
            91: {
                tokenize: $te,
                continuation: {
                    tokenize: zte
                },
                exit: Wte
            }
        },
        text: {
            91: {
                tokenize: Vte
            },
            93: {
                add: "after",
                tokenize: Hte,
                resolveTo: Ute
            }
        }
    }
}
function Hte(t, e, n) {
    const r = this;
    let i = r.events.length;
    const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let o;
    for (; i--; ) {
        const l = r.events[i][1];
        if (l.type === "labelImage") {
            o = l;
            break
        }
        if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
            break
    }
    return a;
    function a(l) {
        if (!o || !o._balanced)
            return n(l);
        const c = Xr(r.sliceSerialize({
            start: o.end,
            end: r.now()
        }));
        return c.codePointAt(0) !== 94 || !s.includes(c.slice(1)) ? n(l) : (t.enter("gfmFootnoteCallLabelMarker"),
        t.consume(l),
        t.exit("gfmFootnoteCallLabelMarker"),
        e(l))
    }
}
function Ute(t, e) {
    let n = t.length;
    for (; n--; )
        if (t[n][1].type === "labelImage" && t[n][0] === "enter") {
            t[n][1];
            break
        }
    t[n + 1][1].type = "data",
    t[n + 3][1].type = "gfmFootnoteCallLabelMarker";
    const r = {
        type: "gfmFootnoteCall",
        start: Object.assign({}, t[n + 3][1].start),
        end: Object.assign({}, t[t.length - 1][1].end)
    }
      , i = {
        type: "gfmFootnoteCallMarker",
        start: Object.assign({}, t[n + 3][1].end),
        end: Object.assign({}, t[n + 3][1].end)
    };
    i.end.column++,
    i.end.offset++,
    i.end._bufferIndex++;
    const s = {
        type: "gfmFootnoteCallString",
        start: Object.assign({}, i.end),
        end: Object.assign({}, t[t.length - 1][1].start)
    }
      , o = {
        type: "chunkString",
        contentType: "string",
        start: Object.assign({}, s.start),
        end: Object.assign({}, s.end)
    }
      , a = [t[n + 1], t[n + 2], ["enter", r, e], t[n + 3], t[n + 4], ["enter", i, e], ["exit", i, e], ["enter", s, e], ["enter", o, e], ["exit", o, e], ["exit", s, e], t[t.length - 2], t[t.length - 1], ["exit", r, e]];
    return t.splice(n, t.length - n + 1, ...a),
    t
}
function Vte(t, e, n) {
    const r = this
      , i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let s = 0, o;
    return a;
    function a(h) {
        return t.enter("gfmFootnoteCall"),
        t.enter("gfmFootnoteCallLabelMarker"),
        t.consume(h),
        t.exit("gfmFootnoteCallLabelMarker"),
        l
    }
    function l(h) {
        return h !== 94 ? n(h) : (t.enter("gfmFootnoteCallMarker"),
        t.consume(h),
        t.exit("gfmFootnoteCallMarker"),
        t.enter("gfmFootnoteCallString"),
        t.enter("chunkString").contentType = "string",
        c)
    }
    function c(h) {
        if (s > 999 || h === 93 && !o || h === null || h === 91 || At(h))
            return n(h);
        if (h === 93) {
            t.exit("chunkString");
            const d = t.exit("gfmFootnoteCallString");
            return i.includes(Xr(r.sliceSerialize(d))) ? (t.enter("gfmFootnoteCallLabelMarker"),
            t.consume(h),
            t.exit("gfmFootnoteCallLabelMarker"),
            t.exit("gfmFootnoteCall"),
            e) : n(h)
        }
        return At(h) || (o = !0),
        s++,
        t.consume(h),
        h === 92 ? u : c
    }
    function u(h) {
        return h === 91 || h === 92 || h === 93 ? (t.consume(h),
        s++,
        c) : c(h)
    }
}
function $te(t, e, n) {
    const r = this
      , i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let s, o = 0, a;
    return l;
    function l(g) {
        return t.enter("gfmFootnoteDefinition")._container = !0,
        t.enter("gfmFootnoteDefinitionLabel"),
        t.enter("gfmFootnoteDefinitionLabelMarker"),
        t.consume(g),
        t.exit("gfmFootnoteDefinitionLabelMarker"),
        c
    }
    function c(g) {
        return g === 94 ? (t.enter("gfmFootnoteDefinitionMarker"),
        t.consume(g),
        t.exit("gfmFootnoteDefinitionMarker"),
        t.enter("gfmFootnoteDefinitionLabelString"),
        t.enter("chunkString").contentType = "string",
        u) : n(g)
    }
    function u(g) {
        if (o > 999 || g === 93 && !a || g === null || g === 91 || At(g))
            return n(g);
        if (g === 93) {
            t.exit("chunkString");
            const _ = t.exit("gfmFootnoteDefinitionLabelString");
            return s = Xr(r.sliceSerialize(_)),
            t.enter("gfmFootnoteDefinitionLabelMarker"),
            t.consume(g),
            t.exit("gfmFootnoteDefinitionLabelMarker"),
            t.exit("gfmFootnoteDefinitionLabel"),
            d
        }
        return At(g) || (a = !0),
        o++,
        t.consume(g),
        g === 92 ? h : u
    }
    function h(g) {
        return g === 91 || g === 92 || g === 93 ? (t.consume(g),
        o++,
        u) : u(g)
    }
    function d(g) {
        return g === 58 ? (t.enter("definitionMarker"),
        t.consume(g),
        t.exit("definitionMarker"),
        i.includes(s) || i.push(s),
        ht(t, f, "gfmFootnoteDefinitionWhitespace")) : n(g)
    }
    function f(g) {
        return e(g)
    }
}
function zte(t, e, n) {
    return t.check(Nh, e, t.attempt(Fte, e, n))
}
function Wte(t) {
    t.exit("gfmFootnoteDefinition")
}
function Gte(t, e, n) {
    const r = this;
    return ht(t, i, "gfmFootnoteDefinitionIndent", 5);
    function i(s) {
        const o = r.events[r.events.length - 1];
        return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(s) : n(s)
    }
}
function qte(t) {
    let n = (t || {}).singleTilde;
    const r = {
        tokenize: s,
        resolveAll: i
    };
    return n == null && (n = !0),
    {
        text: {
            126: r
        },
        insideSpan: {
            null: [r]
        },
        attentionMarkers: {
            null: [126]
        }
    };
    function i(o, a) {
        let l = -1;
        for (; ++l < o.length; )
            if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
                let c = l;
                for (; c--; )
                    if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
                        o[l][1].type = "strikethroughSequence",
                        o[c][1].type = "strikethroughSequence";
                        const u = {
                            type: "strikethrough",
                            start: Object.assign({}, o[c][1].start),
                            end: Object.assign({}, o[l][1].end)
                        }
                          , h = {
                            type: "strikethroughText",
                            start: Object.assign({}, o[c][1].end),
                            end: Object.assign({}, o[l][1].start)
                        }
                          , d = [["enter", u, a], ["enter", o[c][1], a], ["exit", o[c][1], a], ["enter", h, a]]
                          , f = a.parser.constructs.insideSpan.null;
                        f && Pr(d, d.length, 0, km(f, o.slice(c + 1, l), a)),
                        Pr(d, d.length, 0, [["exit", h, a], ["enter", o[l][1], a], ["exit", o[l][1], a], ["exit", u, a]]),
                        Pr(o, c - 1, l - c + 3, d),
                        l = c + d.length - 2;
                        break
                    }
            }
        for (l = -1; ++l < o.length; )
            o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
        return o
    }
    function s(o, a, l) {
        const c = this.previous
          , u = this.events;
        let h = 0;
        return d;
        function d(g) {
            return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(g) : (o.enter("strikethroughSequenceTemporary"),
            f(g))
        }
        function f(g) {
            const _ = Kf(c);
            if (g === 126)
                return h > 1 ? l(g) : (o.consume(g),
                h++,
                f);
            if (h < 2 && !n)
                return l(g);
            const m = o.exit("strikethroughSequenceTemporary")
              , p = Kf(g);
            return m._open = !p || p === 2 && !!_,
            m._close = !_ || _ === 2 && !!p,
            a(g)
        }
    }
}
class Kte {
    constructor() {
        this.map = []
    }
    add(e, n, r) {
        Yte(this, e, n, r)
    }
    consume(e) {
        if (this.map.sort(function(s, o) {
            return s[0] - o[0]
        }),
        this.map.length === 0)
            return;
        let n = this.map.length;
        const r = [];
        for (; n > 0; )
            n -= 1,
            r.push(e.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]),
            e.length = this.map[n][0];
        r.push([...e]),
        e.length = 0;
        let i = r.pop();
        for (; i; )
            e.push(...i),
            i = r.pop();
        this.map.length = 0
    }
}
function Yte(t, e, n, r) {
    let i = 0;
    if (!(n === 0 && r.length === 0)) {
        for (; i < t.map.length; ) {
            if (t.map[i][0] === e) {
                t.map[i][1] += n,
                t.map[i][2].push(...r);
                return
            }
            i += 1
        }
        t.map.push([e, n, r])
    }
}
function Xte(t, e) {
    let n = !1;
    const r = [];
    for (; e < t.length; ) {
        const i = t[e];
        if (n) {
            if (i[0] === "enter")
                i[1].type === "tableContent" && r.push(t[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
            else if (i[1].type === "tableContent") {
                if (t[e - 1][1].type === "tableDelimiterMarker") {
                    const s = r.length - 1;
                    r[s] = r[s] === "left" ? "center" : "right"
                }
            } else if (i[1].type === "tableDelimiterRow")
                break
        } else
            i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
        e += 1
    }
    return r
}
function Qte() {
    return {
        flow: {
            null: {
                tokenize: Jte,
                resolveAll: Zte
            }
        }
    }
}
function Jte(t, e, n) {
    const r = this;
    let i = 0, s = 0, o;
    return a;
    function a(I) {
        let N = r.events.length - 1;
        for (; N > -1; ) {
            const H = r.events[N][1].type;
            if (H === "lineEnding" || H === "linePrefix")
                N--;
            else
                break
        }
        const O = N > -1 ? r.events[N][1].type : null
          , M = O === "tableHead" || O === "tableRow" ? w : l;
        return M === w && r.parser.lazy[r.now().line] ? n(I) : M(I)
    }
    function l(I) {
        return t.enter("tableHead"),
        t.enter("tableRow"),
        c(I)
    }
    function c(I) {
        return I === 124 || (o = !0,
        s += 1),
        u(I)
    }
    function u(I) {
        return I === null ? n(I) : je(I) ? s > 1 ? (s = 0,
        r.interrupt = !0,
        t.exit("tableRow"),
        t.enter("lineEnding"),
        t.consume(I),
        t.exit("lineEnding"),
        f) : n(I) : st(I) ? ht(t, u, "whitespace")(I) : (s += 1,
        o && (o = !1,
        i += 1),
        I === 124 ? (t.enter("tableCellDivider"),
        t.consume(I),
        t.exit("tableCellDivider"),
        o = !0,
        u) : (t.enter("data"),
        h(I)))
    }
    function h(I) {
        return I === null || I === 124 || At(I) ? (t.exit("data"),
        u(I)) : (t.consume(I),
        I === 92 ? d : h)
    }
    function d(I) {
        return I === 92 || I === 124 ? (t.consume(I),
        h) : h(I)
    }
    function f(I) {
        return r.interrupt = !1,
        r.parser.lazy[r.now().line] ? n(I) : (t.enter("tableDelimiterRow"),
        o = !1,
        st(I) ? ht(t, g, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(I) : g(I))
    }
    function g(I) {
        return I === 45 || I === 58 ? m(I) : I === 124 ? (o = !0,
        t.enter("tableCellDivider"),
        t.consume(I),
        t.exit("tableCellDivider"),
        _) : E(I)
    }
    function _(I) {
        return st(I) ? ht(t, m, "whitespace")(I) : m(I)
    }
    function m(I) {
        return I === 58 ? (s += 1,
        o = !0,
        t.enter("tableDelimiterMarker"),
        t.consume(I),
        t.exit("tableDelimiterMarker"),
        p) : I === 45 ? (s += 1,
        p(I)) : I === null || je(I) ? x(I) : E(I)
    }
    function p(I) {
        return I === 45 ? (t.enter("tableDelimiterFiller"),
        b(I)) : E(I)
    }
    function b(I) {
        return I === 45 ? (t.consume(I),
        b) : I === 58 ? (o = !0,
        t.exit("tableDelimiterFiller"),
        t.enter("tableDelimiterMarker"),
        t.consume(I),
        t.exit("tableDelimiterMarker"),
        y) : (t.exit("tableDelimiterFiller"),
        y(I))
    }
    function y(I) {
        return st(I) ? ht(t, x, "whitespace")(I) : x(I)
    }
    function x(I) {
        return I === 124 ? g(I) : I === null || je(I) ? !o || i !== s ? E(I) : (t.exit("tableDelimiterRow"),
        t.exit("tableHead"),
        e(I)) : E(I)
    }
    function E(I) {
        return n(I)
    }
    function w(I) {
        return t.enter("tableRow"),
        A(I)
    }
    function A(I) {
        return I === 124 ? (t.enter("tableCellDivider"),
        t.consume(I),
        t.exit("tableCellDivider"),
        A) : I === null || je(I) ? (t.exit("tableRow"),
        e(I)) : st(I) ? ht(t, A, "whitespace")(I) : (t.enter("data"),
        C(I))
    }
    function C(I) {
        return I === null || I === 124 || At(I) ? (t.exit("data"),
        A(I)) : (t.consume(I),
        I === 92 ? k : C)
    }
    function k(I) {
        return I === 92 || I === 124 ? (t.consume(I),
        C) : C(I)
    }
}
function Zte(t, e) {
    let n = -1, r = !0, i = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], a = !1, l = 0, c, u, h;
    const d = new Kte;
    for (; ++n < t.length; ) {
        const f = t[n]
          , g = f[1];
        f[0] === "enter" ? g.type === "tableHead" ? (a = !1,
        l !== 0 && (Xw(d, e, l, c, u),
        u = void 0,
        l = 0),
        c = {
            type: "table",
            start: Object.assign({}, g.start),
            end: Object.assign({}, g.end)
        },
        d.add(n, 0, [["enter", c, e]])) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (r = !0,
        h = void 0,
        s = [0, 0, 0, 0],
        o = [0, n + 1, 0, 0],
        a && (a = !1,
        u = {
            type: "tableBody",
            start: Object.assign({}, g.start),
            end: Object.assign({}, g.end)
        },
        d.add(n, 0, [["enter", u, e]])),
        i = g.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") ? (r = !1,
        o[2] === 0 && (s[1] !== 0 && (o[0] = o[1],
        h = Cd(d, e, s, i, void 0, h),
        s = [0, 0, 0, 0]),
        o[2] = n)) : g.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1],
        h = Cd(d, e, s, i, void 0, h)),
        s = o,
        o = [s[1], n, 0, 0])) : g.type === "tableHead" ? (a = !0,
        l = n) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (l = n,
        s[1] !== 0 ? (o[0] = o[1],
        h = Cd(d, e, s, i, n, h)) : o[1] !== 0 && (h = Cd(d, e, o, i, n, h)),
        i = 0) : i && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") && (o[3] = n)
    }
    for (l !== 0 && Xw(d, e, l, c, u),
    d.consume(e.events),
    n = -1; ++n < e.events.length; ) {
        const f = e.events[n];
        f[0] === "enter" && f[1].type === "table" && (f[1]._align = Xte(e.events, n))
    }
    return t
}
function Cd(t, e, n, r, i, s) {
    const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData"
      , a = "tableContent";
    n[0] !== 0 && (s.end = Object.assign({}, $a(e.events, n[0])),
    t.add(n[0], 0, [["exit", s, e]]));
    const l = $a(e.events, n[1]);
    if (s = {
        type: o,
        start: Object.assign({}, l),
        end: Object.assign({}, l)
    },
    t.add(n[1], 0, [["enter", s, e]]),
    n[2] !== 0) {
        const c = $a(e.events, n[2])
          , u = $a(e.events, n[3])
          , h = {
            type: a,
            start: Object.assign({}, c),
            end: Object.assign({}, u)
        };
        if (t.add(n[2], 0, [["enter", h, e]]),
        r !== 2) {
            const d = e.events[n[2]]
              , f = e.events[n[3]];
            if (d[1].end = Object.assign({}, f[1].end),
            d[1].type = "chunkText",
            d[1].contentType = "text",
            n[3] > n[2] + 1) {
                const g = n[2] + 1
                  , _ = n[3] - n[2] - 1;
                t.add(g, _, [])
            }
        }
        t.add(n[3] + 1, 0, [["exit", h, e]])
    }
    return i !== void 0 && (s.end = Object.assign({}, $a(e.events, i)),
    t.add(i, 0, [["exit", s, e]]),
    s = void 0),
    s
}
function Xw(t, e, n, r, i) {
    const s = []
      , o = $a(e.events, n);
    i && (i.end = Object.assign({}, o),
    s.push(["exit", i, e])),
    r.end = Object.assign({}, o),
    s.push(["exit", r, e]),
    t.add(n + 1, 0, s)
}
function $a(t, e) {
    const n = t[e]
      , r = n[0] === "enter" ? "start" : "end";
    return n[1][r]
}
const ene = {
    tokenize: nne
};
function tne() {
    return {
        text: {
            91: ene
        }
    }
}
function nne(t, e, n) {
    const r = this;
    return i;
    function i(l) {
        return r.previous !== null || !r._gfmTasklistFirstContentOfListItem ? n(l) : (t.enter("taskListCheck"),
        t.enter("taskListCheckMarker"),
        t.consume(l),
        t.exit("taskListCheckMarker"),
        s)
    }
    function s(l) {
        return At(l) ? (t.enter("taskListCheckValueUnchecked"),
        t.consume(l),
        t.exit("taskListCheckValueUnchecked"),
        o) : l === 88 || l === 120 ? (t.enter("taskListCheckValueChecked"),
        t.consume(l),
        t.exit("taskListCheckValueChecked"),
        o) : n(l)
    }
    function o(l) {
        return l === 93 ? (t.enter("taskListCheckMarker"),
        t.consume(l),
        t.exit("taskListCheckMarker"),
        t.exit("taskListCheck"),
        a) : n(l)
    }
    function a(l) {
        return je(l) ? e(l) : st(l) ? t.check({
            tokenize: rne
        }, e, n)(l) : n(l)
    }
}
function rne(t, e, n) {
    return ht(t, r, "whitespace");
    function r(i) {
        return i === null ? n(i) : e(i)
    }
}
function ine(t) {
    return q2([Rte(), jte(), qte(t), Qte(), tne()])
}
const sne = {};
function one(t) {
    const e = this
      , n = t || sne
      , r = e.data()
      , i = r.micromarkExtensions || (r.micromarkExtensions = [])
      , s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = [])
      , o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
    i.push(ine(n)),
    s.push(Cte()),
    o.push(Tte(n))
}
const ane = [/^<div class="__boltFileSelections__" data-selections="[^"]+"><\/div>$/]
  , lne = {
    ...Za,
    tagNames: MP,
    attributes: {
        ...Za.attributes,
        div: [...Za.attributes?.div ?? [], "data*", ["className", "__boltArtifact__", "__boltFileSelections__"]],
        a: dne(Za.attributes?.a, [["className", "__boltUpgradePlan__"]])
    },
    strip: []
};
function cne(t) {
    const e = [one];
    return t && e.unshift(hne),
    e
}
function une(t) {
    const e = [];
    return t && e.push(HZ, [XZ, lne]),
    e
}
const hne = () => (t, e) => {
    const n = e.toString();
    Mh(t, (r, i, s) => {
        if (r.type === "html")
            return ane.every(a => "value"in r && typeof r.value == "string" && a.test(r.value));
        if (i == null || ["paragraph", "text", "inlineCode", "code", "strong", "emphasis"].includes(r.type) || !r.position)
            return !0;
        let o = n.slice(r.position.start.offset, r.position.end.offset);
        return r.type === "heading" && (o = `
${o}`),
        s.children[i] = {
            type: "text",
            value: o
        },
        [dI, i]
    }
    )
}
;
function dne(t, e) {
    if (!t)
        return e;
    const n = new Map
      , r = i => Array.isArray(i) ? i[0] : i;
    for (const i of e) {
        const s = r(i);
        n.set(s, i)
    }
    for (const i of t) {
        const s = r(i)
          , o = n.get(s);
        if (!o) {
            n.set(s, i);
            continue
        }
        if (Array.isArray(o)) {
            const a = Array.isArray(i) ? i.slice(1) : [i];
            o.push(...a)
        }
    }
    return [...n.values()]
}
const fne = "_MarkdownContent_1mdbx_1"
  , pne = {
    MarkdownContent: fne
}
  , Qw = nr("MarkdownComponent")
  , s1 = S.memo( ({children: t, html: e=!1, limitedMarkdown: n=!1, scrollToBottom: r}) => {
    Qw.trace("Render");
    const i = S.useMemo( () => ({
        div: ({className: s, children: o, node: a, ...l}) => {
            if (s?.includes("__boltArtifact__")) {
                const c = a?.properties.dataArtifactId;
                return c || Qw.error(`Invalid artifact id ${c}`),
                v.jsx(vX, {
                    id: c,
                    scrollToBottom: r
                }, c)
            }
            return v.jsx("div", {
                className: s,
                ...l,
                children: o
            })
        }
        ,
        a: ({node: s, children: o, className: a, ...l}) => a?.includes("__boltUpgradePlan__") ? v.jsx(kX, {}) : v.jsx("a", {
            ...l,
            target: "_blank",
            children: o
        }),
        pre: s => {
            const {children: o, node: a, ...l} = s
              , [c] = a?.children ?? [];
            if (c && c.type === "element" && c.tagName === "code" && c.children[0].type === "text") {
                const {className: u, ...h} = c.properties
                  , [,d="plaintext"] = /language-(\w+)/.exec(String(u) || "") ?? [];
                return v.jsx(NP, {
                    code: c.children[0].value,
                    language: d,
                    ...h
                })
            }
            return v.jsx("pre", {
                ...l,
                children: o
            })
        }
    }), []);
    return v.jsx(Nz, {
        allowedElements: MP,
        className: pne.MarkdownContent,
        components: i,
        remarkPlugins: cne(n),
        rehypePlugins: une(e),
        children: t
    })
}
)
  , mne = S.memo( ({content: t, scrollToBottom: e, className: n}) => v.jsx("div", {
    className: be("overflow-hidden w-full", n),
    children: v.jsx(s1, {
        html: !0,
        scrollToBottom: e,
        children: t
    })
}));
var g0 = "focusScope.autoFocusOnMount"
  , _0 = "focusScope.autoFocusOnUnmount"
  , Jw = {
    bubbles: !1,
    cancelable: !0
}
  , gne = "FocusScope"
  , Wh = S.forwardRef( (t, e) => {
    const {loop: n=!1, trapped: r=!1, onMountAutoFocus: i, onUnmountAutoFocus: s, ...o} = t
      , [a,l] = S.useState(null)
      , c = vn(i)
      , u = vn(s)
      , h = S.useRef(null)
      , d = rt(e, _ => l(_))
      , f = S.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    S.useEffect( () => {
        if (r) {
            let _ = function(y) {
                if (f.paused || !a)
                    return;
                const x = y.target;
                a.contains(x) ? h.current = x : ys(h.current, {
                    select: !0
                })
            }
              , m = function(y) {
                if (f.paused || !a)
                    return;
                const x = y.relatedTarget;
                x !== null && (a.contains(x) || ys(h.current, {
                    select: !0
                }))
            }
              , p = function(y) {
                if (document.activeElement === document.body)
                    for (const E of y)
                        E.removedNodes.length > 0 && ys(a)
            };
            document.addEventListener("focusin", _),
            document.addEventListener("focusout", m);
            const b = new MutationObserver(p);
            return a && b.observe(a, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", _),
                document.removeEventListener("focusout", m),
                b.disconnect()
            }
        }
    }
    , [r, a, f.paused]),
    S.useEffect( () => {
        if (a) {
            eC.add(f);
            const _ = document.activeElement;
            if (!a.contains(_)) {
                const p = new CustomEvent(g0,Jw);
                a.addEventListener(g0, c),
                a.dispatchEvent(p),
                p.defaultPrevented || (_ne(Ene(YD(a)), {
                    select: !0
                }),
                document.activeElement === _ && ys(a))
            }
            return () => {
                a.removeEventListener(g0, c),
                setTimeout( () => {
                    const p = new CustomEvent(_0,Jw);
                    a.addEventListener(_0, u),
                    a.dispatchEvent(p),
                    p.defaultPrevented || ys(_ ?? document.body, {
                        select: !0
                    }),
                    a.removeEventListener(_0, u),
                    eC.remove(f)
                }
                , 0)
            }
        }
    }
    , [a, c, u, f]);
    const g = S.useCallback(_ => {
        if (!n && !r || f.paused)
            return;
        const m = _.key === "Tab" && !_.altKey && !_.ctrlKey && !_.metaKey
          , p = document.activeElement;
        if (m && p) {
            const b = _.currentTarget
              , [y,x] = bne(b);
            y && x ? !_.shiftKey && p === x ? (_.preventDefault(),
            n && ys(y, {
                select: !0
            })) : _.shiftKey && p === y && (_.preventDefault(),
            n && ys(x, {
                select: !0
            })) : p === b && _.preventDefault()
        }
    }
    , [n, r, f.paused]);
    return v.jsx(We.div, {
        tabIndex: -1,
        ...o,
        ref: d,
        onKeyDown: g
    })
}
);
Wh.displayName = gne;
function _ne(t, {select: e=!1}={}) {
    const n = document.activeElement;
    for (const r of t)
        if (ys(r, {
            select: e
        }),
        document.activeElement !== n)
            return
}
function bne(t) {
    const e = YD(t)
      , n = Zw(e, t)
      , r = Zw(e.reverse(), t);
    return [n, r]
}
function YD(t) {
    const e = []
      , n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: r => {
            const i = r.tagName === "INPUT" && r.type === "hidden";
            return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        e.push(n.currentNode);
    return e
}
function Zw(t, e) {
    for (const n of t)
        if (!yne(n, {
            upTo: e
        }))
            return n
}
function yne(t, {upTo: e}) {
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    for (; t; ) {
        if (e !== void 0 && t === e)
            return !1;
        if (getComputedStyle(t).display === "none")
            return !0;
        t = t.parentElement
    }
    return !1
}
function vne(t) {
    return t instanceof HTMLInputElement && "select"in t
}
function ys(t, {select: e=!1}={}) {
    if (t && t.focus) {
        const n = document.activeElement;
        t.focus({
            preventScroll: !0
        }),
        t !== n && vne(t) && e && t.select()
    }
}
var eC = xne();
function xne() {
    let t = [];
    return {
        add(e) {
            const n = t[0];
            e !== n && n?.pause(),
            t = tC(t, e),
            t.unshift(e)
        },
        remove(e) {
            t = tC(t, e),
            t[0]?.resume()
        }
    }
}
function tC(t, e) {
    const n = [...t]
      , r = n.indexOf(e);
    return r !== -1 && n.splice(r, 1),
    n
}
function Ene(t) {
    return t.filter(e => e.tagName !== "A")
}
var b0 = 0;
function o1() {
    S.useEffect( () => {
        const t = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", t[0] ?? nC()),
        document.body.insertAdjacentElement("beforeend", t[1] ?? nC()),
        b0++,
        () => {
            b0 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()),
            b0--
        }
    }
    , [])
}
function nC() {
    const t = document.createElement("span");
    return t.setAttribute("data-radix-focus-guard", ""),
    t.tabIndex = 0,
    t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none",
    t
}
var Qc = "right-scroll-bar-position"
  , Jc = "width-before-scroll-bar"
  , Sne = "with-scroll-bars-hidden"
  , wne = "--removed-body-scroll-bar-size";
function y0(t, e) {
    return typeof t == "function" ? t(e) : t && (t.current = e),
    t
}
function Cne(t, e) {
    var n = S.useState(function() {
        return {
            value: t,
            callback: e,
            facade: {
                get current() {
                    return n.value
                },
                set current(r) {
                    var i = n.value;
                    i !== r && (n.value = r,
                    n.callback(r, i))
                }
            }
        }
    })[0];
    return n.callback = e,
    n.facade
}
var Tne = typeof window < "u" ? S.useLayoutEffect : S.useEffect
  , rC = new WeakMap;
function XD(t, e) {
    var n = Cne(null, function(r) {
        return t.forEach(function(i) {
            return y0(i, r)
        })
    });
    return Tne(function() {
        var r = rC.get(n);
        if (r) {
            var i = new Set(r)
              , s = new Set(t)
              , o = n.current;
            i.forEach(function(a) {
                s.has(a) || y0(a, null)
            }),
            s.forEach(function(a) {
                i.has(a) || y0(a, o)
            })
        }
        rC.set(n, t)
    }, [t]),
    n
}
function Ane(t) {
    return t
}
function kne(t, e) {
    e === void 0 && (e = Ane);
    var n = []
      , r = !1
      , i = {
        read: function() {
            if (r)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return n.length ? n[n.length - 1] : t
        },
        useMedium: function(s) {
            var o = e(s, r);
            return n.push(o),
            function() {
                n = n.filter(function(a) {
                    return a !== o
                })
            }
        },
        assignSyncMedium: function(s) {
            for (r = !0; n.length; ) {
                var o = n;
                n = [],
                o.forEach(s)
            }
            n = {
                push: function(a) {
                    return s(a)
                },
                filter: function() {
                    return n
                }
            }
        },
        assignMedium: function(s) {
            r = !0;
            var o = [];
            if (n.length) {
                var a = n;
                n = [],
                a.forEach(s),
                o = n
            }
            var l = function() {
                var u = o;
                o = [],
                u.forEach(s)
            }
              , c = function() {
                return Promise.resolve().then(l)
            };
            c(),
            n = {
                push: function(u) {
                    o.push(u),
                    c()
                },
                filter: function(u) {
                    return o = o.filter(u),
                    n
                }
            }
        }
    };
    return i
}
function QD(t) {
    t === void 0 && (t = {});
    var e = kne(null);
    return e.options = An({
        async: !0,
        ssr: !1
    }, t),
    e
}
var JD = function(t) {
    var e = t.sideCar
      , n = Iy(t, ["sideCar"]);
    if (!e)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = e.read();
    if (!r)
        throw new Error("Sidecar medium not found");
    return S.createElement(r, An({}, n))
};
JD.isSideCarExport = !0;
function ZD(t, e) {
    return t.useMedium(e),
    JD
}
var eL = QD()
  , v0 = function() {}
  , Vm = S.forwardRef(function(t, e) {
    var n = S.useRef(null)
      , r = S.useState({
        onScrollCapture: v0,
        onWheelCapture: v0,
        onTouchMoveCapture: v0
    })
      , i = r[0]
      , s = r[1]
      , o = t.forwardProps
      , a = t.children
      , l = t.className
      , c = t.removeScrollBar
      , u = t.enabled
      , h = t.shards
      , d = t.sideCar
      , f = t.noIsolation
      , g = t.inert
      , _ = t.allowPinchZoom
      , m = t.as
      , p = m === void 0 ? "div" : m
      , b = t.gapMode
      , y = Iy(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , x = d
      , E = XD([n, e])
      , w = An(An({}, y), i);
    return S.createElement(S.Fragment, null, u && S.createElement(x, {
        sideCar: eL,
        removeScrollBar: c,
        shards: h,
        noIsolation: f,
        inert: g,
        setCallbacks: s,
        allowPinchZoom: !!_,
        lockRef: n,
        gapMode: b
    }), o ? S.cloneElement(S.Children.only(a), An(An({}, w), {
        ref: E
    })) : S.createElement(p, An({}, w, {
        className: l,
        ref: E
    }), a))
});
Vm.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
Vm.classNames = {
    fullWidth: Jc,
    zeroRight: Qc
};
var Rne = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function Ine() {
    if (!document)
        return null;
    var t = document.createElement("style");
    t.type = "text/css";
    var e = Rne();
    return e && t.setAttribute("nonce", e),
    t
}
function Pne(t, e) {
    t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e))
}
function Dne(t) {
    var e = document.head || document.getElementsByTagName("head")[0];
    e.appendChild(t)
}
var Lne = function() {
    var t = 0
      , e = null;
    return {
        add: function(n) {
            t == 0 && (e = Ine()) && (Pne(e, n),
            Dne(e)),
            t++
        },
        remove: function() {
            t--,
            !t && e && (e.parentNode && e.parentNode.removeChild(e),
            e = null)
        }
    }
}
  , One = function() {
    var t = Lne();
    return function(e, n) {
        S.useEffect(function() {
            return t.add(e),
            function() {
                t.remove()
            }
        }, [e && n])
    }
}
  , a1 = function() {
    var t = One()
      , e = function(n) {
        var r = n.styles
          , i = n.dynamic;
        return t(r, i),
        null
    };
    return e
}
  , Nne = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , x0 = function(t) {
    return parseInt(t || "", 10) || 0
}
  , Mne = function(t) {
    var e = window.getComputedStyle(document.body)
      , n = e[t === "padding" ? "paddingLeft" : "marginLeft"]
      , r = e[t === "padding" ? "paddingTop" : "marginTop"]
      , i = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [x0(n), x0(r), x0(i)]
}
  , Bne = function(t) {
    if (t === void 0 && (t = "margin"),
    typeof window > "u")
        return Nne;
    var e = Mne(t)
      , n = document.documentElement.clientWidth
      , r = window.innerWidth;
    return {
        left: e[0],
        top: e[1],
        right: e[2],
        gap: Math.max(0, r - n + e[2] - e[0])
    }
}
  , Fne = a1()
  , fl = "data-scroll-locked"
  , jne = function(t, e, n, r) {
    var i = t.left
      , s = t.top
      , o = t.right
      , a = t.gap;
    return n === void 0 && (n = "margin"),
    `
  .`.concat(Sne, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(fl, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Qc, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Jc, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Qc, " .").concat(Qc, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Jc, " .").concat(Jc, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(fl, `] {
    `).concat(wne, ": ").concat(a, `px;
  }
`)
}
  , iC = function() {
    var t = parseInt(document.body.getAttribute(fl) || "0", 10);
    return isFinite(t) ? t : 0
}
  , Hne = function() {
    S.useEffect(function() {
        return document.body.setAttribute(fl, (iC() + 1).toString()),
        function() {
            var t = iC() - 1;
            t <= 0 ? document.body.removeAttribute(fl) : document.body.setAttribute(fl, t.toString())
        }
    }, [])
}
  , tL = function(t) {
    var e = t.noRelative
      , n = t.noImportant
      , r = t.gapMode
      , i = r === void 0 ? "margin" : r;
    Hne();
    var s = S.useMemo(function() {
        return Bne(i)
    }, [i]);
    return S.createElement(Fne, {
        styles: jne(s, !e, i, n ? "" : "!important")
    })
}
  , lb = !1;
if (typeof window < "u")
    try {
        var Td = Object.defineProperty({}, "passive", {
            get: function() {
                return lb = !0,
                !0
            }
        });
        window.addEventListener("test", Td, Td),
        window.removeEventListener("test", Td, Td)
    } catch {
        lb = !1
    }
var Da = lb ? {
    passive: !1
} : !1
  , Une = function(t) {
    return t.tagName === "TEXTAREA"
}
  , nL = function(t, e) {
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !Une(t) && n[e] === "visible")
}
  , Vne = function(t) {
    return nL(t, "overflowY")
}
  , $ne = function(t) {
    return nL(t, "overflowX")
}
  , sC = function(t, e) {
    var n = e.ownerDocument
      , r = e;
    do {
        typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
        var i = rL(t, r);
        if (i) {
            var s = iL(t, r)
              , o = s[1]
              , a = s[2];
            if (o > a)
                return !0
        }
        r = r.parentNode
    } while (r && r !== n.body);
    return !1
}
  , zne = function(t) {
    var e = t.scrollTop
      , n = t.scrollHeight
      , r = t.clientHeight;
    return [e, n, r]
}
  , Wne = function(t) {
    var e = t.scrollLeft
      , n = t.scrollWidth
      , r = t.clientWidth;
    return [e, n, r]
}
  , rL = function(t, e) {
    return t === "v" ? Vne(e) : $ne(e)
}
  , iL = function(t, e) {
    return t === "v" ? zne(e) : Wne(e)
}
  , Gne = function(t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
}
  , qne = function(t, e, n, r, i) {
    var s = Gne(t, window.getComputedStyle(e).direction)
      , o = s * r
      , a = n.target
      , l = e.contains(a)
      , c = !1
      , u = o > 0
      , h = 0
      , d = 0;
    do {
        var f = iL(t, a)
          , g = f[0]
          , _ = f[1]
          , m = f[2]
          , p = _ - m - s * g;
        (g || p) && rL(t, a) && (h += p,
        d += g),
        a instanceof ShadowRoot ? a = a.host : a = a.parentNode
    } while (!l && a !== document.body || l && (e.contains(a) || e === a));
    return (u && (Math.abs(h) < 1 || !i) || !u && (Math.abs(d) < 1 || !i)) && (c = !0),
    c
}
  , Ad = function(t) {
    return "changedTouches"in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
}
  , oC = function(t) {
    return [t.deltaX, t.deltaY]
}
  , aC = function(t) {
    return t && "current"in t ? t.current : t
}
  , Kne = function(t, e) {
    return t[0] === e[0] && t[1] === e[1]
}
  , Yne = function(t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}
  , Xne = 0
  , La = [];
function Qne(t) {
    var e = S.useRef([])
      , n = S.useRef([0, 0])
      , r = S.useRef()
      , i = S.useState(Xne++)[0]
      , s = S.useState(a1)[0]
      , o = S.useRef(t);
    S.useEffect(function() {
        o.current = t
    }, [t]),
    S.useEffect(function() {
        if (t.inert) {
            document.body.classList.add("block-interactivity-".concat(i));
            var _ = dk([t.lockRef.current], (t.shards || []).map(aC), !0).filter(Boolean);
            return _.forEach(function(m) {
                return m.classList.add("allow-interactivity-".concat(i))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(i)),
                _.forEach(function(m) {
                    return m.classList.remove("allow-interactivity-".concat(i))
                })
            }
        }
    }, [t.inert, t.lockRef.current, t.shards]);
    var a = S.useCallback(function(_, m) {
        if ("touches"in _ && _.touches.length === 2)
            return !o.current.allowPinchZoom;
        var p = Ad(_), b = n.current, y = "deltaX"in _ ? _.deltaX : b[0] - p[0], x = "deltaY"in _ ? _.deltaY : b[1] - p[1], E, w = _.target, A = Math.abs(y) > Math.abs(x) ? "h" : "v";
        if ("touches"in _ && A === "h" && w.type === "range")
            return !1;
        var C = sC(A, w);
        if (!C)
            return !0;
        if (C ? E = A : (E = A === "v" ? "h" : "v",
        C = sC(A, w)),
        !C)
            return !1;
        if (!r.current && "changedTouches"in _ && (y || x) && (r.current = E),
        !E)
            return !0;
        var k = r.current || E;
        return qne(k, m, _, k === "h" ? y : x, !0)
    }, [])
      , l = S.useCallback(function(_) {
        var m = _;
        if (!(!La.length || La[La.length - 1] !== s)) {
            var p = "deltaY"in m ? oC(m) : Ad(m)
              , b = e.current.filter(function(E) {
                return E.name === m.type && (E.target === m.target || m.target === E.shadowParent) && Kne(E.delta, p)
            })[0];
            if (b && b.should) {
                m.cancelable && m.preventDefault();
                return
            }
            if (!b) {
                var y = (o.current.shards || []).map(aC).filter(Boolean).filter(function(E) {
                    return E.contains(m.target)
                })
                  , x = y.length > 0 ? a(m, y[0]) : !o.current.noIsolation;
                x && m.cancelable && m.preventDefault()
            }
        }
    }, [])
      , c = S.useCallback(function(_, m, p, b) {
        var y = {
            name: _,
            delta: m,
            target: p,
            should: b,
            shadowParent: Jne(p)
        };
        e.current.push(y),
        setTimeout(function() {
            e.current = e.current.filter(function(x) {
                return x !== y
            })
        }, 1)
    }, [])
      , u = S.useCallback(function(_) {
        n.current = Ad(_),
        r.current = void 0
    }, [])
      , h = S.useCallback(function(_) {
        c(_.type, oC(_), _.target, a(_, t.lockRef.current))
    }, [])
      , d = S.useCallback(function(_) {
        c(_.type, Ad(_), _.target, a(_, t.lockRef.current))
    }, []);
    S.useEffect(function() {
        return La.push(s),
        t.setCallbacks({
            onScrollCapture: h,
            onWheelCapture: h,
            onTouchMoveCapture: d
        }),
        document.addEventListener("wheel", l, Da),
        document.addEventListener("touchmove", l, Da),
        document.addEventListener("touchstart", u, Da),
        function() {
            La = La.filter(function(_) {
                return _ !== s
            }),
            document.removeEventListener("wheel", l, Da),
            document.removeEventListener("touchmove", l, Da),
            document.removeEventListener("touchstart", u, Da)
        }
    }, []);
    var f = t.removeScrollBar
      , g = t.inert;
    return S.createElement(S.Fragment, null, g ? S.createElement(s, {
        styles: Yne(i)
    }) : null, f ? S.createElement(tL, {
        gapMode: t.gapMode
    }) : null)
}
function Jne(t) {
    for (var e = null; t !== null; )
        t instanceof ShadowRoot && (e = t.host,
        t = t.host),
        t = t.parentNode;
    return e
}
const Zne = ZD(eL, Qne);
var $m = S.forwardRef(function(t, e) {
    return S.createElement(Vm, An({}, t, {
        ref: e,
        sideCar: Zne
    }))
});
$m.classNames = Vm.classNames;
var ere = function(t) {
    if (typeof document > "u")
        return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body
}
  , Oa = new WeakMap
  , kd = new WeakMap
  , Rd = {}
  , E0 = 0
  , sL = function(t) {
    return t && (t.host || sL(t.parentNode))
}
  , tre = function(t, e) {
    return e.map(function(n) {
        if (t.contains(n))
            return n;
        var r = sL(n);
        return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"),
        null)
    }).filter(function(n) {
        return !!n
    })
}
  , nre = function(t, e, n, r) {
    var i = tre(e, Array.isArray(t) ? t : [t]);
    Rd[n] || (Rd[n] = new WeakMap);
    var s = Rd[n]
      , o = []
      , a = new Set
      , l = new Set(i)
      , c = function(h) {
        !h || a.has(h) || (a.add(h),
        c(h.parentNode))
    };
    i.forEach(c);
    var u = function(h) {
        !h || l.has(h) || Array.prototype.forEach.call(h.children, function(d) {
            if (a.has(d))
                u(d);
            else
                try {
                    var f = d.getAttribute(r)
                      , g = f !== null && f !== "false"
                      , _ = (Oa.get(d) || 0) + 1
                      , m = (s.get(d) || 0) + 1;
                    Oa.set(d, _),
                    s.set(d, m),
                    o.push(d),
                    _ === 1 && g && kd.set(d, !0),
                    m === 1 && d.setAttribute(n, "true"),
                    g || d.setAttribute(r, "true")
                } catch (p) {
                    console.error("aria-hidden: cannot operate on ", d, p)
                }
        })
    };
    return u(e),
    a.clear(),
    E0++,
    function() {
        o.forEach(function(h) {
            var d = Oa.get(h) - 1
              , f = s.get(h) - 1;
            Oa.set(h, d),
            s.set(h, f),
            d || (kd.has(h) || h.removeAttribute(r),
            kd.delete(h)),
            f || h.removeAttribute(n)
        }),
        E0--,
        E0 || (Oa = new WeakMap,
        Oa = new WeakMap,
        kd = new WeakMap,
        Rd = {})
    }
}
  , zm = function(t, e, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(t) ? t : [t])
      , i = ere(t);
    return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))),
    nre(r, i, n, "aria-hidden")) : function() {
        return null
    }
}
  , l1 = "Dialog"
  , [oL,rve] = cs(l1)
  , [rre,si] = oL(l1)
  , aL = t => {
    const {__scopeDialog: e, children: n, open: r, defaultOpen: i, onOpenChange: s, modal: o=!0} = t
      , a = S.useRef(null)
      , l = S.useRef(null)
      , [c=!1,u] = Go({
        prop: r,
        defaultProp: i,
        onChange: s
    });
    return v.jsx(rre, {
        scope: e,
        triggerRef: a,
        contentRef: l,
        contentId: Ci(),
        titleId: Ci(),
        descriptionId: Ci(),
        open: c,
        onOpenChange: u,
        onOpenToggle: S.useCallback( () => u(h => !h), [u]),
        modal: o,
        children: n
    })
}
;
aL.displayName = l1;
var lL = "DialogTrigger"
  , ire = S.forwardRef( (t, e) => {
    const {__scopeDialog: n, ...r} = t
      , i = si(lL, n)
      , s = rt(e, i.triggerRef);
    return v.jsx(We.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": h1(i.open),
        ...r,
        ref: s,
        onClick: Ee(t.onClick, i.onOpenToggle)
    })
}
);
ire.displayName = lL;
var c1 = "DialogPortal"
  , [sre,cL] = oL(c1, {
    forceMount: void 0
})
  , uL = t => {
    const {__scopeDialog: e, forceMount: n, children: r, container: i} = t
      , s = si(c1, e);
    return v.jsx(sre, {
        scope: e,
        forceMount: n,
        children: S.Children.map(r, o => v.jsx(Li, {
            present: n || s.open,
            children: v.jsx(Th, {
                asChild: !0,
                container: i,
                children: o
            })
        }))
    })
}
;
uL.displayName = c1;
var yp = "DialogOverlay"
  , hL = S.forwardRef( (t, e) => {
    const n = cL(yp, t.__scopeDialog)
      , {forceMount: r=n.forceMount, ...i} = t
      , s = si(yp, t.__scopeDialog);
    return s.modal ? v.jsx(Li, {
        present: r || s.open,
        children: v.jsx(ore, {
            ...i,
            ref: e
        })
    }) : null
}
);
hL.displayName = yp;
var ore = S.forwardRef( (t, e) => {
    const {__scopeDialog: n, ...r} = t
      , i = si(yp, n);
    return v.jsx($m, {
        as: Fs,
        allowPinchZoom: !0,
        shards: [i.contentRef],
        children: v.jsx(We.div, {
            "data-state": h1(i.open),
            ...r,
            ref: e,
            style: {
                pointerEvents: "auto",
                ...r.style
            }
        })
    })
}
)
  , ta = "DialogContent"
  , dL = S.forwardRef( (t, e) => {
    const n = cL(ta, t.__scopeDialog)
      , {forceMount: r=n.forceMount, ...i} = t
      , s = si(ta, t.__scopeDialog);
    return v.jsx(Li, {
        present: r || s.open,
        children: s.modal ? v.jsx(are, {
            ...i,
            ref: e
        }) : v.jsx(lre, {
            ...i,
            ref: e
        })
    })
}
);
dL.displayName = ta;
var are = S.forwardRef( (t, e) => {
    const n = si(ta, t.__scopeDialog)
      , r = S.useRef(null)
      , i = rt(e, n.contentRef, r);
    return S.useEffect( () => {
        const s = r.current;
        if (s)
            return zm(s)
    }
    , []),
    v.jsx(fL, {
        ...t,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ee(t.onCloseAutoFocus, s => {
            s.preventDefault(),
            n.triggerRef.current?.focus()
        }
        ),
        onPointerDownOutside: Ee(t.onPointerDownOutside, s => {
            const o = s.detail.originalEvent
              , a = o.button === 0 && o.ctrlKey === !0;
            (o.button === 2 || a) && s.preventDefault()
        }
        ),
        onFocusOutside: Ee(t.onFocusOutside, s => s.preventDefault())
    })
}
)
  , lre = S.forwardRef( (t, e) => {
    const n = si(ta, t.__scopeDialog)
      , r = S.useRef(!1)
      , i = S.useRef(!1);
    return v.jsx(fL, {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: s => {
            t.onCloseAutoFocus?.(s),
            s.defaultPrevented || (r.current || n.triggerRef.current?.focus(),
            s.preventDefault()),
            r.current = !1,
            i.current = !1
        }
        ,
        onInteractOutside: s => {
            t.onInteractOutside?.(s),
            s.defaultPrevented || (r.current = !0,
            s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
            const o = s.target;
            n.triggerRef.current?.contains(o) && s.preventDefault(),
            s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault()
        }
    })
}
)
  , fL = S.forwardRef( (t, e) => {
    const {__scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...o} = t
      , a = si(ta, n)
      , l = S.useRef(null)
      , c = rt(e, l);
    return o1(),
    v.jsxs(v.Fragment, {
        children: [v.jsx(Wh, {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: i,
            onUnmountAutoFocus: s,
            children: v.jsx(wh, {
                role: "dialog",
                id: a.contentId,
                "aria-describedby": a.descriptionId,
                "aria-labelledby": a.titleId,
                "data-state": h1(a.open),
                ...o,
                ref: c,
                onDismiss: () => a.onOpenChange(!1)
            })
        }), v.jsxs(v.Fragment, {
            children: [v.jsx(cre, {
                titleId: a.titleId
            }), v.jsx(hre, {
                contentRef: l,
                descriptionId: a.descriptionId
            })]
        })]
    })
}
)
  , u1 = "DialogTitle"
  , pL = S.forwardRef( (t, e) => {
    const {__scopeDialog: n, ...r} = t
      , i = si(u1, n);
    return v.jsx(We.h2, {
        id: i.titleId,
        ...r,
        ref: e
    })
}
);
pL.displayName = u1;
var mL = "DialogDescription"
  , gL = S.forwardRef( (t, e) => {
    const {__scopeDialog: n, ...r} = t
      , i = si(mL, n);
    return v.jsx(We.p, {
        id: i.descriptionId,
        ...r,
        ref: e
    })
}
);
gL.displayName = mL;
var _L = "DialogClose"
  , bL = S.forwardRef( (t, e) => {
    const {__scopeDialog: n, ...r} = t
      , i = si(_L, n);
    return v.jsx(We.button, {
        type: "button",
        ...r,
        ref: e,
        onClick: Ee(t.onClick, () => i.onOpenChange(!1))
    })
}
);
bL.displayName = _L;
function h1(t) {
    return t ? "open" : "closed"
}
var yL = "DialogTitleWarning"
  , [ive,vL] = q6(yL, {
    contentName: ta,
    titleName: u1,
    docsSlug: "dialog"
})
  , cre = ({titleId: t}) => {
    const e = vL(yL)
      , n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
    return S.useEffect( () => {
        t && (document.getElementById(t) || console.error(n))
    }
    , [n, t]),
    null
}
  , ure = "DialogDescriptionWarning"
  , hre = ({contentRef: t, descriptionId: e}) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${vL(ure).contentName}}.`;
    return S.useEffect( () => {
        const i = t.current?.getAttribute("aria-describedby");
        e && i && (document.getElementById(e) || console.warn(r))
    }
    , [r, t, e]),
    null
}
  , dre = aL
  , fre = uL
  , pre = hL
  , mre = dL
  , gre = pL
  , _re = gL
  , bre = bL;
const vp = {
    duration: .15,
    ease: Ft
}
  , yre = {
    closed: {
        opacity: 0,
        transition: vp
    },
    open: {
        opacity: 1,
        transition: vp
    }
}
  , vre = {
    closed: {
        x: "-50%",
        y: "-40%",
        scale: .96,
        opacity: 0,
        transition: vp
    },
    open: {
        x: "-50%",
        y: "-50%",
        scale: 1,
        opacity: 1,
        transition: vp
    }
}
  , Mu = S.memo( ({children: t}) => v.jsx("div", {
    className: "px-5 pb-4 bg-bolt-elements-background-depth-2 flex gap-2 justify-end",
    children: t
}))
  , Gi = S.memo( ({type: t, disabled: e=!1, minWidth: n, children: r, onClick: i}) => v.jsx("button", {
    disabled: e,
    className: be("inline-flex h-[35px] items-center justify-center rounded-lg px-4 text-sm leading-none focus:outline-none gap-2 disabled:cursor-not-allowed", {
        "bg-bolt-elements-button-primary-background text-bolt-elements-button-primary-text enabled:hover:bg-bolt-elements-button-primary-backgroundHover": t === "primary",
        "bg-bolt-elements-button-secondary-background text-bolt-elements-button-secondary-text enabled:hover:bg-bolt-elements-button-secondary-backgroundHover": t === "secondary",
        "bg-bolt-elements-button-danger-background text-bolt-elements-button-danger-text enabled:hover:bg-bolt-elements-button-danger-backgroundHover": t === "danger",
        "bg-bolt-elements-button-warn-background text-bolt-elements-button-warn-text enabled:hover:bg-bolt-elements-button-warn-backgroundHover": t === "warn"
    }),
    style: {
        ...n && {
            minWidth: typeof n == "string" ? n : `${n}px`
        }
    },
    onClick: i,
    children: r
}))
  , Os = S.memo( ({className: t, unstyled: e, children: n, ...r}) => v.jsx(gre, {
    className: be(e ? void 0 : "px-5 py-4 border-b border-bolt-elements-borderColor text-lg font-semibold leading-6 text-bolt-elements-textPrimary", t),
    ...r,
    children: n
}))
  , Ns = S.memo( ({className: t, unstyled: e=!1, noPadding: n=!1, children: r, ...i}) => v.jsx(_re, {
    className: be(e ? void 0 : "text-bolt-elements-textPrimary text-md", {
        "px-5 py-4": !e && !n
    }, t),
    asChild: !0,
    ...i,
    children: v.jsx("div", {
        children: r
    })
}))
  , Vo = S.memo( ({contentClassName: t, open: e=!1, width: n="90vw", maxWidth: r=450, maxHeight: i="85vh", showCloseButton: s=!0, closeOnBackdropClick: o=!0, unstyled: a=!1, children: l, onClose: c}) => (S.useEffect( () => {
    const u = h => {
        h.key === "Escape" && c?.(h)
    }
    ;
    return window.addEventListener("keydown", u),
    () => {
        window.removeEventListener("keydown", u)
    }
}
, [c]),
v.jsx(dre, {
    open: e,
    children: v.jsx(hs, {
        children: e && v.jsxs(fre, {
            forceMount: !0,
            children: [v.jsx(pre, {
                onClick: o ? c : void 0,
                asChild: !0,
                children: v.jsx(It.div, {
                    className: "bg-black/50 fixed inset-0 z-dialog",
                    initial: "closed",
                    animate: "open",
                    exit: "closed",
                    variants: yre
                })
            }), v.jsx(mre, {
                asChild: !0,
                children: v.jsxs(It.div, {
                    className: be("fixed top-[50%] left-[50%] z-max translate-x-[-50%] translate-y-[-50%] focus:outline-none overflow-hidden", a ? void 0 : "border border-bolt-elements-borderColor rounded-lg bg-bolt-elements-background-depth-2 shadow-lg", t),
                    style: {
                        width: typeof n == "string" ? n : `${n}px`,
                        maxWidth: typeof r == "string" ? r : `${r}px`,
                        maxHeight: typeof i == "string" ? i : `${i}px`
                    },
                    initial: "closed",
                    animate: "open",
                    exit: "closed",
                    variants: vre,
                    children: [l, s && v.jsx(bre, {
                        asChild: !0,
                        onClick: c,
                        children: v.jsx(tn, {
                            icon: "i-ph:x",
                            className: "absolute top-[10px] right-[10px]"
                        })
                    })]
                })
            })]
        })
    })
})))
  , na = S.memo(S.forwardRef( ({maxWidth: t, hideArrow: e, truncate: n, children: r, ...i}, s) => v.jsxs(O5, {
    ref: s,
    className: be("z-max text-xs bg-gray-950 text-white border border-bolt-elements-borderColor rounded-lg px-2 py-1.5 ", {
        truncate: n === !0 || n === void 0
    }),
    style: {
        ...t === void 0 ? void 0 : {
            maxWidth: typeof t == "string" ? t : `${t}px`
        }
    },
    ...i,
    children: [!e && v.jsx(Zk, {
        className: "dark:fill-bolt-elements-borderColor"
    }), r]
})))
  , xL = S.memo( ({attachment: t, allowRemove: e=!1, showWarning: n=!1, onRemove: r}) => {
    _r.trace("Attachment");
    const [{url: i, name: s, uploading: o, isImage: a, extension: l},c] = S.useState({
        url: "",
        uploading: !1,
        isImage: !1
    })
      , [u,h] = S.useState(!1)
      , [d,f] = S.useState(!1)
      , g = S.useRef(null)
      , _ = S.useRef(null)
      , m = S.useRef(null);
    return S.useEffect( () => () => {
        _.current && (URL.revokeObjectURL(_.current),
        _.current = null,
        g.current = null)
    }
    , []),
    S.useEffect( () => {
        if (lC(t)) {
            const p = t.file;
            if (p !== g.current) {
                _.current && URL.revokeObjectURL(_.current);
                const b = URL.createObjectURL(p);
                _.current = b,
                g.current = p,
                c({
                    url: b,
                    name: p.name,
                    uploading: t.uploading,
                    isImage: uC(t.file.type),
                    extension: cC(t.file.name)
                })
            } else
                c(b => ({
                    ...b,
                    uploading: t.uploading
                }))
        } else
            c(p => p.url === t.url ? p : {
                ...t,
                uploading: !1,
                isImage: uC(t.contentType),
                extension: cC(t.name)
            })
    }
    , [t]),
    S.useEffect( () => {
        if (!o && a) {
            const p = new Image;
            p.onload = () => {
                m.current = p,
                f(p.width * p.height < 1e4)
            }
            ,
            p.src = i
        }
    }
    , [i, o, a]),
    v.jsx(ga, {
        children: v.jsxs("div", {
            className: "relative",
            children: [v.jsxs("div", {
                className: "relative flex rounded-lg border border-bolt-elements-borderColor overflow-hidden",
                children: [o ? v.jsx("div", {
                    className: "h-20 w-20"
                }) : v.jsxs(Vs, {
                    delayDuration: 0,
                    children: [v.jsx(qo, {
                        asChild: !0,
                        children: v.jsx("button", {
                            className: "h-20 w-20 bg-transparent outline-none",
                            disabled: !a,
                            onClick: () => h(!u),
                            children: a ? v.jsx("img", {
                                src: i,
                                alt: s,
                                className: "w-full h-full object-cover"
                            }) : v.jsxs("div", {
                                className: "w-full h-full flex flex-col items-center justify-center gap-1.5 text-xs overflow-hidden bg-bolt-elements-background-depth-2",
                                children: [l ? v.jsx("div", {
                                    className: "uppercase bg-alpha-accent-20 dark:bg-alpha-accent-20 rounded-full px-2 py-0.5 text-xs text-accent-600",
                                    children: l
                                }) : v.jsx("div", {
                                    className: "i-ph:file-duotone text-xl"
                                }), v.jsx("div", {
                                    className: "truncate max-w-[80%]",
                                    children: s
                                })]
                            })
                        })
                    }), v.jsx(Ko, {
                        children: v.jsx(na, {
                            side: "bottom",
                            align: "center",
                            sideOffset: 6,
                            maxWidth: 180,
                            children: s
                        })
                    })]
                }), v.jsx(hs, {
                    children: o && v.jsx(It.div, {
                        className: "absolute flex items-center justify-center inset-0 bg-bolt-elements-prompt-attachments-backgroundLoading text-bolt-elements-textPrimary",
                        exit: {
                            opacity: 0
                        },
                        transition: {
                            duration: .2,
                            ease: Ft
                        },
                        children: v.jsx("div", {
                            className: "i-svg-spinners:90-ring-with-bg text-lg"
                        })
                    })
                })]
            }), e && v.jsx("button", {
                onClick: () => {
                    lC(t) && r?.(t)
                }
                ,
                className: "absolute top-0 right-0 -translate-y-1/2 translate-x-1/2 rounded-full w-[18px] h-[18px] flex items-center justify-center z-1 bg-bolt-elements-prompt-attachments-button-background hover:bg-bolt-elements-prompt-attachments-button-backgroundHover border border-bolt-elements-borderColor text-bolt-elements-prompt-attachments-button-text hover:text-bolt-elements-prompt-attachments-button-textHover",
                children: v.jsx("div", {
                    className: "i-ph:x scale-70"
                })
            }), n && a && d && v.jsx("div", {
                className: "absolute flex items-center justify-center -right-[9px] -bottom-[8px] rounded-full bg-bolt-elements-background-depth-1",
                children: v.jsxs(Vs, {
                    delayDuration: 0,
                    children: [v.jsx(qo, {
                        asChild: !0,
                        children: v.jsx("div", {
                            className: "i-ph:warning-circle-fill text-orange-500 text-xl"
                        })
                    }), v.jsx(Ko, {
                        children: v.jsx(na, {
                            side: "bottom",
                            align: "start",
                            sideOffset: 4,
                            alignOffset: -16,
                            maxWidth: 186,
                            truncate: !1,
                            children: "Attach an image with a higher resolution for better results"
                        })
                    })]
                })
            }), v.jsxs(Vo, {
                open: u,
                showCloseButton: !1,
                contentClassName: "flex flex-col items-center",
                unstyled: !0,
                width: "auto",
                maxWidth: "100%",
                maxHeight: "100%",
                onClose: () => h(!1),
                children: [v.jsx(Ns, {
                    className: "max-h-[75vh] max-w-[80vw] rounded-lg overflow-hidden",
                    unstyled: !0,
                    style: m.current ? {
                        aspectRatio: m.current.width / m.current.height
                    } : void 0,
                    children: v.jsx("img", {
                        className: "h-full w-full object-container",
                        src: i,
                        alt: s
                    })
                }), v.jsx(Os, {
                    className: "text-white text-sm mt-2.5 text-center",
                    unstyled: !0,
                    children: s
                })]
            })]
        })
    })
}
);
function lC(t) {
    return "file"in t
}
function cC(t) {
    const e = t?.split(".");
    if (!(!e || e.length === 1))
        return e.at(-1)
}
function uC(t) {
    return t?.startsWith("image/") ?? !1
}
const hC = {
    duration: .2,
    ease: Ft
}
  , xre = {
    closed: {
        height: 0,
        opacity: 0,
        transition: hC
    },
    open: {
        height: "auto",
        opacity: 1,
        transition: hC
    }
}
  , EL = S.memo( ({className: t, itemClassName: e, buttonClassName: n, allowDelete: r, fileSelections: i=[], onFileSelectionDelete: s}) => {
    const [o,a] = S.useState(new Set)
      , l = c => {
        const u = new Set(o);
        o.has(c) ? u.delete(c) : u.add(c),
        a(u)
    }
    ;
    return i.length === 0 ? null : v.jsx(v.Fragment, {
        children: v.jsx("div", {
            className: be("file-selections", t),
            children: v.jsx("div", {
                className: "flex flex-col space-y-2",
                children: i.map( ({filePath: c, text: u}, h) => {
                    const d = c.split(".").at(-1)
                      , f = o.has(h);
                    return v.jsxs("div", {
                        className: "border border-bolt-elements-borderColor rounded-lg overflow-hidden",
                        children: [v.jsxs("div", {
                            className: be("flex items-center pr-1", e),
                            children: [v.jsxs("button", {
                                className: be("bg-transparent w-full flex items-center", n),
                                onClick: () => l(h),
                                children: [v.jsxs("div", {
                                    className: "flex-1 flex items-center gap-1 text-left text-sm px-2 py-1",
                                    children: [v.jsx("div", {
                                        className: "i-ph:file-duotone"
                                    }), c.replace(`${jt}/`, "")]
                                }), v.jsx("span", {
                                    className: be("cursor-pointer", {
                                        "i-ph:caret-down": f,
                                        "i-ph:caret-right": !f
                                    })
                                })]
                            }), r && v.jsx(tn, {
                                className: "ml-0.5",
                                icon: "i-ph:x",
                                size: "sm",
                                onClick: () => s?.(h)
                            })]
                        }), v.jsxs(It.div, {
                            initial: "closed",
                            animate: f ? "open" : "closed",
                            exit: "closed",
                            variants: xre,
                            className: "text-xs",
                            children: [v.jsx("div", {
                                className: "h-[1px] bg-bolt-elements-borderColor"
                            }), v.jsx("div", {
                                className: "p-4 bg-bolt-elements-messages-code-background max-h-[250px] overflow-y-auto",
                                children: v.jsx(NP, {
                                    code: u,
                                    language: d,
                                    disableCopy: !0
                                })
                            })]
                        })]
                    }, h)
                }
                )
            })
        })
    })
}
);
function Ere({content: t, attachments: e, fileSelections: n, className: r}) {
    return v.jsxs("div", {
        className: be("overflow-hidden", r),
        children: [e && e.length > 0 && v.jsx(v.Fragment, {
            children: v.jsx("div", {
                className: "flex gap-3.5 mb-4",
                children: e?.map(i => v.jsx(xL, {
                    attachment: i
                }, i.url))
            })
        }), v.jsx(EL, {
            className: "mb-4",
            itemClassName: "bg-bolt-elements-messages-selections-background",
            buttonClassName: "text-bolt-elements-messages-selections-text hover:text-bolt-elements-messages-selections-textHover",
            fileSelections: n
        }), v.jsx(s1, {
            limitedMarkdown: !0,
            html: !0,
            children: t
        })]
    })
}
const S0 = {
    scale: 1,
    background: "var(--bolt-elements-messages-counter-background)"
};
function SL({children: t, className: e, onChange: n}) {
    const r = gU()
      , i = S.useRef(null)
      , s = Ie(da);
    return Rh( () => {
        if (i.current == null || i.current === t) {
            i.current = t;
            return
        }
        n?.(i.current),
        i.current = t,
        r.set(S0),
        r.start({
            scale: 1.25,
            background: "var(--bolt-elements-messages-counter-backgroundPulse)"
        }, {
            duration: .05
        }).then(async () => {
            o || await r.start(S0, {
                duration: .2
            })
        }
        );
        let o = !1;
        return () => {
            o = !0,
            r.stop()
        }
    }
    , [t, s]),
    v.jsx(It.div, {
        className: be("flex shrink-0 leading-6 justify-center items-center rounded-full w-6 h-6", t >= 100 ? "text-[10px]" : "text-xs", e),
        style: S0,
        animate: r,
        children: t
    })
}
const Sre = "_PreviewError_1lprf_1"
  , dC = {
    PreviewError: Sre
}
  , wre = S.lazy( () => K( () => import("./ConsoleInspector-CScDT6Zw.js"), __vite__mapDeps([114, 115, 116, 117, 118])))
  , Cre = /^ /gm;
function Tre({count: t, error: e}) {
    let n = null
      , r = "message"in e ? e.message : null;
    if ("stack"in e && e.stack) {
        const i = e.stack.split(`
`);
        r = i.shift() ?? r,
        n = i.join(`
`)
    }
    return e.type === Mo.ConsoleError && (r = v.jsx(wre, {
        ...e
    })),
    v.jsxs("div", {
        className: "flex items-center px-3 py-4 gap-3 text-sm rounded-lg bg-bolt-elements-messages-background font-mono leading-4.5",
        children: [v.jsx(SL, {
            className: "mb-auto",
            children: t
        }), n ? v.jsxs("details", {
            className: "w-full overflow-hidden",
            onClick: i => {
                const s = i.target
                  , o = i.currentTarget
                  , a = s.closest("li[role=treeitem]");
                if (!a)
                    return;
                const l = a?.ariaExpanded;
                requestAnimationFrame( () => {
                    a.ariaExpanded !== l && (o.open = !o.open)
                }
                )
            }
            ,
            children: [v.jsx("summary", {
                className: be(dC.PreviewError, "cursor-pointer ![&_*]:cursor-pointer"),
                children: v.jsx("div", {
                    className: "ml-2",
                    children: r
                })
            }), v.jsx("pre", {
                className: "overflow-scroll mt-1.5 text-bolt-elements-textSecondary text-[0.6rem] leading-4",
                children: n.replace(Cre, "")
            })]
        }) : v.jsx("div", {
            className: dC.PreviewError,
            children: r
        })]
    })
}
var wL = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    }
    )(self, () => ( () => {
        var n = {};
        return ( () => {
            var r = n;
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.FitAddon = void 0,
            r.FitAddon = class {
                activate(i) {
                    this._terminal = i
                }
                dispose() {}
                fit() {
                    const i = this.proposeDimensions();
                    if (!i || !this._terminal || isNaN(i.cols) || isNaN(i.rows))
                        return;
                    const s = this._terminal._core;
                    this._terminal.rows === i.rows && this._terminal.cols === i.cols || (s._renderService.clear(),
                    this._terminal.resize(i.cols, i.rows))
                }
                proposeDimensions() {
                    if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement)
                        return;
                    const i = this._terminal._core
                      , s = i._renderService.dimensions;
                    if (s.css.cell.width === 0 || s.css.cell.height === 0)
                        return;
                    const o = this._terminal.options.scrollback === 0 ? 0 : i.viewport.scrollBarWidth
                      , a = window.getComputedStyle(this._terminal.element.parentElement)
                      , l = parseInt(a.getPropertyValue("height"))
                      , c = Math.max(0, parseInt(a.getPropertyValue("width")))
                      , u = window.getComputedStyle(this._terminal.element)
                      , h = l - (parseInt(u.getPropertyValue("padding-top")) + parseInt(u.getPropertyValue("padding-bottom")))
                      , d = c - (parseInt(u.getPropertyValue("padding-right")) + parseInt(u.getPropertyValue("padding-left"))) - o;
                    return {
                        cols: Math.max(2, Math.floor(d / s.css.cell.width)),
                        rows: Math.max(1, Math.floor(h / s.css.cell.height))
                    }
                }
            }
        }
        )(),
        n
    }
    )())
}
)(wL);
var Are = wL.exports
  , CL = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    }
    )(self, () => ( () => {
        var n = {
            6: (o, a) => {
                function l(u) {
                    try {
                        const h = new URL(u)
                          , d = h.password && h.username ? `${h.protocol}//${h.username}:${h.password}@${h.host}` : h.username ? `${h.protocol}//${h.username}@${h.host}` : `${h.protocol}//${h.host}`;
                        return u.toLocaleLowerCase().startsWith(d.toLocaleLowerCase())
                    } catch {
                        return !1
                    }
                }
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.LinkComputer = a.WebLinkProvider = void 0,
                a.WebLinkProvider = class {
                    constructor(u, h, d, f={}) {
                        this._terminal = u,
                        this._regex = h,
                        this._handler = d,
                        this._options = f
                    }
                    provideLinks(u, h) {
                        const d = c.computeLink(u, this._regex, this._terminal, this._handler);
                        h(this._addCallbacks(d))
                    }
                    _addCallbacks(u) {
                        return u.map(h => (h.leave = this._options.leave,
                        h.hover = (d, f) => {
                            if (this._options.hover) {
                                const {range: g} = h;
                                this._options.hover(d, f, g)
                            }
                        }
                        ,
                        h))
                    }
                }
                ;
                class c {
                    static computeLink(h, d, f, g) {
                        const _ = new RegExp(d.source,(d.flags || "") + "g")
                          , [m,p] = c._getWindowedLineStrings(h - 1, f)
                          , b = m.join("");
                        let y;
                        const x = [];
                        for (; y = _.exec(b); ) {
                            const E = y[0];
                            if (!l(E))
                                continue;
                            const [w,A] = c._mapStrIdx(f, p, 0, y.index)
                              , [C,k] = c._mapStrIdx(f, w, A, E.length);
                            if (w === -1 || A === -1 || C === -1 || k === -1)
                                continue;
                            const I = {
                                start: {
                                    x: A + 1,
                                    y: w + 1
                                },
                                end: {
                                    x: k,
                                    y: C + 1
                                }
                            };
                            x.push({
                                range: I,
                                text: E,
                                activate: g
                            })
                        }
                        return x
                    }
                    static _getWindowedLineStrings(h, d) {
                        let f, g = h, _ = h, m = 0, p = "";
                        const b = [];
                        if (f = d.buffer.active.getLine(h)) {
                            const y = f.translateToString(!0);
                            if (f.isWrapped && y[0] !== " ") {
                                for (m = 0; (f = d.buffer.active.getLine(--g)) && m < 2048 && (p = f.translateToString(!0),
                                m += p.length,
                                b.push(p),
                                f.isWrapped && p.indexOf(" ") === -1); )
                                    ;
                                b.reverse()
                            }
                            for (b.push(y),
                            m = 0; (f = d.buffer.active.getLine(++_)) && f.isWrapped && m < 2048 && (p = f.translateToString(!0),
                            m += p.length,
                            b.push(p),
                            p.indexOf(" ") === -1); )
                                ;
                        }
                        return [b, g]
                    }
                    static _mapStrIdx(h, d, f, g) {
                        const _ = h.buffer.active
                          , m = _.getNullCell();
                        let p = f;
                        for (; g; ) {
                            const b = _.getLine(d);
                            if (!b)
                                return [-1, -1];
                            for (let y = p; y < b.length; ++y) {
                                b.getCell(y, m);
                                const x = m.getChars();
                                if (m.getWidth() && (g -= x.length || 1,
                                y === b.length - 1 && x === "")) {
                                    const E = _.getLine(d + 1);
                                    E && E.isWrapped && (E.getCell(0, m),
                                    m.getWidth() === 2 && (g += 1))
                                }
                                if (g < 0)
                                    return [d, y]
                            }
                            d++,
                            p = 0
                        }
                        return [d, p]
                    }
                }
                a.LinkComputer = c
            }
        }
          , r = {};
        function i(o) {
            var a = r[o];
            if (a !== void 0)
                return a.exports;
            var l = r[o] = {
                exports: {}
            };
            return n[o](l, l.exports, i),
            l.exports
        }
        var s = {};
        return ( () => {
            var o = s;
            Object.defineProperty(o, "__esModule", {
                value: !0
            }),
            o.WebLinksAddon = void 0;
            const a = i(6)
              , l = /(https?|HTTPS?):[/]{2}[^\s"'!*(){}|\\\^<>`]*[^\s"':,.!?{}|\\\^~\[\]`()<>]/;
            function c(u, h) {
                const d = window.open();
                if (d) {
                    try {
                        d.opener = null
                    } catch {}
                    d.location.href = h
                } else
                    console.warn("Opening link blocked as opener could not be cleared")
            }
            o.WebLinksAddon = class {
                constructor(u=c, h={}) {
                    this._handler = u,
                    this._options = h
                }
                activate(u) {
                    this._terminal = u;
                    const h = this._options
                      , d = h.urlRegex || l;
                    this._linkProvider = this._terminal.registerLinkProvider(new a.WebLinkProvider(this._terminal,d,this._handler,h))
                }
                dispose() {
                    this._linkProvider?.dispose()
                }
            }
        }
        )(),
        s
    }
    )())
}
)(CL);
var kre = CL.exports
  , TL = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    }
    )(globalThis, () => ( () => {
        var n = {
            4567: function(o, a, l) {
                var c = this && this.__decorate || function(b, y, x, E) {
                    var w, A = arguments.length, C = A < 3 ? y : E === null ? E = Object.getOwnPropertyDescriptor(y, x) : E;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        C = Reflect.decorate(b, y, x, E);
                    else
                        for (var k = b.length - 1; k >= 0; k--)
                            (w = b[k]) && (C = (A < 3 ? w(C) : A > 3 ? w(y, x, C) : w(y, x)) || C);
                    return A > 3 && C && Object.defineProperty(y, x, C),
                    C
                }
                  , u = this && this.__param || function(b, y) {
                    return function(x, E) {
                        y(x, E, b)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.AccessibilityManager = void 0;
                const h = l(9042)
                  , d = l(9924)
                  , f = l(844)
                  , g = l(4725)
                  , _ = l(2585)
                  , m = l(3656);
                let p = a.AccessibilityManager = class extends f.Disposable {
                    constructor(b, y, x, E) {
                        super(),
                        this._terminal = b,
                        this._coreBrowserService = x,
                        this._renderService = E,
                        this._rowColumns = new WeakMap,
                        this._liveRegionLineCount = 0,
                        this._charsToConsume = [],
                        this._charsToAnnounce = "",
                        this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"),
                        this._accessibilityContainer.classList.add("xterm-accessibility"),
                        this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"),
                        this._rowContainer.setAttribute("role", "list"),
                        this._rowContainer.classList.add("xterm-accessibility-tree"),
                        this._rowElements = [];
                        for (let w = 0; w < this._terminal.rows; w++)
                            this._rowElements[w] = this._createAccessibilityTreeNode(),
                            this._rowContainer.appendChild(this._rowElements[w]);
                        if (this._topBoundaryFocusListener = w => this._handleBoundaryFocus(w, 0),
                        this._bottomBoundaryFocusListener = w => this._handleBoundaryFocus(w, 1),
                        this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener),
                        this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener),
                        this._refreshRowsDimensions(),
                        this._accessibilityContainer.appendChild(this._rowContainer),
                        this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"),
                        this._liveRegion.classList.add("live-region"),
                        this._liveRegion.setAttribute("aria-live", "assertive"),
                        this._accessibilityContainer.appendChild(this._liveRegion),
                        this._liveRegionDebouncer = this.register(new d.TimeBasedDebouncer(this._renderRows.bind(this))),
                        !this._terminal.element)
                            throw new Error("Cannot enable accessibility before Terminal.open");
                        this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer),
                        this.register(this._terminal.onResize(w => this._handleResize(w.rows))),
                        this.register(this._terminal.onRender(w => this._refreshRows(w.start, w.end))),
                        this.register(this._terminal.onScroll( () => this._refreshRows())),
                        this.register(this._terminal.onA11yChar(w => this._handleChar(w))),
                        this.register(this._terminal.onLineFeed( () => this._handleChar(`
`))),
                        this.register(this._terminal.onA11yTab(w => this._handleTab(w))),
                        this.register(this._terminal.onKey(w => this._handleKey(w.key))),
                        this.register(this._terminal.onBlur( () => this._clearLiveRegion())),
                        this.register(this._renderService.onDimensionsChange( () => this._refreshRowsDimensions())),
                        this.register((0,
                        m.addDisposableDomListener)(document, "selectionchange", () => this._handleSelectionChange())),
                        this.register(this._coreBrowserService.onDprChange( () => this._refreshRowsDimensions())),
                        this._refreshRows(),
                        this.register((0,
                        f.toDisposable)( () => {
                            this._accessibilityContainer.remove(),
                            this._rowElements.length = 0
                        }
                        ))
                    }
                    _handleTab(b) {
                        for (let y = 0; y < b; y++)
                            this._handleChar(" ")
                    }
                    _handleChar(b) {
                        this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== b && (this._charsToAnnounce += b) : this._charsToAnnounce += b,
                        b === `
` && (this._liveRegionLineCount++,
                        this._liveRegionLineCount === 21 && (this._liveRegion.textContent += h.tooMuchOutput)))
                    }
                    _clearLiveRegion() {
                        this._liveRegion.textContent = "",
                        this._liveRegionLineCount = 0
                    }
                    _handleKey(b) {
                        this._clearLiveRegion(),
                        /\p{Control}/u.test(b) || this._charsToConsume.push(b)
                    }
                    _refreshRows(b, y) {
                        this._liveRegionDebouncer.refresh(b, y, this._terminal.rows)
                    }
                    _renderRows(b, y) {
                        const x = this._terminal.buffer
                          , E = x.lines.length.toString();
                        for (let w = b; w <= y; w++) {
                            const A = x.lines.get(x.ydisp + w)
                              , C = []
                              , k = A?.translateToString(!0, void 0, void 0, C) || ""
                              , I = (x.ydisp + w + 1).toString()
                              , N = this._rowElements[w];
                            N && (k.length === 0 ? (N.innerText = "",
                            this._rowColumns.set(N, [0, 1])) : (N.textContent = k,
                            this._rowColumns.set(N, C)),
                            N.setAttribute("aria-posinset", I),
                            N.setAttribute("aria-setsize", E))
                        }
                        this._announceCharacters()
                    }
                    _announceCharacters() {
                        this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce,
                        this._charsToAnnounce = "")
                    }
                    _handleBoundaryFocus(b, y) {
                        const x = b.target
                          , E = this._rowElements[y === 0 ? 1 : this._rowElements.length - 2];
                        if (x.getAttribute("aria-posinset") === (y === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || b.relatedTarget !== E)
                            return;
                        let w, A;
                        if (y === 0 ? (w = x,
                        A = this._rowElements.pop(),
                        this._rowContainer.removeChild(A)) : (w = this._rowElements.shift(),
                        A = x,
                        this._rowContainer.removeChild(w)),
                        w.removeEventListener("focus", this._topBoundaryFocusListener),
                        A.removeEventListener("focus", this._bottomBoundaryFocusListener),
                        y === 0) {
                            const C = this._createAccessibilityTreeNode();
                            this._rowElements.unshift(C),
                            this._rowContainer.insertAdjacentElement("afterbegin", C)
                        } else {
                            const C = this._createAccessibilityTreeNode();
                            this._rowElements.push(C),
                            this._rowContainer.appendChild(C)
                        }
                        this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener),
                        this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener),
                        this._terminal.scrollLines(y === 0 ? -1 : 1),
                        this._rowElements[y === 0 ? 1 : this._rowElements.length - 2].focus(),
                        b.preventDefault(),
                        b.stopImmediatePropagation()
                    }
                    _handleSelectionChange() {
                        if (this._rowElements.length === 0)
                            return;
                        const b = document.getSelection();
                        if (!b)
                            return;
                        if (b.isCollapsed)
                            return void (this._rowContainer.contains(b.anchorNode) && this._terminal.clearSelection());
                        if (!b.anchorNode || !b.focusNode)
                            return void console.error("anchorNode and/or focusNode are null");
                        let y = {
                            node: b.anchorNode,
                            offset: b.anchorOffset
                        }
                          , x = {
                            node: b.focusNode,
                            offset: b.focusOffset
                        };
                        if ((y.node.compareDocumentPosition(x.node) & Node.DOCUMENT_POSITION_PRECEDING || y.node === x.node && y.offset > x.offset) && ([y,x] = [x, y]),
                        y.node.compareDocumentPosition(this._rowElements[0]) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING) && (y = {
                            node: this._rowElements[0].childNodes[0],
                            offset: 0
                        }),
                        !this._rowContainer.contains(y.node))
                            return;
                        const E = this._rowElements.slice(-1)[0];
                        if (x.node.compareDocumentPosition(E) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_PRECEDING) && (x = {
                            node: E,
                            offset: E.textContent?.length ?? 0
                        }),
                        !this._rowContainer.contains(x.node))
                            return;
                        const w = ({node: k, offset: I}) => {
                            const N = k instanceof Text ? k.parentNode : k;
                            let O = parseInt(N?.getAttribute("aria-posinset"), 10) - 1;
                            if (isNaN(O))
                                return console.warn("row is invalid. Race condition?"),
                                null;
                            const M = this._rowColumns.get(N);
                            if (!M)
                                return console.warn("columns is null. Race condition?"),
                                null;
                            let H = I < M.length ? M[I] : M.slice(-1)[0] + 1;
                            return H >= this._terminal.cols && (++O,
                            H = 0),
                            {
                                row: O,
                                column: H
                            }
                        }
                          , A = w(y)
                          , C = w(x);
                        if (A && C) {
                            if (A.row > C.row || A.row === C.row && A.column >= C.column)
                                throw new Error("invalid range");
                            this._terminal.select(A.column, A.row, (C.row - A.row) * this._terminal.cols - A.column + C.column)
                        }
                    }
                    _handleResize(b) {
                        this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
                        for (let y = this._rowContainer.children.length; y < this._terminal.rows; y++)
                            this._rowElements[y] = this._createAccessibilityTreeNode(),
                            this._rowContainer.appendChild(this._rowElements[y]);
                        for (; this._rowElements.length > b; )
                            this._rowContainer.removeChild(this._rowElements.pop());
                        this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener),
                        this._refreshRowsDimensions()
                    }
                    _createAccessibilityTreeNode() {
                        const b = this._coreBrowserService.mainDocument.createElement("div");
                        return b.setAttribute("role", "listitem"),
                        b.tabIndex = -1,
                        this._refreshRowDimensions(b),
                        b
                    }
                    _refreshRowsDimensions() {
                        if (this._renderService.dimensions.css.cell.height) {
                            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`,
                            this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
                            for (let b = 0; b < this._terminal.rows; b++)
                                this._refreshRowDimensions(this._rowElements[b])
                        }
                    }
                    _refreshRowDimensions(b) {
                        b.style.height = `${this._renderService.dimensions.css.cell.height}px`
                    }
                }
                ;
                a.AccessibilityManager = p = c([u(1, _.IInstantiationService), u(2, g.ICoreBrowserService), u(3, g.IRenderService)], p)
            },
            3614: (o, a) => {
                function l(d) {
                    return d.replace(/\r?\n/g, "\r")
                }
                function c(d, f) {
                    return f ? "\x1B[200~" + d + "\x1B[201~" : d
                }
                function u(d, f, g, _) {
                    d = c(d = l(d), g.decPrivateModes.bracketedPasteMode && _.rawOptions.ignoreBracketedPasteMode !== !0),
                    g.triggerDataEvent(d, !0),
                    f.value = ""
                }
                function h(d, f, g) {
                    const _ = g.getBoundingClientRect()
                      , m = d.clientX - _.left - 10
                      , p = d.clientY - _.top - 10;
                    f.style.width = "20px",
                    f.style.height = "20px",
                    f.style.left = `${m}px`,
                    f.style.top = `${p}px`,
                    f.style.zIndex = "1000",
                    f.focus()
                }
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.rightClickHandler = a.moveTextAreaUnderMouseCursor = a.paste = a.handlePasteEvent = a.copyHandler = a.bracketTextForPaste = a.prepareTextForTerminal = void 0,
                a.prepareTextForTerminal = l,
                a.bracketTextForPaste = c,
                a.copyHandler = function(d, f) {
                    d.clipboardData && d.clipboardData.setData("text/plain", f.selectionText),
                    d.preventDefault()
                }
                ,
                a.handlePasteEvent = function(d, f, g, _) {
                    d.stopPropagation(),
                    d.clipboardData && u(d.clipboardData.getData("text/plain"), f, g, _)
                }
                ,
                a.paste = u,
                a.moveTextAreaUnderMouseCursor = h,
                a.rightClickHandler = function(d, f, g, _, m) {
                    h(d, f, g),
                    m && _.rightClickSelect(d),
                    f.value = _.selectionText,
                    f.select()
                }
            }
            ,
            7239: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.ColorContrastCache = void 0;
                const c = l(1505);
                a.ColorContrastCache = class {
                    constructor() {
                        this._color = new c.TwoKeyMap,
                        this._css = new c.TwoKeyMap
                    }
                    setCss(u, h, d) {
                        this._css.set(u, h, d)
                    }
                    getCss(u, h) {
                        return this._css.get(u, h)
                    }
                    setColor(u, h, d) {
                        this._color.set(u, h, d)
                    }
                    getColor(u, h) {
                        return this._color.get(u, h)
                    }
                    clear() {
                        this._color.clear(),
                        this._css.clear()
                    }
                }
            }
            ,
            3656: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.addDisposableDomListener = void 0,
                a.addDisposableDomListener = function(l, c, u, h) {
                    l.addEventListener(c, u, h);
                    let d = !1;
                    return {
                        dispose: () => {
                            d || (d = !0,
                            l.removeEventListener(c, u, h))
                        }
                    }
                }
            }
            ,
            3551: function(o, a, l) {
                var c = this && this.__decorate || function(p, b, y, x) {
                    var E, w = arguments.length, A = w < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, y) : x;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        A = Reflect.decorate(p, b, y, x);
                    else
                        for (var C = p.length - 1; C >= 0; C--)
                            (E = p[C]) && (A = (w < 3 ? E(A) : w > 3 ? E(b, y, A) : E(b, y)) || A);
                    return w > 3 && A && Object.defineProperty(b, y, A),
                    A
                }
                  , u = this && this.__param || function(p, b) {
                    return function(y, x) {
                        b(y, x, p)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Linkifier = void 0;
                const h = l(3656)
                  , d = l(8460)
                  , f = l(844)
                  , g = l(2585)
                  , _ = l(4725);
                let m = a.Linkifier = class extends f.Disposable {
                    get currentLink() {
                        return this._currentLink
                    }
                    constructor(p, b, y, x, E) {
                        super(),
                        this._element = p,
                        this._mouseService = b,
                        this._renderService = y,
                        this._bufferService = x,
                        this._linkProviderService = E,
                        this._linkCacheDisposables = [],
                        this._isMouseOut = !0,
                        this._wasResized = !1,
                        this._activeLine = -1,
                        this._onShowLinkUnderline = this.register(new d.EventEmitter),
                        this.onShowLinkUnderline = this._onShowLinkUnderline.event,
                        this._onHideLinkUnderline = this.register(new d.EventEmitter),
                        this.onHideLinkUnderline = this._onHideLinkUnderline.event,
                        this.register((0,
                        f.getDisposeArrayDisposable)(this._linkCacheDisposables)),
                        this.register((0,
                        f.toDisposable)( () => {
                            this._lastMouseEvent = void 0,
                            this._activeProviderReplies?.clear()
                        }
                        )),
                        this.register(this._bufferService.onResize( () => {
                            this._clearCurrentLink(),
                            this._wasResized = !0
                        }
                        )),
                        this.register((0,
                        h.addDisposableDomListener)(this._element, "mouseleave", () => {
                            this._isMouseOut = !0,
                            this._clearCurrentLink()
                        }
                        )),
                        this.register((0,
                        h.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))),
                        this.register((0,
                        h.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))),
                        this.register((0,
                        h.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)))
                    }
                    _handleMouseMove(p) {
                        this._lastMouseEvent = p;
                        const b = this._positionFromMouseEvent(p, this._element, this._mouseService);
                        if (!b)
                            return;
                        this._isMouseOut = !1;
                        const y = p.composedPath();
                        for (let x = 0; x < y.length; x++) {
                            const E = y[x];
                            if (E.classList.contains("xterm"))
                                break;
                            if (E.classList.contains("xterm-hover"))
                                return
                        }
                        this._lastBufferCell && b.x === this._lastBufferCell.x && b.y === this._lastBufferCell.y || (this._handleHover(b),
                        this._lastBufferCell = b)
                    }
                    _handleHover(p) {
                        if (this._activeLine !== p.y || this._wasResized)
                            return this._clearCurrentLink(),
                            this._askForLink(p, !1),
                            void (this._wasResized = !1);
                        this._currentLink && this._linkAtPosition(this._currentLink.link, p) || (this._clearCurrentLink(),
                        this._askForLink(p, !0))
                    }
                    _askForLink(p, b) {
                        this._activeProviderReplies && b || (this._activeProviderReplies?.forEach(x => {
                            x?.forEach(E => {
                                E.link.dispose && E.link.dispose()
                            }
                            )
                        }
                        ),
                        this._activeProviderReplies = new Map,
                        this._activeLine = p.y);
                        let y = !1;
                        for (const [x,E] of this._linkProviderService.linkProviders.entries())
                            b ? this._activeProviderReplies?.get(x) && (y = this._checkLinkProviderResult(x, p, y)) : E.provideLinks(p.y, w => {
                                if (this._isMouseOut)
                                    return;
                                const A = w?.map(C => ({
                                    link: C
                                }));
                                this._activeProviderReplies?.set(x, A),
                                y = this._checkLinkProviderResult(x, p, y),
                                this._activeProviderReplies?.size === this._linkProviderService.linkProviders.length && this._removeIntersectingLinks(p.y, this._activeProviderReplies)
                            }
                            )
                    }
                    _removeIntersectingLinks(p, b) {
                        const y = new Set;
                        for (let x = 0; x < b.size; x++) {
                            const E = b.get(x);
                            if (E)
                                for (let w = 0; w < E.length; w++) {
                                    const A = E[w]
                                      , C = A.link.range.start.y < p ? 0 : A.link.range.start.x
                                      , k = A.link.range.end.y > p ? this._bufferService.cols : A.link.range.end.x;
                                    for (let I = C; I <= k; I++) {
                                        if (y.has(I)) {
                                            E.splice(w--, 1);
                                            break
                                        }
                                        y.add(I)
                                    }
                                }
                        }
                    }
                    _checkLinkProviderResult(p, b, y) {
                        if (!this._activeProviderReplies)
                            return y;
                        const x = this._activeProviderReplies.get(p);
                        let E = !1;
                        for (let w = 0; w < p; w++)
                            this._activeProviderReplies.has(w) && !this._activeProviderReplies.get(w) || (E = !0);
                        if (!E && x) {
                            const w = x.find(A => this._linkAtPosition(A.link, b));
                            w && (y = !0,
                            this._handleNewLink(w))
                        }
                        if (this._activeProviderReplies.size === this._linkProviderService.linkProviders.length && !y)
                            for (let w = 0; w < this._activeProviderReplies.size; w++) {
                                const A = this._activeProviderReplies.get(w)?.find(C => this._linkAtPosition(C.link, b));
                                if (A) {
                                    y = !0,
                                    this._handleNewLink(A);
                                    break
                                }
                            }
                        return y
                    }
                    _handleMouseDown() {
                        this._mouseDownLink = this._currentLink
                    }
                    _handleMouseUp(p) {
                        if (!this._currentLink)
                            return;
                        const b = this._positionFromMouseEvent(p, this._element, this._mouseService);
                        b && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, b) && this._currentLink.link.activate(p, this._currentLink.link.text)
                    }
                    _clearCurrentLink(p, b) {
                        this._currentLink && this._lastMouseEvent && (!p || !b || this._currentLink.link.range.start.y >= p && this._currentLink.link.range.end.y <= b) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent),
                        this._currentLink = void 0,
                        (0,
                        f.disposeArray)(this._linkCacheDisposables))
                    }
                    _handleNewLink(p) {
                        if (!this._lastMouseEvent)
                            return;
                        const b = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                        b && this._linkAtPosition(p.link, b) && (this._currentLink = p,
                        this._currentLink.state = {
                            decorations: {
                                underline: p.link.decorations === void 0 || p.link.decorations.underline,
                                pointerCursor: p.link.decorations === void 0 || p.link.decorations.pointerCursor
                            },
                            isHovered: !0
                        },
                        this._linkHover(this._element, p.link, this._lastMouseEvent),
                        p.link.decorations = {},
                        Object.defineProperties(p.link.decorations, {
                            pointerCursor: {
                                get: () => this._currentLink?.state?.decorations.pointerCursor,
                                set: y => {
                                    this._currentLink?.state && this._currentLink.state.decorations.pointerCursor !== y && (this._currentLink.state.decorations.pointerCursor = y,
                                    this._currentLink.state.isHovered && this._element.classList.toggle("xterm-cursor-pointer", y))
                                }
                            },
                            underline: {
                                get: () => this._currentLink?.state?.decorations.underline,
                                set: y => {
                                    this._currentLink?.state && this._currentLink?.state?.decorations.underline !== y && (this._currentLink.state.decorations.underline = y,
                                    this._currentLink.state.isHovered && this._fireUnderlineEvent(p.link, y))
                                }
                            }
                        }),
                        this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange(y => {
                            if (!this._currentLink)
                                return;
                            const x = y.start === 0 ? 0 : y.start + 1 + this._bufferService.buffer.ydisp
                              , E = this._bufferService.buffer.ydisp + 1 + y.end;
                            if (this._currentLink.link.range.start.y >= x && this._currentLink.link.range.end.y <= E && (this._clearCurrentLink(x, E),
                            this._lastMouseEvent)) {
                                const w = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                                w && this._askForLink(w, !1)
                            }
                        }
                        )))
                    }
                    _linkHover(p, b, y) {
                        this._currentLink?.state && (this._currentLink.state.isHovered = !0,
                        this._currentLink.state.decorations.underline && this._fireUnderlineEvent(b, !0),
                        this._currentLink.state.decorations.pointerCursor && p.classList.add("xterm-cursor-pointer")),
                        b.hover && b.hover(y, b.text)
                    }
                    _fireUnderlineEvent(p, b) {
                        const y = p.range
                          , x = this._bufferService.buffer.ydisp
                          , E = this._createLinkUnderlineEvent(y.start.x - 1, y.start.y - x - 1, y.end.x, y.end.y - x - 1, void 0);
                        (b ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(E)
                    }
                    _linkLeave(p, b, y) {
                        this._currentLink?.state && (this._currentLink.state.isHovered = !1,
                        this._currentLink.state.decorations.underline && this._fireUnderlineEvent(b, !1),
                        this._currentLink.state.decorations.pointerCursor && p.classList.remove("xterm-cursor-pointer")),
                        b.leave && b.leave(y, b.text)
                    }
                    _linkAtPosition(p, b) {
                        const y = p.range.start.y * this._bufferService.cols + p.range.start.x
                          , x = p.range.end.y * this._bufferService.cols + p.range.end.x
                          , E = b.y * this._bufferService.cols + b.x;
                        return y <= E && E <= x
                    }
                    _positionFromMouseEvent(p, b, y) {
                        const x = y.getCoords(p, b, this._bufferService.cols, this._bufferService.rows);
                        if (x)
                            return {
                                x: x[0],
                                y: x[1] + this._bufferService.buffer.ydisp
                            }
                    }
                    _createLinkUnderlineEvent(p, b, y, x, E) {
                        return {
                            x1: p,
                            y1: b,
                            x2: y,
                            y2: x,
                            cols: this._bufferService.cols,
                            fg: E
                        }
                    }
                }
                ;
                a.Linkifier = m = c([u(1, _.IMouseService), u(2, _.IRenderService), u(3, g.IBufferService), u(4, _.ILinkProviderService)], m)
            },
            9042: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.tooMuchOutput = a.promptLabel = void 0,
                a.promptLabel = "Terminal input",
                a.tooMuchOutput = "Too much output to announce, navigate to rows manually to read"
            }
            ,
            3730: function(o, a, l) {
                var c = this && this.__decorate || function(_, m, p, b) {
                    var y, x = arguments.length, E = x < 3 ? m : b === null ? b = Object.getOwnPropertyDescriptor(m, p) : b;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        E = Reflect.decorate(_, m, p, b);
                    else
                        for (var w = _.length - 1; w >= 0; w--)
                            (y = _[w]) && (E = (x < 3 ? y(E) : x > 3 ? y(m, p, E) : y(m, p)) || E);
                    return x > 3 && E && Object.defineProperty(m, p, E),
                    E
                }
                  , u = this && this.__param || function(_, m) {
                    return function(p, b) {
                        m(p, b, _)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.OscLinkProvider = void 0;
                const h = l(511)
                  , d = l(2585);
                let f = a.OscLinkProvider = class {
                    constructor(_, m, p) {
                        this._bufferService = _,
                        this._optionsService = m,
                        this._oscLinkService = p
                    }
                    provideLinks(_, m) {
                        const p = this._bufferService.buffer.lines.get(_ - 1);
                        if (!p)
                            return void m(void 0);
                        const b = []
                          , y = this._optionsService.rawOptions.linkHandler
                          , x = new h.CellData
                          , E = p.getTrimmedLength();
                        let w = -1
                          , A = -1
                          , C = !1;
                        for (let k = 0; k < E; k++)
                            if (A !== -1 || p.hasContent(k)) {
                                if (p.loadCell(k, x),
                                x.hasExtendedAttrs() && x.extended.urlId) {
                                    if (A === -1) {
                                        A = k,
                                        w = x.extended.urlId;
                                        continue
                                    }
                                    C = x.extended.urlId !== w
                                } else
                                    A !== -1 && (C = !0);
                                if (C || A !== -1 && k === E - 1) {
                                    const I = this._oscLinkService.getLinkData(w)?.uri;
                                    if (I) {
                                        const N = {
                                            start: {
                                                x: A + 1,
                                                y: _
                                            },
                                            end: {
                                                x: k + (C || k !== E - 1 ? 0 : 1),
                                                y: _
                                            }
                                        };
                                        let O = !1;
                                        if (!y?.allowNonHttpProtocols)
                                            try {
                                                const M = new URL(I);
                                                ["http:", "https:"].includes(M.protocol) || (O = !0)
                                            } catch {
                                                O = !0
                                            }
                                        O || b.push({
                                            text: I,
                                            range: N,
                                            activate: (M, H) => y ? y.activate(M, H, N) : g(0, H),
                                            hover: (M, H) => y?.hover?.(M, H, N),
                                            leave: (M, H) => y?.leave?.(M, H, N)
                                        })
                                    }
                                    C = !1,
                                    x.hasExtendedAttrs() && x.extended.urlId ? (A = k,
                                    w = x.extended.urlId) : (A = -1,
                                    w = -1)
                                }
                            }
                        m(b)
                    }
                }
                ;
                function g(_, m) {
                    if (confirm(`Do you want to navigate to ${m}?

WARNING: This link could potentially be dangerous`)) {
                        const p = window.open();
                        if (p) {
                            try {
                                p.opener = null
                            } catch {}
                            p.location.href = m
                        } else
                            console.warn("Opening link blocked as opener could not be cleared")
                    }
                }
                a.OscLinkProvider = f = c([u(0, d.IBufferService), u(1, d.IOptionsService), u(2, d.IOscLinkService)], f)
            },
            6193: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.RenderDebouncer = void 0,
                a.RenderDebouncer = class {
                    constructor(l, c) {
                        this._renderCallback = l,
                        this._coreBrowserService = c,
                        this._refreshCallbacks = []
                    }
                    dispose() {
                        this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame),
                        this._animationFrame = void 0)
                    }
                    addRefreshCallback(l) {
                        return this._refreshCallbacks.push(l),
                        this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame( () => this._innerRefresh())),
                        this._animationFrame
                    }
                    refresh(l, c, u) {
                        this._rowCount = u,
                        l = l !== void 0 ? l : 0,
                        c = c !== void 0 ? c : this._rowCount - 1,
                        this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l,
                        this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c,
                        this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame( () => this._innerRefresh()))
                    }
                    _innerRefresh() {
                        if (this._animationFrame = void 0,
                        this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0)
                            return void this._runRefreshCallbacks();
                        const l = Math.max(this._rowStart, 0)
                          , c = Math.min(this._rowEnd, this._rowCount - 1);
                        this._rowStart = void 0,
                        this._rowEnd = void 0,
                        this._renderCallback(l, c),
                        this._runRefreshCallbacks()
                    }
                    _runRefreshCallbacks() {
                        for (const l of this._refreshCallbacks)
                            l(0);
                        this._refreshCallbacks = []
                    }
                }
            }
            ,
            3236: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Terminal = void 0;
                const c = l(3614)
                  , u = l(3656)
                  , h = l(3551)
                  , d = l(9042)
                  , f = l(3730)
                  , g = l(1680)
                  , _ = l(3107)
                  , m = l(5744)
                  , p = l(2950)
                  , b = l(1296)
                  , y = l(428)
                  , x = l(4269)
                  , E = l(5114)
                  , w = l(8934)
                  , A = l(3230)
                  , C = l(9312)
                  , k = l(4725)
                  , I = l(6731)
                  , N = l(8055)
                  , O = l(8969)
                  , M = l(8460)
                  , H = l(844)
                  , $ = l(6114)
                  , J = l(8437)
                  , Q = l(2584)
                  , ee = l(7399)
                  , D = l(5941)
                  , L = l(9074)
                  , z = l(2585)
                  , V = l(5435)
                  , B = l(4567)
                  , Z = l(779);
                class se extends O.CoreTerminal {
                    get onFocus() {
                        return this._onFocus.event
                    }
                    get onBlur() {
                        return this._onBlur.event
                    }
                    get onA11yChar() {
                        return this._onA11yCharEmitter.event
                    }
                    get onA11yTab() {
                        return this._onA11yTabEmitter.event
                    }
                    get onWillOpen() {
                        return this._onWillOpen.event
                    }
                    constructor(G={}) {
                        super(G),
                        this.browser = $,
                        this._keyDownHandled = !1,
                        this._keyDownSeen = !1,
                        this._keyPressHandled = !1,
                        this._unprocessedDeadKey = !1,
                        this._accessibilityManager = this.register(new H.MutableDisposable),
                        this._onCursorMove = this.register(new M.EventEmitter),
                        this.onCursorMove = this._onCursorMove.event,
                        this._onKey = this.register(new M.EventEmitter),
                        this.onKey = this._onKey.event,
                        this._onRender = this.register(new M.EventEmitter),
                        this.onRender = this._onRender.event,
                        this._onSelectionChange = this.register(new M.EventEmitter),
                        this.onSelectionChange = this._onSelectionChange.event,
                        this._onTitleChange = this.register(new M.EventEmitter),
                        this.onTitleChange = this._onTitleChange.event,
                        this._onBell = this.register(new M.EventEmitter),
                        this.onBell = this._onBell.event,
                        this._onFocus = this.register(new M.EventEmitter),
                        this._onBlur = this.register(new M.EventEmitter),
                        this._onA11yCharEmitter = this.register(new M.EventEmitter),
                        this._onA11yTabEmitter = this.register(new M.EventEmitter),
                        this._onWillOpen = this.register(new M.EventEmitter),
                        this._setup(),
                        this._decorationService = this._instantiationService.createInstance(L.DecorationService),
                        this._instantiationService.setService(z.IDecorationService, this._decorationService),
                        this._linkProviderService = this._instantiationService.createInstance(Z.LinkProviderService),
                        this._instantiationService.setService(k.ILinkProviderService, this._linkProviderService),
                        this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(f.OscLinkProvider)),
                        this.register(this._inputHandler.onRequestBell( () => this._onBell.fire())),
                        this.register(this._inputHandler.onRequestRefreshRows( (j, oe) => this.refresh(j, oe))),
                        this.register(this._inputHandler.onRequestSendFocus( () => this._reportFocus())),
                        this.register(this._inputHandler.onRequestReset( () => this.reset())),
                        this.register(this._inputHandler.onRequestWindowsOptionsReport(j => this._reportWindowsOptions(j))),
                        this.register(this._inputHandler.onColor(j => this._handleColorEvent(j))),
                        this.register((0,
                        M.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)),
                        this.register((0,
                        M.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)),
                        this.register((0,
                        M.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)),
                        this.register((0,
                        M.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)),
                        this.register(this._bufferService.onResize(j => this._afterResize(j.cols, j.rows))),
                        this.register((0,
                        H.toDisposable)( () => {
                            this._customKeyEventHandler = void 0,
                            this.element?.parentNode?.removeChild(this.element)
                        }
                        ))
                    }
                    _handleColorEvent(G) {
                        if (this._themeService)
                            for (const j of G) {
                                let oe, le = "";
                                switch (j.index) {
                                case 256:
                                    oe = "foreground",
                                    le = "10";
                                    break;
                                case 257:
                                    oe = "background",
                                    le = "11";
                                    break;
                                case 258:
                                    oe = "cursor",
                                    le = "12";
                                    break;
                                default:
                                    oe = "ansi",
                                    le = "4;" + j.index
                                }
                                switch (j.type) {
                                case 0:
                                    const de = N.color.toColorRGB(oe === "ansi" ? this._themeService.colors.ansi[j.index] : this._themeService.colors[oe]);
                                    this.coreService.triggerDataEvent(`${Q.C0.ESC}]${le};${(0,
                                    D.toRgbString)(de)}${Q.C1_ESCAPED.ST}`);
                                    break;
                                case 1:
                                    if (oe === "ansi")
                                        this._themeService.modifyColors(ne => ne.ansi[j.index] = N.channels.toColor(...j.color));
                                    else {
                                        const ne = oe;
                                        this._themeService.modifyColors(pe => pe[ne] = N.channels.toColor(...j.color))
                                    }
                                    break;
                                case 2:
                                    this._themeService.restoreColor(j.index)
                                }
                            }
                    }
                    _setup() {
                        super._setup(),
                        this._customKeyEventHandler = void 0
                    }
                    get buffer() {
                        return this.buffers.active
                    }
                    focus() {
                        this.textarea && this.textarea.focus({
                            preventScroll: !0
                        })
                    }
                    _handleScreenReaderModeOptionChange(G) {
                        G ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(B.AccessibilityManager, this)) : this._accessibilityManager.clear()
                    }
                    _handleTextAreaFocus(G) {
                        this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(Q.C0.ESC + "[I"),
                        this.element.classList.add("focus"),
                        this._showCursor(),
                        this._onFocus.fire()
                    }
                    blur() {
                        return this.textarea?.blur()
                    }
                    _handleTextAreaBlur() {
                        this.textarea.value = "",
                        this.refresh(this.buffer.y, this.buffer.y),
                        this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(Q.C0.ESC + "[O"),
                        this.element.classList.remove("focus"),
                        this._onBlur.fire()
                    }
                    _syncTextArea() {
                        if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
                            return;
                        const G = this.buffer.ybase + this.buffer.y
                          , j = this.buffer.lines.get(G);
                        if (!j)
                            return;
                        const oe = Math.min(this.buffer.x, this.cols - 1)
                          , le = this._renderService.dimensions.css.cell.height
                          , de = j.getWidth(oe)
                          , ne = this._renderService.dimensions.css.cell.width * de
                          , pe = this.buffer.y * this._renderService.dimensions.css.cell.height
                          , Te = oe * this._renderService.dimensions.css.cell.width;
                        this.textarea.style.left = Te + "px",
                        this.textarea.style.top = pe + "px",
                        this.textarea.style.width = ne + "px",
                        this.textarea.style.height = le + "px",
                        this.textarea.style.lineHeight = le + "px",
                        this.textarea.style.zIndex = "-5"
                    }
                    _initGlobal() {
                        this._bindKeys(),
                        this.register((0,
                        u.addDisposableDomListener)(this.element, "copy", j => {
                            this.hasSelection() && (0,
                            c.copyHandler)(j, this._selectionService)
                        }
                        ));
                        const G = j => (0,
                        c.handlePasteEvent)(j, this.textarea, this.coreService, this.optionsService);
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "paste", G)),
                        this.register((0,
                        u.addDisposableDomListener)(this.element, "paste", G)),
                        $.isFirefox ? this.register((0,
                        u.addDisposableDomListener)(this.element, "mousedown", j => {
                            j.button === 2 && (0,
                            c.rightClickHandler)(j, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord)
                        }
                        )) : this.register((0,
                        u.addDisposableDomListener)(this.element, "contextmenu", j => {
                            (0,
                            c.rightClickHandler)(j, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord)
                        }
                        )),
                        $.isLinux && this.register((0,
                        u.addDisposableDomListener)(this.element, "auxclick", j => {
                            j.button === 1 && (0,
                            c.moveTextAreaUnderMouseCursor)(j, this.textarea, this.screenElement)
                        }
                        ))
                    }
                    _bindKeys() {
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "keyup", G => this._keyUp(G), !0)),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "keydown", G => this._keyDown(G), !0)),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "keypress", G => this._keyPress(G), !0)),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "compositionupdate", G => this._compositionHelper.compositionupdate(G))),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "input", G => this._inputEvent(G), !0)),
                        this.register(this.onRender( () => this._compositionHelper.updateCompositionElements()))
                    }
                    open(G) {
                        if (!G)
                            throw new Error("Terminal requires a parent element.");
                        if (G.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"),
                        this.element?.ownerDocument.defaultView && this._coreBrowserService)
                            return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
                        this._document = G.ownerDocument,
                        this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride),
                        this.element = this._document.createElement("div"),
                        this.element.dir = "ltr",
                        this.element.classList.add("terminal"),
                        this.element.classList.add("xterm"),
                        G.appendChild(this.element);
                        const j = this._document.createDocumentFragment();
                        this._viewportElement = this._document.createElement("div"),
                        this._viewportElement.classList.add("xterm-viewport"),
                        j.appendChild(this._viewportElement),
                        this._viewportScrollArea = this._document.createElement("div"),
                        this._viewportScrollArea.classList.add("xterm-scroll-area"),
                        this._viewportElement.appendChild(this._viewportScrollArea),
                        this.screenElement = this._document.createElement("div"),
                        this.screenElement.classList.add("xterm-screen"),
                        this.register((0,
                        u.addDisposableDomListener)(this.screenElement, "mousemove", oe => this.updateCursorStyle(oe))),
                        this._helperContainer = this._document.createElement("div"),
                        this._helperContainer.classList.add("xterm-helpers"),
                        this.screenElement.appendChild(this._helperContainer),
                        j.appendChild(this.screenElement),
                        this.textarea = this._document.createElement("textarea"),
                        this.textarea.classList.add("xterm-helper-textarea"),
                        this.textarea.setAttribute("aria-label", d.promptLabel),
                        $.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"),
                        this.textarea.setAttribute("autocorrect", "off"),
                        this.textarea.setAttribute("autocapitalize", "off"),
                        this.textarea.setAttribute("spellcheck", "false"),
                        this.textarea.tabIndex = 0,
                        this._coreBrowserService = this.register(this._instantiationService.createInstance(E.CoreBrowserService, this.textarea, G.ownerDocument.defaultView ?? window, this._document ?? typeof window < "u" ? window.document : null)),
                        this._instantiationService.setService(k.ICoreBrowserService, this._coreBrowserService),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "focus", oe => this._handleTextAreaFocus(oe))),
                        this.register((0,
                        u.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())),
                        this._helperContainer.appendChild(this.textarea),
                        this._charSizeService = this._instantiationService.createInstance(y.CharSizeService, this._document, this._helperContainer),
                        this._instantiationService.setService(k.ICharSizeService, this._charSizeService),
                        this._themeService = this._instantiationService.createInstance(I.ThemeService),
                        this._instantiationService.setService(k.IThemeService, this._themeService),
                        this._characterJoinerService = this._instantiationService.createInstance(x.CharacterJoinerService),
                        this._instantiationService.setService(k.ICharacterJoinerService, this._characterJoinerService),
                        this._renderService = this.register(this._instantiationService.createInstance(A.RenderService, this.rows, this.screenElement)),
                        this._instantiationService.setService(k.IRenderService, this._renderService),
                        this.register(this._renderService.onRenderedViewportChange(oe => this._onRender.fire(oe))),
                        this.onResize(oe => this._renderService.resize(oe.cols, oe.rows)),
                        this._compositionView = this._document.createElement("div"),
                        this._compositionView.classList.add("composition-view"),
                        this._compositionHelper = this._instantiationService.createInstance(p.CompositionHelper, this.textarea, this._compositionView),
                        this._helperContainer.appendChild(this._compositionView),
                        this._mouseService = this._instantiationService.createInstance(w.MouseService),
                        this._instantiationService.setService(k.IMouseService, this._mouseService),
                        this.linkifier = this.register(this._instantiationService.createInstance(h.Linkifier, this.screenElement)),
                        this.element.appendChild(j);
                        try {
                            this._onWillOpen.fire(this.element)
                        } catch {}
                        this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()),
                        this.viewport = this._instantiationService.createInstance(g.Viewport, this._viewportElement, this._viewportScrollArea),
                        this.viewport.onRequestScrollLines(oe => this.scrollLines(oe.amount, oe.suppressScrollEvent, 1)),
                        this.register(this._inputHandler.onRequestSyncScrollBar( () => this.viewport.syncScrollArea())),
                        this.register(this.viewport),
                        this.register(this.onCursorMove( () => {
                            this._renderService.handleCursorMove(),
                            this._syncTextArea()
                        }
                        )),
                        this.register(this.onResize( () => this._renderService.handleResize(this.cols, this.rows))),
                        this.register(this.onBlur( () => this._renderService.handleBlur())),
                        this.register(this.onFocus( () => this._renderService.handleFocus())),
                        this.register(this._renderService.onDimensionsChange( () => this.viewport.syncScrollArea())),
                        this._selectionService = this.register(this._instantiationService.createInstance(C.SelectionService, this.element, this.screenElement, this.linkifier)),
                        this._instantiationService.setService(k.ISelectionService, this._selectionService),
                        this.register(this._selectionService.onRequestScrollLines(oe => this.scrollLines(oe.amount, oe.suppressScrollEvent))),
                        this.register(this._selectionService.onSelectionChange( () => this._onSelectionChange.fire())),
                        this.register(this._selectionService.onRequestRedraw(oe => this._renderService.handleSelectionChanged(oe.start, oe.end, oe.columnSelectMode))),
                        this.register(this._selectionService.onLinuxMouseSelection(oe => {
                            this.textarea.value = oe,
                            this.textarea.focus(),
                            this.textarea.select()
                        }
                        )),
                        this.register(this._onScroll.event(oe => {
                            this.viewport.syncScrollArea(),
                            this._selectionService.refresh()
                        }
                        )),
                        this.register((0,
                        u.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())),
                        this.register(this._instantiationService.createInstance(_.BufferDecorationRenderer, this.screenElement)),
                        this.register((0,
                        u.addDisposableDomListener)(this.element, "mousedown", oe => this._selectionService.handleMouseDown(oe))),
                        this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(),
                        this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(),
                        this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(B.AccessibilityManager, this)),
                        this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", oe => this._handleScreenReaderModeOptionChange(oe))),
                        this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(m.OverviewRulerRenderer, this._viewportElement, this.screenElement))),
                        this.optionsService.onSpecificOptionChange("overviewRulerWidth", oe => {
                            !this._overviewRulerRenderer && oe && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(m.OverviewRulerRenderer, this._viewportElement, this.screenElement)))
                        }
                        ),
                        this._charSizeService.measure(),
                        this.refresh(0, this.rows - 1),
                        this._initGlobal(),
                        this.bindMouse()
                    }
                    _createRenderer() {
                        return this._instantiationService.createInstance(b.DomRenderer, this, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier)
                    }
                    bindMouse() {
                        const G = this
                          , j = this.element;
                        function oe(ne) {
                            const pe = G._mouseService.getMouseReportCoords(ne, G.screenElement);
                            if (!pe)
                                return !1;
                            let Te, Ce;
                            switch (ne.overrideType || ne.type) {
                            case "mousemove":
                                Ce = 32,
                                ne.buttons === void 0 ? (Te = 3,
                                ne.button !== void 0 && (Te = ne.button < 3 ? ne.button : 3)) : Te = 1 & ne.buttons ? 0 : 4 & ne.buttons ? 1 : 2 & ne.buttons ? 2 : 3;
                                break;
                            case "mouseup":
                                Ce = 0,
                                Te = ne.button < 3 ? ne.button : 3;
                                break;
                            case "mousedown":
                                Ce = 1,
                                Te = ne.button < 3 ? ne.button : 3;
                                break;
                            case "wheel":
                                if (G._customWheelEventHandler && G._customWheelEventHandler(ne) === !1 || G.viewport.getLinesScrolled(ne) === 0)
                                    return !1;
                                Ce = ne.deltaY < 0 ? 0 : 1,
                                Te = 4;
                                break;
                            default:
                                return !1
                            }
                            return !(Ce === void 0 || Te === void 0 || Te > 4) && G.coreMouseService.triggerMouseEvent({
                                col: pe.col,
                                row: pe.row,
                                x: pe.x,
                                y: pe.y,
                                button: Te,
                                action: Ce,
                                ctrl: ne.ctrlKey,
                                alt: ne.altKey,
                                shift: ne.shiftKey
                            })
                        }
                        const le = {
                            mouseup: null,
                            wheel: null,
                            mousedrag: null,
                            mousemove: null
                        }
                          , de = {
                            mouseup: ne => (oe(ne),
                            ne.buttons || (this._document.removeEventListener("mouseup", le.mouseup),
                            le.mousedrag && this._document.removeEventListener("mousemove", le.mousedrag)),
                            this.cancel(ne)),
                            wheel: ne => (oe(ne),
                            this.cancel(ne, !0)),
                            mousedrag: ne => {
                                ne.buttons && oe(ne)
                            }
                            ,
                            mousemove: ne => {
                                ne.buttons || oe(ne)
                            }
                        };
                        this.register(this.coreMouseService.onProtocolChange(ne => {
                            ne ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(ne)),
                            this.element.classList.add("enable-mouse-events"),
                            this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."),
                            this.element.classList.remove("enable-mouse-events"),
                            this._selectionService.enable()),
                            8 & ne ? le.mousemove || (j.addEventListener("mousemove", de.mousemove),
                            le.mousemove = de.mousemove) : (j.removeEventListener("mousemove", le.mousemove),
                            le.mousemove = null),
                            16 & ne ? le.wheel || (j.addEventListener("wheel", de.wheel, {
                                passive: !1
                            }),
                            le.wheel = de.wheel) : (j.removeEventListener("wheel", le.wheel),
                            le.wheel = null),
                            2 & ne ? le.mouseup || (le.mouseup = de.mouseup) : (this._document.removeEventListener("mouseup", le.mouseup),
                            le.mouseup = null),
                            4 & ne ? le.mousedrag || (le.mousedrag = de.mousedrag) : (this._document.removeEventListener("mousemove", le.mousedrag),
                            le.mousedrag = null)
                        }
                        )),
                        this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol,
                        this.register((0,
                        u.addDisposableDomListener)(j, "mousedown", ne => {
                            if (ne.preventDefault(),
                            this.focus(),
                            this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(ne))
                                return oe(ne),
                                le.mouseup && this._document.addEventListener("mouseup", le.mouseup),
                                le.mousedrag && this._document.addEventListener("mousemove", le.mousedrag),
                                this.cancel(ne)
                        }
                        )),
                        this.register((0,
                        u.addDisposableDomListener)(j, "wheel", ne => {
                            if (!le.wheel) {
                                if (this._customWheelEventHandler && this._customWheelEventHandler(ne) === !1)
                                    return !1;
                                if (!this.buffer.hasScrollback) {
                                    const pe = this.viewport.getLinesScrolled(ne);
                                    if (pe === 0)
                                        return;
                                    const Te = Q.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (ne.deltaY < 0 ? "A" : "B");
                                    let Ce = "";
                                    for (let Re = 0; Re < Math.abs(pe); Re++)
                                        Ce += Te;
                                    return this.coreService.triggerDataEvent(Ce, !0),
                                    this.cancel(ne, !0)
                                }
                                return this.viewport.handleWheel(ne) ? this.cancel(ne) : void 0
                            }
                        }
                        , {
                            passive: !1
                        })),
                        this.register((0,
                        u.addDisposableDomListener)(j, "touchstart", ne => {
                            if (!this.coreMouseService.areMouseEventsActive)
                                return this.viewport.handleTouchStart(ne),
                                this.cancel(ne)
                        }
                        , {
                            passive: !0
                        })),
                        this.register((0,
                        u.addDisposableDomListener)(j, "touchmove", ne => {
                            if (!this.coreMouseService.areMouseEventsActive)
                                return this.viewport.handleTouchMove(ne) ? void 0 : this.cancel(ne)
                        }
                        , {
                            passive: !1
                        }))
                    }
                    refresh(G, j) {
                        this._renderService?.refreshRows(G, j)
                    }
                    updateCursorStyle(G) {
                        this._selectionService?.shouldColumnSelect(G) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select")
                    }
                    _showCursor() {
                        this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0,
                        this.refresh(this.buffer.y, this.buffer.y))
                    }
                    scrollLines(G, j, oe=0) {
                        oe === 1 ? (super.scrollLines(G, j, oe),
                        this.refresh(0, this.rows - 1)) : this.viewport?.scrollLines(G)
                    }
                    paste(G) {
                        (0,
                        c.paste)(G, this.textarea, this.coreService, this.optionsService)
                    }
                    attachCustomKeyEventHandler(G) {
                        this._customKeyEventHandler = G
                    }
                    attachCustomWheelEventHandler(G) {
                        this._customWheelEventHandler = G
                    }
                    registerLinkProvider(G) {
                        return this._linkProviderService.registerLinkProvider(G)
                    }
                    registerCharacterJoiner(G) {
                        if (!this._characterJoinerService)
                            throw new Error("Terminal must be opened first");
                        const j = this._characterJoinerService.register(G);
                        return this.refresh(0, this.rows - 1),
                        j
                    }
                    deregisterCharacterJoiner(G) {
                        if (!this._characterJoinerService)
                            throw new Error("Terminal must be opened first");
                        this._characterJoinerService.deregister(G) && this.refresh(0, this.rows - 1)
                    }
                    get markers() {
                        return this.buffer.markers
                    }
                    registerMarker(G) {
                        return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + G)
                    }
                    registerDecoration(G) {
                        return this._decorationService.registerDecoration(G)
                    }
                    hasSelection() {
                        return !!this._selectionService && this._selectionService.hasSelection
                    }
                    select(G, j, oe) {
                        this._selectionService.setSelection(G, j, oe)
                    }
                    getSelection() {
                        return this._selectionService ? this._selectionService.selectionText : ""
                    }
                    getSelectionPosition() {
                        if (this._selectionService && this._selectionService.hasSelection)
                            return {
                                start: {
                                    x: this._selectionService.selectionStart[0],
                                    y: this._selectionService.selectionStart[1]
                                },
                                end: {
                                    x: this._selectionService.selectionEnd[0],
                                    y: this._selectionService.selectionEnd[1]
                                }
                            }
                    }
                    clearSelection() {
                        this._selectionService?.clearSelection()
                    }
                    selectAll() {
                        this._selectionService?.selectAll()
                    }
                    selectLines(G, j) {
                        this._selectionService?.selectLines(G, j)
                    }
                    _keyDown(G) {
                        if (this._keyDownHandled = !1,
                        this._keyDownSeen = !0,
                        this._customKeyEventHandler && this._customKeyEventHandler(G) === !1)
                            return !1;
                        const j = this.browser.isMac && this.options.macOptionIsMeta && G.altKey;
                        if (!j && !this._compositionHelper.keydown(G))
                            return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(),
                            !1;
                        j || G.key !== "Dead" && G.key !== "AltGraph" || (this._unprocessedDeadKey = !0);
                        const oe = (0,
                        ee.evaluateKeyboardEvent)(G, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
                        if (this.updateCursorStyle(G),
                        oe.type === 3 || oe.type === 2) {
                            const le = this.rows - 1;
                            return this.scrollLines(oe.type === 2 ? -le : le),
                            this.cancel(G, !0)
                        }
                        return oe.type === 1 && this.selectAll(),
                        !!this._isThirdLevelShift(this.browser, G) || (oe.cancel && this.cancel(G, !0),
                        !oe.key || !!(G.key && !G.ctrlKey && !G.altKey && !G.metaKey && G.key.length === 1 && G.key.charCodeAt(0) >= 65 && G.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1,
                        !0) : (oe.key !== Q.C0.ETX && oe.key !== Q.C0.CR || (this.textarea.value = ""),
                        this._onKey.fire({
                            key: oe.key,
                            domEvent: G
                        }),
                        this._showCursor(),
                        this.coreService.triggerDataEvent(oe.key, !0),
                        !this.optionsService.rawOptions.screenReaderMode || G.altKey || G.ctrlKey ? this.cancel(G, !0) : void (this._keyDownHandled = !0))))
                    }
                    _isThirdLevelShift(G, j) {
                        const oe = G.isMac && !this.options.macOptionIsMeta && j.altKey && !j.ctrlKey && !j.metaKey || G.isWindows && j.altKey && j.ctrlKey && !j.metaKey || G.isWindows && j.getModifierState("AltGraph");
                        return j.type === "keypress" ? oe : oe && (!j.keyCode || j.keyCode > 47)
                    }
                    _keyUp(G) {
                        this._keyDownSeen = !1,
                        this._customKeyEventHandler && this._customKeyEventHandler(G) === !1 || (function(j) {
                            return j.keyCode === 16 || j.keyCode === 17 || j.keyCode === 18
                        }(G) || this.focus(),
                        this.updateCursorStyle(G),
                        this._keyPressHandled = !1)
                    }
                    _keyPress(G) {
                        let j;
                        if (this._keyPressHandled = !1,
                        this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(G) === !1)
                            return !1;
                        if (this.cancel(G),
                        G.charCode)
                            j = G.charCode;
                        else if (G.which === null || G.which === void 0)
                            j = G.keyCode;
                        else {
                            if (G.which === 0 || G.charCode === 0)
                                return !1;
                            j = G.which
                        }
                        return !(!j || (G.altKey || G.ctrlKey || G.metaKey) && !this._isThirdLevelShift(this.browser, G) || (j = String.fromCharCode(j),
                        this._onKey.fire({
                            key: j,
                            domEvent: G
                        }),
                        this._showCursor(),
                        this.coreService.triggerDataEvent(j, !0),
                        this._keyPressHandled = !0,
                        this._unprocessedDeadKey = !1,
                        0))
                    }
                    _inputEvent(G) {
                        if (G.data && G.inputType === "insertText" && (!G.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
                            if (this._keyPressHandled)
                                return !1;
                            this._unprocessedDeadKey = !1;
                            const j = G.data;
                            return this.coreService.triggerDataEvent(j, !0),
                            this.cancel(G),
                            !0
                        }
                        return !1
                    }
                    resize(G, j) {
                        G !== this.cols || j !== this.rows ? super.resize(G, j) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure()
                    }
                    _afterResize(G, j) {
                        this._charSizeService?.measure(),
                        this.viewport?.syncScrollArea(!0)
                    }
                    clear() {
                        if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
                            this.buffer.clearAllMarkers(),
                            this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)),
                            this.buffer.lines.length = 1,
                            this.buffer.ydisp = 0,
                            this.buffer.ybase = 0,
                            this.buffer.y = 0;
                            for (let G = 1; G < this.rows; G++)
                                this.buffer.lines.push(this.buffer.getBlankLine(J.DEFAULT_ATTR_DATA));
                            this._onScroll.fire({
                                position: this.buffer.ydisp,
                                source: 0
                            }),
                            this.viewport?.reset(),
                            this.refresh(0, this.rows - 1)
                        }
                    }
                    reset() {
                        this.options.rows = this.rows,
                        this.options.cols = this.cols;
                        const G = this._customKeyEventHandler;
                        this._setup(),
                        super.reset(),
                        this._selectionService?.reset(),
                        this._decorationService.reset(),
                        this.viewport?.reset(),
                        this._customKeyEventHandler = G,
                        this.refresh(0, this.rows - 1)
                    }
                    clearTextureAtlas() {
                        this._renderService?.clearTextureAtlas()
                    }
                    _reportFocus() {
                        this.element?.classList.contains("focus") ? this.coreService.triggerDataEvent(Q.C0.ESC + "[I") : this.coreService.triggerDataEvent(Q.C0.ESC + "[O")
                    }
                    _reportWindowsOptions(G) {
                        if (this._renderService)
                            switch (G) {
                            case V.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                                const j = this._renderService.dimensions.css.canvas.width.toFixed(0)
                                  , oe = this._renderService.dimensions.css.canvas.height.toFixed(0);
                                this.coreService.triggerDataEvent(`${Q.C0.ESC}[4;${oe};${j}t`);
                                break;
                            case V.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                                const le = this._renderService.dimensions.css.cell.width.toFixed(0)
                                  , de = this._renderService.dimensions.css.cell.height.toFixed(0);
                                this.coreService.triggerDataEvent(`${Q.C0.ESC}[6;${de};${le}t`)
                            }
                    }
                    cancel(G, j) {
                        if (this.options.cancelEvents || j)
                            return G.preventDefault(),
                            G.stopPropagation(),
                            !1
                    }
                }
                a.Terminal = se
            }
            ,
            9924: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.TimeBasedDebouncer = void 0,
                a.TimeBasedDebouncer = class {
                    constructor(l, c=1e3) {
                        this._renderCallback = l,
                        this._debounceThresholdMS = c,
                        this._lastRefreshMs = 0,
                        this._additionalRefreshRequested = !1
                    }
                    dispose() {
                        this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID)
                    }
                    refresh(l, c, u) {
                        this._rowCount = u,
                        l = l !== void 0 ? l : 0,
                        c = c !== void 0 ? c : this._rowCount - 1,
                        this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l,
                        this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c;
                        const h = Date.now();
                        if (h - this._lastRefreshMs >= this._debounceThresholdMS)
                            this._lastRefreshMs = h,
                            this._innerRefresh();
                        else if (!this._additionalRefreshRequested) {
                            const d = h - this._lastRefreshMs
                              , f = this._debounceThresholdMS - d;
                            this._additionalRefreshRequested = !0,
                            this._refreshTimeoutID = window.setTimeout( () => {
                                this._lastRefreshMs = Date.now(),
                                this._innerRefresh(),
                                this._additionalRefreshRequested = !1,
                                this._refreshTimeoutID = void 0
                            }
                            , f)
                        }
                    }
                    _innerRefresh() {
                        if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0)
                            return;
                        const l = Math.max(this._rowStart, 0)
                          , c = Math.min(this._rowEnd, this._rowCount - 1);
                        this._rowStart = void 0,
                        this._rowEnd = void 0,
                        this._renderCallback(l, c)
                    }
                }
            }
            ,
            1680: function(o, a, l) {
                var c = this && this.__decorate || function(p, b, y, x) {
                    var E, w = arguments.length, A = w < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, y) : x;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        A = Reflect.decorate(p, b, y, x);
                    else
                        for (var C = p.length - 1; C >= 0; C--)
                            (E = p[C]) && (A = (w < 3 ? E(A) : w > 3 ? E(b, y, A) : E(b, y)) || A);
                    return w > 3 && A && Object.defineProperty(b, y, A),
                    A
                }
                  , u = this && this.__param || function(p, b) {
                    return function(y, x) {
                        b(y, x, p)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Viewport = void 0;
                const h = l(3656)
                  , d = l(4725)
                  , f = l(8460)
                  , g = l(844)
                  , _ = l(2585);
                let m = a.Viewport = class extends g.Disposable {
                    constructor(p, b, y, x, E, w, A, C) {
                        super(),
                        this._viewportElement = p,
                        this._scrollArea = b,
                        this._bufferService = y,
                        this._optionsService = x,
                        this._charSizeService = E,
                        this._renderService = w,
                        this._coreBrowserService = A,
                        this.scrollBarWidth = 0,
                        this._currentRowHeight = 0,
                        this._currentDeviceCellHeight = 0,
                        this._lastRecordedBufferLength = 0,
                        this._lastRecordedViewportHeight = 0,
                        this._lastRecordedBufferHeight = 0,
                        this._lastTouchY = 0,
                        this._lastScrollTop = 0,
                        this._wheelPartialScroll = 0,
                        this._refreshAnimationFrame = null,
                        this._ignoreNextScrollEvent = !1,
                        this._smoothScrollState = {
                            startTime: 0,
                            origin: -1,
                            target: -1
                        },
                        this._onRequestScrollLines = this.register(new f.EventEmitter),
                        this.onRequestScrollLines = this._onRequestScrollLines.event,
                        this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15,
                        this.register((0,
                        h.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))),
                        this._activeBuffer = this._bufferService.buffer,
                        this.register(this._bufferService.buffers.onBufferActivate(k => this._activeBuffer = k.activeBuffer)),
                        this._renderDimensions = this._renderService.dimensions,
                        this.register(this._renderService.onDimensionsChange(k => this._renderDimensions = k)),
                        this._handleThemeChange(C.colors),
                        this.register(C.onChangeColors(k => this._handleThemeChange(k))),
                        this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())),
                        setTimeout( () => this.syncScrollArea())
                    }
                    _handleThemeChange(p) {
                        this._viewportElement.style.backgroundColor = p.background.css
                    }
                    reset() {
                        this._currentRowHeight = 0,
                        this._currentDeviceCellHeight = 0,
                        this._lastRecordedBufferLength = 0,
                        this._lastRecordedViewportHeight = 0,
                        this._lastRecordedBufferHeight = 0,
                        this._lastTouchY = 0,
                        this._lastScrollTop = 0,
                        this._coreBrowserService.window.requestAnimationFrame( () => this.syncScrollArea())
                    }
                    _refresh(p) {
                        if (p)
                            return this._innerRefresh(),
                            void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
                        this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame( () => this._innerRefresh()))
                    }
                    _innerRefresh() {
                        if (this._charSizeService.height > 0) {
                            this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr,
                            this._currentDeviceCellHeight = this._renderDimensions.device.cell.height,
                            this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
                            const b = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
                            this._lastRecordedBufferHeight !== b && (this._lastRecordedBufferHeight = b,
                            this._scrollArea.style.height = this._lastRecordedBufferHeight + "px")
                        }
                        const p = this._bufferService.buffer.ydisp * this._currentRowHeight;
                        this._viewportElement.scrollTop !== p && (this._ignoreNextScrollEvent = !0,
                        this._viewportElement.scrollTop = p),
                        this._refreshAnimationFrame = null
                    }
                    syncScrollArea(p=!1) {
                        if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
                            return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length,
                            void this._refresh(p);
                        this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(p)
                    }
                    _handleScroll(p) {
                        if (this._lastScrollTop = this._viewportElement.scrollTop,
                        !this._viewportElement.offsetParent)
                            return;
                        if (this._ignoreNextScrollEvent)
                            return this._ignoreNextScrollEvent = !1,
                            void this._onRequestScrollLines.fire({
                                amount: 0,
                                suppressScrollEvent: !0
                            });
                        const b = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
                        this._onRequestScrollLines.fire({
                            amount: b,
                            suppressScrollEvent: !0
                        })
                    }
                    _smoothScroll() {
                        if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1)
                            return;
                        const p = this._smoothScrollPercent();
                        this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(p * (this._smoothScrollState.target - this._smoothScrollState.origin)),
                        p < 1 ? this._coreBrowserService.window.requestAnimationFrame( () => this._smoothScroll()) : this._clearSmoothScrollState()
                    }
                    _smoothScrollPercent() {
                        return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1
                    }
                    _clearSmoothScrollState() {
                        this._smoothScrollState.startTime = 0,
                        this._smoothScrollState.origin = -1,
                        this._smoothScrollState.target = -1
                    }
                    _bubbleScroll(p, b) {
                        const y = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
                        return !(b < 0 && this._viewportElement.scrollTop !== 0 || b > 0 && y < this._lastRecordedBufferHeight) || (p.cancelable && p.preventDefault(),
                        !1)
                    }
                    handleWheel(p) {
                        const b = this._getPixelsScrolled(p);
                        return b !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(),
                        this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop,
                        this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + b : this._smoothScrollState.target += b,
                        this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0),
                        this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += b,
                        this._bubbleScroll(p, b))
                    }
                    scrollLines(p) {
                        if (p !== 0)
                            if (this._optionsService.rawOptions.smoothScrollDuration) {
                                const b = p * this._currentRowHeight;
                                this._smoothScrollState.startTime = Date.now(),
                                this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop,
                                this._smoothScrollState.target = this._smoothScrollState.origin + b,
                                this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0),
                                this._smoothScroll()) : this._clearSmoothScrollState()
                            } else
                                this._onRequestScrollLines.fire({
                                    amount: p,
                                    suppressScrollEvent: !1
                                })
                    }
                    _getPixelsScrolled(p) {
                        if (p.deltaY === 0 || p.shiftKey)
                            return 0;
                        let b = this._applyScrollModifier(p.deltaY, p);
                        return p.deltaMode === WheelEvent.DOM_DELTA_LINE ? b *= this._currentRowHeight : p.deltaMode === WheelEvent.DOM_DELTA_PAGE && (b *= this._currentRowHeight * this._bufferService.rows),
                        b
                    }
                    getBufferElements(p, b) {
                        let y, x = "";
                        const E = []
                          , w = b ?? this._bufferService.buffer.lines.length
                          , A = this._bufferService.buffer.lines;
                        for (let C = p; C < w; C++) {
                            const k = A.get(C);
                            if (!k)
                                continue;
                            const I = A.get(C + 1)?.isWrapped;
                            if (x += k.translateToString(!I),
                            !I || C === A.length - 1) {
                                const N = document.createElement("div");
                                N.textContent = x,
                                E.push(N),
                                x.length > 0 && (y = N),
                                x = ""
                            }
                        }
                        return {
                            bufferElements: E,
                            cursorElement: y
                        }
                    }
                    getLinesScrolled(p) {
                        if (p.deltaY === 0 || p.shiftKey)
                            return 0;
                        let b = this._applyScrollModifier(p.deltaY, p);
                        return p.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (b /= this._currentRowHeight + 0,
                        this._wheelPartialScroll += b,
                        b = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1),
                        this._wheelPartialScroll %= 1) : p.deltaMode === WheelEvent.DOM_DELTA_PAGE && (b *= this._bufferService.rows),
                        b
                    }
                    _applyScrollModifier(p, b) {
                        const y = this._optionsService.rawOptions.fastScrollModifier;
                        return y === "alt" && b.altKey || y === "ctrl" && b.ctrlKey || y === "shift" && b.shiftKey ? p * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : p * this._optionsService.rawOptions.scrollSensitivity
                    }
                    handleTouchStart(p) {
                        this._lastTouchY = p.touches[0].pageY
                    }
                    handleTouchMove(p) {
                        const b = this._lastTouchY - p.touches[0].pageY;
                        return this._lastTouchY = p.touches[0].pageY,
                        b !== 0 && (this._viewportElement.scrollTop += b,
                        this._bubbleScroll(p, b))
                    }
                }
                ;
                a.Viewport = m = c([u(2, _.IBufferService), u(3, _.IOptionsService), u(4, d.ICharSizeService), u(5, d.IRenderService), u(6, d.ICoreBrowserService), u(7, d.IThemeService)], m)
            },
            3107: function(o, a, l) {
                var c = this && this.__decorate || function(_, m, p, b) {
                    var y, x = arguments.length, E = x < 3 ? m : b === null ? b = Object.getOwnPropertyDescriptor(m, p) : b;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        E = Reflect.decorate(_, m, p, b);
                    else
                        for (var w = _.length - 1; w >= 0; w--)
                            (y = _[w]) && (E = (x < 3 ? y(E) : x > 3 ? y(m, p, E) : y(m, p)) || E);
                    return x > 3 && E && Object.defineProperty(m, p, E),
                    E
                }
                  , u = this && this.__param || function(_, m) {
                    return function(p, b) {
                        m(p, b, _)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferDecorationRenderer = void 0;
                const h = l(4725)
                  , d = l(844)
                  , f = l(2585);
                let g = a.BufferDecorationRenderer = class extends d.Disposable {
                    constructor(_, m, p, b, y) {
                        super(),
                        this._screenElement = _,
                        this._bufferService = m,
                        this._coreBrowserService = p,
                        this._decorationService = b,
                        this._renderService = y,
                        this._decorationElements = new Map,
                        this._altBufferIsActive = !1,
                        this._dimensionsChanged = !1,
                        this._container = document.createElement("div"),
                        this._container.classList.add("xterm-decoration-container"),
                        this._screenElement.appendChild(this._container),
                        this.register(this._renderService.onRenderedViewportChange( () => this._doRefreshDecorations())),
                        this.register(this._renderService.onDimensionsChange( () => {
                            this._dimensionsChanged = !0,
                            this._queueRefresh()
                        }
                        )),
                        this.register(this._coreBrowserService.onDprChange( () => this._queueRefresh())),
                        this.register(this._bufferService.buffers.onBufferActivate( () => {
                            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt
                        }
                        )),
                        this.register(this._decorationService.onDecorationRegistered( () => this._queueRefresh())),
                        this.register(this._decorationService.onDecorationRemoved(x => this._removeDecoration(x))),
                        this.register((0,
                        d.toDisposable)( () => {
                            this._container.remove(),
                            this._decorationElements.clear()
                        }
                        ))
                    }
                    _queueRefresh() {
                        this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback( () => {
                            this._doRefreshDecorations(),
                            this._animationFrame = void 0
                        }
                        ))
                    }
                    _doRefreshDecorations() {
                        for (const _ of this._decorationService.decorations)
                            this._renderDecoration(_);
                        this._dimensionsChanged = !1
                    }
                    _renderDecoration(_) {
                        this._refreshStyle(_),
                        this._dimensionsChanged && this._refreshXPosition(_)
                    }
                    _createElement(_) {
                        const m = this._coreBrowserService.mainDocument.createElement("div");
                        m.classList.add("xterm-decoration"),
                        m.classList.toggle("xterm-decoration-top-layer", _?.options?.layer === "top"),
                        m.style.width = `${Math.round((_.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`,
                        m.style.height = (_.options.height || 1) * this._renderService.dimensions.css.cell.height + "px",
                        m.style.top = (_.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px",
                        m.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
                        const p = _.options.x ?? 0;
                        return p && p > this._bufferService.cols && (m.style.display = "none"),
                        this._refreshXPosition(_, m),
                        m
                    }
                    _refreshStyle(_) {
                        const m = _.marker.line - this._bufferService.buffers.active.ydisp;
                        if (m < 0 || m >= this._bufferService.rows)
                            _.element && (_.element.style.display = "none",
                            _.onRenderEmitter.fire(_.element));
                        else {
                            let p = this._decorationElements.get(_);
                            p || (p = this._createElement(_),
                            _.element = p,
                            this._decorationElements.set(_, p),
                            this._container.appendChild(p),
                            _.onDispose( () => {
                                this._decorationElements.delete(_),
                                p.remove()
                            }
                            )),
                            p.style.top = m * this._renderService.dimensions.css.cell.height + "px",
                            p.style.display = this._altBufferIsActive ? "none" : "block",
                            _.onRenderEmitter.fire(p)
                        }
                    }
                    _refreshXPosition(_, m=_.element) {
                        if (!m)
                            return;
                        const p = _.options.x ?? 0;
                        (_.options.anchor || "left") === "right" ? m.style.right = p ? p * this._renderService.dimensions.css.cell.width + "px" : "" : m.style.left = p ? p * this._renderService.dimensions.css.cell.width + "px" : ""
                    }
                    _removeDecoration(_) {
                        this._decorationElements.get(_)?.remove(),
                        this._decorationElements.delete(_),
                        _.dispose()
                    }
                }
                ;
                a.BufferDecorationRenderer = g = c([u(1, f.IBufferService), u(2, h.ICoreBrowserService), u(3, f.IDecorationService), u(4, h.IRenderService)], g)
            },
            5871: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.ColorZoneStore = void 0,
                a.ColorZoneStore = class {
                    constructor() {
                        this._zones = [],
                        this._zonePool = [],
                        this._zonePoolIndex = 0,
                        this._linePadding = {
                            full: 0,
                            left: 0,
                            center: 0,
                            right: 0
                        }
                    }
                    get zones() {
                        return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length),
                        this._zones
                    }
                    clear() {
                        this._zones.length = 0,
                        this._zonePoolIndex = 0
                    }
                    addDecoration(l) {
                        if (l.options.overviewRulerOptions) {
                            for (const c of this._zones)
                                if (c.color === l.options.overviewRulerOptions.color && c.position === l.options.overviewRulerOptions.position) {
                                    if (this._lineIntersectsZone(c, l.marker.line))
                                        return;
                                    if (this._lineAdjacentToZone(c, l.marker.line, l.options.overviewRulerOptions.position))
                                        return void this._addLineToZone(c, l.marker.line)
                                }
                            if (this._zonePoolIndex < this._zonePool.length)
                                return this._zonePool[this._zonePoolIndex].color = l.options.overviewRulerOptions.color,
                                this._zonePool[this._zonePoolIndex].position = l.options.overviewRulerOptions.position,
                                this._zonePool[this._zonePoolIndex].startBufferLine = l.marker.line,
                                this._zonePool[this._zonePoolIndex].endBufferLine = l.marker.line,
                                void this._zones.push(this._zonePool[this._zonePoolIndex++]);
                            this._zones.push({
                                color: l.options.overviewRulerOptions.color,
                                position: l.options.overviewRulerOptions.position,
                                startBufferLine: l.marker.line,
                                endBufferLine: l.marker.line
                            }),
                            this._zonePool.push(this._zones[this._zones.length - 1]),
                            this._zonePoolIndex++
                        }
                    }
                    setPadding(l) {
                        this._linePadding = l
                    }
                    _lineIntersectsZone(l, c) {
                        return c >= l.startBufferLine && c <= l.endBufferLine
                    }
                    _lineAdjacentToZone(l, c, u) {
                        return c >= l.startBufferLine - this._linePadding[u || "full"] && c <= l.endBufferLine + this._linePadding[u || "full"]
                    }
                    _addLineToZone(l, c) {
                        l.startBufferLine = Math.min(l.startBufferLine, c),
                        l.endBufferLine = Math.max(l.endBufferLine, c)
                    }
                }
            }
            ,
            5744: function(o, a, l) {
                var c = this && this.__decorate || function(y, x, E, w) {
                    var A, C = arguments.length, k = C < 3 ? x : w === null ? w = Object.getOwnPropertyDescriptor(x, E) : w;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        k = Reflect.decorate(y, x, E, w);
                    else
                        for (var I = y.length - 1; I >= 0; I--)
                            (A = y[I]) && (k = (C < 3 ? A(k) : C > 3 ? A(x, E, k) : A(x, E)) || k);
                    return C > 3 && k && Object.defineProperty(x, E, k),
                    k
                }
                  , u = this && this.__param || function(y, x) {
                    return function(E, w) {
                        x(E, w, y)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.OverviewRulerRenderer = void 0;
                const h = l(5871)
                  , d = l(4725)
                  , f = l(844)
                  , g = l(2585)
                  , _ = {
                    full: 0,
                    left: 0,
                    center: 0,
                    right: 0
                }
                  , m = {
                    full: 0,
                    left: 0,
                    center: 0,
                    right: 0
                }
                  , p = {
                    full: 0,
                    left: 0,
                    center: 0,
                    right: 0
                };
                let b = a.OverviewRulerRenderer = class extends f.Disposable {
                    get _width() {
                        return this._optionsService.options.overviewRulerWidth || 0
                    }
                    constructor(y, x, E, w, A, C, k) {
                        super(),
                        this._viewportElement = y,
                        this._screenElement = x,
                        this._bufferService = E,
                        this._decorationService = w,
                        this._renderService = A,
                        this._optionsService = C,
                        this._coreBrowserService = k,
                        this._colorZoneStore = new h.ColorZoneStore,
                        this._shouldUpdateDimensions = !0,
                        this._shouldUpdateAnchor = !0,
                        this._lastKnownBufferLength = 0,
                        this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"),
                        this._canvas.classList.add("xterm-decoration-overview-ruler"),
                        this._refreshCanvasDimensions(),
                        this._viewportElement.parentElement?.insertBefore(this._canvas, this._viewportElement);
                        const I = this._canvas.getContext("2d");
                        if (!I)
                            throw new Error("Ctx cannot be null");
                        this._ctx = I,
                        this._registerDecorationListeners(),
                        this._registerBufferChangeListeners(),
                        this._registerDimensionChangeListeners(),
                        this.register((0,
                        f.toDisposable)( () => {
                            this._canvas?.remove()
                        }
                        ))
                    }
                    _registerDecorationListeners() {
                        this.register(this._decorationService.onDecorationRegistered( () => this._queueRefresh(void 0, !0))),
                        this.register(this._decorationService.onDecorationRemoved( () => this._queueRefresh(void 0, !0)))
                    }
                    _registerBufferChangeListeners() {
                        this.register(this._renderService.onRenderedViewportChange( () => this._queueRefresh())),
                        this.register(this._bufferService.buffers.onBufferActivate( () => {
                            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block"
                        }
                        )),
                        this.register(this._bufferService.onScroll( () => {
                            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(),
                            this._refreshColorZonePadding())
                        }
                        ))
                    }
                    _registerDimensionChangeListeners() {
                        this.register(this._renderService.onRender( () => {
                            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0),
                            this._containerHeight = this._screenElement.clientHeight)
                        }
                        )),
                        this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))),
                        this.register(this._coreBrowserService.onDprChange( () => this._queueRefresh(!0))),
                        this._queueRefresh(!0)
                    }
                    _refreshDrawConstants() {
                        const y = Math.floor(this._canvas.width / 3)
                          , x = Math.ceil(this._canvas.width / 3);
                        m.full = this._canvas.width,
                        m.left = y,
                        m.center = x,
                        m.right = y,
                        this._refreshDrawHeightConstants(),
                        p.full = 0,
                        p.left = 0,
                        p.center = m.left,
                        p.right = m.left + m.center
                    }
                    _refreshDrawHeightConstants() {
                        _.full = Math.round(2 * this._coreBrowserService.dpr);
                        const y = this._canvas.height / this._bufferService.buffer.lines.length
                          , x = Math.round(Math.max(Math.min(y, 12), 6) * this._coreBrowserService.dpr);
                        _.left = x,
                        _.center = x,
                        _.right = x
                    }
                    _refreshColorZonePadding() {
                        this._colorZoneStore.setPadding({
                            full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * _.full),
                            left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * _.left),
                            center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * _.center),
                            right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * _.right)
                        }),
                        this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length
                    }
                    _refreshCanvasDimensions() {
                        this._canvas.style.width = `${this._width}px`,
                        this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr),
                        this._canvas.style.height = `${this._screenElement.clientHeight}px`,
                        this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr),
                        this._refreshDrawConstants(),
                        this._refreshColorZonePadding()
                    }
                    _refreshDecorations() {
                        this._shouldUpdateDimensions && this._refreshCanvasDimensions(),
                        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height),
                        this._colorZoneStore.clear();
                        for (const x of this._decorationService.decorations)
                            this._colorZoneStore.addDecoration(x);
                        this._ctx.lineWidth = 1;
                        const y = this._colorZoneStore.zones;
                        for (const x of y)
                            x.position !== "full" && this._renderColorZone(x);
                        for (const x of y)
                            x.position === "full" && this._renderColorZone(x);
                        this._shouldUpdateDimensions = !1,
                        this._shouldUpdateAnchor = !1
                    }
                    _renderColorZone(y) {
                        this._ctx.fillStyle = y.color,
                        this._ctx.fillRect(p[y.position || "full"], Math.round((this._canvas.height - 1) * (y.startBufferLine / this._bufferService.buffers.active.lines.length) - _[y.position || "full"] / 2), m[y.position || "full"], Math.round((this._canvas.height - 1) * ((y.endBufferLine - y.startBufferLine) / this._bufferService.buffers.active.lines.length) + _[y.position || "full"]))
                    }
                    _queueRefresh(y, x) {
                        this._shouldUpdateDimensions = y || this._shouldUpdateDimensions,
                        this._shouldUpdateAnchor = x || this._shouldUpdateAnchor,
                        this._animationFrame === void 0 && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame( () => {
                            this._refreshDecorations(),
                            this._animationFrame = void 0
                        }
                        ))
                    }
                }
                ;
                a.OverviewRulerRenderer = b = c([u(2, g.IBufferService), u(3, g.IDecorationService), u(4, d.IRenderService), u(5, g.IOptionsService), u(6, d.ICoreBrowserService)], b)
            },
            2950: function(o, a, l) {
                var c = this && this.__decorate || function(_, m, p, b) {
                    var y, x = arguments.length, E = x < 3 ? m : b === null ? b = Object.getOwnPropertyDescriptor(m, p) : b;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        E = Reflect.decorate(_, m, p, b);
                    else
                        for (var w = _.length - 1; w >= 0; w--)
                            (y = _[w]) && (E = (x < 3 ? y(E) : x > 3 ? y(m, p, E) : y(m, p)) || E);
                    return x > 3 && E && Object.defineProperty(m, p, E),
                    E
                }
                  , u = this && this.__param || function(_, m) {
                    return function(p, b) {
                        m(p, b, _)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CompositionHelper = void 0;
                const h = l(4725)
                  , d = l(2585)
                  , f = l(2584);
                let g = a.CompositionHelper = class {
                    get isComposing() {
                        return this._isComposing
                    }
                    constructor(_, m, p, b, y, x) {
                        this._textarea = _,
                        this._compositionView = m,
                        this._bufferService = p,
                        this._optionsService = b,
                        this._coreService = y,
                        this._renderService = x,
                        this._isComposing = !1,
                        this._isSendingComposition = !1,
                        this._compositionPosition = {
                            start: 0,
                            end: 0
                        },
                        this._dataAlreadySent = ""
                    }
                    compositionstart() {
                        this._isComposing = !0,
                        this._compositionPosition.start = this._textarea.value.length,
                        this._compositionView.textContent = "",
                        this._dataAlreadySent = "",
                        this._compositionView.classList.add("active")
                    }
                    compositionupdate(_) {
                        this._compositionView.textContent = _.data,
                        this.updateCompositionElements(),
                        setTimeout( () => {
                            this._compositionPosition.end = this._textarea.value.length
                        }
                        , 0)
                    }
                    compositionend() {
                        this._finalizeComposition(!0)
                    }
                    keydown(_) {
                        if (this._isComposing || this._isSendingComposition) {
                            if (_.keyCode === 229 || _.keyCode === 16 || _.keyCode === 17 || _.keyCode === 18)
                                return !1;
                            this._finalizeComposition(!1)
                        }
                        return _.keyCode !== 229 || (this._handleAnyTextareaChanges(),
                        !1)
                    }
                    _finalizeComposition(_) {
                        if (this._compositionView.classList.remove("active"),
                        this._isComposing = !1,
                        _) {
                            const m = {
                                start: this._compositionPosition.start,
                                end: this._compositionPosition.end
                            };
                            this._isSendingComposition = !0,
                            setTimeout( () => {
                                if (this._isSendingComposition) {
                                    let p;
                                    this._isSendingComposition = !1,
                                    m.start += this._dataAlreadySent.length,
                                    p = this._isComposing ? this._textarea.value.substring(m.start, m.end) : this._textarea.value.substring(m.start),
                                    p.length > 0 && this._coreService.triggerDataEvent(p, !0)
                                }
                            }
                            , 0)
                        } else {
                            this._isSendingComposition = !1;
                            const m = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
                            this._coreService.triggerDataEvent(m, !0)
                        }
                    }
                    _handleAnyTextareaChanges() {
                        const _ = this._textarea.value;
                        setTimeout( () => {
                            if (!this._isComposing) {
                                const m = this._textarea.value
                                  , p = m.replace(_, "");
                                this._dataAlreadySent = p,
                                m.length > _.length ? this._coreService.triggerDataEvent(p, !0) : m.length < _.length ? this._coreService.triggerDataEvent(`${f.C0.DEL}`, !0) : m.length === _.length && m !== _ && this._coreService.triggerDataEvent(m, !0)
                            }
                        }
                        , 0)
                    }
                    updateCompositionElements(_) {
                        if (this._isComposing) {
                            if (this._bufferService.buffer.isCursorInViewport) {
                                const m = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1)
                                  , p = this._renderService.dimensions.css.cell.height
                                  , b = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height
                                  , y = m * this._renderService.dimensions.css.cell.width;
                                this._compositionView.style.left = y + "px",
                                this._compositionView.style.top = b + "px",
                                this._compositionView.style.height = p + "px",
                                this._compositionView.style.lineHeight = p + "px",
                                this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily,
                                this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                                const x = this._compositionView.getBoundingClientRect();
                                this._textarea.style.left = y + "px",
                                this._textarea.style.top = b + "px",
                                this._textarea.style.width = Math.max(x.width, 1) + "px",
                                this._textarea.style.height = Math.max(x.height, 1) + "px",
                                this._textarea.style.lineHeight = x.height + "px"
                            }
                            _ || setTimeout( () => this.updateCompositionElements(!0), 0)
                        }
                    }
                }
                ;
                a.CompositionHelper = g = c([u(2, d.IBufferService), u(3, d.IOptionsService), u(4, d.ICoreService), u(5, h.IRenderService)], g)
            },
            9806: (o, a) => {
                function l(c, u, h) {
                    const d = h.getBoundingClientRect()
                      , f = c.getComputedStyle(h)
                      , g = parseInt(f.getPropertyValue("padding-left"))
                      , _ = parseInt(f.getPropertyValue("padding-top"));
                    return [u.clientX - d.left - g, u.clientY - d.top - _]
                }
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.getCoords = a.getCoordsRelativeToElement = void 0,
                a.getCoordsRelativeToElement = l,
                a.getCoords = function(c, u, h, d, f, g, _, m, p) {
                    if (!g)
                        return;
                    const b = l(c, u, h);
                    return b ? (b[0] = Math.ceil((b[0] + (p ? _ / 2 : 0)) / _),
                    b[1] = Math.ceil(b[1] / m),
                    b[0] = Math.min(Math.max(b[0], 1), d + (p ? 1 : 0)),
                    b[1] = Math.min(Math.max(b[1], 1), f),
                    b) : void 0
                }
            }
            ,
            9504: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.moveToCellSequence = void 0;
                const c = l(2584);
                function u(m, p, b, y) {
                    const x = m - h(m, b)
                      , E = p - h(p, b)
                      , w = Math.abs(x - E) - function(A, C, k) {
                        let I = 0;
                        const N = A - h(A, k)
                          , O = C - h(C, k);
                        for (let M = 0; M < Math.abs(N - O); M++) {
                            const H = d(A, C) === "A" ? -1 : 1;
                            k.buffer.lines.get(N + H * M)?.isWrapped && I++
                        }
                        return I
                    }(m, p, b);
                    return _(w, g(d(m, p), y))
                }
                function h(m, p) {
                    let b = 0
                      , y = p.buffer.lines.get(m)
                      , x = y?.isWrapped;
                    for (; x && m >= 0 && m < p.rows; )
                        b++,
                        y = p.buffer.lines.get(--m),
                        x = y?.isWrapped;
                    return b
                }
                function d(m, p) {
                    return m > p ? "A" : "B"
                }
                function f(m, p, b, y, x, E) {
                    let w = m
                      , A = p
                      , C = "";
                    for (; w !== b || A !== y; )
                        w += x ? 1 : -1,
                        x && w > E.cols - 1 ? (C += E.buffer.translateBufferLineToString(A, !1, m, w),
                        w = 0,
                        m = 0,
                        A++) : !x && w < 0 && (C += E.buffer.translateBufferLineToString(A, !1, 0, m + 1),
                        w = E.cols - 1,
                        m = w,
                        A--);
                    return C + E.buffer.translateBufferLineToString(A, !1, m, w)
                }
                function g(m, p) {
                    const b = p ? "O" : "[";
                    return c.C0.ESC + b + m
                }
                function _(m, p) {
                    m = Math.floor(m);
                    let b = "";
                    for (let y = 0; y < m; y++)
                        b += p;
                    return b
                }
                a.moveToCellSequence = function(m, p, b, y) {
                    const x = b.buffer.x
                      , E = b.buffer.y;
                    if (!b.buffer.hasScrollback)
                        return function(C, k, I, N, O, M) {
                            return u(k, N, O, M).length === 0 ? "" : _(f(C, k, C, k - h(k, O), !1, O).length, g("D", M))
                        }(x, E, 0, p, b, y) + u(E, p, b, y) + function(C, k, I, N, O, M) {
                            let H;
                            H = u(k, N, O, M).length > 0 ? N - h(N, O) : k;
                            const $ = N
                              , J = function(Q, ee, D, L, z, V) {
                                let B;
                                return B = u(D, L, z, V).length > 0 ? L - h(L, z) : ee,
                                Q < D && B <= L || Q >= D && B < L ? "C" : "D"
                            }(C, k, I, N, O, M);
                            return _(f(C, H, I, $, J === "C", O).length, g(J, M))
                        }(x, E, m, p, b, y);
                    let w;
                    if (E === p)
                        return w = x > m ? "D" : "C",
                        _(Math.abs(x - m), g(w, y));
                    w = E > p ? "D" : "C";
                    const A = Math.abs(E - p);
                    return _(function(C, k) {
                        return k.cols - C
                    }(E > p ? m : x, b) + (A - 1) * b.cols + 1 + ((E > p ? x : m) - 1), g(w, y))
                }
            }
            ,
            1296: function(o, a, l) {
                var c = this && this.__decorate || function(M, H, $, J) {
                    var Q, ee = arguments.length, D = ee < 3 ? H : J === null ? J = Object.getOwnPropertyDescriptor(H, $) : J;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        D = Reflect.decorate(M, H, $, J);
                    else
                        for (var L = M.length - 1; L >= 0; L--)
                            (Q = M[L]) && (D = (ee < 3 ? Q(D) : ee > 3 ? Q(H, $, D) : Q(H, $)) || D);
                    return ee > 3 && D && Object.defineProperty(H, $, D),
                    D
                }
                  , u = this && this.__param || function(M, H) {
                    return function($, J) {
                        H($, J, M)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.DomRenderer = void 0;
                const h = l(3787)
                  , d = l(2550)
                  , f = l(2223)
                  , g = l(6171)
                  , _ = l(6052)
                  , m = l(4725)
                  , p = l(8055)
                  , b = l(8460)
                  , y = l(844)
                  , x = l(2585)
                  , E = "xterm-dom-renderer-owner-"
                  , w = "xterm-rows"
                  , A = "xterm-fg-"
                  , C = "xterm-bg-"
                  , k = "xterm-focus"
                  , I = "xterm-selection";
                let N = 1
                  , O = a.DomRenderer = class extends y.Disposable {
                    constructor(M, H, $, J, Q, ee, D, L, z, V, B, Z, se) {
                        super(),
                        this._terminal = M,
                        this._document = H,
                        this._element = $,
                        this._screenElement = J,
                        this._viewportElement = Q,
                        this._helperContainer = ee,
                        this._linkifier2 = D,
                        this._charSizeService = z,
                        this._optionsService = V,
                        this._bufferService = B,
                        this._coreBrowserService = Z,
                        this._themeService = se,
                        this._terminalClass = N++,
                        this._rowElements = [],
                        this._selectionRenderModel = (0,
                        _.createSelectionRenderModel)(),
                        this.onRequestRedraw = this.register(new b.EventEmitter).event,
                        this._rowContainer = this._document.createElement("div"),
                        this._rowContainer.classList.add(w),
                        this._rowContainer.style.lineHeight = "normal",
                        this._rowContainer.setAttribute("aria-hidden", "true"),
                        this._refreshRowElements(this._bufferService.cols, this._bufferService.rows),
                        this._selectionContainer = this._document.createElement("div"),
                        this._selectionContainer.classList.add(I),
                        this._selectionContainer.setAttribute("aria-hidden", "true"),
                        this.dimensions = (0,
                        g.createRenderDimensions)(),
                        this._updateDimensions(),
                        this.register(this._optionsService.onOptionChange( () => this._handleOptionsChanged())),
                        this.register(this._themeService.onChangeColors(ae => this._injectCss(ae))),
                        this._injectCss(this._themeService.colors),
                        this._rowFactory = L.createInstance(h.DomRendererRowFactory, document),
                        this._element.classList.add(E + this._terminalClass),
                        this._screenElement.appendChild(this._rowContainer),
                        this._screenElement.appendChild(this._selectionContainer),
                        this.register(this._linkifier2.onShowLinkUnderline(ae => this._handleLinkHover(ae))),
                        this.register(this._linkifier2.onHideLinkUnderline(ae => this._handleLinkLeave(ae))),
                        this.register((0,
                        y.toDisposable)( () => {
                            this._element.classList.remove(E + this._terminalClass),
                            this._rowContainer.remove(),
                            this._selectionContainer.remove(),
                            this._widthCache.dispose(),
                            this._themeStyleElement.remove(),
                            this._dimensionsStyleElement.remove()
                        }
                        )),
                        this._widthCache = new d.WidthCache(this._document,this._helperContainer),
                        this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold),
                        this._setDefaultSpacing()
                    }
                    _updateDimensions() {
                        const M = this._coreBrowserService.dpr;
                        this.dimensions.device.char.width = this._charSizeService.width * M,
                        this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * M),
                        this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing),
                        this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight),
                        this.dimensions.device.char.left = 0,
                        this.dimensions.device.char.top = 0,
                        this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols,
                        this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows,
                        this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / M),
                        this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / M),
                        this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols,
                        this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
                        for (const $ of this._rowElements)
                            $.style.width = `${this.dimensions.css.canvas.width}px`,
                            $.style.height = `${this.dimensions.css.cell.height}px`,
                            $.style.lineHeight = `${this.dimensions.css.cell.height}px`,
                            $.style.overflow = "hidden";
                        this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"),
                        this._screenElement.appendChild(this._dimensionsStyleElement));
                        const H = `${this._terminalSelector} .${w} span { display: inline-block; height: 100%; vertical-align: top;}`;
                        this._dimensionsStyleElement.textContent = H,
                        this._selectionContainer.style.height = this._viewportElement.style.height,
                        this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`,
                        this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`
                    }
                    _injectCss(M) {
                        this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"),
                        this._screenElement.appendChild(this._themeStyleElement));
                        let H = `${this._terminalSelector} .${w} { color: ${M.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
                        H += `${this._terminalSelector} .${w} .xterm-dim { color: ${p.color.multiplyOpacity(M.foreground, .5).css};}`,
                        H += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;
                        const $ = `blink_underline_${this._terminalClass}`
                          , J = `blink_bar_${this._terminalClass}`
                          , Q = `blink_block_${this._terminalClass}`;
                        H += `@keyframes ${$} { 50% {  border-bottom-style: hidden; }}`,
                        H += `@keyframes ${J} { 50% {  box-shadow: none; }}`,
                        H += `@keyframes ${Q} { 0% {  background-color: ${M.cursor.css};  color: ${M.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${M.cursor.css}; }}`,
                        H += `${this._terminalSelector} .${w}.${k} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${$} 1s step-end infinite;}${this._terminalSelector} .${w}.${k} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${J} 1s step-end infinite;}${this._terminalSelector} .${w}.${k} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${Q} 1s step-end infinite;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-block { background-color: ${M.cursor.css}; color: ${M.cursorAccent.css};}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${M.cursor.css} !important; color: ${M.cursorAccent.css} !important;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${M.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${M.cursor.css} inset;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${M.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`,
                        H += `${this._terminalSelector} .${I} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${I} div { position: absolute; background-color: ${M.selectionBackgroundOpaque.css};}${this._terminalSelector} .${I} div { position: absolute; background-color: ${M.selectionInactiveBackgroundOpaque.css};}`;
                        for (const [ee,D] of M.ansi.entries())
                            H += `${this._terminalSelector} .${A}${ee} { color: ${D.css}; }${this._terminalSelector} .${A}${ee}.xterm-dim { color: ${p.color.multiplyOpacity(D, .5).css}; }${this._terminalSelector} .${C}${ee} { background-color: ${D.css}; }`;
                        H += `${this._terminalSelector} .${A}${f.INVERTED_DEFAULT_COLOR} { color: ${p.color.opaque(M.background).css}; }${this._terminalSelector} .${A}${f.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${p.color.multiplyOpacity(p.color.opaque(M.background), .5).css}; }${this._terminalSelector} .${C}${f.INVERTED_DEFAULT_COLOR} { background-color: ${M.foreground.css}; }`,
                        this._themeStyleElement.textContent = H
                    }
                    _setDefaultSpacing() {
                        const M = this.dimensions.css.cell.width - this._widthCache.get("W", !1, !1);
                        this._rowContainer.style.letterSpacing = `${M}px`,
                        this._rowFactory.defaultSpacing = M
                    }
                    handleDevicePixelRatioChange() {
                        this._updateDimensions(),
                        this._widthCache.clear(),
                        this._setDefaultSpacing()
                    }
                    _refreshRowElements(M, H) {
                        for (let $ = this._rowElements.length; $ <= H; $++) {
                            const J = this._document.createElement("div");
                            this._rowContainer.appendChild(J),
                            this._rowElements.push(J)
                        }
                        for (; this._rowElements.length > H; )
                            this._rowContainer.removeChild(this._rowElements.pop())
                    }
                    handleResize(M, H) {
                        this._refreshRowElements(M, H),
                        this._updateDimensions(),
                        this.handleSelectionChanged(this._selectionRenderModel.selectionStart, this._selectionRenderModel.selectionEnd, this._selectionRenderModel.columnSelectMode)
                    }
                    handleCharSizeChanged() {
                        this._updateDimensions(),
                        this._widthCache.clear(),
                        this._setDefaultSpacing()
                    }
                    handleBlur() {
                        this._rowContainer.classList.remove(k),
                        this.renderRows(0, this._bufferService.rows - 1)
                    }
                    handleFocus() {
                        this._rowContainer.classList.add(k),
                        this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y)
                    }
                    handleSelectionChanged(M, H, $) {
                        if (this._selectionContainer.replaceChildren(),
                        this._rowFactory.handleSelectionChanged(M, H, $),
                        this.renderRows(0, this._bufferService.rows - 1),
                        !M || !H)
                            return;
                        this._selectionRenderModel.update(this._terminal, M, H, $);
                        const J = this._selectionRenderModel.viewportStartRow
                          , Q = this._selectionRenderModel.viewportEndRow
                          , ee = this._selectionRenderModel.viewportCappedStartRow
                          , D = this._selectionRenderModel.viewportCappedEndRow;
                        if (ee >= this._bufferService.rows || D < 0)
                            return;
                        const L = this._document.createDocumentFragment();
                        if ($) {
                            const z = M[0] > H[0];
                            L.appendChild(this._createSelectionElement(ee, z ? H[0] : M[0], z ? M[0] : H[0], D - ee + 1))
                        } else {
                            const z = J === ee ? M[0] : 0
                              , V = ee === Q ? H[0] : this._bufferService.cols;
                            L.appendChild(this._createSelectionElement(ee, z, V));
                            const B = D - ee - 1;
                            if (L.appendChild(this._createSelectionElement(ee + 1, 0, this._bufferService.cols, B)),
                            ee !== D) {
                                const Z = Q === D ? H[0] : this._bufferService.cols;
                                L.appendChild(this._createSelectionElement(D, 0, Z))
                            }
                        }
                        this._selectionContainer.appendChild(L)
                    }
                    _createSelectionElement(M, H, $, J=1) {
                        const Q = this._document.createElement("div")
                          , ee = H * this.dimensions.css.cell.width;
                        let D = this.dimensions.css.cell.width * ($ - H);
                        return ee + D > this.dimensions.css.canvas.width && (D = this.dimensions.css.canvas.width - ee),
                        Q.style.height = J * this.dimensions.css.cell.height + "px",
                        Q.style.top = M * this.dimensions.css.cell.height + "px",
                        Q.style.left = `${ee}px`,
                        Q.style.width = `${D}px`,
                        Q
                    }
                    handleCursorMove() {}
                    _handleOptionsChanged() {
                        this._updateDimensions(),
                        this._injectCss(this._themeService.colors),
                        this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold),
                        this._setDefaultSpacing()
                    }
                    clear() {
                        for (const M of this._rowElements)
                            M.replaceChildren()
                    }
                    renderRows(M, H) {
                        const $ = this._bufferService.buffer
                          , J = $.ybase + $.y
                          , Q = Math.min($.x, this._bufferService.cols - 1)
                          , ee = this._optionsService.rawOptions.cursorBlink
                          , D = this._optionsService.rawOptions.cursorStyle
                          , L = this._optionsService.rawOptions.cursorInactiveStyle;
                        for (let z = M; z <= H; z++) {
                            const V = z + $.ydisp
                              , B = this._rowElements[z]
                              , Z = $.lines.get(V);
                            if (!B || !Z)
                                break;
                            B.replaceChildren(...this._rowFactory.createRow(Z, V, V === J, D, L, Q, ee, this.dimensions.css.cell.width, this._widthCache, -1, -1))
                        }
                    }
                    get _terminalSelector() {
                        return `.${E}${this._terminalClass}`
                    }
                    _handleLinkHover(M) {
                        this._setCellUnderline(M.x1, M.x2, M.y1, M.y2, M.cols, !0)
                    }
                    _handleLinkLeave(M) {
                        this._setCellUnderline(M.x1, M.x2, M.y1, M.y2, M.cols, !1)
                    }
                    _setCellUnderline(M, H, $, J, Q, ee) {
                        $ < 0 && (M = 0),
                        J < 0 && (H = 0);
                        const D = this._bufferService.rows - 1;
                        $ = Math.max(Math.min($, D), 0),
                        J = Math.max(Math.min(J, D), 0),
                        Q = Math.min(Q, this._bufferService.cols);
                        const L = this._bufferService.buffer
                          , z = L.ybase + L.y
                          , V = Math.min(L.x, Q - 1)
                          , B = this._optionsService.rawOptions.cursorBlink
                          , Z = this._optionsService.rawOptions.cursorStyle
                          , se = this._optionsService.rawOptions.cursorInactiveStyle;
                        for (let ae = $; ae <= J; ++ae) {
                            const G = ae + L.ydisp
                              , j = this._rowElements[ae]
                              , oe = L.lines.get(G);
                            if (!j || !oe)
                                break;
                            j.replaceChildren(...this._rowFactory.createRow(oe, G, G === z, Z, se, V, B, this.dimensions.css.cell.width, this._widthCache, ee ? ae === $ ? M : 0 : -1, ee ? (ae === J ? H : Q) - 1 : -1))
                        }
                    }
                }
                ;
                a.DomRenderer = O = c([u(7, x.IInstantiationService), u(8, m.ICharSizeService), u(9, x.IOptionsService), u(10, x.IBufferService), u(11, m.ICoreBrowserService), u(12, m.IThemeService)], O)
            },
            3787: function(o, a, l) {
                var c = this && this.__decorate || function(w, A, C, k) {
                    var I, N = arguments.length, O = N < 3 ? A : k === null ? k = Object.getOwnPropertyDescriptor(A, C) : k;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        O = Reflect.decorate(w, A, C, k);
                    else
                        for (var M = w.length - 1; M >= 0; M--)
                            (I = w[M]) && (O = (N < 3 ? I(O) : N > 3 ? I(A, C, O) : I(A, C)) || O);
                    return N > 3 && O && Object.defineProperty(A, C, O),
                    O
                }
                  , u = this && this.__param || function(w, A) {
                    return function(C, k) {
                        A(C, k, w)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.DomRendererRowFactory = void 0;
                const h = l(2223)
                  , d = l(643)
                  , f = l(511)
                  , g = l(2585)
                  , _ = l(8055)
                  , m = l(4725)
                  , p = l(4269)
                  , b = l(6171)
                  , y = l(3734);
                let x = a.DomRendererRowFactory = class {
                    constructor(w, A, C, k, I, N, O) {
                        this._document = w,
                        this._characterJoinerService = A,
                        this._optionsService = C,
                        this._coreBrowserService = k,
                        this._coreService = I,
                        this._decorationService = N,
                        this._themeService = O,
                        this._workCell = new f.CellData,
                        this._columnSelectMode = !1,
                        this.defaultSpacing = 0
                    }
                    handleSelectionChanged(w, A, C) {
                        this._selectionStart = w,
                        this._selectionEnd = A,
                        this._columnSelectMode = C
                    }
                    createRow(w, A, C, k, I, N, O, M, H, $, J) {
                        const Q = []
                          , ee = this._characterJoinerService.getJoinedCharacters(A)
                          , D = this._themeService.colors;
                        let L, z = w.getNoBgTrimmedLength();
                        C && z < N + 1 && (z = N + 1);
                        let V = 0
                          , B = ""
                          , Z = 0
                          , se = 0
                          , ae = 0
                          , G = !1
                          , j = 0
                          , oe = !1
                          , le = 0;
                        const de = []
                          , ne = $ !== -1 && J !== -1;
                        for (let pe = 0; pe < z; pe++) {
                            w.loadCell(pe, this._workCell);
                            let Te = this._workCell.getWidth();
                            if (Te === 0)
                                continue;
                            let Ce = !1
                              , Re = pe
                              , we = this._workCell;
                            if (ee.length > 0 && pe === ee[0][0]) {
                                Ce = !0;
                                const P = ee.shift();
                                we = new p.JoinedCellData(this._workCell,w.translateToString(!0, P[0], P[1]),P[1] - P[0]),
                                Re = P[1] - 1,
                                Te = we.getWidth()
                            }
                            const ze = this._isCellInSelection(pe, A)
                              , qe = C && pe === N
                              , et = ne && pe >= $ && pe <= J;
                            let $t = !1;
                            this._decorationService.forEachDecorationAtCell(pe, A, void 0, P => {
                                $t = !0
                            }
                            );
                            let Jt = we.getChars() || d.WHITESPACE_CELL_CHAR;
                            if (Jt === " " && (we.isUnderline() || we.isOverline()) && (Jt = ""),
                            le = Te * M - H.get(Jt, we.isBold(), we.isItalic()),
                            L) {
                                if (V && (ze && oe || !ze && !oe && we.bg === Z) && (ze && oe && D.selectionForeground || we.fg === se) && we.extended.ext === ae && et === G && le === j && !qe && !Ce && !$t) {
                                    we.isInvisible() ? B += d.WHITESPACE_CELL_CHAR : B += Jt,
                                    V++;
                                    continue
                                }
                                V && (L.textContent = B),
                                L = this._document.createElement("span"),
                                V = 0,
                                B = ""
                            } else
                                L = this._document.createElement("span");
                            if (Z = we.bg,
                            se = we.fg,
                            ae = we.extended.ext,
                            G = et,
                            j = le,
                            oe = ze,
                            Ce && N >= pe && N <= Re && (N = pe),
                            !this._coreService.isCursorHidden && qe && this._coreService.isCursorInitialized) {
                                if (de.push("xterm-cursor"),
                                this._coreBrowserService.isFocused)
                                    O && de.push("xterm-cursor-blink"),
                                    de.push(k === "bar" ? "xterm-cursor-bar" : k === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
                                else if (I)
                                    switch (I) {
                                    case "outline":
                                        de.push("xterm-cursor-outline");
                                        break;
                                    case "block":
                                        de.push("xterm-cursor-block");
                                        break;
                                    case "bar":
                                        de.push("xterm-cursor-bar");
                                        break;
                                    case "underline":
                                        de.push("xterm-cursor-underline")
                                    }
                            }
                            if (we.isBold() && de.push("xterm-bold"),
                            we.isItalic() && de.push("xterm-italic"),
                            we.isDim() && de.push("xterm-dim"),
                            B = we.isInvisible() ? d.WHITESPACE_CELL_CHAR : we.getChars() || d.WHITESPACE_CELL_CHAR,
                            we.isUnderline() && (de.push(`xterm-underline-${we.extended.underlineStyle}`),
                            B === " " && (B = ""),
                            !we.isUnderlineColorDefault()))
                                if (we.isUnderlineColorRGB())
                                    L.style.textDecorationColor = `rgb(${y.AttributeData.toColorRGB(we.getUnderlineColor()).join(",")})`;
                                else {
                                    let P = we.getUnderlineColor();
                                    this._optionsService.rawOptions.drawBoldTextInBrightColors && we.isBold() && P < 8 && (P += 8),
                                    L.style.textDecorationColor = D.ansi[P].css
                                }
                            we.isOverline() && (de.push("xterm-overline"),
                            B === " " && (B = "")),
                            we.isStrikethrough() && de.push("xterm-strikethrough"),
                            et && (L.style.textDecoration = "underline");
                            let _t = we.getFgColor()
                              , St = we.getFgColorMode()
                              , it = we.getBgColor()
                              , he = we.getBgColorMode();
                            const Se = !!we.isInverse();
                            if (Se) {
                                const P = _t;
                                _t = it,
                                it = P;
                                const q = St;
                                St = he,
                                he = q
                            }
                            let De, Ge, F, R = !1;
                            switch (this._decorationService.forEachDecorationAtCell(pe, A, void 0, P => {
                                P.options.layer !== "top" && R || (P.backgroundColorRGB && (he = 50331648,
                                it = P.backgroundColorRGB.rgba >> 8 & 16777215,
                                De = P.backgroundColorRGB),
                                P.foregroundColorRGB && (St = 50331648,
                                _t = P.foregroundColorRGB.rgba >> 8 & 16777215,
                                Ge = P.foregroundColorRGB),
                                R = P.options.layer === "top")
                            }
                            ),
                            !R && ze && (De = this._coreBrowserService.isFocused ? D.selectionBackgroundOpaque : D.selectionInactiveBackgroundOpaque,
                            it = De.rgba >> 8 & 16777215,
                            he = 50331648,
                            R = !0,
                            D.selectionForeground && (St = 50331648,
                            _t = D.selectionForeground.rgba >> 8 & 16777215,
                            Ge = D.selectionForeground)),
                            R && de.push("xterm-decoration-top"),
                            he) {
                            case 16777216:
                            case 33554432:
                                F = D.ansi[it],
                                de.push(`xterm-bg-${it}`);
                                break;
                            case 50331648:
                                F = _.channels.toColor(it >> 16, it >> 8 & 255, 255 & it),
                                this._addStyle(L, `background-color:#${E((it >>> 0).toString(16), "0", 6)}`);
                                break;
                            default:
                                Se ? (F = D.foreground,
                                de.push(`xterm-bg-${h.INVERTED_DEFAULT_COLOR}`)) : F = D.background
                            }
                            switch (De || we.isDim() && (De = _.color.multiplyOpacity(F, .5)),
                            St) {
                            case 16777216:
                            case 33554432:
                                we.isBold() && _t < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (_t += 8),
                                this._applyMinimumContrast(L, F, D.ansi[_t], we, De, void 0) || de.push(`xterm-fg-${_t}`);
                                break;
                            case 50331648:
                                const P = _.channels.toColor(_t >> 16 & 255, _t >> 8 & 255, 255 & _t);
                                this._applyMinimumContrast(L, F, P, we, De, Ge) || this._addStyle(L, `color:#${E(_t.toString(16), "0", 6)}`);
                                break;
                            default:
                                this._applyMinimumContrast(L, F, D.foreground, we, De, Ge) || Se && de.push(`xterm-fg-${h.INVERTED_DEFAULT_COLOR}`)
                            }
                            de.length && (L.className = de.join(" "),
                            de.length = 0),
                            qe || Ce || $t ? L.textContent = B : V++,
                            le !== this.defaultSpacing && (L.style.letterSpacing = `${le}px`),
                            Q.push(L),
                            pe = Re
                        }
                        return L && V && (L.textContent = B),
                        Q
                    }
                    _applyMinimumContrast(w, A, C, k, I, N) {
                        if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0,
                        b.treatGlyphAsBackgroundColor)(k.getCode()))
                            return !1;
                        const O = this._getContrastCache(k);
                        let M;
                        if (I || N || (M = O.getColor(A.rgba, C.rgba)),
                        M === void 0) {
                            const H = this._optionsService.rawOptions.minimumContrastRatio / (k.isDim() ? 2 : 1);
                            M = _.color.ensureContrastRatio(I || A, N || C, H),
                            O.setColor((I || A).rgba, (N || C).rgba, M ?? null)
                        }
                        return !!M && (this._addStyle(w, `color:${M.css}`),
                        !0)
                    }
                    _getContrastCache(w) {
                        return w.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache
                    }
                    _addStyle(w, A) {
                        w.setAttribute("style", `${w.getAttribute("style") || ""}${A};`)
                    }
                    _isCellInSelection(w, A) {
                        const C = this._selectionStart
                          , k = this._selectionEnd;
                        return !(!C || !k) && (this._columnSelectMode ? C[0] <= k[0] ? w >= C[0] && A >= C[1] && w < k[0] && A <= k[1] : w < C[0] && A >= C[1] && w >= k[0] && A <= k[1] : A > C[1] && A < k[1] || C[1] === k[1] && A === C[1] && w >= C[0] && w < k[0] || C[1] < k[1] && A === k[1] && w < k[0] || C[1] < k[1] && A === C[1] && w >= C[0])
                    }
                }
                ;
                function E(w, A, C) {
                    for (; w.length < C; )
                        w = A + w;
                    return w
                }
                a.DomRendererRowFactory = x = c([u(1, m.ICharacterJoinerService), u(2, g.IOptionsService), u(3, m.ICoreBrowserService), u(4, g.ICoreService), u(5, g.IDecorationService), u(6, m.IThemeService)], x)
            },
            2550: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.WidthCache = void 0,
                a.WidthCache = class {
                    constructor(l, c) {
                        this._flat = new Float32Array(256),
                        this._font = "",
                        this._fontSize = 0,
                        this._weight = "normal",
                        this._weightBold = "bold",
                        this._measureElements = [],
                        this._container = l.createElement("div"),
                        this._container.classList.add("xterm-width-cache-measure-container"),
                        this._container.setAttribute("aria-hidden", "true"),
                        this._container.style.whiteSpace = "pre",
                        this._container.style.fontKerning = "none";
                        const u = l.createElement("span");
                        u.classList.add("xterm-char-measure-element");
                        const h = l.createElement("span");
                        h.classList.add("xterm-char-measure-element"),
                        h.style.fontWeight = "bold";
                        const d = l.createElement("span");
                        d.classList.add("xterm-char-measure-element"),
                        d.style.fontStyle = "italic";
                        const f = l.createElement("span");
                        f.classList.add("xterm-char-measure-element"),
                        f.style.fontWeight = "bold",
                        f.style.fontStyle = "italic",
                        this._measureElements = [u, h, d, f],
                        this._container.appendChild(u),
                        this._container.appendChild(h),
                        this._container.appendChild(d),
                        this._container.appendChild(f),
                        c.appendChild(this._container),
                        this.clear()
                    }
                    dispose() {
                        this._container.remove(),
                        this._measureElements.length = 0,
                        this._holey = void 0
                    }
                    clear() {
                        this._flat.fill(-9999),
                        this._holey = new Map
                    }
                    setFont(l, c, u, h) {
                        l === this._font && c === this._fontSize && u === this._weight && h === this._weightBold || (this._font = l,
                        this._fontSize = c,
                        this._weight = u,
                        this._weightBold = h,
                        this._container.style.fontFamily = this._font,
                        this._container.style.fontSize = `${this._fontSize}px`,
                        this._measureElements[0].style.fontWeight = `${u}`,
                        this._measureElements[1].style.fontWeight = `${h}`,
                        this._measureElements[2].style.fontWeight = `${u}`,
                        this._measureElements[3].style.fontWeight = `${h}`,
                        this.clear())
                    }
                    get(l, c, u) {
                        let h = 0;
                        if (!c && !u && l.length === 1 && (h = l.charCodeAt(0)) < 256) {
                            if (this._flat[h] !== -9999)
                                return this._flat[h];
                            const g = this._measure(l, 0);
                            return g > 0 && (this._flat[h] = g),
                            g
                        }
                        let d = l;
                        c && (d += "B"),
                        u && (d += "I");
                        let f = this._holey.get(d);
                        if (f === void 0) {
                            let g = 0;
                            c && (g |= 1),
                            u && (g |= 2),
                            f = this._measure(l, g),
                            f > 0 && this._holey.set(d, f)
                        }
                        return f
                    }
                    _measure(l, c) {
                        const u = this._measureElements[c];
                        return u.textContent = l.repeat(32),
                        u.offsetWidth / 32
                    }
                }
            }
            ,
            2223: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.TEXT_BASELINE = a.DIM_OPACITY = a.INVERTED_DEFAULT_COLOR = void 0;
                const c = l(6114);
                a.INVERTED_DEFAULT_COLOR = 257,
                a.DIM_OPACITY = .5,
                a.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic"
            }
            ,
            6171: (o, a) => {
                function l(u) {
                    return 57508 <= u && u <= 57558
                }
                function c(u) {
                    return u >= 128512 && u <= 128591 || u >= 127744 && u <= 128511 || u >= 128640 && u <= 128767 || u >= 9728 && u <= 9983 || u >= 9984 && u <= 10175 || u >= 65024 && u <= 65039 || u >= 129280 && u <= 129535 || u >= 127462 && u <= 127487
                }
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.computeNextVariantOffset = a.createRenderDimensions = a.treatGlyphAsBackgroundColor = a.allowRescaling = a.isEmoji = a.isRestrictedPowerlineGlyph = a.isPowerlineGlyph = a.throwIfFalsy = void 0,
                a.throwIfFalsy = function(u) {
                    if (!u)
                        throw new Error("value must not be falsy");
                    return u
                }
                ,
                a.isPowerlineGlyph = l,
                a.isRestrictedPowerlineGlyph = function(u) {
                    return 57520 <= u && u <= 57527
                }
                ,
                a.isEmoji = c,
                a.allowRescaling = function(u, h, d, f) {
                    return h === 1 && d > Math.ceil(1.5 * f) && u !== void 0 && u > 255 && !c(u) && !l(u) && !function(g) {
                        return 57344 <= g && g <= 63743
                    }(u)
                }
                ,
                a.treatGlyphAsBackgroundColor = function(u) {
                    return l(u) || function(h) {
                        return 9472 <= h && h <= 9631
                    }(u)
                }
                ,
                a.createRenderDimensions = function() {
                    return {
                        css: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            }
                        },
                        device: {
                            canvas: {
                                width: 0,
                                height: 0
                            },
                            cell: {
                                width: 0,
                                height: 0
                            },
                            char: {
                                width: 0,
                                height: 0,
                                left: 0,
                                top: 0
                            }
                        }
                    }
                }
                ,
                a.computeNextVariantOffset = function(u, h, d=0) {
                    return (u - (2 * Math.round(h) - d)) % (2 * Math.round(h))
                }
            }
            ,
            6052: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.createSelectionRenderModel = void 0;
                class l {
                    constructor() {
                        this.clear()
                    }
                    clear() {
                        this.hasSelection = !1,
                        this.columnSelectMode = !1,
                        this.viewportStartRow = 0,
                        this.viewportEndRow = 0,
                        this.viewportCappedStartRow = 0,
                        this.viewportCappedEndRow = 0,
                        this.startCol = 0,
                        this.endCol = 0,
                        this.selectionStart = void 0,
                        this.selectionEnd = void 0
                    }
                    update(u, h, d, f=!1) {
                        if (this.selectionStart = h,
                        this.selectionEnd = d,
                        !h || !d || h[0] === d[0] && h[1] === d[1])
                            return void this.clear();
                        const g = u.buffers.active.ydisp
                          , _ = h[1] - g
                          , m = d[1] - g
                          , p = Math.max(_, 0)
                          , b = Math.min(m, u.rows - 1);
                        p >= u.rows || b < 0 ? this.clear() : (this.hasSelection = !0,
                        this.columnSelectMode = f,
                        this.viewportStartRow = _,
                        this.viewportEndRow = m,
                        this.viewportCappedStartRow = p,
                        this.viewportCappedEndRow = b,
                        this.startCol = h[0],
                        this.endCol = d[0])
                    }
                    isCellSelected(u, h, d) {
                        return !!this.hasSelection && (d -= u.buffer.active.viewportY,
                        this.columnSelectMode ? this.startCol <= this.endCol ? h >= this.startCol && d >= this.viewportCappedStartRow && h < this.endCol && d <= this.viewportCappedEndRow : h < this.startCol && d >= this.viewportCappedStartRow && h >= this.endCol && d <= this.viewportCappedEndRow : d > this.viewportStartRow && d < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && d === this.viewportStartRow && h >= this.startCol && h < this.endCol || this.viewportStartRow < this.viewportEndRow && d === this.viewportEndRow && h < this.endCol || this.viewportStartRow < this.viewportEndRow && d === this.viewportStartRow && h >= this.startCol)
                    }
                }
                a.createSelectionRenderModel = function() {
                    return new l
                }
            }
            ,
            456: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.SelectionModel = void 0,
                a.SelectionModel = class {
                    constructor(l) {
                        this._bufferService = l,
                        this.isSelectAllActive = !1,
                        this.selectionStartLength = 0
                    }
                    clearSelection() {
                        this.selectionStart = void 0,
                        this.selectionEnd = void 0,
                        this.isSelectAllActive = !1,
                        this.selectionStartLength = 0
                    }
                    get finalSelectionStart() {
                        return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart
                    }
                    get finalSelectionEnd() {
                        if (this.isSelectAllActive)
                            return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
                        if (this.selectionStart) {
                            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                                const l = this.selectionStart[0] + this.selectionStartLength;
                                return l > this._bufferService.cols ? l % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols) - 1] : [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [l, this.selectionStart[1]]
                            }
                            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                                const l = this.selectionStart[0] + this.selectionStartLength;
                                return l > this._bufferService.cols ? [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [Math.max(l, this.selectionEnd[0]), this.selectionEnd[1]]
                            }
                            return this.selectionEnd
                        }
                    }
                    areSelectionValuesReversed() {
                        const l = this.selectionStart
                          , c = this.selectionEnd;
                        return !(!l || !c) && (l[1] > c[1] || l[1] === c[1] && l[0] > c[0])
                    }
                    handleTrim(l) {
                        return this.selectionStart && (this.selectionStart[1] -= l),
                        this.selectionEnd && (this.selectionEnd[1] -= l),
                        this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(),
                        !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0),
                        !1)
                    }
                }
            }
            ,
            428: function(o, a, l) {
                var c = this && this.__decorate || function(b, y, x, E) {
                    var w, A = arguments.length, C = A < 3 ? y : E === null ? E = Object.getOwnPropertyDescriptor(y, x) : E;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        C = Reflect.decorate(b, y, x, E);
                    else
                        for (var k = b.length - 1; k >= 0; k--)
                            (w = b[k]) && (C = (A < 3 ? w(C) : A > 3 ? w(y, x, C) : w(y, x)) || C);
                    return A > 3 && C && Object.defineProperty(y, x, C),
                    C
                }
                  , u = this && this.__param || function(b, y) {
                    return function(x, E) {
                        y(x, E, b)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CharSizeService = void 0;
                const h = l(2585)
                  , d = l(8460)
                  , f = l(844);
                let g = a.CharSizeService = class extends f.Disposable {
                    get hasValidSize() {
                        return this.width > 0 && this.height > 0
                    }
                    constructor(b, y, x) {
                        super(),
                        this._optionsService = x,
                        this.width = 0,
                        this.height = 0,
                        this._onCharSizeChange = this.register(new d.EventEmitter),
                        this.onCharSizeChange = this._onCharSizeChange.event;
                        try {
                            this._measureStrategy = this.register(new p(this._optionsService))
                        } catch {
                            this._measureStrategy = this.register(new m(b,y,this._optionsService))
                        }
                        this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()))
                    }
                    measure() {
                        const b = this._measureStrategy.measure();
                        b.width === this.width && b.height === this.height || (this.width = b.width,
                        this.height = b.height,
                        this._onCharSizeChange.fire())
                    }
                }
                ;
                a.CharSizeService = g = c([u(2, h.IOptionsService)], g);
                class _ extends f.Disposable {
                    constructor() {
                        super(...arguments),
                        this._result = {
                            width: 0,
                            height: 0
                        }
                    }
                    _validateAndSet(y, x) {
                        y !== void 0 && y > 0 && x !== void 0 && x > 0 && (this._result.width = y,
                        this._result.height = x)
                    }
                }
                class m extends _ {
                    constructor(y, x, E) {
                        super(),
                        this._document = y,
                        this._parentElement = x,
                        this._optionsService = E,
                        this._measureElement = this._document.createElement("span"),
                        this._measureElement.classList.add("xterm-char-measure-element"),
                        this._measureElement.textContent = "W".repeat(32),
                        this._measureElement.setAttribute("aria-hidden", "true"),
                        this._measureElement.style.whiteSpace = "pre",
                        this._measureElement.style.fontKerning = "none",
                        this._parentElement.appendChild(this._measureElement)
                    }
                    measure() {
                        return this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily,
                        this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`,
                        this._validateAndSet(Number(this._measureElement.offsetWidth) / 32, Number(this._measureElement.offsetHeight)),
                        this._result
                    }
                }
                class p extends _ {
                    constructor(y) {
                        super(),
                        this._optionsService = y,
                        this._canvas = new OffscreenCanvas(100,100),
                        this._ctx = this._canvas.getContext("2d");
                        const x = this._ctx.measureText("W");
                        if (!("width"in x && "fontBoundingBoxAscent"in x && "fontBoundingBoxDescent"in x))
                            throw new Error("Required font metrics not supported")
                    }
                    measure() {
                        this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;
                        const y = this._ctx.measureText("W");
                        return this._validateAndSet(y.width, y.fontBoundingBoxAscent + y.fontBoundingBoxDescent),
                        this._result
                    }
                }
            },
            4269: function(o, a, l) {
                var c = this && this.__decorate || function(p, b, y, x) {
                    var E, w = arguments.length, A = w < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, y) : x;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        A = Reflect.decorate(p, b, y, x);
                    else
                        for (var C = p.length - 1; C >= 0; C--)
                            (E = p[C]) && (A = (w < 3 ? E(A) : w > 3 ? E(b, y, A) : E(b, y)) || A);
                    return w > 3 && A && Object.defineProperty(b, y, A),
                    A
                }
                  , u = this && this.__param || function(p, b) {
                    return function(y, x) {
                        b(y, x, p)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CharacterJoinerService = a.JoinedCellData = void 0;
                const h = l(3734)
                  , d = l(643)
                  , f = l(511)
                  , g = l(2585);
                class _ extends h.AttributeData {
                    constructor(b, y, x) {
                        super(),
                        this.content = 0,
                        this.combinedData = "",
                        this.fg = b.fg,
                        this.bg = b.bg,
                        this.combinedData = y,
                        this._width = x
                    }
                    isCombined() {
                        return 2097152
                    }
                    getWidth() {
                        return this._width
                    }
                    getChars() {
                        return this.combinedData
                    }
                    getCode() {
                        return 2097151
                    }
                    setFromCharData(b) {
                        throw new Error("not implemented")
                    }
                    getAsCharData() {
                        return [this.fg, this.getChars(), this.getWidth(), this.getCode()]
                    }
                }
                a.JoinedCellData = _;
                let m = a.CharacterJoinerService = class AL {
                    constructor(b) {
                        this._bufferService = b,
                        this._characterJoiners = [],
                        this._nextCharacterJoinerId = 0,
                        this._workCell = new f.CellData
                    }
                    register(b) {
                        const y = {
                            id: this._nextCharacterJoinerId++,
                            handler: b
                        };
                        return this._characterJoiners.push(y),
                        y.id
                    }
                    deregister(b) {
                        for (let y = 0; y < this._characterJoiners.length; y++)
                            if (this._characterJoiners[y].id === b)
                                return this._characterJoiners.splice(y, 1),
                                !0;
                        return !1
                    }
                    getJoinedCharacters(b) {
                        if (this._characterJoiners.length === 0)
                            return [];
                        const y = this._bufferService.buffer.lines.get(b);
                        if (!y || y.length === 0)
                            return [];
                        const x = []
                          , E = y.translateToString(!0);
                        let w = 0
                          , A = 0
                          , C = 0
                          , k = y.getFg(0)
                          , I = y.getBg(0);
                        for (let N = 0; N < y.getTrimmedLength(); N++)
                            if (y.loadCell(N, this._workCell),
                            this._workCell.getWidth() !== 0) {
                                if (this._workCell.fg !== k || this._workCell.bg !== I) {
                                    if (N - w > 1) {
                                        const O = this._getJoinedRanges(E, C, A, y, w);
                                        for (let M = 0; M < O.length; M++)
                                            x.push(O[M])
                                    }
                                    w = N,
                                    C = A,
                                    k = this._workCell.fg,
                                    I = this._workCell.bg
                                }
                                A += this._workCell.getChars().length || d.WHITESPACE_CELL_CHAR.length
                            }
                        if (this._bufferService.cols - w > 1) {
                            const N = this._getJoinedRanges(E, C, A, y, w);
                            for (let O = 0; O < N.length; O++)
                                x.push(N[O])
                        }
                        return x
                    }
                    _getJoinedRanges(b, y, x, E, w) {
                        const A = b.substring(y, x);
                        let C = [];
                        try {
                            C = this._characterJoiners[0].handler(A)
                        } catch (k) {
                            console.error(k)
                        }
                        for (let k = 1; k < this._characterJoiners.length; k++)
                            try {
                                const I = this._characterJoiners[k].handler(A);
                                for (let N = 0; N < I.length; N++)
                                    AL._mergeRanges(C, I[N])
                            } catch (I) {
                                console.error(I)
                            }
                        return this._stringRangesToCellRanges(C, E, w),
                        C
                    }
                    _stringRangesToCellRanges(b, y, x) {
                        let E = 0
                          , w = !1
                          , A = 0
                          , C = b[E];
                        if (C) {
                            for (let k = x; k < this._bufferService.cols; k++) {
                                const I = y.getWidth(k)
                                  , N = y.getString(k).length || d.WHITESPACE_CELL_CHAR.length;
                                if (I !== 0) {
                                    if (!w && C[0] <= A && (C[0] = k,
                                    w = !0),
                                    C[1] <= A) {
                                        if (C[1] = k,
                                        C = b[++E],
                                        !C)
                                            break;
                                        C[0] <= A ? (C[0] = k,
                                        w = !0) : w = !1
                                    }
                                    A += N
                                }
                            }
                            C && (C[1] = this._bufferService.cols)
                        }
                    }
                    static _mergeRanges(b, y) {
                        let x = !1;
                        for (let E = 0; E < b.length; E++) {
                            const w = b[E];
                            if (x) {
                                if (y[1] <= w[0])
                                    return b[E - 1][1] = y[1],
                                    b;
                                if (y[1] <= w[1])
                                    return b[E - 1][1] = Math.max(y[1], w[1]),
                                    b.splice(E, 1),
                                    b;
                                b.splice(E, 1),
                                E--
                            } else {
                                if (y[1] <= w[0])
                                    return b.splice(E, 0, y),
                                    b;
                                if (y[1] <= w[1])
                                    return w[0] = Math.min(y[0], w[0]),
                                    b;
                                y[0] < w[1] && (w[0] = Math.min(y[0], w[0]),
                                x = !0)
                            }
                        }
                        return x ? b[b.length - 1][1] = y[1] : b.push(y),
                        b
                    }
                }
                ;
                a.CharacterJoinerService = m = c([u(0, g.IBufferService)], m)
            },
            5114: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CoreBrowserService = void 0;
                const c = l(844)
                  , u = l(8460)
                  , h = l(3656);
                class d extends c.Disposable {
                    constructor(_, m, p) {
                        super(),
                        this._textarea = _,
                        this._window = m,
                        this.mainDocument = p,
                        this._isFocused = !1,
                        this._cachedIsFocused = void 0,
                        this._screenDprMonitor = new f(this._window),
                        this._onDprChange = this.register(new u.EventEmitter),
                        this.onDprChange = this._onDprChange.event,
                        this._onWindowChange = this.register(new u.EventEmitter),
                        this.onWindowChange = this._onWindowChange.event,
                        this.register(this.onWindowChange(b => this._screenDprMonitor.setWindow(b))),
                        this.register((0,
                        u.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)),
                        this._textarea.addEventListener("focus", () => this._isFocused = !0),
                        this._textarea.addEventListener("blur", () => this._isFocused = !1)
                    }
                    get window() {
                        return this._window
                    }
                    set window(_) {
                        this._window !== _ && (this._window = _,
                        this._onWindowChange.fire(this._window))
                    }
                    get dpr() {
                        return this.window.devicePixelRatio
                    }
                    get isFocused() {
                        return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(),
                        queueMicrotask( () => this._cachedIsFocused = void 0)),
                        this._cachedIsFocused
                    }
                }
                a.CoreBrowserService = d;
                class f extends c.Disposable {
                    constructor(_) {
                        super(),
                        this._parentWindow = _,
                        this._windowResizeListener = this.register(new c.MutableDisposable),
                        this._onDprChange = this.register(new u.EventEmitter),
                        this.onDprChange = this._onDprChange.event,
                        this._outerListener = () => this._setDprAndFireIfDiffers(),
                        this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio,
                        this._updateDpr(),
                        this._setWindowResizeListener(),
                        this.register((0,
                        c.toDisposable)( () => this.clearListener()))
                    }
                    setWindow(_) {
                        this._parentWindow = _,
                        this._setWindowResizeListener(),
                        this._setDprAndFireIfDiffers()
                    }
                    _setWindowResizeListener() {
                        this._windowResizeListener.value = (0,
                        h.addDisposableDomListener)(this._parentWindow, "resize", () => this._setDprAndFireIfDiffers())
                    }
                    _setDprAndFireIfDiffers() {
                        this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio),
                        this._updateDpr()
                    }
                    _updateDpr() {
                        this._outerListener && (this._resolutionMediaMatchList?.removeListener(this._outerListener),
                        this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio,
                        this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`),
                        this._resolutionMediaMatchList.addListener(this._outerListener))
                    }
                    clearListener() {
                        this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener),
                        this._resolutionMediaMatchList = void 0,
                        this._outerListener = void 0)
                    }
                }
            }
            ,
            779: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.LinkProviderService = void 0;
                const c = l(844);
                class u extends c.Disposable {
                    constructor() {
                        super(),
                        this.linkProviders = [],
                        this.register((0,
                        c.toDisposable)( () => this.linkProviders.length = 0))
                    }
                    registerLinkProvider(d) {
                        return this.linkProviders.push(d),
                        {
                            dispose: () => {
                                const f = this.linkProviders.indexOf(d);
                                f !== -1 && this.linkProviders.splice(f, 1)
                            }
                        }
                    }
                }
                a.LinkProviderService = u
            }
            ,
            8934: function(o, a, l) {
                var c = this && this.__decorate || function(g, _, m, p) {
                    var b, y = arguments.length, x = y < 3 ? _ : p === null ? p = Object.getOwnPropertyDescriptor(_, m) : p;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        x = Reflect.decorate(g, _, m, p);
                    else
                        for (var E = g.length - 1; E >= 0; E--)
                            (b = g[E]) && (x = (y < 3 ? b(x) : y > 3 ? b(_, m, x) : b(_, m)) || x);
                    return y > 3 && x && Object.defineProperty(_, m, x),
                    x
                }
                  , u = this && this.__param || function(g, _) {
                    return function(m, p) {
                        _(m, p, g)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.MouseService = void 0;
                const h = l(4725)
                  , d = l(9806);
                let f = a.MouseService = class {
                    constructor(g, _) {
                        this._renderService = g,
                        this._charSizeService = _
                    }
                    getCoords(g, _, m, p, b) {
                        return (0,
                        d.getCoords)(window, g, _, m, p, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, b)
                    }
                    getMouseReportCoords(g, _) {
                        const m = (0,
                        d.getCoordsRelativeToElement)(window, g, _);
                        if (this._charSizeService.hasValidSize)
                            return m[0] = Math.min(Math.max(m[0], 0), this._renderService.dimensions.css.canvas.width - 1),
                            m[1] = Math.min(Math.max(m[1], 0), this._renderService.dimensions.css.canvas.height - 1),
                            {
                                col: Math.floor(m[0] / this._renderService.dimensions.css.cell.width),
                                row: Math.floor(m[1] / this._renderService.dimensions.css.cell.height),
                                x: Math.floor(m[0]),
                                y: Math.floor(m[1])
                            }
                    }
                }
                ;
                a.MouseService = f = c([u(0, h.IRenderService), u(1, h.ICharSizeService)], f)
            },
            3230: function(o, a, l) {
                var c = this && this.__decorate || function(b, y, x, E) {
                    var w, A = arguments.length, C = A < 3 ? y : E === null ? E = Object.getOwnPropertyDescriptor(y, x) : E;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        C = Reflect.decorate(b, y, x, E);
                    else
                        for (var k = b.length - 1; k >= 0; k--)
                            (w = b[k]) && (C = (A < 3 ? w(C) : A > 3 ? w(y, x, C) : w(y, x)) || C);
                    return A > 3 && C && Object.defineProperty(y, x, C),
                    C
                }
                  , u = this && this.__param || function(b, y) {
                    return function(x, E) {
                        y(x, E, b)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.RenderService = void 0;
                const h = l(6193)
                  , d = l(4725)
                  , f = l(8460)
                  , g = l(844)
                  , _ = l(7226)
                  , m = l(2585);
                let p = a.RenderService = class extends g.Disposable {
                    get dimensions() {
                        return this._renderer.value.dimensions
                    }
                    constructor(b, y, x, E, w, A, C, k) {
                        super(),
                        this._rowCount = b,
                        this._charSizeService = E,
                        this._renderer = this.register(new g.MutableDisposable),
                        this._pausedResizeTask = new _.DebouncedIdleTask,
                        this._observerDisposable = this.register(new g.MutableDisposable),
                        this._isPaused = !1,
                        this._needsFullRefresh = !1,
                        this._isNextRenderRedrawOnly = !0,
                        this._needsSelectionRefresh = !1,
                        this._canvasWidth = 0,
                        this._canvasHeight = 0,
                        this._selectionState = {
                            start: void 0,
                            end: void 0,
                            columnSelectMode: !1
                        },
                        this._onDimensionsChange = this.register(new f.EventEmitter),
                        this.onDimensionsChange = this._onDimensionsChange.event,
                        this._onRenderedViewportChange = this.register(new f.EventEmitter),
                        this.onRenderedViewportChange = this._onRenderedViewportChange.event,
                        this._onRender = this.register(new f.EventEmitter),
                        this.onRender = this._onRender.event,
                        this._onRefreshRequest = this.register(new f.EventEmitter),
                        this.onRefreshRequest = this._onRefreshRequest.event,
                        this._renderDebouncer = new h.RenderDebouncer( (I, N) => this._renderRows(I, N),C),
                        this.register(this._renderDebouncer),
                        this.register(C.onDprChange( () => this.handleDevicePixelRatioChange())),
                        this.register(A.onResize( () => this._fullRefresh())),
                        this.register(A.buffers.onBufferActivate( () => this._renderer.value?.clear())),
                        this.register(x.onOptionChange( () => this._handleOptionsChanged())),
                        this.register(this._charSizeService.onCharSizeChange( () => this.handleCharSizeChanged())),
                        this.register(w.onDecorationRegistered( () => this._fullRefresh())),
                        this.register(w.onDecorationRemoved( () => this._fullRefresh())),
                        this.register(x.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio", "rescaleOverlappingGlyphs"], () => {
                            this.clear(),
                            this.handleResize(A.cols, A.rows),
                            this._fullRefresh()
                        }
                        )),
                        this.register(x.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(A.buffer.y, A.buffer.y, !0))),
                        this.register(k.onChangeColors( () => this._fullRefresh())),
                        this._registerIntersectionObserver(C.window, y),
                        this.register(C.onWindowChange(I => this._registerIntersectionObserver(I, y)))
                    }
                    _registerIntersectionObserver(b, y) {
                        if ("IntersectionObserver"in b) {
                            const x = new b.IntersectionObserver(E => this._handleIntersectionChange(E[E.length - 1]),{
                                threshold: 0
                            });
                            x.observe(y),
                            this._observerDisposable.value = (0,
                            g.toDisposable)( () => x.disconnect())
                        }
                    }
                    _handleIntersectionChange(b) {
                        this._isPaused = b.isIntersecting === void 0 ? b.intersectionRatio === 0 : !b.isIntersecting,
                        this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(),
                        !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(),
                        this.refreshRows(0, this._rowCount - 1),
                        this._needsFullRefresh = !1)
                    }
                    refreshRows(b, y, x=!1) {
                        this._isPaused ? this._needsFullRefresh = !0 : (x || (this._isNextRenderRedrawOnly = !1),
                        this._renderDebouncer.refresh(b, y, this._rowCount))
                    }
                    _renderRows(b, y) {
                        this._renderer.value && (b = Math.min(b, this._rowCount - 1),
                        y = Math.min(y, this._rowCount - 1),
                        this._renderer.value.renderRows(b, y),
                        this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode),
                        this._needsSelectionRefresh = !1),
                        this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({
                            start: b,
                            end: y
                        }),
                        this._onRender.fire({
                            start: b,
                            end: y
                        }),
                        this._isNextRenderRedrawOnly = !0)
                    }
                    resize(b, y) {
                        this._rowCount = y,
                        this._fireOnCanvasResize()
                    }
                    _handleOptionsChanged() {
                        this._renderer.value && (this.refreshRows(0, this._rowCount - 1),
                        this._fireOnCanvasResize())
                    }
                    _fireOnCanvasResize() {
                        this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions))
                    }
                    hasRenderer() {
                        return !!this._renderer.value
                    }
                    setRenderer(b) {
                        this._renderer.value = b,
                        this._renderer.value && (this._renderer.value.onRequestRedraw(y => this.refreshRows(y.start, y.end, !0)),
                        this._needsSelectionRefresh = !0,
                        this._fullRefresh())
                    }
                    addRefreshCallback(b) {
                        return this._renderDebouncer.addRefreshCallback(b)
                    }
                    _fullRefresh() {
                        this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1)
                    }
                    clearTextureAtlas() {
                        this._renderer.value && (this._renderer.value.clearTextureAtlas?.(),
                        this._fullRefresh())
                    }
                    handleDevicePixelRatioChange() {
                        this._charSizeService.measure(),
                        this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(),
                        this.refreshRows(0, this._rowCount - 1))
                    }
                    handleResize(b, y) {
                        this._renderer.value && (this._isPaused ? this._pausedResizeTask.set( () => this._renderer.value?.handleResize(b, y)) : this._renderer.value.handleResize(b, y),
                        this._fullRefresh())
                    }
                    handleCharSizeChanged() {
                        this._renderer.value?.handleCharSizeChanged()
                    }
                    handleBlur() {
                        this._renderer.value?.handleBlur()
                    }
                    handleFocus() {
                        this._renderer.value?.handleFocus()
                    }
                    handleSelectionChanged(b, y, x) {
                        this._selectionState.start = b,
                        this._selectionState.end = y,
                        this._selectionState.columnSelectMode = x,
                        this._renderer.value?.handleSelectionChanged(b, y, x)
                    }
                    handleCursorMove() {
                        this._renderer.value?.handleCursorMove()
                    }
                    clear() {
                        this._renderer.value?.clear()
                    }
                }
                ;
                a.RenderService = p = c([u(2, m.IOptionsService), u(3, d.ICharSizeService), u(4, m.IDecorationService), u(5, m.IBufferService), u(6, d.ICoreBrowserService), u(7, d.IThemeService)], p)
            },
            9312: function(o, a, l) {
                var c = this && this.__decorate || function(C, k, I, N) {
                    var O, M = arguments.length, H = M < 3 ? k : N === null ? N = Object.getOwnPropertyDescriptor(k, I) : N;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        H = Reflect.decorate(C, k, I, N);
                    else
                        for (var $ = C.length - 1; $ >= 0; $--)
                            (O = C[$]) && (H = (M < 3 ? O(H) : M > 3 ? O(k, I, H) : O(k, I)) || H);
                    return M > 3 && H && Object.defineProperty(k, I, H),
                    H
                }
                  , u = this && this.__param || function(C, k) {
                    return function(I, N) {
                        k(I, N, C)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.SelectionService = void 0;
                const h = l(9806)
                  , d = l(9504)
                  , f = l(456)
                  , g = l(4725)
                  , _ = l(8460)
                  , m = l(844)
                  , p = l(6114)
                  , b = l(4841)
                  , y = l(511)
                  , x = l(2585)
                  , E = ""
                  , w = new RegExp(E,"g");
                let A = a.SelectionService = class extends m.Disposable {
                    constructor(C, k, I, N, O, M, H, $, J) {
                        super(),
                        this._element = C,
                        this._screenElement = k,
                        this._linkifier = I,
                        this._bufferService = N,
                        this._coreService = O,
                        this._mouseService = M,
                        this._optionsService = H,
                        this._renderService = $,
                        this._coreBrowserService = J,
                        this._dragScrollAmount = 0,
                        this._enabled = !0,
                        this._workCell = new y.CellData,
                        this._mouseDownTimeStamp = 0,
                        this._oldHasSelection = !1,
                        this._oldSelectionStart = void 0,
                        this._oldSelectionEnd = void 0,
                        this._onLinuxMouseSelection = this.register(new _.EventEmitter),
                        this.onLinuxMouseSelection = this._onLinuxMouseSelection.event,
                        this._onRedrawRequest = this.register(new _.EventEmitter),
                        this.onRequestRedraw = this._onRedrawRequest.event,
                        this._onSelectionChange = this.register(new _.EventEmitter),
                        this.onSelectionChange = this._onSelectionChange.event,
                        this._onRequestScrollLines = this.register(new _.EventEmitter),
                        this.onRequestScrollLines = this._onRequestScrollLines.event,
                        this._mouseMoveListener = Q => this._handleMouseMove(Q),
                        this._mouseUpListener = Q => this._handleMouseUp(Q),
                        this._coreService.onUserInput( () => {
                            this.hasSelection && this.clearSelection()
                        }
                        ),
                        this._trimListener = this._bufferService.buffer.lines.onTrim(Q => this._handleTrim(Q)),
                        this.register(this._bufferService.buffers.onBufferActivate(Q => this._handleBufferActivate(Q))),
                        this.enable(),
                        this._model = new f.SelectionModel(this._bufferService),
                        this._activeSelectionMode = 0,
                        this.register((0,
                        m.toDisposable)( () => {
                            this._removeMouseDownListeners()
                        }
                        ))
                    }
                    reset() {
                        this.clearSelection()
                    }
                    disable() {
                        this.clearSelection(),
                        this._enabled = !1
                    }
                    enable() {
                        this._enabled = !0
                    }
                    get selectionStart() {
                        return this._model.finalSelectionStart
                    }
                    get selectionEnd() {
                        return this._model.finalSelectionEnd
                    }
                    get hasSelection() {
                        const C = this._model.finalSelectionStart
                          , k = this._model.finalSelectionEnd;
                        return !(!C || !k || C[0] === k[0] && C[1] === k[1])
                    }
                    get selectionText() {
                        const C = this._model.finalSelectionStart
                          , k = this._model.finalSelectionEnd;
                        if (!C || !k)
                            return "";
                        const I = this._bufferService.buffer
                          , N = [];
                        if (this._activeSelectionMode === 3) {
                            if (C[0] === k[0])
                                return "";
                            const O = C[0] < k[0] ? C[0] : k[0]
                              , M = C[0] < k[0] ? k[0] : C[0];
                            for (let H = C[1]; H <= k[1]; H++) {
                                const $ = I.translateBufferLineToString(H, !0, O, M);
                                N.push($)
                            }
                        } else {
                            const O = C[1] === k[1] ? k[0] : void 0;
                            N.push(I.translateBufferLineToString(C[1], !0, C[0], O));
                            for (let M = C[1] + 1; M <= k[1] - 1; M++) {
                                const H = I.lines.get(M)
                                  , $ = I.translateBufferLineToString(M, !0);
                                H?.isWrapped ? N[N.length - 1] += $ : N.push($)
                            }
                            if (C[1] !== k[1]) {
                                const M = I.lines.get(k[1])
                                  , H = I.translateBufferLineToString(k[1], !0, 0, k[0]);
                                M && M.isWrapped ? N[N.length - 1] += H : N.push(H)
                            }
                        }
                        return N.map(O => O.replace(w, " ")).join(p.isWindows ? `\r
` : `
`)
                    }
                    clearSelection() {
                        this._model.clearSelection(),
                        this._removeMouseDownListeners(),
                        this.refresh(),
                        this._onSelectionChange.fire()
                    }
                    refresh(C) {
                        this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame( () => this._refresh())),
                        p.isLinux && C && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText)
                    }
                    _refresh() {
                        this._refreshAnimationFrame = void 0,
                        this._onRedrawRequest.fire({
                            start: this._model.finalSelectionStart,
                            end: this._model.finalSelectionEnd,
                            columnSelectMode: this._activeSelectionMode === 3
                        })
                    }
                    _isClickInSelection(C) {
                        const k = this._getMouseBufferCoords(C)
                          , I = this._model.finalSelectionStart
                          , N = this._model.finalSelectionEnd;
                        return !!(I && N && k) && this._areCoordsInSelection(k, I, N)
                    }
                    isCellInSelection(C, k) {
                        const I = this._model.finalSelectionStart
                          , N = this._model.finalSelectionEnd;
                        return !(!I || !N) && this._areCoordsInSelection([C, k], I, N)
                    }
                    _areCoordsInSelection(C, k, I) {
                        return C[1] > k[1] && C[1] < I[1] || k[1] === I[1] && C[1] === k[1] && C[0] >= k[0] && C[0] < I[0] || k[1] < I[1] && C[1] === I[1] && C[0] < I[0] || k[1] < I[1] && C[1] === k[1] && C[0] >= k[0]
                    }
                    _selectWordAtCursor(C, k) {
                        const I = this._linkifier.currentLink?.link?.range;
                        if (I)
                            return this._model.selectionStart = [I.start.x - 1, I.start.y - 1],
                            this._model.selectionStartLength = (0,
                            b.getRangeLength)(I, this._bufferService.cols),
                            this._model.selectionEnd = void 0,
                            !0;
                        const N = this._getMouseBufferCoords(C);
                        return !!N && (this._selectWordAt(N, k),
                        this._model.selectionEnd = void 0,
                        !0)
                    }
                    selectAll() {
                        this._model.isSelectAllActive = !0,
                        this.refresh(),
                        this._onSelectionChange.fire()
                    }
                    selectLines(C, k) {
                        this._model.clearSelection(),
                        C = Math.max(C, 0),
                        k = Math.min(k, this._bufferService.buffer.lines.length - 1),
                        this._model.selectionStart = [0, C],
                        this._model.selectionEnd = [this._bufferService.cols, k],
                        this.refresh(),
                        this._onSelectionChange.fire()
                    }
                    _handleTrim(C) {
                        this._model.handleTrim(C) && this.refresh()
                    }
                    _getMouseBufferCoords(C) {
                        const k = this._mouseService.getCoords(C, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
                        if (k)
                            return k[0]--,
                            k[1]--,
                            k[1] += this._bufferService.buffer.ydisp,
                            k
                    }
                    _getMouseEventScrollAmount(C) {
                        let k = (0,
                        h.getCoordsRelativeToElement)(this._coreBrowserService.window, C, this._screenElement)[1];
                        const I = this._renderService.dimensions.css.canvas.height;
                        return k >= 0 && k <= I ? 0 : (k > I && (k -= I),
                        k = Math.min(Math.max(k, -50), 50),
                        k /= 50,
                        k / Math.abs(k) + Math.round(14 * k))
                    }
                    shouldForceSelection(C) {
                        return p.isMac ? C.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : C.shiftKey
                    }
                    handleMouseDown(C) {
                        if (this._mouseDownTimeStamp = C.timeStamp,
                        (C.button !== 2 || !this.hasSelection) && C.button === 0) {
                            if (!this._enabled) {
                                if (!this.shouldForceSelection(C))
                                    return;
                                C.stopPropagation()
                            }
                            C.preventDefault(),
                            this._dragScrollAmount = 0,
                            this._enabled && C.shiftKey ? this._handleIncrementalClick(C) : C.detail === 1 ? this._handleSingleClick(C) : C.detail === 2 ? this._handleDoubleClick(C) : C.detail === 3 && this._handleTripleClick(C),
                            this._addMouseDownListeners(),
                            this.refresh(!0)
                        }
                    }
                    _addMouseDownListeners() {
                        this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener),
                        this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)),
                        this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval( () => this._dragScroll(), 50)
                    }
                    _removeMouseDownListeners() {
                        this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener),
                        this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)),
                        this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer),
                        this._dragScrollIntervalTimer = void 0
                    }
                    _handleIncrementalClick(C) {
                        this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(C))
                    }
                    _handleSingleClick(C) {
                        if (this._model.selectionStartLength = 0,
                        this._model.isSelectAllActive = !1,
                        this._activeSelectionMode = this.shouldColumnSelect(C) ? 3 : 0,
                        this._model.selectionStart = this._getMouseBufferCoords(C),
                        !this._model.selectionStart)
                            return;
                        this._model.selectionEnd = void 0;
                        const k = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
                        k && k.length !== this._model.selectionStart[0] && k.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++
                    }
                    _handleDoubleClick(C) {
                        this._selectWordAtCursor(C, !0) && (this._activeSelectionMode = 1)
                    }
                    _handleTripleClick(C) {
                        const k = this._getMouseBufferCoords(C);
                        k && (this._activeSelectionMode = 2,
                        this._selectLineAt(k[1]))
                    }
                    shouldColumnSelect(C) {
                        return C.altKey && !(p.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection)
                    }
                    _handleMouseMove(C) {
                        if (C.stopImmediatePropagation(),
                        !this._model.selectionStart)
                            return;
                        const k = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
                        if (this._model.selectionEnd = this._getMouseBufferCoords(C),
                        !this._model.selectionEnd)
                            return void this.refresh(!0);
                        this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd),
                        this._dragScrollAmount = this._getMouseEventScrollAmount(C),
                        this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
                        const I = this._bufferService.buffer;
                        if (this._model.selectionEnd[1] < I.lines.length) {
                            const N = I.lines.get(this._model.selectionEnd[1]);
                            N && N.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++
                        }
                        k && k[0] === this._model.selectionEnd[0] && k[1] === this._model.selectionEnd[1] || this.refresh(!0)
                    }
                    _dragScroll() {
                        if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
                            this._onRequestScrollLines.fire({
                                amount: this._dragScrollAmount,
                                suppressScrollEvent: !1
                            });
                            const C = this._bufferService.buffer;
                            this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols),
                            this._model.selectionEnd[1] = Math.min(C.ydisp + this._bufferService.rows, C.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0),
                            this._model.selectionEnd[1] = C.ydisp),
                            this.refresh()
                        }
                    }
                    _handleMouseUp(C) {
                        const k = C.timeStamp - this._mouseDownTimeStamp;
                        if (this._removeMouseDownListeners(),
                        this.selectionText.length <= 1 && k < 500 && C.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
                            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                                const I = this._mouseService.getCoords(C, this._element, this._bufferService.cols, this._bufferService.rows, !1);
                                if (I && I[0] !== void 0 && I[1] !== void 0) {
                                    const N = (0,
                                    d.moveToCellSequence)(I[0] - 1, I[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                                    this._coreService.triggerDataEvent(N, !0)
                                }
                            }
                        } else
                            this._fireEventIfSelectionChanged()
                    }
                    _fireEventIfSelectionChanged() {
                        const C = this._model.finalSelectionStart
                          , k = this._model.finalSelectionEnd
                          , I = !(!C || !k || C[0] === k[0] && C[1] === k[1]);
                        I ? C && k && (this._oldSelectionStart && this._oldSelectionEnd && C[0] === this._oldSelectionStart[0] && C[1] === this._oldSelectionStart[1] && k[0] === this._oldSelectionEnd[0] && k[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(C, k, I)) : this._oldHasSelection && this._fireOnSelectionChange(C, k, I)
                    }
                    _fireOnSelectionChange(C, k, I) {
                        this._oldSelectionStart = C,
                        this._oldSelectionEnd = k,
                        this._oldHasSelection = I,
                        this._onSelectionChange.fire()
                    }
                    _handleBufferActivate(C) {
                        this.clearSelection(),
                        this._trimListener.dispose(),
                        this._trimListener = C.activeBuffer.lines.onTrim(k => this._handleTrim(k))
                    }
                    _convertViewportColToCharacterIndex(C, k) {
                        let I = k;
                        for (let N = 0; k >= N; N++) {
                            const O = C.loadCell(N, this._workCell).getChars().length;
                            this._workCell.getWidth() === 0 ? I-- : O > 1 && k !== N && (I += O - 1)
                        }
                        return I
                    }
                    setSelection(C, k, I) {
                        this._model.clearSelection(),
                        this._removeMouseDownListeners(),
                        this._model.selectionStart = [C, k],
                        this._model.selectionStartLength = I,
                        this.refresh(),
                        this._fireEventIfSelectionChanged()
                    }
                    rightClickSelect(C) {
                        this._isClickInSelection(C) || (this._selectWordAtCursor(C, !1) && this.refresh(!0),
                        this._fireEventIfSelectionChanged())
                    }
                    _getWordAt(C, k, I=!0, N=!0) {
                        if (C[0] >= this._bufferService.cols)
                            return;
                        const O = this._bufferService.buffer
                          , M = O.lines.get(C[1]);
                        if (!M)
                            return;
                        const H = O.translateBufferLineToString(C[1], !1);
                        let $ = this._convertViewportColToCharacterIndex(M, C[0])
                          , J = $;
                        const Q = C[0] - $;
                        let ee = 0
                          , D = 0
                          , L = 0
                          , z = 0;
                        if (H.charAt($) === " ") {
                            for (; $ > 0 && H.charAt($ - 1) === " "; )
                                $--;
                            for (; J < H.length && H.charAt(J + 1) === " "; )
                                J++
                        } else {
                            let Z = C[0]
                              , se = C[0];
                            M.getWidth(Z) === 0 && (ee++,
                            Z--),
                            M.getWidth(se) === 2 && (D++,
                            se++);
                            const ae = M.getString(se).length;
                            for (ae > 1 && (z += ae - 1,
                            J += ae - 1); Z > 0 && $ > 0 && !this._isCharWordSeparator(M.loadCell(Z - 1, this._workCell)); ) {
                                M.loadCell(Z - 1, this._workCell);
                                const G = this._workCell.getChars().length;
                                this._workCell.getWidth() === 0 ? (ee++,
                                Z--) : G > 1 && (L += G - 1,
                                $ -= G - 1),
                                $--,
                                Z--
                            }
                            for (; se < M.length && J + 1 < H.length && !this._isCharWordSeparator(M.loadCell(se + 1, this._workCell)); ) {
                                M.loadCell(se + 1, this._workCell);
                                const G = this._workCell.getChars().length;
                                this._workCell.getWidth() === 2 ? (D++,
                                se++) : G > 1 && (z += G - 1,
                                J += G - 1),
                                J++,
                                se++
                            }
                        }
                        J++;
                        let V = $ + Q - ee + L
                          , B = Math.min(this._bufferService.cols, J - $ + ee + D - L - z);
                        if (k || H.slice($, J).trim() !== "") {
                            if (I && V === 0 && M.getCodePoint(0) !== 32) {
                                const Z = O.lines.get(C[1] - 1);
                                if (Z && M.isWrapped && Z.getCodePoint(this._bufferService.cols - 1) !== 32) {
                                    const se = this._getWordAt([this._bufferService.cols - 1, C[1] - 1], !1, !0, !1);
                                    if (se) {
                                        const ae = this._bufferService.cols - se.start;
                                        V -= ae,
                                        B += ae
                                    }
                                }
                            }
                            if (N && V + B === this._bufferService.cols && M.getCodePoint(this._bufferService.cols - 1) !== 32) {
                                const Z = O.lines.get(C[1] + 1);
                                if (Z?.isWrapped && Z.getCodePoint(0) !== 32) {
                                    const se = this._getWordAt([0, C[1] + 1], !1, !1, !0);
                                    se && (B += se.length)
                                }
                            }
                            return {
                                start: V,
                                length: B
                            }
                        }
                    }
                    _selectWordAt(C, k) {
                        const I = this._getWordAt(C, k);
                        if (I) {
                            for (; I.start < 0; )
                                I.start += this._bufferService.cols,
                                C[1]--;
                            this._model.selectionStart = [I.start, C[1]],
                            this._model.selectionStartLength = I.length
                        }
                    }
                    _selectToWordAt(C) {
                        const k = this._getWordAt(C, !0);
                        if (k) {
                            let I = C[1];
                            for (; k.start < 0; )
                                k.start += this._bufferService.cols,
                                I--;
                            if (!this._model.areSelectionValuesReversed())
                                for (; k.start + k.length > this._bufferService.cols; )
                                    k.length -= this._bufferService.cols,
                                    I++;
                            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? k.start : k.start + k.length, I]
                        }
                    }
                    _isCharWordSeparator(C) {
                        return C.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(C.getChars()) >= 0
                    }
                    _selectLineAt(C) {
                        const k = this._bufferService.buffer.getWrappedRangeForLine(C)
                          , I = {
                            start: {
                                x: 0,
                                y: k.first
                            },
                            end: {
                                x: this._bufferService.cols - 1,
                                y: k.last
                            }
                        };
                        this._model.selectionStart = [0, k.first],
                        this._model.selectionEnd = void 0,
                        this._model.selectionStartLength = (0,
                        b.getRangeLength)(I, this._bufferService.cols)
                    }
                }
                ;
                a.SelectionService = A = c([u(3, x.IBufferService), u(4, x.ICoreService), u(5, g.IMouseService), u(6, x.IOptionsService), u(7, g.IRenderService), u(8, g.ICoreBrowserService)], A)
            },
            4725: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.ILinkProviderService = a.IThemeService = a.ICharacterJoinerService = a.ISelectionService = a.IRenderService = a.IMouseService = a.ICoreBrowserService = a.ICharSizeService = void 0;
                const c = l(8343);
                a.ICharSizeService = (0,
                c.createDecorator)("CharSizeService"),
                a.ICoreBrowserService = (0,
                c.createDecorator)("CoreBrowserService"),
                a.IMouseService = (0,
                c.createDecorator)("MouseService"),
                a.IRenderService = (0,
                c.createDecorator)("RenderService"),
                a.ISelectionService = (0,
                c.createDecorator)("SelectionService"),
                a.ICharacterJoinerService = (0,
                c.createDecorator)("CharacterJoinerService"),
                a.IThemeService = (0,
                c.createDecorator)("ThemeService"),
                a.ILinkProviderService = (0,
                c.createDecorator)("LinkProviderService")
            }
            ,
            6731: function(o, a, l) {
                var c = this && this.__decorate || function(A, C, k, I) {
                    var N, O = arguments.length, M = O < 3 ? C : I === null ? I = Object.getOwnPropertyDescriptor(C, k) : I;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        M = Reflect.decorate(A, C, k, I);
                    else
                        for (var H = A.length - 1; H >= 0; H--)
                            (N = A[H]) && (M = (O < 3 ? N(M) : O > 3 ? N(C, k, M) : N(C, k)) || M);
                    return O > 3 && M && Object.defineProperty(C, k, M),
                    M
                }
                  , u = this && this.__param || function(A, C) {
                    return function(k, I) {
                        C(k, I, A)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.ThemeService = a.DEFAULT_ANSI_COLORS = void 0;
                const h = l(7239)
                  , d = l(8055)
                  , f = l(8460)
                  , g = l(844)
                  , _ = l(2585)
                  , m = d.css.toColor("#ffffff")
                  , p = d.css.toColor("#000000")
                  , b = d.css.toColor("#ffffff")
                  , y = d.css.toColor("#000000")
                  , x = {
                    css: "rgba(255, 255, 255, 0.3)",
                    rgba: 4294967117
                };
                a.DEFAULT_ANSI_COLORS = Object.freeze(( () => {
                    const A = [d.css.toColor("#2e3436"), d.css.toColor("#cc0000"), d.css.toColor("#4e9a06"), d.css.toColor("#c4a000"), d.css.toColor("#3465a4"), d.css.toColor("#75507b"), d.css.toColor("#06989a"), d.css.toColor("#d3d7cf"), d.css.toColor("#555753"), d.css.toColor("#ef2929"), d.css.toColor("#8ae234"), d.css.toColor("#fce94f"), d.css.toColor("#729fcf"), d.css.toColor("#ad7fa8"), d.css.toColor("#34e2e2"), d.css.toColor("#eeeeec")]
                      , C = [0, 95, 135, 175, 215, 255];
                    for (let k = 0; k < 216; k++) {
                        const I = C[k / 36 % 6 | 0]
                          , N = C[k / 6 % 6 | 0]
                          , O = C[k % 6];
                        A.push({
                            css: d.channels.toCss(I, N, O),
                            rgba: d.channels.toRgba(I, N, O)
                        })
                    }
                    for (let k = 0; k < 24; k++) {
                        const I = 8 + 10 * k;
                        A.push({
                            css: d.channels.toCss(I, I, I),
                            rgba: d.channels.toRgba(I, I, I)
                        })
                    }
                    return A
                }
                )());
                let E = a.ThemeService = class extends g.Disposable {
                    get colors() {
                        return this._colors
                    }
                    constructor(A) {
                        super(),
                        this._optionsService = A,
                        this._contrastCache = new h.ColorContrastCache,
                        this._halfContrastCache = new h.ColorContrastCache,
                        this._onChangeColors = this.register(new f.EventEmitter),
                        this.onChangeColors = this._onChangeColors.event,
                        this._colors = {
                            foreground: m,
                            background: p,
                            cursor: b,
                            cursorAccent: y,
                            selectionForeground: void 0,
                            selectionBackgroundTransparent: x,
                            selectionBackgroundOpaque: d.color.blend(p, x),
                            selectionInactiveBackgroundTransparent: x,
                            selectionInactiveBackgroundOpaque: d.color.blend(p, x),
                            ansi: a.DEFAULT_ANSI_COLORS.slice(),
                            contrastCache: this._contrastCache,
                            halfContrastCache: this._halfContrastCache
                        },
                        this._updateRestoreColors(),
                        this._setTheme(this._optionsService.rawOptions.theme),
                        this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())),
                        this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)))
                    }
                    _setTheme(A={}) {
                        const C = this._colors;
                        if (C.foreground = w(A.foreground, m),
                        C.background = w(A.background, p),
                        C.cursor = w(A.cursor, b),
                        C.cursorAccent = w(A.cursorAccent, y),
                        C.selectionBackgroundTransparent = w(A.selectionBackground, x),
                        C.selectionBackgroundOpaque = d.color.blend(C.background, C.selectionBackgroundTransparent),
                        C.selectionInactiveBackgroundTransparent = w(A.selectionInactiveBackground, C.selectionBackgroundTransparent),
                        C.selectionInactiveBackgroundOpaque = d.color.blend(C.background, C.selectionInactiveBackgroundTransparent),
                        C.selectionForeground = A.selectionForeground ? w(A.selectionForeground, d.NULL_COLOR) : void 0,
                        C.selectionForeground === d.NULL_COLOR && (C.selectionForeground = void 0),
                        d.color.isOpaque(C.selectionBackgroundTransparent) && (C.selectionBackgroundTransparent = d.color.opacity(C.selectionBackgroundTransparent, .3)),
                        d.color.isOpaque(C.selectionInactiveBackgroundTransparent) && (C.selectionInactiveBackgroundTransparent = d.color.opacity(C.selectionInactiveBackgroundTransparent, .3)),
                        C.ansi = a.DEFAULT_ANSI_COLORS.slice(),
                        C.ansi[0] = w(A.black, a.DEFAULT_ANSI_COLORS[0]),
                        C.ansi[1] = w(A.red, a.DEFAULT_ANSI_COLORS[1]),
                        C.ansi[2] = w(A.green, a.DEFAULT_ANSI_COLORS[2]),
                        C.ansi[3] = w(A.yellow, a.DEFAULT_ANSI_COLORS[3]),
                        C.ansi[4] = w(A.blue, a.DEFAULT_ANSI_COLORS[4]),
                        C.ansi[5] = w(A.magenta, a.DEFAULT_ANSI_COLORS[5]),
                        C.ansi[6] = w(A.cyan, a.DEFAULT_ANSI_COLORS[6]),
                        C.ansi[7] = w(A.white, a.DEFAULT_ANSI_COLORS[7]),
                        C.ansi[8] = w(A.brightBlack, a.DEFAULT_ANSI_COLORS[8]),
                        C.ansi[9] = w(A.brightRed, a.DEFAULT_ANSI_COLORS[9]),
                        C.ansi[10] = w(A.brightGreen, a.DEFAULT_ANSI_COLORS[10]),
                        C.ansi[11] = w(A.brightYellow, a.DEFAULT_ANSI_COLORS[11]),
                        C.ansi[12] = w(A.brightBlue, a.DEFAULT_ANSI_COLORS[12]),
                        C.ansi[13] = w(A.brightMagenta, a.DEFAULT_ANSI_COLORS[13]),
                        C.ansi[14] = w(A.brightCyan, a.DEFAULT_ANSI_COLORS[14]),
                        C.ansi[15] = w(A.brightWhite, a.DEFAULT_ANSI_COLORS[15]),
                        A.extendedAnsi) {
                            const k = Math.min(C.ansi.length - 16, A.extendedAnsi.length);
                            for (let I = 0; I < k; I++)
                                C.ansi[I + 16] = w(A.extendedAnsi[I], a.DEFAULT_ANSI_COLORS[I + 16])
                        }
                        this._contrastCache.clear(),
                        this._halfContrastCache.clear(),
                        this._updateRestoreColors(),
                        this._onChangeColors.fire(this.colors)
                    }
                    restoreColor(A) {
                        this._restoreColor(A),
                        this._onChangeColors.fire(this.colors)
                    }
                    _restoreColor(A) {
                        if (A !== void 0)
                            switch (A) {
                            case 256:
                                this._colors.foreground = this._restoreColors.foreground;
                                break;
                            case 257:
                                this._colors.background = this._restoreColors.background;
                                break;
                            case 258:
                                this._colors.cursor = this._restoreColors.cursor;
                                break;
                            default:
                                this._colors.ansi[A] = this._restoreColors.ansi[A]
                            }
                        else
                            for (let C = 0; C < this._restoreColors.ansi.length; ++C)
                                this._colors.ansi[C] = this._restoreColors.ansi[C]
                    }
                    modifyColors(A) {
                        A(this._colors),
                        this._onChangeColors.fire(this.colors)
                    }
                    _updateRestoreColors() {
                        this._restoreColors = {
                            foreground: this._colors.foreground,
                            background: this._colors.background,
                            cursor: this._colors.cursor,
                            ansi: this._colors.ansi.slice()
                        }
                    }
                }
                ;
                function w(A, C) {
                    if (A !== void 0)
                        try {
                            return d.css.toColor(A)
                        } catch {}
                    return C
                }
                a.ThemeService = E = c([u(0, _.IOptionsService)], E)
            },
            6349: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CircularList = void 0;
                const c = l(8460)
                  , u = l(844);
                class h extends u.Disposable {
                    constructor(f) {
                        super(),
                        this._maxLength = f,
                        this.onDeleteEmitter = this.register(new c.EventEmitter),
                        this.onDelete = this.onDeleteEmitter.event,
                        this.onInsertEmitter = this.register(new c.EventEmitter),
                        this.onInsert = this.onInsertEmitter.event,
                        this.onTrimEmitter = this.register(new c.EventEmitter),
                        this.onTrim = this.onTrimEmitter.event,
                        this._array = new Array(this._maxLength),
                        this._startIndex = 0,
                        this._length = 0
                    }
                    get maxLength() {
                        return this._maxLength
                    }
                    set maxLength(f) {
                        if (this._maxLength === f)
                            return;
                        const g = new Array(f);
                        for (let _ = 0; _ < Math.min(f, this.length); _++)
                            g[_] = this._array[this._getCyclicIndex(_)];
                        this._array = g,
                        this._maxLength = f,
                        this._startIndex = 0
                    }
                    get length() {
                        return this._length
                    }
                    set length(f) {
                        if (f > this._length)
                            for (let g = this._length; g < f; g++)
                                this._array[g] = void 0;
                        this._length = f
                    }
                    get(f) {
                        return this._array[this._getCyclicIndex(f)]
                    }
                    set(f, g) {
                        this._array[this._getCyclicIndex(f)] = g
                    }
                    push(f) {
                        this._array[this._getCyclicIndex(this._length)] = f,
                        this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength,
                        this.onTrimEmitter.fire(1)) : this._length++
                    }
                    recycle() {
                        if (this._length !== this._maxLength)
                            throw new Error("Can only recycle when the buffer is full");
                        return this._startIndex = ++this._startIndex % this._maxLength,
                        this.onTrimEmitter.fire(1),
                        this._array[this._getCyclicIndex(this._length - 1)]
                    }
                    get isFull() {
                        return this._length === this._maxLength
                    }
                    pop() {
                        return this._array[this._getCyclicIndex(this._length-- - 1)]
                    }
                    splice(f, g, ..._) {
                        if (g) {
                            for (let m = f; m < this._length - g; m++)
                                this._array[this._getCyclicIndex(m)] = this._array[this._getCyclicIndex(m + g)];
                            this._length -= g,
                            this.onDeleteEmitter.fire({
                                index: f,
                                amount: g
                            })
                        }
                        for (let m = this._length - 1; m >= f; m--)
                            this._array[this._getCyclicIndex(m + _.length)] = this._array[this._getCyclicIndex(m)];
                        for (let m = 0; m < _.length; m++)
                            this._array[this._getCyclicIndex(f + m)] = _[m];
                        if (_.length && this.onInsertEmitter.fire({
                            index: f,
                            amount: _.length
                        }),
                        this._length + _.length > this._maxLength) {
                            const m = this._length + _.length - this._maxLength;
                            this._startIndex += m,
                            this._length = this._maxLength,
                            this.onTrimEmitter.fire(m)
                        } else
                            this._length += _.length
                    }
                    trimStart(f) {
                        f > this._length && (f = this._length),
                        this._startIndex += f,
                        this._length -= f,
                        this.onTrimEmitter.fire(f)
                    }
                    shiftElements(f, g, _) {
                        if (!(g <= 0)) {
                            if (f < 0 || f >= this._length)
                                throw new Error("start argument out of range");
                            if (f + _ < 0)
                                throw new Error("Cannot shift elements in list beyond index 0");
                            if (_ > 0) {
                                for (let p = g - 1; p >= 0; p--)
                                    this.set(f + p + _, this.get(f + p));
                                const m = f + g + _ - this._length;
                                if (m > 0)
                                    for (this._length += m; this._length > this._maxLength; )
                                        this._length--,
                                        this._startIndex++,
                                        this.onTrimEmitter.fire(1)
                            } else
                                for (let m = 0; m < g; m++)
                                    this.set(f + m + _, this.get(f + m))
                        }
                    }
                    _getCyclicIndex(f) {
                        return (this._startIndex + f) % this._maxLength
                    }
                }
                a.CircularList = h
            }
            ,
            1439: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.clone = void 0,
                a.clone = function l(c, u=5) {
                    if (typeof c != "object")
                        return c;
                    const h = Array.isArray(c) ? [] : {};
                    for (const d in c)
                        h[d] = u <= 1 ? c[d] : c[d] && l(c[d], u - 1);
                    return h
                }
            }
            ,
            8055: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.contrastRatio = a.toPaddedHex = a.rgba = a.rgb = a.css = a.color = a.channels = a.NULL_COLOR = void 0;
                let l = 0
                  , c = 0
                  , u = 0
                  , h = 0;
                var d, f, g, _, m;
                function p(y) {
                    const x = y.toString(16);
                    return x.length < 2 ? "0" + x : x
                }
                function b(y, x) {
                    return y < x ? (x + .05) / (y + .05) : (y + .05) / (x + .05)
                }
                a.NULL_COLOR = {
                    css: "#00000000",
                    rgba: 0
                },
                function(y) {
                    y.toCss = function(x, E, w, A) {
                        return A !== void 0 ? `#${p(x)}${p(E)}${p(w)}${p(A)}` : `#${p(x)}${p(E)}${p(w)}`
                    }
                    ,
                    y.toRgba = function(x, E, w, A=255) {
                        return (x << 24 | E << 16 | w << 8 | A) >>> 0
                    }
                    ,
                    y.toColor = function(x, E, w, A) {
                        return {
                            css: y.toCss(x, E, w, A),
                            rgba: y.toRgba(x, E, w, A)
                        }
                    }
                }(d || (a.channels = d = {})),
                function(y) {
                    function x(E, w) {
                        return h = Math.round(255 * w),
                        [l,c,u] = m.toChannels(E.rgba),
                        {
                            css: d.toCss(l, c, u, h),
                            rgba: d.toRgba(l, c, u, h)
                        }
                    }
                    y.blend = function(E, w) {
                        if (h = (255 & w.rgba) / 255,
                        h === 1)
                            return {
                                css: w.css,
                                rgba: w.rgba
                            };
                        const A = w.rgba >> 24 & 255
                          , C = w.rgba >> 16 & 255
                          , k = w.rgba >> 8 & 255
                          , I = E.rgba >> 24 & 255
                          , N = E.rgba >> 16 & 255
                          , O = E.rgba >> 8 & 255;
                        return l = I + Math.round((A - I) * h),
                        c = N + Math.round((C - N) * h),
                        u = O + Math.round((k - O) * h),
                        {
                            css: d.toCss(l, c, u),
                            rgba: d.toRgba(l, c, u)
                        }
                    }
                    ,
                    y.isOpaque = function(E) {
                        return (255 & E.rgba) == 255
                    }
                    ,
                    y.ensureContrastRatio = function(E, w, A) {
                        const C = m.ensureContrastRatio(E.rgba, w.rgba, A);
                        if (C)
                            return d.toColor(C >> 24 & 255, C >> 16 & 255, C >> 8 & 255)
                    }
                    ,
                    y.opaque = function(E) {
                        const w = (255 | E.rgba) >>> 0;
                        return [l,c,u] = m.toChannels(w),
                        {
                            css: d.toCss(l, c, u),
                            rgba: w
                        }
                    }
                    ,
                    y.opacity = x,
                    y.multiplyOpacity = function(E, w) {
                        return h = 255 & E.rgba,
                        x(E, h * w / 255)
                    }
                    ,
                    y.toColorRGB = function(E) {
                        return [E.rgba >> 24 & 255, E.rgba >> 16 & 255, E.rgba >> 8 & 255]
                    }
                }(f || (a.color = f = {})),
                function(y) {
                    let x, E;
                    try {
                        const w = document.createElement("canvas");
                        w.width = 1,
                        w.height = 1;
                        const A = w.getContext("2d", {
                            willReadFrequently: !0
                        });
                        A && (x = A,
                        x.globalCompositeOperation = "copy",
                        E = x.createLinearGradient(0, 0, 1, 1))
                    } catch {}
                    y.toColor = function(w) {
                        if (w.match(/#[\da-f]{3,8}/i))
                            switch (w.length) {
                            case 4:
                                return l = parseInt(w.slice(1, 2).repeat(2), 16),
                                c = parseInt(w.slice(2, 3).repeat(2), 16),
                                u = parseInt(w.slice(3, 4).repeat(2), 16),
                                d.toColor(l, c, u);
                            case 5:
                                return l = parseInt(w.slice(1, 2).repeat(2), 16),
                                c = parseInt(w.slice(2, 3).repeat(2), 16),
                                u = parseInt(w.slice(3, 4).repeat(2), 16),
                                h = parseInt(w.slice(4, 5).repeat(2), 16),
                                d.toColor(l, c, u, h);
                            case 7:
                                return {
                                    css: w,
                                    rgba: (parseInt(w.slice(1), 16) << 8 | 255) >>> 0
                                };
                            case 9:
                                return {
                                    css: w,
                                    rgba: parseInt(w.slice(1), 16) >>> 0
                                }
                            }
                        const A = w.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
                        if (A)
                            return l = parseInt(A[1]),
                            c = parseInt(A[2]),
                            u = parseInt(A[3]),
                            h = Math.round(255 * (A[5] === void 0 ? 1 : parseFloat(A[5]))),
                            d.toColor(l, c, u, h);
                        if (!x || !E)
                            throw new Error("css.toColor: Unsupported css format");
                        if (x.fillStyle = E,
                        x.fillStyle = w,
                        typeof x.fillStyle != "string")
                            throw new Error("css.toColor: Unsupported css format");
                        if (x.fillRect(0, 0, 1, 1),
                        [l,c,u,h] = x.getImageData(0, 0, 1, 1).data,
                        h !== 255)
                            throw new Error("css.toColor: Unsupported css format");
                        return {
                            rgba: d.toRgba(l, c, u, h),
                            css: w
                        }
                    }
                }(g || (a.css = g = {})),
                function(y) {
                    function x(E, w, A) {
                        const C = E / 255
                          , k = w / 255
                          , I = A / 255;
                        return .2126 * (C <= .03928 ? C / 12.92 : Math.pow((C + .055) / 1.055, 2.4)) + .7152 * (k <= .03928 ? k / 12.92 : Math.pow((k + .055) / 1.055, 2.4)) + .0722 * (I <= .03928 ? I / 12.92 : Math.pow((I + .055) / 1.055, 2.4))
                    }
                    y.relativeLuminance = function(E) {
                        return x(E >> 16 & 255, E >> 8 & 255, 255 & E)
                    }
                    ,
                    y.relativeLuminance2 = x
                }(_ || (a.rgb = _ = {})),
                function(y) {
                    function x(w, A, C) {
                        const k = w >> 24 & 255
                          , I = w >> 16 & 255
                          , N = w >> 8 & 255;
                        let O = A >> 24 & 255
                          , M = A >> 16 & 255
                          , H = A >> 8 & 255
                          , $ = b(_.relativeLuminance2(O, M, H), _.relativeLuminance2(k, I, N));
                        for (; $ < C && (O > 0 || M > 0 || H > 0); )
                            O -= Math.max(0, Math.ceil(.1 * O)),
                            M -= Math.max(0, Math.ceil(.1 * M)),
                            H -= Math.max(0, Math.ceil(.1 * H)),
                            $ = b(_.relativeLuminance2(O, M, H), _.relativeLuminance2(k, I, N));
                        return (O << 24 | M << 16 | H << 8 | 255) >>> 0
                    }
                    function E(w, A, C) {
                        const k = w >> 24 & 255
                          , I = w >> 16 & 255
                          , N = w >> 8 & 255;
                        let O = A >> 24 & 255
                          , M = A >> 16 & 255
                          , H = A >> 8 & 255
                          , $ = b(_.relativeLuminance2(O, M, H), _.relativeLuminance2(k, I, N));
                        for (; $ < C && (O < 255 || M < 255 || H < 255); )
                            O = Math.min(255, O + Math.ceil(.1 * (255 - O))),
                            M = Math.min(255, M + Math.ceil(.1 * (255 - M))),
                            H = Math.min(255, H + Math.ceil(.1 * (255 - H))),
                            $ = b(_.relativeLuminance2(O, M, H), _.relativeLuminance2(k, I, N));
                        return (O << 24 | M << 16 | H << 8 | 255) >>> 0
                    }
                    y.blend = function(w, A) {
                        if (h = (255 & A) / 255,
                        h === 1)
                            return A;
                        const C = A >> 24 & 255
                          , k = A >> 16 & 255
                          , I = A >> 8 & 255
                          , N = w >> 24 & 255
                          , O = w >> 16 & 255
                          , M = w >> 8 & 255;
                        return l = N + Math.round((C - N) * h),
                        c = O + Math.round((k - O) * h),
                        u = M + Math.round((I - M) * h),
                        d.toRgba(l, c, u)
                    }
                    ,
                    y.ensureContrastRatio = function(w, A, C) {
                        const k = _.relativeLuminance(w >> 8)
                          , I = _.relativeLuminance(A >> 8);
                        if (b(k, I) < C) {
                            if (I < k) {
                                const M = x(w, A, C)
                                  , H = b(k, _.relativeLuminance(M >> 8));
                                if (H < C) {
                                    const $ = E(w, A, C);
                                    return H > b(k, _.relativeLuminance($ >> 8)) ? M : $
                                }
                                return M
                            }
                            const N = E(w, A, C)
                              , O = b(k, _.relativeLuminance(N >> 8));
                            if (O < C) {
                                const M = x(w, A, C);
                                return O > b(k, _.relativeLuminance(M >> 8)) ? N : M
                            }
                            return N
                        }
                    }
                    ,
                    y.reduceLuminance = x,
                    y.increaseLuminance = E,
                    y.toChannels = function(w) {
                        return [w >> 24 & 255, w >> 16 & 255, w >> 8 & 255, 255 & w]
                    }
                }(m || (a.rgba = m = {})),
                a.toPaddedHex = p,
                a.contrastRatio = b
            }
            ,
            8969: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CoreTerminal = void 0;
                const c = l(844)
                  , u = l(2585)
                  , h = l(4348)
                  , d = l(7866)
                  , f = l(744)
                  , g = l(7302)
                  , _ = l(6975)
                  , m = l(8460)
                  , p = l(1753)
                  , b = l(1480)
                  , y = l(7994)
                  , x = l(9282)
                  , E = l(5435)
                  , w = l(5981)
                  , A = l(2660);
                let C = !1;
                class k extends c.Disposable {
                    get onScroll() {
                        return this._onScrollApi || (this._onScrollApi = this.register(new m.EventEmitter),
                        this._onScroll.event(N => {
                            this._onScrollApi?.fire(N.position)
                        }
                        )),
                        this._onScrollApi.event
                    }
                    get cols() {
                        return this._bufferService.cols
                    }
                    get rows() {
                        return this._bufferService.rows
                    }
                    get buffers() {
                        return this._bufferService.buffers
                    }
                    get options() {
                        return this.optionsService.options
                    }
                    set options(N) {
                        for (const O in N)
                            this.optionsService.options[O] = N[O]
                    }
                    constructor(N) {
                        super(),
                        this._windowsWrappingHeuristics = this.register(new c.MutableDisposable),
                        this._onBinary = this.register(new m.EventEmitter),
                        this.onBinary = this._onBinary.event,
                        this._onData = this.register(new m.EventEmitter),
                        this.onData = this._onData.event,
                        this._onLineFeed = this.register(new m.EventEmitter),
                        this.onLineFeed = this._onLineFeed.event,
                        this._onResize = this.register(new m.EventEmitter),
                        this.onResize = this._onResize.event,
                        this._onWriteParsed = this.register(new m.EventEmitter),
                        this.onWriteParsed = this._onWriteParsed.event,
                        this._onScroll = this.register(new m.EventEmitter),
                        this._instantiationService = new h.InstantiationService,
                        this.optionsService = this.register(new g.OptionsService(N)),
                        this._instantiationService.setService(u.IOptionsService, this.optionsService),
                        this._bufferService = this.register(this._instantiationService.createInstance(f.BufferService)),
                        this._instantiationService.setService(u.IBufferService, this._bufferService),
                        this._logService = this.register(this._instantiationService.createInstance(d.LogService)),
                        this._instantiationService.setService(u.ILogService, this._logService),
                        this.coreService = this.register(this._instantiationService.createInstance(_.CoreService)),
                        this._instantiationService.setService(u.ICoreService, this.coreService),
                        this.coreMouseService = this.register(this._instantiationService.createInstance(p.CoreMouseService)),
                        this._instantiationService.setService(u.ICoreMouseService, this.coreMouseService),
                        this.unicodeService = this.register(this._instantiationService.createInstance(b.UnicodeService)),
                        this._instantiationService.setService(u.IUnicodeService, this.unicodeService),
                        this._charsetService = this._instantiationService.createInstance(y.CharsetService),
                        this._instantiationService.setService(u.ICharsetService, this._charsetService),
                        this._oscLinkService = this._instantiationService.createInstance(A.OscLinkService),
                        this._instantiationService.setService(u.IOscLinkService, this._oscLinkService),
                        this._inputHandler = this.register(new E.InputHandler(this._bufferService,this._charsetService,this.coreService,this._logService,this.optionsService,this._oscLinkService,this.coreMouseService,this.unicodeService)),
                        this.register((0,
                        m.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)),
                        this.register(this._inputHandler),
                        this.register((0,
                        m.forwardEvent)(this._bufferService.onResize, this._onResize)),
                        this.register((0,
                        m.forwardEvent)(this.coreService.onData, this._onData)),
                        this.register((0,
                        m.forwardEvent)(this.coreService.onBinary, this._onBinary)),
                        this.register(this.coreService.onRequestScrollToBottom( () => this.scrollToBottom())),
                        this.register(this.coreService.onUserInput( () => this._writeBuffer.handleUserInput())),
                        this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())),
                        this.register(this._bufferService.onScroll(O => {
                            this._onScroll.fire({
                                position: this._bufferService.buffer.ydisp,
                                source: 0
                            }),
                            this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom)
                        }
                        )),
                        this.register(this._inputHandler.onScroll(O => {
                            this._onScroll.fire({
                                position: this._bufferService.buffer.ydisp,
                                source: 0
                            }),
                            this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom)
                        }
                        )),
                        this._writeBuffer = this.register(new w.WriteBuffer( (O, M) => this._inputHandler.parse(O, M))),
                        this.register((0,
                        m.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed))
                    }
                    write(N, O) {
                        this._writeBuffer.write(N, O)
                    }
                    writeSync(N, O) {
                        this._logService.logLevel <= u.LogLevelEnum.WARN && !C && (this._logService.warn("writeSync is unreliable and will be removed soon."),
                        C = !0),
                        this._writeBuffer.writeSync(N, O)
                    }
                    input(N, O=!0) {
                        this.coreService.triggerDataEvent(N, O)
                    }
                    resize(N, O) {
                        isNaN(N) || isNaN(O) || (N = Math.max(N, f.MINIMUM_COLS),
                        O = Math.max(O, f.MINIMUM_ROWS),
                        this._bufferService.resize(N, O))
                    }
                    scroll(N, O=!1) {
                        this._bufferService.scroll(N, O)
                    }
                    scrollLines(N, O, M) {
                        this._bufferService.scrollLines(N, O, M)
                    }
                    scrollPages(N) {
                        this.scrollLines(N * (this.rows - 1))
                    }
                    scrollToTop() {
                        this.scrollLines(-this._bufferService.buffer.ydisp)
                    }
                    scrollToBottom() {
                        this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp)
                    }
                    scrollToLine(N) {
                        const O = N - this._bufferService.buffer.ydisp;
                        O !== 0 && this.scrollLines(O)
                    }
                    registerEscHandler(N, O) {
                        return this._inputHandler.registerEscHandler(N, O)
                    }
                    registerDcsHandler(N, O) {
                        return this._inputHandler.registerDcsHandler(N, O)
                    }
                    registerCsiHandler(N, O) {
                        return this._inputHandler.registerCsiHandler(N, O)
                    }
                    registerOscHandler(N, O) {
                        return this._inputHandler.registerOscHandler(N, O)
                    }
                    _setup() {
                        this._handleWindowsPtyOptionChange()
                    }
                    reset() {
                        this._inputHandler.reset(),
                        this._bufferService.reset(),
                        this._charsetService.reset(),
                        this.coreService.reset(),
                        this.coreMouseService.reset()
                    }
                    _handleWindowsPtyOptionChange() {
                        let N = !1;
                        const O = this.optionsService.rawOptions.windowsPty;
                        O && O.buildNumber !== void 0 && O.buildNumber !== void 0 ? N = O.backend === "conpty" && O.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (N = !0),
                        N ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear()
                    }
                    _enableWindowsWrappingHeuristics() {
                        if (!this._windowsWrappingHeuristics.value) {
                            const N = [];
                            N.push(this.onLineFeed(x.updateWindowsModeWrappedState.bind(null, this._bufferService))),
                            N.push(this.registerCsiHandler({
                                final: "H"
                            }, () => ((0,
                            x.updateWindowsModeWrappedState)(this._bufferService),
                            !1))),
                            this._windowsWrappingHeuristics.value = (0,
                            c.toDisposable)( () => {
                                for (const O of N)
                                    O.dispose()
                            }
                            )
                        }
                    }
                }
                a.CoreTerminal = k
            }
            ,
            8460: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.runAndSubscribe = a.forwardEvent = a.EventEmitter = void 0,
                a.EventEmitter = class {
                    constructor() {
                        this._listeners = [],
                        this._disposed = !1
                    }
                    get event() {
                        return this._event || (this._event = l => (this._listeners.push(l),
                        {
                            dispose: () => {
                                if (!this._disposed) {
                                    for (let c = 0; c < this._listeners.length; c++)
                                        if (this._listeners[c] === l)
                                            return void this._listeners.splice(c, 1)
                                }
                            }
                        })),
                        this._event
                    }
                    fire(l, c) {
                        const u = [];
                        for (let h = 0; h < this._listeners.length; h++)
                            u.push(this._listeners[h]);
                        for (let h = 0; h < u.length; h++)
                            u[h].call(void 0, l, c)
                    }
                    dispose() {
                        this.clearListeners(),
                        this._disposed = !0
                    }
                    clearListeners() {
                        this._listeners && (this._listeners.length = 0)
                    }
                }
                ,
                a.forwardEvent = function(l, c) {
                    return l(u => c.fire(u))
                }
                ,
                a.runAndSubscribe = function(l, c) {
                    return c(void 0),
                    l(u => c(u))
                }
            }
            ,
            5435: function(o, a, l) {
                var c = this && this.__decorate || function(ee, D, L, z) {
                    var V, B = arguments.length, Z = B < 3 ? D : z === null ? z = Object.getOwnPropertyDescriptor(D, L) : z;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        Z = Reflect.decorate(ee, D, L, z);
                    else
                        for (var se = ee.length - 1; se >= 0; se--)
                            (V = ee[se]) && (Z = (B < 3 ? V(Z) : B > 3 ? V(D, L, Z) : V(D, L)) || Z);
                    return B > 3 && Z && Object.defineProperty(D, L, Z),
                    Z
                }
                  , u = this && this.__param || function(ee, D) {
                    return function(L, z) {
                        D(L, z, ee)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.InputHandler = a.WindowsOptionsReportType = void 0;
                const h = l(2584)
                  , d = l(7116)
                  , f = l(2015)
                  , g = l(844)
                  , _ = l(482)
                  , m = l(8437)
                  , p = l(8460)
                  , b = l(643)
                  , y = l(511)
                  , x = l(3734)
                  , E = l(2585)
                  , w = l(1480)
                  , A = l(6242)
                  , C = l(6351)
                  , k = l(5941)
                  , I = {
                    "(": 0,
                    ")": 1,
                    "*": 2,
                    "+": 3,
                    "-": 1,
                    ".": 2
                }
                  , N = 131072;
                function O(ee, D) {
                    if (ee > 24)
                        return D.setWinLines || !1;
                    switch (ee) {
                    case 1:
                        return !!D.restoreWin;
                    case 2:
                        return !!D.minimizeWin;
                    case 3:
                        return !!D.setWinPosition;
                    case 4:
                        return !!D.setWinSizePixels;
                    case 5:
                        return !!D.raiseWin;
                    case 6:
                        return !!D.lowerWin;
                    case 7:
                        return !!D.refreshWin;
                    case 8:
                        return !!D.setWinSizeChars;
                    case 9:
                        return !!D.maximizeWin;
                    case 10:
                        return !!D.fullscreenWin;
                    case 11:
                        return !!D.getWinState;
                    case 13:
                        return !!D.getWinPosition;
                    case 14:
                        return !!D.getWinSizePixels;
                    case 15:
                        return !!D.getScreenSizePixels;
                    case 16:
                        return !!D.getCellSizePixels;
                    case 18:
                        return !!D.getWinSizeChars;
                    case 19:
                        return !!D.getScreenSizeChars;
                    case 20:
                        return !!D.getIconTitle;
                    case 21:
                        return !!D.getWinTitle;
                    case 22:
                        return !!D.pushTitle;
                    case 23:
                        return !!D.popTitle;
                    case 24:
                        return !!D.setWinLines
                    }
                    return !1
                }
                var M;
                (function(ee) {
                    ee[ee.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS",
                    ee[ee.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS"
                }
                )(M || (a.WindowsOptionsReportType = M = {}));
                let H = 0;
                class $ extends g.Disposable {
                    getAttrData() {
                        return this._curAttrData
                    }
                    constructor(D, L, z, V, B, Z, se, ae, G=new f.EscapeSequenceParser) {
                        super(),
                        this._bufferService = D,
                        this._charsetService = L,
                        this._coreService = z,
                        this._logService = V,
                        this._optionsService = B,
                        this._oscLinkService = Z,
                        this._coreMouseService = se,
                        this._unicodeService = ae,
                        this._parser = G,
                        this._parseBuffer = new Uint32Array(4096),
                        this._stringDecoder = new _.StringToUtf32,
                        this._utf8Decoder = new _.Utf8ToUtf32,
                        this._workCell = new y.CellData,
                        this._windowTitle = "",
                        this._iconName = "",
                        this._windowTitleStack = [],
                        this._iconNameStack = [],
                        this._curAttrData = m.DEFAULT_ATTR_DATA.clone(),
                        this._eraseAttrDataInternal = m.DEFAULT_ATTR_DATA.clone(),
                        this._onRequestBell = this.register(new p.EventEmitter),
                        this.onRequestBell = this._onRequestBell.event,
                        this._onRequestRefreshRows = this.register(new p.EventEmitter),
                        this.onRequestRefreshRows = this._onRequestRefreshRows.event,
                        this._onRequestReset = this.register(new p.EventEmitter),
                        this.onRequestReset = this._onRequestReset.event,
                        this._onRequestSendFocus = this.register(new p.EventEmitter),
                        this.onRequestSendFocus = this._onRequestSendFocus.event,
                        this._onRequestSyncScrollBar = this.register(new p.EventEmitter),
                        this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event,
                        this._onRequestWindowsOptionsReport = this.register(new p.EventEmitter),
                        this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event,
                        this._onA11yChar = this.register(new p.EventEmitter),
                        this.onA11yChar = this._onA11yChar.event,
                        this._onA11yTab = this.register(new p.EventEmitter),
                        this.onA11yTab = this._onA11yTab.event,
                        this._onCursorMove = this.register(new p.EventEmitter),
                        this.onCursorMove = this._onCursorMove.event,
                        this._onLineFeed = this.register(new p.EventEmitter),
                        this.onLineFeed = this._onLineFeed.event,
                        this._onScroll = this.register(new p.EventEmitter),
                        this.onScroll = this._onScroll.event,
                        this._onTitleChange = this.register(new p.EventEmitter),
                        this.onTitleChange = this._onTitleChange.event,
                        this._onColor = this.register(new p.EventEmitter),
                        this.onColor = this._onColor.event,
                        this._parseStack = {
                            paused: !1,
                            cursorStartX: 0,
                            cursorStartY: 0,
                            decodedLength: 0,
                            position: 0
                        },
                        this._specialColors = [256, 257, 258],
                        this.register(this._parser),
                        this._dirtyRowTracker = new J(this._bufferService),
                        this._activeBuffer = this._bufferService.buffer,
                        this.register(this._bufferService.buffers.onBufferActivate(j => this._activeBuffer = j.activeBuffer)),
                        this._parser.setCsiHandlerFallback( (j, oe) => {
                            this._logService.debug("Unknown CSI code: ", {
                                identifier: this._parser.identToString(j),
                                params: oe.toArray()
                            })
                        }
                        ),
                        this._parser.setEscHandlerFallback(j => {
                            this._logService.debug("Unknown ESC code: ", {
                                identifier: this._parser.identToString(j)
                            })
                        }
                        ),
                        this._parser.setExecuteHandlerFallback(j => {
                            this._logService.debug("Unknown EXECUTE code: ", {
                                code: j
                            })
                        }
                        ),
                        this._parser.setOscHandlerFallback( (j, oe, le) => {
                            this._logService.debug("Unknown OSC code: ", {
                                identifier: j,
                                action: oe,
                                data: le
                            })
                        }
                        ),
                        this._parser.setDcsHandlerFallback( (j, oe, le) => {
                            oe === "HOOK" && (le = le.toArray()),
                            this._logService.debug("Unknown DCS code: ", {
                                identifier: this._parser.identToString(j),
                                action: oe,
                                payload: le
                            })
                        }
                        ),
                        this._parser.setPrintHandler( (j, oe, le) => this.print(j, oe, le)),
                        this._parser.registerCsiHandler({
                            final: "@"
                        }, j => this.insertChars(j)),
                        this._parser.registerCsiHandler({
                            intermediates: " ",
                            final: "@"
                        }, j => this.scrollLeft(j)),
                        this._parser.registerCsiHandler({
                            final: "A"
                        }, j => this.cursorUp(j)),
                        this._parser.registerCsiHandler({
                            intermediates: " ",
                            final: "A"
                        }, j => this.scrollRight(j)),
                        this._parser.registerCsiHandler({
                            final: "B"
                        }, j => this.cursorDown(j)),
                        this._parser.registerCsiHandler({
                            final: "C"
                        }, j => this.cursorForward(j)),
                        this._parser.registerCsiHandler({
                            final: "D"
                        }, j => this.cursorBackward(j)),
                        this._parser.registerCsiHandler({
                            final: "E"
                        }, j => this.cursorNextLine(j)),
                        this._parser.registerCsiHandler({
                            final: "F"
                        }, j => this.cursorPrecedingLine(j)),
                        this._parser.registerCsiHandler({
                            final: "G"
                        }, j => this.cursorCharAbsolute(j)),
                        this._parser.registerCsiHandler({
                            final: "H"
                        }, j => this.cursorPosition(j)),
                        this._parser.registerCsiHandler({
                            final: "I"
                        }, j => this.cursorForwardTab(j)),
                        this._parser.registerCsiHandler({
                            final: "J"
                        }, j => this.eraseInDisplay(j, !1)),
                        this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "J"
                        }, j => this.eraseInDisplay(j, !0)),
                        this._parser.registerCsiHandler({
                            final: "K"
                        }, j => this.eraseInLine(j, !1)),
                        this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "K"
                        }, j => this.eraseInLine(j, !0)),
                        this._parser.registerCsiHandler({
                            final: "L"
                        }, j => this.insertLines(j)),
                        this._parser.registerCsiHandler({
                            final: "M"
                        }, j => this.deleteLines(j)),
                        this._parser.registerCsiHandler({
                            final: "P"
                        }, j => this.deleteChars(j)),
                        this._parser.registerCsiHandler({
                            final: "S"
                        }, j => this.scrollUp(j)),
                        this._parser.registerCsiHandler({
                            final: "T"
                        }, j => this.scrollDown(j)),
                        this._parser.registerCsiHandler({
                            final: "X"
                        }, j => this.eraseChars(j)),
                        this._parser.registerCsiHandler({
                            final: "Z"
                        }, j => this.cursorBackwardTab(j)),
                        this._parser.registerCsiHandler({
                            final: "`"
                        }, j => this.charPosAbsolute(j)),
                        this._parser.registerCsiHandler({
                            final: "a"
                        }, j => this.hPositionRelative(j)),
                        this._parser.registerCsiHandler({
                            final: "b"
                        }, j => this.repeatPrecedingCharacter(j)),
                        this._parser.registerCsiHandler({
                            final: "c"
                        }, j => this.sendDeviceAttributesPrimary(j)),
                        this._parser.registerCsiHandler({
                            prefix: ">",
                            final: "c"
                        }, j => this.sendDeviceAttributesSecondary(j)),
                        this._parser.registerCsiHandler({
                            final: "d"
                        }, j => this.linePosAbsolute(j)),
                        this._parser.registerCsiHandler({
                            final: "e"
                        }, j => this.vPositionRelative(j)),
                        this._parser.registerCsiHandler({
                            final: "f"
                        }, j => this.hVPosition(j)),
                        this._parser.registerCsiHandler({
                            final: "g"
                        }, j => this.tabClear(j)),
                        this._parser.registerCsiHandler({
                            final: "h"
                        }, j => this.setMode(j)),
                        this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "h"
                        }, j => this.setModePrivate(j)),
                        this._parser.registerCsiHandler({
                            final: "l"
                        }, j => this.resetMode(j)),
                        this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "l"
                        }, j => this.resetModePrivate(j)),
                        this._parser.registerCsiHandler({
                            final: "m"
                        }, j => this.charAttributes(j)),
                        this._parser.registerCsiHandler({
                            final: "n"
                        }, j => this.deviceStatus(j)),
                        this._parser.registerCsiHandler({
                            prefix: "?",
                            final: "n"
                        }, j => this.deviceStatusPrivate(j)),
                        this._parser.registerCsiHandler({
                            intermediates: "!",
                            final: "p"
                        }, j => this.softReset(j)),
                        this._parser.registerCsiHandler({
                            intermediates: " ",
                            final: "q"
                        }, j => this.setCursorStyle(j)),
                        this._parser.registerCsiHandler({
                            final: "r"
                        }, j => this.setScrollRegion(j)),
                        this._parser.registerCsiHandler({
                            final: "s"
                        }, j => this.saveCursor(j)),
                        this._parser.registerCsiHandler({
                            final: "t"
                        }, j => this.windowOptions(j)),
                        this._parser.registerCsiHandler({
                            final: "u"
                        }, j => this.restoreCursor(j)),
                        this._parser.registerCsiHandler({
                            intermediates: "'",
                            final: "}"
                        }, j => this.insertColumns(j)),
                        this._parser.registerCsiHandler({
                            intermediates: "'",
                            final: "~"
                        }, j => this.deleteColumns(j)),
                        this._parser.registerCsiHandler({
                            intermediates: '"',
                            final: "q"
                        }, j => this.selectProtected(j)),
                        this._parser.registerCsiHandler({
                            intermediates: "$",
                            final: "p"
                        }, j => this.requestMode(j, !0)),
                        this._parser.registerCsiHandler({
                            prefix: "?",
                            intermediates: "$",
                            final: "p"
                        }, j => this.requestMode(j, !1)),
                        this._parser.setExecuteHandler(h.C0.BEL, () => this.bell()),
                        this._parser.setExecuteHandler(h.C0.LF, () => this.lineFeed()),
                        this._parser.setExecuteHandler(h.C0.VT, () => this.lineFeed()),
                        this._parser.setExecuteHandler(h.C0.FF, () => this.lineFeed()),
                        this._parser.setExecuteHandler(h.C0.CR, () => this.carriageReturn()),
                        this._parser.setExecuteHandler(h.C0.BS, () => this.backspace()),
                        this._parser.setExecuteHandler(h.C0.HT, () => this.tab()),
                        this._parser.setExecuteHandler(h.C0.SO, () => this.shiftOut()),
                        this._parser.setExecuteHandler(h.C0.SI, () => this.shiftIn()),
                        this._parser.setExecuteHandler(h.C1.IND, () => this.index()),
                        this._parser.setExecuteHandler(h.C1.NEL, () => this.nextLine()),
                        this._parser.setExecuteHandler(h.C1.HTS, () => this.tabSet()),
                        this._parser.registerOscHandler(0, new A.OscHandler(j => (this.setTitle(j),
                        this.setIconName(j),
                        !0))),
                        this._parser.registerOscHandler(1, new A.OscHandler(j => this.setIconName(j))),
                        this._parser.registerOscHandler(2, new A.OscHandler(j => this.setTitle(j))),
                        this._parser.registerOscHandler(4, new A.OscHandler(j => this.setOrReportIndexedColor(j))),
                        this._parser.registerOscHandler(8, new A.OscHandler(j => this.setHyperlink(j))),
                        this._parser.registerOscHandler(10, new A.OscHandler(j => this.setOrReportFgColor(j))),
                        this._parser.registerOscHandler(11, new A.OscHandler(j => this.setOrReportBgColor(j))),
                        this._parser.registerOscHandler(12, new A.OscHandler(j => this.setOrReportCursorColor(j))),
                        this._parser.registerOscHandler(104, new A.OscHandler(j => this.restoreIndexedColor(j))),
                        this._parser.registerOscHandler(110, new A.OscHandler(j => this.restoreFgColor(j))),
                        this._parser.registerOscHandler(111, new A.OscHandler(j => this.restoreBgColor(j))),
                        this._parser.registerOscHandler(112, new A.OscHandler(j => this.restoreCursorColor(j))),
                        this._parser.registerEscHandler({
                            final: "7"
                        }, () => this.saveCursor()),
                        this._parser.registerEscHandler({
                            final: "8"
                        }, () => this.restoreCursor()),
                        this._parser.registerEscHandler({
                            final: "D"
                        }, () => this.index()),
                        this._parser.registerEscHandler({
                            final: "E"
                        }, () => this.nextLine()),
                        this._parser.registerEscHandler({
                            final: "H"
                        }, () => this.tabSet()),
                        this._parser.registerEscHandler({
                            final: "M"
                        }, () => this.reverseIndex()),
                        this._parser.registerEscHandler({
                            final: "="
                        }, () => this.keypadApplicationMode()),
                        this._parser.registerEscHandler({
                            final: ">"
                        }, () => this.keypadNumericMode()),
                        this._parser.registerEscHandler({
                            final: "c"
                        }, () => this.fullReset()),
                        this._parser.registerEscHandler({
                            final: "n"
                        }, () => this.setgLevel(2)),
                        this._parser.registerEscHandler({
                            final: "o"
                        }, () => this.setgLevel(3)),
                        this._parser.registerEscHandler({
                            final: "|"
                        }, () => this.setgLevel(3)),
                        this._parser.registerEscHandler({
                            final: "}"
                        }, () => this.setgLevel(2)),
                        this._parser.registerEscHandler({
                            final: "~"
                        }, () => this.setgLevel(1)),
                        this._parser.registerEscHandler({
                            intermediates: "%",
                            final: "@"
                        }, () => this.selectDefaultCharset()),
                        this._parser.registerEscHandler({
                            intermediates: "%",
                            final: "G"
                        }, () => this.selectDefaultCharset());
                        for (const j in d.CHARSETS)
                            this._parser.registerEscHandler({
                                intermediates: "(",
                                final: j
                            }, () => this.selectCharset("(" + j)),
                            this._parser.registerEscHandler({
                                intermediates: ")",
                                final: j
                            }, () => this.selectCharset(")" + j)),
                            this._parser.registerEscHandler({
                                intermediates: "*",
                                final: j
                            }, () => this.selectCharset("*" + j)),
                            this._parser.registerEscHandler({
                                intermediates: "+",
                                final: j
                            }, () => this.selectCharset("+" + j)),
                            this._parser.registerEscHandler({
                                intermediates: "-",
                                final: j
                            }, () => this.selectCharset("-" + j)),
                            this._parser.registerEscHandler({
                                intermediates: ".",
                                final: j
                            }, () => this.selectCharset("." + j)),
                            this._parser.registerEscHandler({
                                intermediates: "/",
                                final: j
                            }, () => this.selectCharset("/" + j));
                        this._parser.registerEscHandler({
                            intermediates: "#",
                            final: "8"
                        }, () => this.screenAlignmentPattern()),
                        this._parser.setErrorHandler(j => (this._logService.error("Parsing error: ", j),
                        j)),
                        this._parser.registerDcsHandler({
                            intermediates: "$",
                            final: "q"
                        }, new C.DcsHandler( (j, oe) => this.requestStatusString(j, oe)))
                    }
                    _preserveStack(D, L, z, V) {
                        this._parseStack.paused = !0,
                        this._parseStack.cursorStartX = D,
                        this._parseStack.cursorStartY = L,
                        this._parseStack.decodedLength = z,
                        this._parseStack.position = V
                    }
                    _logSlowResolvingAsync(D) {
                        this._logService.logLevel <= E.LogLevelEnum.WARN && Promise.race([D, new Promise( (L, z) => setTimeout( () => z("#SLOW_TIMEOUT"), 5e3))]).catch(L => {
                            if (L !== "#SLOW_TIMEOUT")
                                throw L;
                            console.warn("async parser handler taking longer than 5000 ms")
                        }
                        )
                    }
                    _getCurrentLinkId() {
                        return this._curAttrData.extended.urlId
                    }
                    parse(D, L) {
                        let z, V = this._activeBuffer.x, B = this._activeBuffer.y, Z = 0;
                        const se = this._parseStack.paused;
                        if (se) {
                            if (z = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, L))
                                return this._logSlowResolvingAsync(z),
                                z;
                            V = this._parseStack.cursorStartX,
                            B = this._parseStack.cursorStartY,
                            this._parseStack.paused = !1,
                            D.length > N && (Z = this._parseStack.position + N)
                        }
                        if (this._logService.logLevel <= E.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof D == "string" ? ` "${D}"` : ` "${Array.prototype.map.call(D, j => String.fromCharCode(j)).join("")}"`), typeof D == "string" ? D.split("").map(j => j.charCodeAt(0)) : D),
                        this._parseBuffer.length < D.length && this._parseBuffer.length < N && (this._parseBuffer = new Uint32Array(Math.min(D.length, N))),
                        se || this._dirtyRowTracker.clearRange(),
                        D.length > N)
                            for (let j = Z; j < D.length; j += N) {
                                const oe = j + N < D.length ? j + N : D.length
                                  , le = typeof D == "string" ? this._stringDecoder.decode(D.substring(j, oe), this._parseBuffer) : this._utf8Decoder.decode(D.subarray(j, oe), this._parseBuffer);
                                if (z = this._parser.parse(this._parseBuffer, le))
                                    return this._preserveStack(V, B, le, j),
                                    this._logSlowResolvingAsync(z),
                                    z
                            }
                        else if (!se) {
                            const j = typeof D == "string" ? this._stringDecoder.decode(D, this._parseBuffer) : this._utf8Decoder.decode(D, this._parseBuffer);
                            if (z = this._parser.parse(this._parseBuffer, j))
                                return this._preserveStack(V, B, j, 0),
                                this._logSlowResolvingAsync(z),
                                z
                        }
                        this._activeBuffer.x === V && this._activeBuffer.y === B || this._onCursorMove.fire();
                        const ae = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp)
                          , G = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
                        G < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(G, this._bufferService.rows - 1), Math.min(ae, this._bufferService.rows - 1))
                    }
                    print(D, L, z) {
                        let V, B;
                        const Z = this._charsetService.charset
                          , se = this._optionsService.rawOptions.screenReaderMode
                          , ae = this._bufferService.cols
                          , G = this._coreService.decPrivateModes.wraparound
                          , j = this._coreService.modes.insertMode
                          , oe = this._curAttrData;
                        let le = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                        this._activeBuffer.x && z - L > 0 && le.getWidth(this._activeBuffer.x - 1) === 2 && le.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, oe);
                        let de = this._parser.precedingJoinState;
                        for (let ne = L; ne < z; ++ne) {
                            if (V = D[ne],
                            V < 127 && Z) {
                                const Re = Z[String.fromCharCode(V)];
                                Re && (V = Re.charCodeAt(0))
                            }
                            const pe = this._unicodeService.charProperties(V, de);
                            B = w.UnicodeService.extractWidth(pe);
                            const Te = w.UnicodeService.extractShouldJoin(pe)
                              , Ce = Te ? w.UnicodeService.extractWidth(de) : 0;
                            if (de = pe,
                            se && this._onA11yChar.fire((0,
                            _.stringFromCodePoint)(V)),
                            this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y),
                            this._activeBuffer.x + B - Ce > ae) {
                                if (G) {
                                    const Re = le;
                                    let we = this._activeBuffer.x - Ce;
                                    for (this._activeBuffer.x = Ce,
                                    this._activeBuffer.y++,
                                    this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--,
                                    this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1),
                                    this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0),
                                    le = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y),
                                    Ce > 0 && le instanceof m.BufferLine && le.copyCellsFrom(Re, we, 0, Ce, !1); we < ae; )
                                        Re.setCellFromCodepoint(we++, 0, 1, oe)
                                } else if (this._activeBuffer.x = ae - 1,
                                B === 2)
                                    continue
                            }
                            if (Te && this._activeBuffer.x) {
                                const Re = le.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
                                le.addCodepointToCell(this._activeBuffer.x - Re, V, B);
                                for (let we = B - Ce; --we >= 0; )
                                    le.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, oe)
                            } else if (j && (le.insertCells(this._activeBuffer.x, B - Ce, this._activeBuffer.getNullCell(oe)),
                            le.getWidth(ae - 1) === 2 && le.setCellFromCodepoint(ae - 1, b.NULL_CELL_CODE, b.NULL_CELL_WIDTH, oe)),
                            le.setCellFromCodepoint(this._activeBuffer.x++, V, B, oe),
                            B > 0)
                                for (; --B; )
                                    le.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, oe)
                        }
                        this._parser.precedingJoinState = de,
                        this._activeBuffer.x < ae && z - L > 0 && le.getWidth(this._activeBuffer.x) === 0 && !le.hasContent(this._activeBuffer.x) && le.setCellFromCodepoint(this._activeBuffer.x, 0, 1, oe),
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y)
                    }
                    registerCsiHandler(D, L) {
                        return D.final !== "t" || D.prefix || D.intermediates ? this._parser.registerCsiHandler(D, L) : this._parser.registerCsiHandler(D, z => !O(z.params[0], this._optionsService.rawOptions.windowOptions) || L(z))
                    }
                    registerDcsHandler(D, L) {
                        return this._parser.registerDcsHandler(D, new C.DcsHandler(L))
                    }
                    registerEscHandler(D, L) {
                        return this._parser.registerEscHandler(D, L)
                    }
                    registerOscHandler(D, L) {
                        return this._parser.registerOscHandler(D, new A.OscHandler(L))
                    }
                    bell() {
                        return this._onRequestBell.fire(),
                        !0
                    }
                    lineFeed() {
                        return this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                        this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0),
                        this._activeBuffer.y++,
                        this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--,
                        this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1,
                        this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--,
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                        this._onLineFeed.fire(),
                        !0
                    }
                    carriageReturn() {
                        return this._activeBuffer.x = 0,
                        !0
                    }
                    backspace() {
                        if (!this._coreService.decPrivateModes.reverseWraparound)
                            return this._restrictCursor(),
                            this._activeBuffer.x > 0 && this._activeBuffer.x--,
                            !0;
                        if (this._restrictCursor(this._bufferService.cols),
                        this._activeBuffer.x > 0)
                            this._activeBuffer.x--;
                        else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
                            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1,
                            this._activeBuffer.y--,
                            this._activeBuffer.x = this._bufferService.cols - 1;
                            const D = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                            D.hasWidth(this._activeBuffer.x) && !D.hasContent(this._activeBuffer.x) && this._activeBuffer.x--
                        }
                        return this._restrictCursor(),
                        !0
                    }
                    tab() {
                        if (this._activeBuffer.x >= this._bufferService.cols)
                            return !0;
                        const D = this._activeBuffer.x;
                        return this._activeBuffer.x = this._activeBuffer.nextStop(),
                        this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - D),
                        !0
                    }
                    shiftOut() {
                        return this._charsetService.setgLevel(1),
                        !0
                    }
                    shiftIn() {
                        return this._charsetService.setgLevel(0),
                        !0
                    }
                    _restrictCursor(D=this._bufferService.cols - 1) {
                        this._activeBuffer.x = Math.min(D, Math.max(0, this._activeBuffer.x)),
                        this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)),
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y)
                    }
                    _setCursor(D, L) {
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                        this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = D,
                        this._activeBuffer.y = this._activeBuffer.scrollTop + L) : (this._activeBuffer.x = D,
                        this._activeBuffer.y = L),
                        this._restrictCursor(),
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y)
                    }
                    _moveCursor(D, L) {
                        this._restrictCursor(),
                        this._setCursor(this._activeBuffer.x + D, this._activeBuffer.y + L)
                    }
                    cursorUp(D) {
                        const L = this._activeBuffer.y - this._activeBuffer.scrollTop;
                        return L >= 0 ? this._moveCursor(0, -Math.min(L, D.params[0] || 1)) : this._moveCursor(0, -(D.params[0] || 1)),
                        !0
                    }
                    cursorDown(D) {
                        const L = this._activeBuffer.scrollBottom - this._activeBuffer.y;
                        return L >= 0 ? this._moveCursor(0, Math.min(L, D.params[0] || 1)) : this._moveCursor(0, D.params[0] || 1),
                        !0
                    }
                    cursorForward(D) {
                        return this._moveCursor(D.params[0] || 1, 0),
                        !0
                    }
                    cursorBackward(D) {
                        return this._moveCursor(-(D.params[0] || 1), 0),
                        !0
                    }
                    cursorNextLine(D) {
                        return this.cursorDown(D),
                        this._activeBuffer.x = 0,
                        !0
                    }
                    cursorPrecedingLine(D) {
                        return this.cursorUp(D),
                        this._activeBuffer.x = 0,
                        !0
                    }
                    cursorCharAbsolute(D) {
                        return this._setCursor((D.params[0] || 1) - 1, this._activeBuffer.y),
                        !0
                    }
                    cursorPosition(D) {
                        return this._setCursor(D.length >= 2 ? (D.params[1] || 1) - 1 : 0, (D.params[0] || 1) - 1),
                        !0
                    }
                    charPosAbsolute(D) {
                        return this._setCursor((D.params[0] || 1) - 1, this._activeBuffer.y),
                        !0
                    }
                    hPositionRelative(D) {
                        return this._moveCursor(D.params[0] || 1, 0),
                        !0
                    }
                    linePosAbsolute(D) {
                        return this._setCursor(this._activeBuffer.x, (D.params[0] || 1) - 1),
                        !0
                    }
                    vPositionRelative(D) {
                        return this._moveCursor(0, D.params[0] || 1),
                        !0
                    }
                    hVPosition(D) {
                        return this.cursorPosition(D),
                        !0
                    }
                    tabClear(D) {
                        const L = D.params[0];
                        return L === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : L === 3 && (this._activeBuffer.tabs = {}),
                        !0
                    }
                    cursorForwardTab(D) {
                        if (this._activeBuffer.x >= this._bufferService.cols)
                            return !0;
                        let L = D.params[0] || 1;
                        for (; L--; )
                            this._activeBuffer.x = this._activeBuffer.nextStop();
                        return !0
                    }
                    cursorBackwardTab(D) {
                        if (this._activeBuffer.x >= this._bufferService.cols)
                            return !0;
                        let L = D.params[0] || 1;
                        for (; L--; )
                            this._activeBuffer.x = this._activeBuffer.prevStop();
                        return !0
                    }
                    selectProtected(D) {
                        const L = D.params[0];
                        return L === 1 && (this._curAttrData.bg |= 536870912),
                        L !== 2 && L !== 0 || (this._curAttrData.bg &= -536870913),
                        !0
                    }
                    _eraseInBufferLine(D, L, z, V=!1, B=!1) {
                        const Z = this._activeBuffer.lines.get(this._activeBuffer.ybase + D);
                        Z.replaceCells(L, z, this._activeBuffer.getNullCell(this._eraseAttrData()), B),
                        V && (Z.isWrapped = !1)
                    }
                    _resetBufferLine(D, L=!1) {
                        const z = this._activeBuffer.lines.get(this._activeBuffer.ybase + D);
                        z && (z.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), L),
                        this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + D),
                        z.isWrapped = !1)
                    }
                    eraseInDisplay(D, L=!1) {
                        let z;
                        switch (this._restrictCursor(this._bufferService.cols),
                        D.params[0]) {
                        case 0:
                            for (z = this._activeBuffer.y,
                            this._dirtyRowTracker.markDirty(z),
                            this._eraseInBufferLine(z++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, L); z < this._bufferService.rows; z++)
                                this._resetBufferLine(z, L);
                            this._dirtyRowTracker.markDirty(z);
                            break;
                        case 1:
                            for (z = this._activeBuffer.y,
                            this._dirtyRowTracker.markDirty(z),
                            this._eraseInBufferLine(z, 0, this._activeBuffer.x + 1, !0, L),
                            this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(z + 1).isWrapped = !1); z--; )
                                this._resetBufferLine(z, L);
                            this._dirtyRowTracker.markDirty(0);
                            break;
                        case 2:
                            for (z = this._bufferService.rows,
                            this._dirtyRowTracker.markDirty(z - 1); z--; )
                                this._resetBufferLine(z, L);
                            this._dirtyRowTracker.markDirty(0);
                            break;
                        case 3:
                            const V = this._activeBuffer.lines.length - this._bufferService.rows;
                            V > 0 && (this._activeBuffer.lines.trimStart(V),
                            this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - V, 0),
                            this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - V, 0),
                            this._onScroll.fire(0))
                        }
                        return !0
                    }
                    eraseInLine(D, L=!1) {
                        switch (this._restrictCursor(this._bufferService.cols),
                        D.params[0]) {
                        case 0:
                            this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, L);
                            break;
                        case 1:
                            this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, L);
                            break;
                        case 2:
                            this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, L)
                        }
                        return this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                        !0
                    }
                    insertLines(D) {
                        this._restrictCursor();
                        let L = D.params[0] || 1;
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                            return !0;
                        const z = this._activeBuffer.ybase + this._activeBuffer.y
                          , V = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom
                          , B = this._bufferService.rows - 1 + this._activeBuffer.ybase - V + 1;
                        for (; L--; )
                            this._activeBuffer.lines.splice(B - 1, 1),
                            this._activeBuffer.lines.splice(z, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom),
                        this._activeBuffer.x = 0,
                        !0
                    }
                    deleteLines(D) {
                        this._restrictCursor();
                        let L = D.params[0] || 1;
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                            return !0;
                        const z = this._activeBuffer.ybase + this._activeBuffer.y;
                        let V;
                        for (V = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom,
                        V = this._bufferService.rows - 1 + this._activeBuffer.ybase - V; L--; )
                            this._activeBuffer.lines.splice(z, 1),
                            this._activeBuffer.lines.splice(V, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom),
                        this._activeBuffer.x = 0,
                        !0
                    }
                    insertChars(D) {
                        this._restrictCursor();
                        const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        return L && (L.insertCells(this._activeBuffer.x, D.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())),
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y)),
                        !0
                    }
                    deleteChars(D) {
                        this._restrictCursor();
                        const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        return L && (L.deleteCells(this._activeBuffer.x, D.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())),
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y)),
                        !0
                    }
                    scrollUp(D) {
                        let L = D.params[0] || 1;
                        for (; L--; )
                            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1),
                            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom),
                        !0
                    }
                    scrollDown(D) {
                        let L = D.params[0] || 1;
                        for (; L--; )
                            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1),
                            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(m.DEFAULT_ATTR_DATA));
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom),
                        !0
                    }
                    scrollLeft(D) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                            return !0;
                        const L = D.params[0] || 1;
                        for (let z = this._activeBuffer.scrollTop; z <= this._activeBuffer.scrollBottom; ++z) {
                            const V = this._activeBuffer.lines.get(this._activeBuffer.ybase + z);
                            V.deleteCells(0, L, this._activeBuffer.getNullCell(this._eraseAttrData())),
                            V.isWrapped = !1
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom),
                        !0
                    }
                    scrollRight(D) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                            return !0;
                        const L = D.params[0] || 1;
                        for (let z = this._activeBuffer.scrollTop; z <= this._activeBuffer.scrollBottom; ++z) {
                            const V = this._activeBuffer.lines.get(this._activeBuffer.ybase + z);
                            V.insertCells(0, L, this._activeBuffer.getNullCell(this._eraseAttrData())),
                            V.isWrapped = !1
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom),
                        !0
                    }
                    insertColumns(D) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                            return !0;
                        const L = D.params[0] || 1;
                        for (let z = this._activeBuffer.scrollTop; z <= this._activeBuffer.scrollBottom; ++z) {
                            const V = this._activeBuffer.lines.get(this._activeBuffer.ybase + z);
                            V.insertCells(this._activeBuffer.x, L, this._activeBuffer.getNullCell(this._eraseAttrData())),
                            V.isWrapped = !1
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom),
                        !0
                    }
                    deleteColumns(D) {
                        if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                            return !0;
                        const L = D.params[0] || 1;
                        for (let z = this._activeBuffer.scrollTop; z <= this._activeBuffer.scrollBottom; ++z) {
                            const V = this._activeBuffer.lines.get(this._activeBuffer.ybase + z);
                            V.deleteCells(this._activeBuffer.x, L, this._activeBuffer.getNullCell(this._eraseAttrData())),
                            V.isWrapped = !1
                        }
                        return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom),
                        !0
                    }
                    eraseChars(D) {
                        this._restrictCursor();
                        const L = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                        return L && (L.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (D.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())),
                        this._dirtyRowTracker.markDirty(this._activeBuffer.y)),
                        !0
                    }
                    repeatPrecedingCharacter(D) {
                        const L = this._parser.precedingJoinState;
                        if (!L)
                            return !0;
                        const z = D.params[0] || 1
                          , V = w.UnicodeService.extractWidth(L)
                          , B = this._activeBuffer.x - V
                          , Z = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(B)
                          , se = new Uint32Array(Z.length * z);
                        let ae = 0;
                        for (let j = 0; j < Z.length; ) {
                            const oe = Z.codePointAt(j) || 0;
                            se[ae++] = oe,
                            j += oe > 65535 ? 2 : 1
                        }
                        let G = ae;
                        for (let j = 1; j < z; ++j)
                            se.copyWithin(G, 0, ae),
                            G += ae;
                        return this.print(se, 0, G),
                        !0
                    }
                    sendDeviceAttributesPrimary(D) {
                        return D.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(h.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(h.C0.ESC + "[?6c")),
                        !0
                    }
                    sendDeviceAttributesSecondary(D) {
                        return D.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(h.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(h.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(D.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(h.C0.ESC + "[>83;40003;0c")),
                        !0
                    }
                    _is(D) {
                        return (this._optionsService.rawOptions.termName + "").indexOf(D) === 0
                    }
                    setMode(D) {
                        for (let L = 0; L < D.length; L++)
                            switch (D.params[L]) {
                            case 4:
                                this._coreService.modes.insertMode = !0;
                                break;
                            case 20:
                                this._optionsService.options.convertEol = !0
                            }
                        return !0
                    }
                    setModePrivate(D) {
                        for (let L = 0; L < D.length; L++)
                            switch (D.params[L]) {
                            case 1:
                                this._coreService.decPrivateModes.applicationCursorKeys = !0;
                                break;
                            case 2:
                                this._charsetService.setgCharset(0, d.DEFAULT_CHARSET),
                                this._charsetService.setgCharset(1, d.DEFAULT_CHARSET),
                                this._charsetService.setgCharset(2, d.DEFAULT_CHARSET),
                                this._charsetService.setgCharset(3, d.DEFAULT_CHARSET);
                                break;
                            case 3:
                                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows),
                                this._onRequestReset.fire());
                                break;
                            case 6:
                                this._coreService.decPrivateModes.origin = !0,
                                this._setCursor(0, 0);
                                break;
                            case 7:
                                this._coreService.decPrivateModes.wraparound = !0;
                                break;
                            case 12:
                                this._optionsService.options.cursorBlink = !0;
                                break;
                            case 45:
                                this._coreService.decPrivateModes.reverseWraparound = !0;
                                break;
                            case 66:
                                this._logService.debug("Serial port requested application keypad."),
                                this._coreService.decPrivateModes.applicationKeypad = !0,
                                this._onRequestSyncScrollBar.fire();
                                break;
                            case 9:
                                this._coreMouseService.activeProtocol = "X10";
                                break;
                            case 1e3:
                                this._coreMouseService.activeProtocol = "VT200";
                                break;
                            case 1002:
                                this._coreMouseService.activeProtocol = "DRAG";
                                break;
                            case 1003:
                                this._coreMouseService.activeProtocol = "ANY";
                                break;
                            case 1004:
                                this._coreService.decPrivateModes.sendFocus = !0,
                                this._onRequestSendFocus.fire();
                                break;
                            case 1005:
                                this._logService.debug("DECSET 1005 not supported (see #2507)");
                                break;
                            case 1006:
                                this._coreMouseService.activeEncoding = "SGR";
                                break;
                            case 1015:
                                this._logService.debug("DECSET 1015 not supported (see #2507)");
                                break;
                            case 1016:
                                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                                break;
                            case 25:
                                this._coreService.isCursorHidden = !1;
                                break;
                            case 1048:
                                this.saveCursor();
                                break;
                            case 1049:
                                this.saveCursor();
                            case 47:
                            case 1047:
                                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()),
                                this._coreService.isCursorInitialized = !0,
                                this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1),
                                this._onRequestSyncScrollBar.fire();
                                break;
                            case 2004:
                                this._coreService.decPrivateModes.bracketedPasteMode = !0
                            }
                        return !0
                    }
                    resetMode(D) {
                        for (let L = 0; L < D.length; L++)
                            switch (D.params[L]) {
                            case 4:
                                this._coreService.modes.insertMode = !1;
                                break;
                            case 20:
                                this._optionsService.options.convertEol = !1
                            }
                        return !0
                    }
                    resetModePrivate(D) {
                        for (let L = 0; L < D.length; L++)
                            switch (D.params[L]) {
                            case 1:
                                this._coreService.decPrivateModes.applicationCursorKeys = !1;
                                break;
                            case 3:
                                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows),
                                this._onRequestReset.fire());
                                break;
                            case 6:
                                this._coreService.decPrivateModes.origin = !1,
                                this._setCursor(0, 0);
                                break;
                            case 7:
                                this._coreService.decPrivateModes.wraparound = !1;
                                break;
                            case 12:
                                this._optionsService.options.cursorBlink = !1;
                                break;
                            case 45:
                                this._coreService.decPrivateModes.reverseWraparound = !1;
                                break;
                            case 66:
                                this._logService.debug("Switching back to normal keypad."),
                                this._coreService.decPrivateModes.applicationKeypad = !1,
                                this._onRequestSyncScrollBar.fire();
                                break;
                            case 9:
                            case 1e3:
                            case 1002:
                            case 1003:
                                this._coreMouseService.activeProtocol = "NONE";
                                break;
                            case 1004:
                                this._coreService.decPrivateModes.sendFocus = !1;
                                break;
                            case 1005:
                                this._logService.debug("DECRST 1005 not supported (see #2507)");
                                break;
                            case 1006:
                            case 1016:
                                this._coreMouseService.activeEncoding = "DEFAULT";
                                break;
                            case 1015:
                                this._logService.debug("DECRST 1015 not supported (see #2507)");
                                break;
                            case 25:
                                this._coreService.isCursorHidden = !0;
                                break;
                            case 1048:
                                this.restoreCursor();
                                break;
                            case 1049:
                            case 47:
                            case 1047:
                                this._bufferService.buffers.activateNormalBuffer(),
                                D.params[L] === 1049 && this.restoreCursor(),
                                this._coreService.isCursorInitialized = !0,
                                this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1),
                                this._onRequestSyncScrollBar.fire();
                                break;
                            case 2004:
                                this._coreService.decPrivateModes.bracketedPasteMode = !1
                            }
                        return !0
                    }
                    requestMode(D, L) {
                        const z = this._coreService.decPrivateModes
                          , {activeProtocol: V, activeEncoding: B} = this._coreMouseService
                          , Z = this._coreService
                          , {buffers: se, cols: ae} = this._bufferService
                          , {active: G, alt: j} = se
                          , oe = this._optionsService.rawOptions
                          , le = Te => Te ? 1 : 2
                          , de = D.params[0];
                        return ne = de,
                        pe = L ? de === 2 ? 4 : de === 4 ? le(Z.modes.insertMode) : de === 12 ? 3 : de === 20 ? le(oe.convertEol) : 0 : de === 1 ? le(z.applicationCursorKeys) : de === 3 ? oe.windowOptions.setWinLines ? ae === 80 ? 2 : ae === 132 ? 1 : 0 : 0 : de === 6 ? le(z.origin) : de === 7 ? le(z.wraparound) : de === 8 ? 3 : de === 9 ? le(V === "X10") : de === 12 ? le(oe.cursorBlink) : de === 25 ? le(!Z.isCursorHidden) : de === 45 ? le(z.reverseWraparound) : de === 66 ? le(z.applicationKeypad) : de === 67 ? 4 : de === 1e3 ? le(V === "VT200") : de === 1002 ? le(V === "DRAG") : de === 1003 ? le(V === "ANY") : de === 1004 ? le(z.sendFocus) : de === 1005 ? 4 : de === 1006 ? le(B === "SGR") : de === 1015 ? 4 : de === 1016 ? le(B === "SGR_PIXELS") : de === 1048 ? 1 : de === 47 || de === 1047 || de === 1049 ? le(G === j) : de === 2004 ? le(z.bracketedPasteMode) : 0,
                        Z.triggerDataEvent(`${h.C0.ESC}[${L ? "" : "?"}${ne};${pe}$y`),
                        !0;
                        var ne, pe
                    }
                    _updateAttrColor(D, L, z, V, B) {
                        return L === 2 ? (D |= 50331648,
                        D &= -16777216,
                        D |= x.AttributeData.fromColorRGB([z, V, B])) : L === 5 && (D &= -50331904,
                        D |= 33554432 | 255 & z),
                        D
                    }
                    _extractColor(D, L, z) {
                        const V = [0, 0, -1, 0, 0, 0];
                        let B = 0
                          , Z = 0;
                        do {
                            if (V[Z + B] = D.params[L + Z],
                            D.hasSubParams(L + Z)) {
                                const se = D.getSubParams(L + Z);
                                let ae = 0;
                                do
                                    V[1] === 5 && (B = 1),
                                    V[Z + ae + 1 + B] = se[ae];
                                while (++ae < se.length && ae + Z + 1 + B < V.length);
                                break
                            }
                            if (V[1] === 5 && Z + B >= 2 || V[1] === 2 && Z + B >= 5)
                                break;
                            V[1] && (B = 1)
                        } while (++Z + L < D.length && Z + B < V.length);
                        for (let se = 2; se < V.length; ++se)
                            V[se] === -1 && (V[se] = 0);
                        switch (V[0]) {
                        case 38:
                            z.fg = this._updateAttrColor(z.fg, V[1], V[3], V[4], V[5]);
                            break;
                        case 48:
                            z.bg = this._updateAttrColor(z.bg, V[1], V[3], V[4], V[5]);
                            break;
                        case 58:
                            z.extended = z.extended.clone(),
                            z.extended.underlineColor = this._updateAttrColor(z.extended.underlineColor, V[1], V[3], V[4], V[5])
                        }
                        return Z
                    }
                    _processUnderline(D, L) {
                        L.extended = L.extended.clone(),
                        (!~D || D > 5) && (D = 1),
                        L.extended.underlineStyle = D,
                        L.fg |= 268435456,
                        D === 0 && (L.fg &= -268435457),
                        L.updateExtended()
                    }
                    _processSGR0(D) {
                        D.fg = m.DEFAULT_ATTR_DATA.fg,
                        D.bg = m.DEFAULT_ATTR_DATA.bg,
                        D.extended = D.extended.clone(),
                        D.extended.underlineStyle = 0,
                        D.extended.underlineColor &= -67108864,
                        D.updateExtended()
                    }
                    charAttributes(D) {
                        if (D.length === 1 && D.params[0] === 0)
                            return this._processSGR0(this._curAttrData),
                            !0;
                        const L = D.length;
                        let z;
                        const V = this._curAttrData;
                        for (let B = 0; B < L; B++)
                            z = D.params[B],
                            z >= 30 && z <= 37 ? (V.fg &= -50331904,
                            V.fg |= 16777216 | z - 30) : z >= 40 && z <= 47 ? (V.bg &= -50331904,
                            V.bg |= 16777216 | z - 40) : z >= 90 && z <= 97 ? (V.fg &= -50331904,
                            V.fg |= 16777224 | z - 90) : z >= 100 && z <= 107 ? (V.bg &= -50331904,
                            V.bg |= 16777224 | z - 100) : z === 0 ? this._processSGR0(V) : z === 1 ? V.fg |= 134217728 : z === 3 ? V.bg |= 67108864 : z === 4 ? (V.fg |= 268435456,
                            this._processUnderline(D.hasSubParams(B) ? D.getSubParams(B)[0] : 1, V)) : z === 5 ? V.fg |= 536870912 : z === 7 ? V.fg |= 67108864 : z === 8 ? V.fg |= 1073741824 : z === 9 ? V.fg |= 2147483648 : z === 2 ? V.bg |= 134217728 : z === 21 ? this._processUnderline(2, V) : z === 22 ? (V.fg &= -134217729,
                            V.bg &= -134217729) : z === 23 ? V.bg &= -67108865 : z === 24 ? (V.fg &= -268435457,
                            this._processUnderline(0, V)) : z === 25 ? V.fg &= -536870913 : z === 27 ? V.fg &= -67108865 : z === 28 ? V.fg &= -1073741825 : z === 29 ? V.fg &= 2147483647 : z === 39 ? (V.fg &= -67108864,
                            V.fg |= 16777215 & m.DEFAULT_ATTR_DATA.fg) : z === 49 ? (V.bg &= -67108864,
                            V.bg |= 16777215 & m.DEFAULT_ATTR_DATA.bg) : z === 38 || z === 48 || z === 58 ? B += this._extractColor(D, B, V) : z === 53 ? V.bg |= 1073741824 : z === 55 ? V.bg &= -1073741825 : z === 59 ? (V.extended = V.extended.clone(),
                            V.extended.underlineColor = -1,
                            V.updateExtended()) : z === 100 ? (V.fg &= -67108864,
                            V.fg |= 16777215 & m.DEFAULT_ATTR_DATA.fg,
                            V.bg &= -67108864,
                            V.bg |= 16777215 & m.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", z);
                        return !0
                    }
                    deviceStatus(D) {
                        switch (D.params[0]) {
                        case 5:
                            this._coreService.triggerDataEvent(`${h.C0.ESC}[0n`);
                            break;
                        case 6:
                            const L = this._activeBuffer.y + 1
                              , z = this._activeBuffer.x + 1;
                            this._coreService.triggerDataEvent(`${h.C0.ESC}[${L};${z}R`)
                        }
                        return !0
                    }
                    deviceStatusPrivate(D) {
                        if (D.params[0] === 6) {
                            const L = this._activeBuffer.y + 1
                              , z = this._activeBuffer.x + 1;
                            this._coreService.triggerDataEvent(`${h.C0.ESC}[?${L};${z}R`)
                        }
                        return !0
                    }
                    softReset(D) {
                        return this._coreService.isCursorHidden = !1,
                        this._onRequestSyncScrollBar.fire(),
                        this._activeBuffer.scrollTop = 0,
                        this._activeBuffer.scrollBottom = this._bufferService.rows - 1,
                        this._curAttrData = m.DEFAULT_ATTR_DATA.clone(),
                        this._coreService.reset(),
                        this._charsetService.reset(),
                        this._activeBuffer.savedX = 0,
                        this._activeBuffer.savedY = this._activeBuffer.ybase,
                        this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg,
                        this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg,
                        this._activeBuffer.savedCharset = this._charsetService.charset,
                        this._coreService.decPrivateModes.origin = !1,
                        !0
                    }
                    setCursorStyle(D) {
                        const L = D.params[0] || 1;
                        switch (L) {
                        case 1:
                        case 2:
                            this._optionsService.options.cursorStyle = "block";
                            break;
                        case 3:
                        case 4:
                            this._optionsService.options.cursorStyle = "underline";
                            break;
                        case 5:
                        case 6:
                            this._optionsService.options.cursorStyle = "bar"
                        }
                        const z = L % 2 == 1;
                        return this._optionsService.options.cursorBlink = z,
                        !0
                    }
                    setScrollRegion(D) {
                        const L = D.params[0] || 1;
                        let z;
                        return (D.length < 2 || (z = D.params[1]) > this._bufferService.rows || z === 0) && (z = this._bufferService.rows),
                        z > L && (this._activeBuffer.scrollTop = L - 1,
                        this._activeBuffer.scrollBottom = z - 1,
                        this._setCursor(0, 0)),
                        !0
                    }
                    windowOptions(D) {
                        if (!O(D.params[0], this._optionsService.rawOptions.windowOptions))
                            return !0;
                        const L = D.length > 1 ? D.params[1] : 0;
                        switch (D.params[0]) {
                        case 14:
                            L !== 2 && this._onRequestWindowsOptionsReport.fire(M.GET_WIN_SIZE_PIXELS);
                            break;
                        case 16:
                            this._onRequestWindowsOptionsReport.fire(M.GET_CELL_SIZE_PIXELS);
                            break;
                        case 18:
                            this._bufferService && this._coreService.triggerDataEvent(`${h.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                            break;
                        case 22:
                            L !== 0 && L !== 2 || (this._windowTitleStack.push(this._windowTitle),
                            this._windowTitleStack.length > 10 && this._windowTitleStack.shift()),
                            L !== 0 && L !== 1 || (this._iconNameStack.push(this._iconName),
                            this._iconNameStack.length > 10 && this._iconNameStack.shift());
                            break;
                        case 23:
                            L !== 0 && L !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()),
                            L !== 0 && L !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop())
                        }
                        return !0
                    }
                    saveCursor(D) {
                        return this._activeBuffer.savedX = this._activeBuffer.x,
                        this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y,
                        this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg,
                        this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg,
                        this._activeBuffer.savedCharset = this._charsetService.charset,
                        !0
                    }
                    restoreCursor(D) {
                        return this._activeBuffer.x = this._activeBuffer.savedX || 0,
                        this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0),
                        this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg,
                        this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg,
                        this._charsetService.charset = this._savedCharset,
                        this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset),
                        this._restrictCursor(),
                        !0
                    }
                    setTitle(D) {
                        return this._windowTitle = D,
                        this._onTitleChange.fire(D),
                        !0
                    }
                    setIconName(D) {
                        return this._iconName = D,
                        !0
                    }
                    setOrReportIndexedColor(D) {
                        const L = []
                          , z = D.split(";");
                        for (; z.length > 1; ) {
                            const V = z.shift()
                              , B = z.shift();
                            if (/^\d+$/.exec(V)) {
                                const Z = parseInt(V);
                                if (Q(Z))
                                    if (B === "?")
                                        L.push({
                                            type: 0,
                                            index: Z
                                        });
                                    else {
                                        const se = (0,
                                        k.parseColor)(B);
                                        se && L.push({
                                            type: 1,
                                            index: Z,
                                            color: se
                                        })
                                    }
                            }
                        }
                        return L.length && this._onColor.fire(L),
                        !0
                    }
                    setHyperlink(D) {
                        const L = D.split(";");
                        return !(L.length < 2) && (L[1] ? this._createHyperlink(L[0], L[1]) : !L[0] && this._finishHyperlink())
                    }
                    _createHyperlink(D, L) {
                        this._getCurrentLinkId() && this._finishHyperlink();
                        const z = D.split(":");
                        let V;
                        const B = z.findIndex(Z => Z.startsWith("id="));
                        return B !== -1 && (V = z[B].slice(3) || void 0),
                        this._curAttrData.extended = this._curAttrData.extended.clone(),
                        this._curAttrData.extended.urlId = this._oscLinkService.registerLink({
                            id: V,
                            uri: L
                        }),
                        this._curAttrData.updateExtended(),
                        !0
                    }
                    _finishHyperlink() {
                        return this._curAttrData.extended = this._curAttrData.extended.clone(),
                        this._curAttrData.extended.urlId = 0,
                        this._curAttrData.updateExtended(),
                        !0
                    }
                    _setOrReportSpecialColor(D, L) {
                        const z = D.split(";");
                        for (let V = 0; V < z.length && !(L >= this._specialColors.length); ++V,
                        ++L)
                            if (z[V] === "?")
                                this._onColor.fire([{
                                    type: 0,
                                    index: this._specialColors[L]
                                }]);
                            else {
                                const B = (0,
                                k.parseColor)(z[V]);
                                B && this._onColor.fire([{
                                    type: 1,
                                    index: this._specialColors[L],
                                    color: B
                                }])
                            }
                        return !0
                    }
                    setOrReportFgColor(D) {
                        return this._setOrReportSpecialColor(D, 0)
                    }
                    setOrReportBgColor(D) {
                        return this._setOrReportSpecialColor(D, 1)
                    }
                    setOrReportCursorColor(D) {
                        return this._setOrReportSpecialColor(D, 2)
                    }
                    restoreIndexedColor(D) {
                        if (!D)
                            return this._onColor.fire([{
                                type: 2
                            }]),
                            !0;
                        const L = []
                          , z = D.split(";");
                        for (let V = 0; V < z.length; ++V)
                            if (/^\d+$/.exec(z[V])) {
                                const B = parseInt(z[V]);
                                Q(B) && L.push({
                                    type: 2,
                                    index: B
                                })
                            }
                        return L.length && this._onColor.fire(L),
                        !0
                    }
                    restoreFgColor(D) {
                        return this._onColor.fire([{
                            type: 2,
                            index: 256
                        }]),
                        !0
                    }
                    restoreBgColor(D) {
                        return this._onColor.fire([{
                            type: 2,
                            index: 257
                        }]),
                        !0
                    }
                    restoreCursorColor(D) {
                        return this._onColor.fire([{
                            type: 2,
                            index: 258
                        }]),
                        !0
                    }
                    nextLine() {
                        return this._activeBuffer.x = 0,
                        this.index(),
                        !0
                    }
                    keypadApplicationMode() {
                        return this._logService.debug("Serial port requested application keypad."),
                        this._coreService.decPrivateModes.applicationKeypad = !0,
                        this._onRequestSyncScrollBar.fire(),
                        !0
                    }
                    keypadNumericMode() {
                        return this._logService.debug("Switching back to normal keypad."),
                        this._coreService.decPrivateModes.applicationKeypad = !1,
                        this._onRequestSyncScrollBar.fire(),
                        !0
                    }
                    selectDefaultCharset() {
                        return this._charsetService.setgLevel(0),
                        this._charsetService.setgCharset(0, d.DEFAULT_CHARSET),
                        !0
                    }
                    selectCharset(D) {
                        return D.length !== 2 ? (this.selectDefaultCharset(),
                        !0) : (D[0] === "/" || this._charsetService.setgCharset(I[D[0]], d.CHARSETS[D[1]] || d.DEFAULT_CHARSET),
                        !0)
                    }
                    index() {
                        return this._restrictCursor(),
                        this._activeBuffer.y++,
                        this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--,
                        this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1),
                        this._restrictCursor(),
                        !0
                    }
                    tabSet() {
                        return this._activeBuffer.tabs[this._activeBuffer.x] = !0,
                        !0
                    }
                    reverseIndex() {
                        if (this._restrictCursor(),
                        this._activeBuffer.y === this._activeBuffer.scrollTop) {
                            const D = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
                            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, D, 1),
                            this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())),
                            this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom)
                        } else
                            this._activeBuffer.y--,
                            this._restrictCursor();
                        return !0
                    }
                    fullReset() {
                        return this._parser.reset(),
                        this._onRequestReset.fire(),
                        !0
                    }
                    reset() {
                        this._curAttrData = m.DEFAULT_ATTR_DATA.clone(),
                        this._eraseAttrDataInternal = m.DEFAULT_ATTR_DATA.clone()
                    }
                    _eraseAttrData() {
                        return this._eraseAttrDataInternal.bg &= -67108864,
                        this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg,
                        this._eraseAttrDataInternal
                    }
                    setgLevel(D) {
                        return this._charsetService.setgLevel(D),
                        !0
                    }
                    screenAlignmentPattern() {
                        const D = new y.CellData;
                        D.content = 4194373,
                        D.fg = this._curAttrData.fg,
                        D.bg = this._curAttrData.bg,
                        this._setCursor(0, 0);
                        for (let L = 0; L < this._bufferService.rows; ++L) {
                            const z = this._activeBuffer.ybase + this._activeBuffer.y + L
                              , V = this._activeBuffer.lines.get(z);
                            V && (V.fill(D),
                            V.isWrapped = !1)
                        }
                        return this._dirtyRowTracker.markAllDirty(),
                        this._setCursor(0, 0),
                        !0
                    }
                    requestStatusString(D, L) {
                        const z = this._bufferService.buffer
                          , V = this._optionsService.rawOptions;
                        return (B => (this._coreService.triggerDataEvent(`${h.C0.ESC}${B}${h.C0.ESC}\\`),
                        !0))(D === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : D === '"p' ? 'P1$r61;1"p' : D === "r" ? `P1$r${z.scrollTop + 1};${z.scrollBottom + 1}r` : D === "m" ? "P1$r0m" : D === " q" ? `P1$r${{
                            block: 2,
                            underline: 4,
                            bar: 6
                        }[V.cursorStyle] - (V.cursorBlink ? 1 : 0)} q` : "P0$r")
                    }
                    markRangeDirty(D, L) {
                        this._dirtyRowTracker.markRangeDirty(D, L)
                    }
                }
                a.InputHandler = $;
                let J = class {
                    constructor(ee) {
                        this._bufferService = ee,
                        this.clearRange()
                    }
                    clearRange() {
                        this.start = this._bufferService.buffer.y,
                        this.end = this._bufferService.buffer.y
                    }
                    markDirty(ee) {
                        ee < this.start ? this.start = ee : ee > this.end && (this.end = ee)
                    }
                    markRangeDirty(ee, D) {
                        ee > D && (H = ee,
                        ee = D,
                        D = H),
                        ee < this.start && (this.start = ee),
                        D > this.end && (this.end = D)
                    }
                    markAllDirty() {
                        this.markRangeDirty(0, this._bufferService.rows - 1)
                    }
                }
                ;
                function Q(ee) {
                    return 0 <= ee && ee < 256
                }
                J = c([u(0, E.IBufferService)], J)
            },
            844: (o, a) => {
                function l(c) {
                    for (const u of c)
                        u.dispose();
                    c.length = 0
                }
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.getDisposeArrayDisposable = a.disposeArray = a.toDisposable = a.MutableDisposable = a.Disposable = void 0,
                a.Disposable = class {
                    constructor() {
                        this._disposables = [],
                        this._isDisposed = !1
                    }
                    dispose() {
                        this._isDisposed = !0;
                        for (const c of this._disposables)
                            c.dispose();
                        this._disposables.length = 0
                    }
                    register(c) {
                        return this._disposables.push(c),
                        c
                    }
                    unregister(c) {
                        const u = this._disposables.indexOf(c);
                        u !== -1 && this._disposables.splice(u, 1)
                    }
                }
                ,
                a.MutableDisposable = class {
                    constructor() {
                        this._isDisposed = !1
                    }
                    get value() {
                        return this._isDisposed ? void 0 : this._value
                    }
                    set value(c) {
                        this._isDisposed || c === this._value || (this._value?.dispose(),
                        this._value = c)
                    }
                    clear() {
                        this.value = void 0
                    }
                    dispose() {
                        this._isDisposed = !0,
                        this._value?.dispose(),
                        this._value = void 0
                    }
                }
                ,
                a.toDisposable = function(c) {
                    return {
                        dispose: c
                    }
                }
                ,
                a.disposeArray = l,
                a.getDisposeArrayDisposable = function(c) {
                    return {
                        dispose: () => l(c)
                    }
                }
            }
            ,
            1505: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.FourKeyMap = a.TwoKeyMap = void 0;
                class l {
                    constructor() {
                        this._data = {}
                    }
                    set(u, h, d) {
                        this._data[u] || (this._data[u] = {}),
                        this._data[u][h] = d
                    }
                    get(u, h) {
                        return this._data[u] ? this._data[u][h] : void 0
                    }
                    clear() {
                        this._data = {}
                    }
                }
                a.TwoKeyMap = l,
                a.FourKeyMap = class {
                    constructor() {
                        this._data = new l
                    }
                    set(c, u, h, d, f) {
                        this._data.get(c, u) || this._data.set(c, u, new l),
                        this._data.get(c, u).set(h, d, f)
                    }
                    get(c, u, h, d) {
                        return this._data.get(c, u)?.get(h, d)
                    }
                    clear() {
                        this._data.clear()
                    }
                }
            }
            ,
            6114: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.isChromeOS = a.isLinux = a.isWindows = a.isIphone = a.isIpad = a.isMac = a.getSafariVersion = a.isSafari = a.isLegacyEdge = a.isFirefox = a.isNode = void 0,
                a.isNode = typeof lu < "u" && "title"in lu;
                const l = a.isNode ? "node" : navigator.userAgent
                  , c = a.isNode ? "node" : navigator.platform;
                a.isFirefox = l.includes("Firefox"),
                a.isLegacyEdge = l.includes("Edge"),
                a.isSafari = /^((?!chrome|android).)*safari/i.test(l),
                a.getSafariVersion = function() {
                    if (!a.isSafari)
                        return 0;
                    const u = l.match(/Version\/(\d+)/);
                    return u === null || u.length < 2 ? 0 : parseInt(u[1])
                }
                ,
                a.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c),
                a.isIpad = c === "iPad",
                a.isIphone = c === "iPhone",
                a.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c),
                a.isLinux = c.indexOf("Linux") >= 0,
                a.isChromeOS = /\bCrOS\b/.test(l)
            }
            ,
            6106: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.SortedList = void 0;
                let l = 0;
                a.SortedList = class {
                    constructor(c) {
                        this._getKey = c,
                        this._array = []
                    }
                    clear() {
                        this._array.length = 0
                    }
                    insert(c) {
                        this._array.length !== 0 ? (l = this._search(this._getKey(c)),
                        this._array.splice(l, 0, c)) : this._array.push(c)
                    }
                    delete(c) {
                        if (this._array.length === 0)
                            return !1;
                        const u = this._getKey(c);
                        if (u === void 0 || (l = this._search(u),
                        l === -1) || this._getKey(this._array[l]) !== u)
                            return !1;
                        do
                            if (this._array[l] === c)
                                return this._array.splice(l, 1),
                                !0;
                        while (++l < this._array.length && this._getKey(this._array[l]) === u);
                        return !1
                    }
                    *getKeyIterator(c) {
                        if (this._array.length !== 0 && (l = this._search(c),
                        !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c))
                            do
                                yield this._array[l];
                            while (++l < this._array.length && this._getKey(this._array[l]) === c)
                    }
                    forEachByKey(c, u) {
                        if (this._array.length !== 0 && (l = this._search(c),
                        !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c))
                            do
                                u(this._array[l]);
                            while (++l < this._array.length && this._getKey(this._array[l]) === c)
                    }
                    values() {
                        return [...this._array].values()
                    }
                    _search(c) {
                        let u = 0
                          , h = this._array.length - 1;
                        for (; h >= u; ) {
                            let d = u + h >> 1;
                            const f = this._getKey(this._array[d]);
                            if (f > c)
                                h = d - 1;
                            else {
                                if (!(f < c)) {
                                    for (; d > 0 && this._getKey(this._array[d - 1]) === c; )
                                        d--;
                                    return d
                                }
                                u = d + 1
                            }
                        }
                        return u
                    }
                }
            }
            ,
            7226: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.DebouncedIdleTask = a.IdleTaskQueue = a.PriorityTaskQueue = void 0;
                const c = l(6114);
                class u {
                    constructor() {
                        this._tasks = [],
                        this._i = 0
                    }
                    enqueue(f) {
                        this._tasks.push(f),
                        this._start()
                    }
                    flush() {
                        for (; this._i < this._tasks.length; )
                            this._tasks[this._i]() || this._i++;
                        this.clear()
                    }
                    clear() {
                        this._idleCallback && (this._cancelCallback(this._idleCallback),
                        this._idleCallback = void 0),
                        this._i = 0,
                        this._tasks.length = 0
                    }
                    _start() {
                        this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)))
                    }
                    _process(f) {
                        this._idleCallback = void 0;
                        let g = 0
                          , _ = 0
                          , m = f.timeRemaining()
                          , p = 0;
                        for (; this._i < this._tasks.length; ) {
                            if (g = Date.now(),
                            this._tasks[this._i]() || this._i++,
                            g = Math.max(1, Date.now() - g),
                            _ = Math.max(g, _),
                            p = f.timeRemaining(),
                            1.5 * _ > p)
                                return m - g < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(m - g))}ms`),
                                void this._start();
                            m = p
                        }
                        this.clear()
                    }
                }
                class h extends u {
                    _requestCallback(f) {
                        return setTimeout( () => f(this._createDeadline(16)))
                    }
                    _cancelCallback(f) {
                        clearTimeout(f)
                    }
                    _createDeadline(f) {
                        const g = Date.now() + f;
                        return {
                            timeRemaining: () => Math.max(0, g - Date.now())
                        }
                    }
                }
                a.PriorityTaskQueue = h,
                a.IdleTaskQueue = !c.isNode && "requestIdleCallback"in window ? class extends u {
                    _requestCallback(d) {
                        return requestIdleCallback(d)
                    }
                    _cancelCallback(d) {
                        cancelIdleCallback(d)
                    }
                }
                : h,
                a.DebouncedIdleTask = class {
                    constructor() {
                        this._queue = new a.IdleTaskQueue
                    }
                    set(d) {
                        this._queue.clear(),
                        this._queue.enqueue(d)
                    }
                    flush() {
                        this._queue.flush()
                    }
                }
            }
            ,
            9282: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.updateWindowsModeWrappedState = void 0;
                const c = l(643);
                a.updateWindowsModeWrappedState = function(u) {
                    const h = u.buffer.lines.get(u.buffer.ybase + u.buffer.y - 1)
                      , d = h?.get(u.cols - 1)
                      , f = u.buffer.lines.get(u.buffer.ybase + u.buffer.y);
                    f && d && (f.isWrapped = d[c.CHAR_DATA_CODE_INDEX] !== c.NULL_CELL_CODE && d[c.CHAR_DATA_CODE_INDEX] !== c.WHITESPACE_CELL_CODE)
                }
            }
            ,
            3734: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.ExtendedAttrs = a.AttributeData = void 0;
                class l {
                    constructor() {
                        this.fg = 0,
                        this.bg = 0,
                        this.extended = new c
                    }
                    static toColorRGB(h) {
                        return [h >>> 16 & 255, h >>> 8 & 255, 255 & h]
                    }
                    static fromColorRGB(h) {
                        return (255 & h[0]) << 16 | (255 & h[1]) << 8 | 255 & h[2]
                    }
                    clone() {
                        const h = new l;
                        return h.fg = this.fg,
                        h.bg = this.bg,
                        h.extended = this.extended.clone(),
                        h
                    }
                    isInverse() {
                        return 67108864 & this.fg
                    }
                    isBold() {
                        return 134217728 & this.fg
                    }
                    isUnderline() {
                        return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg
                    }
                    isBlink() {
                        return 536870912 & this.fg
                    }
                    isInvisible() {
                        return 1073741824 & this.fg
                    }
                    isItalic() {
                        return 67108864 & this.bg
                    }
                    isDim() {
                        return 134217728 & this.bg
                    }
                    isStrikethrough() {
                        return 2147483648 & this.fg
                    }
                    isProtected() {
                        return 536870912 & this.bg
                    }
                    isOverline() {
                        return 1073741824 & this.bg
                    }
                    getFgColorMode() {
                        return 50331648 & this.fg
                    }
                    getBgColorMode() {
                        return 50331648 & this.bg
                    }
                    isFgRGB() {
                        return (50331648 & this.fg) == 50331648
                    }
                    isBgRGB() {
                        return (50331648 & this.bg) == 50331648
                    }
                    isFgPalette() {
                        return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432
                    }
                    isBgPalette() {
                        return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432
                    }
                    isFgDefault() {
                        return (50331648 & this.fg) == 0
                    }
                    isBgDefault() {
                        return (50331648 & this.bg) == 0
                    }
                    isAttributeDefault() {
                        return this.fg === 0 && this.bg === 0
                    }
                    getFgColor() {
                        switch (50331648 & this.fg) {
                        case 16777216:
                        case 33554432:
                            return 255 & this.fg;
                        case 50331648:
                            return 16777215 & this.fg;
                        default:
                            return -1
                        }
                    }
                    getBgColor() {
                        switch (50331648 & this.bg) {
                        case 16777216:
                        case 33554432:
                            return 255 & this.bg;
                        case 50331648:
                            return 16777215 & this.bg;
                        default:
                            return -1
                        }
                    }
                    hasExtendedAttrs() {
                        return 268435456 & this.bg
                    }
                    updateExtended() {
                        this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456
                    }
                    getUnderlineColor() {
                        if (268435456 & this.bg && ~this.extended.underlineColor)
                            switch (50331648 & this.extended.underlineColor) {
                            case 16777216:
                            case 33554432:
                                return 255 & this.extended.underlineColor;
                            case 50331648:
                                return 16777215 & this.extended.underlineColor;
                            default:
                                return this.getFgColor()
                            }
                        return this.getFgColor()
                    }
                    getUnderlineColorMode() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode()
                    }
                    isUnderlineColorRGB() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB()
                    }
                    isUnderlineColorPalette() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette()
                    }
                    isUnderlineColorDefault() {
                        return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault()
                    }
                    getUnderlineStyle() {
                        return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0
                    }
                    getUnderlineVariantOffset() {
                        return this.extended.underlineVariantOffset
                    }
                }
                a.AttributeData = l;
                class c {
                    get ext() {
                        return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext
                    }
                    set ext(h) {
                        this._ext = h
                    }
                    get underlineStyle() {
                        return this._urlId ? 5 : (469762048 & this._ext) >> 26
                    }
                    set underlineStyle(h) {
                        this._ext &= -469762049,
                        this._ext |= h << 26 & 469762048
                    }
                    get underlineColor() {
                        return 67108863 & this._ext
                    }
                    set underlineColor(h) {
                        this._ext &= -67108864,
                        this._ext |= 67108863 & h
                    }
                    get urlId() {
                        return this._urlId
                    }
                    set urlId(h) {
                        this._urlId = h
                    }
                    get underlineVariantOffset() {
                        const h = (3758096384 & this._ext) >> 29;
                        return h < 0 ? 4294967288 ^ h : h
                    }
                    set underlineVariantOffset(h) {
                        this._ext &= 536870911,
                        this._ext |= h << 29 & 3758096384
                    }
                    constructor(h=0, d=0) {
                        this._ext = 0,
                        this._urlId = 0,
                        this._ext = h,
                        this._urlId = d
                    }
                    clone() {
                        return new c(this._ext,this._urlId)
                    }
                    isEmpty() {
                        return this.underlineStyle === 0 && this._urlId === 0
                    }
                }
                a.ExtendedAttrs = c
            }
            ,
            9092: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Buffer = a.MAX_BUFFER_SIZE = void 0;
                const c = l(6349)
                  , u = l(7226)
                  , h = l(3734)
                  , d = l(8437)
                  , f = l(4634)
                  , g = l(511)
                  , _ = l(643)
                  , m = l(4863)
                  , p = l(7116);
                a.MAX_BUFFER_SIZE = 4294967295,
                a.Buffer = class {
                    constructor(b, y, x) {
                        this._hasScrollback = b,
                        this._optionsService = y,
                        this._bufferService = x,
                        this.ydisp = 0,
                        this.ybase = 0,
                        this.y = 0,
                        this.x = 0,
                        this.tabs = {},
                        this.savedY = 0,
                        this.savedX = 0,
                        this.savedCurAttrData = d.DEFAULT_ATTR_DATA.clone(),
                        this.savedCharset = p.DEFAULT_CHARSET,
                        this.markers = [],
                        this._nullCell = g.CellData.fromCharData([0, _.NULL_CELL_CHAR, _.NULL_CELL_WIDTH, _.NULL_CELL_CODE]),
                        this._whitespaceCell = g.CellData.fromCharData([0, _.WHITESPACE_CELL_CHAR, _.WHITESPACE_CELL_WIDTH, _.WHITESPACE_CELL_CODE]),
                        this._isClearing = !1,
                        this._memoryCleanupQueue = new u.IdleTaskQueue,
                        this._memoryCleanupPosition = 0,
                        this._cols = this._bufferService.cols,
                        this._rows = this._bufferService.rows,
                        this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)),
                        this.scrollTop = 0,
                        this.scrollBottom = this._rows - 1,
                        this.setupTabStops()
                    }
                    getNullCell(b) {
                        return b ? (this._nullCell.fg = b.fg,
                        this._nullCell.bg = b.bg,
                        this._nullCell.extended = b.extended) : (this._nullCell.fg = 0,
                        this._nullCell.bg = 0,
                        this._nullCell.extended = new h.ExtendedAttrs),
                        this._nullCell
                    }
                    getWhitespaceCell(b) {
                        return b ? (this._whitespaceCell.fg = b.fg,
                        this._whitespaceCell.bg = b.bg,
                        this._whitespaceCell.extended = b.extended) : (this._whitespaceCell.fg = 0,
                        this._whitespaceCell.bg = 0,
                        this._whitespaceCell.extended = new h.ExtendedAttrs),
                        this._whitespaceCell
                    }
                    getBlankLine(b, y) {
                        return new d.BufferLine(this._bufferService.cols,this.getNullCell(b),y)
                    }
                    get hasScrollback() {
                        return this._hasScrollback && this.lines.maxLength > this._rows
                    }
                    get isCursorInViewport() {
                        const b = this.ybase + this.y - this.ydisp;
                        return b >= 0 && b < this._rows
                    }
                    _getCorrectBufferLength(b) {
                        if (!this._hasScrollback)
                            return b;
                        const y = b + this._optionsService.rawOptions.scrollback;
                        return y > a.MAX_BUFFER_SIZE ? a.MAX_BUFFER_SIZE : y
                    }
                    fillViewportRows(b) {
                        if (this.lines.length === 0) {
                            b === void 0 && (b = d.DEFAULT_ATTR_DATA);
                            let y = this._rows;
                            for (; y--; )
                                this.lines.push(this.getBlankLine(b))
                        }
                    }
                    clear() {
                        this.ydisp = 0,
                        this.ybase = 0,
                        this.y = 0,
                        this.x = 0,
                        this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)),
                        this.scrollTop = 0,
                        this.scrollBottom = this._rows - 1,
                        this.setupTabStops()
                    }
                    resize(b, y) {
                        const x = this.getNullCell(d.DEFAULT_ATTR_DATA);
                        let E = 0;
                        const w = this._getCorrectBufferLength(y);
                        if (w > this.lines.maxLength && (this.lines.maxLength = w),
                        this.lines.length > 0) {
                            if (this._cols < b)
                                for (let C = 0; C < this.lines.length; C++)
                                    E += +this.lines.get(C).resize(b, x);
                            let A = 0;
                            if (this._rows < y)
                                for (let C = this._rows; C < y; C++)
                                    this.lines.length < y + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new d.BufferLine(b,x)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + A + 1 ? (this.ybase--,
                                    A++,
                                    this.ydisp > 0 && this.ydisp--) : this.lines.push(new d.BufferLine(b,x)));
                            else
                                for (let C = this._rows; C > y; C--)
                                    this.lines.length > y + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++,
                                    this.ydisp++));
                            if (w < this.lines.maxLength) {
                                const C = this.lines.length - w;
                                C > 0 && (this.lines.trimStart(C),
                                this.ybase = Math.max(this.ybase - C, 0),
                                this.ydisp = Math.max(this.ydisp - C, 0),
                                this.savedY = Math.max(this.savedY - C, 0)),
                                this.lines.maxLength = w
                            }
                            this.x = Math.min(this.x, b - 1),
                            this.y = Math.min(this.y, y - 1),
                            A && (this.y += A),
                            this.savedX = Math.min(this.savedX, b - 1),
                            this.scrollTop = 0
                        }
                        if (this.scrollBottom = y - 1,
                        this._isReflowEnabled && (this._reflow(b, y),
                        this._cols > b))
                            for (let A = 0; A < this.lines.length; A++)
                                E += +this.lines.get(A).resize(b, x);
                        this._cols = b,
                        this._rows = y,
                        this._memoryCleanupQueue.clear(),
                        E > .1 * this.lines.length && (this._memoryCleanupPosition = 0,
                        this._memoryCleanupQueue.enqueue( () => this._batchedMemoryCleanup()))
                    }
                    _batchedMemoryCleanup() {
                        let b = !0;
                        this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0,
                        b = !1);
                        let y = 0;
                        for (; this._memoryCleanupPosition < this.lines.length; )
                            if (y += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(),
                            y > 100)
                                return !0;
                        return b
                    }
                    get _isReflowEnabled() {
                        const b = this._optionsService.rawOptions.windowsPty;
                        return b && b.buildNumber ? this._hasScrollback && b.backend === "conpty" && b.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode
                    }
                    _reflow(b, y) {
                        this._cols !== b && (b > this._cols ? this._reflowLarger(b, y) : this._reflowSmaller(b, y))
                    }
                    _reflowLarger(b, y) {
                        const x = (0,
                        f.reflowLargerGetLinesToRemove)(this.lines, this._cols, b, this.ybase + this.y, this.getNullCell(d.DEFAULT_ATTR_DATA));
                        if (x.length > 0) {
                            const E = (0,
                            f.reflowLargerCreateNewLayout)(this.lines, x);
                            (0,
                            f.reflowLargerApplyNewLayout)(this.lines, E.layout),
                            this._reflowLargerAdjustViewport(b, y, E.countRemoved)
                        }
                    }
                    _reflowLargerAdjustViewport(b, y, x) {
                        const E = this.getNullCell(d.DEFAULT_ATTR_DATA);
                        let w = x;
                        for (; w-- > 0; )
                            this.ybase === 0 ? (this.y > 0 && this.y--,
                            this.lines.length < y && this.lines.push(new d.BufferLine(b,E))) : (this.ydisp === this.ybase && this.ydisp--,
                            this.ybase--);
                        this.savedY = Math.max(this.savedY - x, 0)
                    }
                    _reflowSmaller(b, y) {
                        const x = this.getNullCell(d.DEFAULT_ATTR_DATA)
                          , E = [];
                        let w = 0;
                        for (let A = this.lines.length - 1; A >= 0; A--) {
                            let C = this.lines.get(A);
                            if (!C || !C.isWrapped && C.getTrimmedLength() <= b)
                                continue;
                            const k = [C];
                            for (; C.isWrapped && A > 0; )
                                C = this.lines.get(--A),
                                k.unshift(C);
                            const I = this.ybase + this.y;
                            if (I >= A && I < A + k.length)
                                continue;
                            const N = k[k.length - 1].getTrimmedLength()
                              , O = (0,
                            f.reflowSmallerGetNewLineLengths)(k, this._cols, b)
                              , M = O.length - k.length;
                            let H;
                            H = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + M) : Math.max(0, this.lines.length - this.lines.maxLength + M);
                            const $ = [];
                            for (let z = 0; z < M; z++) {
                                const V = this.getBlankLine(d.DEFAULT_ATTR_DATA, !0);
                                $.push(V)
                            }
                            $.length > 0 && (E.push({
                                start: A + k.length + w,
                                newLines: $
                            }),
                            w += $.length),
                            k.push(...$);
                            let J = O.length - 1
                              , Q = O[J];
                            Q === 0 && (J--,
                            Q = O[J]);
                            let ee = k.length - M - 1
                              , D = N;
                            for (; ee >= 0; ) {
                                const z = Math.min(D, Q);
                                if (k[J] === void 0)
                                    break;
                                if (k[J].copyCellsFrom(k[ee], D - z, Q - z, z, !0),
                                Q -= z,
                                Q === 0 && (J--,
                                Q = O[J]),
                                D -= z,
                                D === 0) {
                                    ee--;
                                    const V = Math.max(ee, 0);
                                    D = (0,
                                    f.getWrappedLineTrimmedLength)(k, V, this._cols)
                                }
                            }
                            for (let z = 0; z < k.length; z++)
                                O[z] < b && k[z].setCell(O[z], x);
                            let L = M - H;
                            for (; L-- > 0; )
                                this.ybase === 0 ? this.y < y - 1 ? (this.y++,
                                this.lines.pop()) : (this.ybase++,
                                this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + w) - y && (this.ybase === this.ydisp && this.ydisp++,
                                this.ybase++);
                            this.savedY = Math.min(this.savedY + M, this.ybase + y - 1)
                        }
                        if (E.length > 0) {
                            const A = []
                              , C = [];
                            for (let J = 0; J < this.lines.length; J++)
                                C.push(this.lines.get(J));
                            const k = this.lines.length;
                            let I = k - 1
                              , N = 0
                              , O = E[N];
                            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + w);
                            let M = 0;
                            for (let J = Math.min(this.lines.maxLength - 1, k + w - 1); J >= 0; J--)
                                if (O && O.start > I + M) {
                                    for (let Q = O.newLines.length - 1; Q >= 0; Q--)
                                        this.lines.set(J--, O.newLines[Q]);
                                    J++,
                                    A.push({
                                        index: I + 1,
                                        amount: O.newLines.length
                                    }),
                                    M += O.newLines.length,
                                    O = E[++N]
                                } else
                                    this.lines.set(J, C[I--]);
                            let H = 0;
                            for (let J = A.length - 1; J >= 0; J--)
                                A[J].index += H,
                                this.lines.onInsertEmitter.fire(A[J]),
                                H += A[J].amount;
                            const $ = Math.max(0, k + w - this.lines.maxLength);
                            $ > 0 && this.lines.onTrimEmitter.fire($)
                        }
                    }
                    translateBufferLineToString(b, y, x=0, E) {
                        const w = this.lines.get(b);
                        return w ? w.translateToString(y, x, E) : ""
                    }
                    getWrappedRangeForLine(b) {
                        let y = b
                          , x = b;
                        for (; y > 0 && this.lines.get(y).isWrapped; )
                            y--;
                        for (; x + 1 < this.lines.length && this.lines.get(x + 1).isWrapped; )
                            x++;
                        return {
                            first: y,
                            last: x
                        }
                    }
                    setupTabStops(b) {
                        for (b != null ? this.tabs[b] || (b = this.prevStop(b)) : (this.tabs = {},
                        b = 0); b < this._cols; b += this._optionsService.rawOptions.tabStopWidth)
                            this.tabs[b] = !0
                    }
                    prevStop(b) {
                        for (b == null && (b = this.x); !this.tabs[--b] && b > 0; )
                            ;
                        return b >= this._cols ? this._cols - 1 : b < 0 ? 0 : b
                    }
                    nextStop(b) {
                        for (b == null && (b = this.x); !this.tabs[++b] && b < this._cols; )
                            ;
                        return b >= this._cols ? this._cols - 1 : b < 0 ? 0 : b
                    }
                    clearMarkers(b) {
                        this._isClearing = !0;
                        for (let y = 0; y < this.markers.length; y++)
                            this.markers[y].line === b && (this.markers[y].dispose(),
                            this.markers.splice(y--, 1));
                        this._isClearing = !1
                    }
                    clearAllMarkers() {
                        this._isClearing = !0;
                        for (let b = 0; b < this.markers.length; b++)
                            this.markers[b].dispose(),
                            this.markers.splice(b--, 1);
                        this._isClearing = !1
                    }
                    addMarker(b) {
                        const y = new m.Marker(b);
                        return this.markers.push(y),
                        y.register(this.lines.onTrim(x => {
                            y.line -= x,
                            y.line < 0 && y.dispose()
                        }
                        )),
                        y.register(this.lines.onInsert(x => {
                            y.line >= x.index && (y.line += x.amount)
                        }
                        )),
                        y.register(this.lines.onDelete(x => {
                            y.line >= x.index && y.line < x.index + x.amount && y.dispose(),
                            y.line > x.index && (y.line -= x.amount)
                        }
                        )),
                        y.register(y.onDispose( () => this._removeMarker(y))),
                        y
                    }
                    _removeMarker(b) {
                        this._isClearing || this.markers.splice(this.markers.indexOf(b), 1)
                    }
                }
            }
            ,
            8437: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferLine = a.DEFAULT_ATTR_DATA = void 0;
                const c = l(3734)
                  , u = l(511)
                  , h = l(643)
                  , d = l(482);
                a.DEFAULT_ATTR_DATA = Object.freeze(new c.AttributeData);
                let f = 0;
                class g {
                    constructor(m, p, b=!1) {
                        this.isWrapped = b,
                        this._combined = {},
                        this._extendedAttrs = {},
                        this._data = new Uint32Array(3 * m);
                        const y = p || u.CellData.fromCharData([0, h.NULL_CELL_CHAR, h.NULL_CELL_WIDTH, h.NULL_CELL_CODE]);
                        for (let x = 0; x < m; ++x)
                            this.setCell(x, y);
                        this.length = m
                    }
                    get(m) {
                        const p = this._data[3 * m + 0]
                          , b = 2097151 & p;
                        return [this._data[3 * m + 1], 2097152 & p ? this._combined[m] : b ? (0,
                        d.stringFromCodePoint)(b) : "", p >> 22, 2097152 & p ? this._combined[m].charCodeAt(this._combined[m].length - 1) : b]
                    }
                    set(m, p) {
                        this._data[3 * m + 1] = p[h.CHAR_DATA_ATTR_INDEX],
                        p[h.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[m] = p[1],
                        this._data[3 * m + 0] = 2097152 | m | p[h.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * m + 0] = p[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | p[h.CHAR_DATA_WIDTH_INDEX] << 22
                    }
                    getWidth(m) {
                        return this._data[3 * m + 0] >> 22
                    }
                    hasWidth(m) {
                        return 12582912 & this._data[3 * m + 0]
                    }
                    getFg(m) {
                        return this._data[3 * m + 1]
                    }
                    getBg(m) {
                        return this._data[3 * m + 2]
                    }
                    hasContent(m) {
                        return 4194303 & this._data[3 * m + 0]
                    }
                    getCodePoint(m) {
                        const p = this._data[3 * m + 0];
                        return 2097152 & p ? this._combined[m].charCodeAt(this._combined[m].length - 1) : 2097151 & p
                    }
                    isCombined(m) {
                        return 2097152 & this._data[3 * m + 0]
                    }
                    getString(m) {
                        const p = this._data[3 * m + 0];
                        return 2097152 & p ? this._combined[m] : 2097151 & p ? (0,
                        d.stringFromCodePoint)(2097151 & p) : ""
                    }
                    isProtected(m) {
                        return 536870912 & this._data[3 * m + 2]
                    }
                    loadCell(m, p) {
                        return f = 3 * m,
                        p.content = this._data[f + 0],
                        p.fg = this._data[f + 1],
                        p.bg = this._data[f + 2],
                        2097152 & p.content && (p.combinedData = this._combined[m]),
                        268435456 & p.bg && (p.extended = this._extendedAttrs[m]),
                        p
                    }
                    setCell(m, p) {
                        2097152 & p.content && (this._combined[m] = p.combinedData),
                        268435456 & p.bg && (this._extendedAttrs[m] = p.extended),
                        this._data[3 * m + 0] = p.content,
                        this._data[3 * m + 1] = p.fg,
                        this._data[3 * m + 2] = p.bg
                    }
                    setCellFromCodepoint(m, p, b, y) {
                        268435456 & y.bg && (this._extendedAttrs[m] = y.extended),
                        this._data[3 * m + 0] = p | b << 22,
                        this._data[3 * m + 1] = y.fg,
                        this._data[3 * m + 2] = y.bg
                    }
                    addCodepointToCell(m, p, b) {
                        let y = this._data[3 * m + 0];
                        2097152 & y ? this._combined[m] += (0,
                        d.stringFromCodePoint)(p) : 2097151 & y ? (this._combined[m] = (0,
                        d.stringFromCodePoint)(2097151 & y) + (0,
                        d.stringFromCodePoint)(p),
                        y &= -2097152,
                        y |= 2097152) : y = p | 4194304,
                        b && (y &= -12582913,
                        y |= b << 22),
                        this._data[3 * m + 0] = y
                    }
                    insertCells(m, p, b) {
                        if ((m %= this.length) && this.getWidth(m - 1) === 2 && this.setCellFromCodepoint(m - 1, 0, 1, b),
                        p < this.length - m) {
                            const y = new u.CellData;
                            for (let x = this.length - m - p - 1; x >= 0; --x)
                                this.setCell(m + p + x, this.loadCell(m + x, y));
                            for (let x = 0; x < p; ++x)
                                this.setCell(m + x, b)
                        } else
                            for (let y = m; y < this.length; ++y)
                                this.setCell(y, b);
                        this.getWidth(this.length - 1) === 2 && this.setCellFromCodepoint(this.length - 1, 0, 1, b)
                    }
                    deleteCells(m, p, b) {
                        if (m %= this.length,
                        p < this.length - m) {
                            const y = new u.CellData;
                            for (let x = 0; x < this.length - m - p; ++x)
                                this.setCell(m + x, this.loadCell(m + p + x, y));
                            for (let x = this.length - p; x < this.length; ++x)
                                this.setCell(x, b)
                        } else
                            for (let y = m; y < this.length; ++y)
                                this.setCell(y, b);
                        m && this.getWidth(m - 1) === 2 && this.setCellFromCodepoint(m - 1, 0, 1, b),
                        this.getWidth(m) !== 0 || this.hasContent(m) || this.setCellFromCodepoint(m, 0, 1, b)
                    }
                    replaceCells(m, p, b, y=!1) {
                        if (y)
                            for (m && this.getWidth(m - 1) === 2 && !this.isProtected(m - 1) && this.setCellFromCodepoint(m - 1, 0, 1, b),
                            p < this.length && this.getWidth(p - 1) === 2 && !this.isProtected(p) && this.setCellFromCodepoint(p, 0, 1, b); m < p && m < this.length; )
                                this.isProtected(m) || this.setCell(m, b),
                                m++;
                        else
                            for (m && this.getWidth(m - 1) === 2 && this.setCellFromCodepoint(m - 1, 0, 1, b),
                            p < this.length && this.getWidth(p - 1) === 2 && this.setCellFromCodepoint(p, 0, 1, b); m < p && m < this.length; )
                                this.setCell(m++, b)
                    }
                    resize(m, p) {
                        if (m === this.length)
                            return 4 * this._data.length * 2 < this._data.buffer.byteLength;
                        const b = 3 * m;
                        if (m > this.length) {
                            if (this._data.buffer.byteLength >= 4 * b)
                                this._data = new Uint32Array(this._data.buffer,0,b);
                            else {
                                const y = new Uint32Array(b);
                                y.set(this._data),
                                this._data = y
                            }
                            for (let y = this.length; y < m; ++y)
                                this.setCell(y, p)
                        } else {
                            this._data = this._data.subarray(0, b);
                            const y = Object.keys(this._combined);
                            for (let E = 0; E < y.length; E++) {
                                const w = parseInt(y[E], 10);
                                w >= m && delete this._combined[w]
                            }
                            const x = Object.keys(this._extendedAttrs);
                            for (let E = 0; E < x.length; E++) {
                                const w = parseInt(x[E], 10);
                                w >= m && delete this._extendedAttrs[w]
                            }
                        }
                        return this.length = m,
                        4 * b * 2 < this._data.buffer.byteLength
                    }
                    cleanupMemory() {
                        if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
                            const m = new Uint32Array(this._data.length);
                            return m.set(this._data),
                            this._data = m,
                            1
                        }
                        return 0
                    }
                    fill(m, p=!1) {
                        if (p)
                            for (let b = 0; b < this.length; ++b)
                                this.isProtected(b) || this.setCell(b, m);
                        else {
                            this._combined = {},
                            this._extendedAttrs = {};
                            for (let b = 0; b < this.length; ++b)
                                this.setCell(b, m)
                        }
                    }
                    copyFrom(m) {
                        this.length !== m.length ? this._data = new Uint32Array(m._data) : this._data.set(m._data),
                        this.length = m.length,
                        this._combined = {};
                        for (const p in m._combined)
                            this._combined[p] = m._combined[p];
                        this._extendedAttrs = {};
                        for (const p in m._extendedAttrs)
                            this._extendedAttrs[p] = m._extendedAttrs[p];
                        this.isWrapped = m.isWrapped
                    }
                    clone() {
                        const m = new g(0);
                        m._data = new Uint32Array(this._data),
                        m.length = this.length;
                        for (const p in this._combined)
                            m._combined[p] = this._combined[p];
                        for (const p in this._extendedAttrs)
                            m._extendedAttrs[p] = this._extendedAttrs[p];
                        return m.isWrapped = this.isWrapped,
                        m
                    }
                    getTrimmedLength() {
                        for (let m = this.length - 1; m >= 0; --m)
                            if (4194303 & this._data[3 * m + 0])
                                return m + (this._data[3 * m + 0] >> 22);
                        return 0
                    }
                    getNoBgTrimmedLength() {
                        for (let m = this.length - 1; m >= 0; --m)
                            if (4194303 & this._data[3 * m + 0] || 50331648 & this._data[3 * m + 2])
                                return m + (this._data[3 * m + 0] >> 22);
                        return 0
                    }
                    copyCellsFrom(m, p, b, y, x) {
                        const E = m._data;
                        if (x)
                            for (let A = y - 1; A >= 0; A--) {
                                for (let C = 0; C < 3; C++)
                                    this._data[3 * (b + A) + C] = E[3 * (p + A) + C];
                                268435456 & E[3 * (p + A) + 2] && (this._extendedAttrs[b + A] = m._extendedAttrs[p + A])
                            }
                        else
                            for (let A = 0; A < y; A++) {
                                for (let C = 0; C < 3; C++)
                                    this._data[3 * (b + A) + C] = E[3 * (p + A) + C];
                                268435456 & E[3 * (p + A) + 2] && (this._extendedAttrs[b + A] = m._extendedAttrs[p + A])
                            }
                        const w = Object.keys(m._combined);
                        for (let A = 0; A < w.length; A++) {
                            const C = parseInt(w[A], 10);
                            C >= p && (this._combined[C - p + b] = m._combined[C])
                        }
                    }
                    translateToString(m, p, b, y) {
                        p = p ?? 0,
                        b = b ?? this.length,
                        m && (b = Math.min(b, this.getTrimmedLength())),
                        y && (y.length = 0);
                        let x = "";
                        for (; p < b; ) {
                            const E = this._data[3 * p + 0]
                              , w = 2097151 & E
                              , A = 2097152 & E ? this._combined[p] : w ? (0,
                            d.stringFromCodePoint)(w) : h.WHITESPACE_CELL_CHAR;
                            if (x += A,
                            y)
                                for (let C = 0; C < A.length; ++C)
                                    y.push(p);
                            p += E >> 22 || 1
                        }
                        return y && y.push(p),
                        x
                    }
                }
                a.BufferLine = g
            }
            ,
            4841: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.getRangeLength = void 0,
                a.getRangeLength = function(l, c) {
                    if (l.start.y > l.end.y)
                        throw new Error(`Buffer range end (${l.end.x}, ${l.end.y}) cannot be before start (${l.start.x}, ${l.start.y})`);
                    return c * (l.end.y - l.start.y) + (l.end.x - l.start.x + 1)
                }
            }
            ,
            4634: (o, a) => {
                function l(c, u, h) {
                    if (u === c.length - 1)
                        return c[u].getTrimmedLength();
                    const d = !c[u].hasContent(h - 1) && c[u].getWidth(h - 1) === 1
                      , f = c[u + 1].getWidth(0) === 2;
                    return d && f ? h - 1 : h
                }
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.getWrappedLineTrimmedLength = a.reflowSmallerGetNewLineLengths = a.reflowLargerApplyNewLayout = a.reflowLargerCreateNewLayout = a.reflowLargerGetLinesToRemove = void 0,
                a.reflowLargerGetLinesToRemove = function(c, u, h, d, f) {
                    const g = [];
                    for (let _ = 0; _ < c.length - 1; _++) {
                        let m = _
                          , p = c.get(++m);
                        if (!p.isWrapped)
                            continue;
                        const b = [c.get(_)];
                        for (; m < c.length && p.isWrapped; )
                            b.push(p),
                            p = c.get(++m);
                        if (d >= _ && d < m) {
                            _ += b.length - 1;
                            continue
                        }
                        let y = 0
                          , x = l(b, y, u)
                          , E = 1
                          , w = 0;
                        for (; E < b.length; ) {
                            const C = l(b, E, u)
                              , k = C - w
                              , I = h - x
                              , N = Math.min(k, I);
                            b[y].copyCellsFrom(b[E], w, x, N, !1),
                            x += N,
                            x === h && (y++,
                            x = 0),
                            w += N,
                            w === C && (E++,
                            w = 0),
                            x === 0 && y !== 0 && b[y - 1].getWidth(h - 1) === 2 && (b[y].copyCellsFrom(b[y - 1], h - 1, x++, 1, !1),
                            b[y - 1].setCell(h - 1, f))
                        }
                        b[y].replaceCells(x, h, f);
                        let A = 0;
                        for (let C = b.length - 1; C > 0 && (C > y || b[C].getTrimmedLength() === 0); C--)
                            A++;
                        A > 0 && (g.push(_ + b.length - A),
                        g.push(A)),
                        _ += b.length - 1
                    }
                    return g
                }
                ,
                a.reflowLargerCreateNewLayout = function(c, u) {
                    const h = [];
                    let d = 0
                      , f = u[d]
                      , g = 0;
                    for (let _ = 0; _ < c.length; _++)
                        if (f === _) {
                            const m = u[++d];
                            c.onDeleteEmitter.fire({
                                index: _ - g,
                                amount: m
                            }),
                            _ += m - 1,
                            g += m,
                            f = u[++d]
                        } else
                            h.push(_);
                    return {
                        layout: h,
                        countRemoved: g
                    }
                }
                ,
                a.reflowLargerApplyNewLayout = function(c, u) {
                    const h = [];
                    for (let d = 0; d < u.length; d++)
                        h.push(c.get(u[d]));
                    for (let d = 0; d < h.length; d++)
                        c.set(d, h[d]);
                    c.length = u.length
                }
                ,
                a.reflowSmallerGetNewLineLengths = function(c, u, h) {
                    const d = []
                      , f = c.map( (p, b) => l(c, b, u)).reduce( (p, b) => p + b);
                    let g = 0
                      , _ = 0
                      , m = 0;
                    for (; m < f; ) {
                        if (f - m < h) {
                            d.push(f - m);
                            break
                        }
                        g += h;
                        const p = l(c, _, u);
                        g > p && (g -= p,
                        _++);
                        const b = c[_].getWidth(g - 1) === 2;
                        b && g--;
                        const y = b ? h - 1 : h;
                        d.push(y),
                        m += y
                    }
                    return d
                }
                ,
                a.getWrappedLineTrimmedLength = l
            }
            ,
            5295: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferSet = void 0;
                const c = l(8460)
                  , u = l(844)
                  , h = l(9092);
                class d extends u.Disposable {
                    constructor(g, _) {
                        super(),
                        this._optionsService = g,
                        this._bufferService = _,
                        this._onBufferActivate = this.register(new c.EventEmitter),
                        this.onBufferActivate = this._onBufferActivate.event,
                        this.reset(),
                        this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))),
                        this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()))
                    }
                    reset() {
                        this._normal = new h.Buffer(!0,this._optionsService,this._bufferService),
                        this._normal.fillViewportRows(),
                        this._alt = new h.Buffer(!1,this._optionsService,this._bufferService),
                        this._activeBuffer = this._normal,
                        this._onBufferActivate.fire({
                            activeBuffer: this._normal,
                            inactiveBuffer: this._alt
                        }),
                        this.setupTabStops()
                    }
                    get alt() {
                        return this._alt
                    }
                    get active() {
                        return this._activeBuffer
                    }
                    get normal() {
                        return this._normal
                    }
                    activateNormalBuffer() {
                        this._activeBuffer !== this._normal && (this._normal.x = this._alt.x,
                        this._normal.y = this._alt.y,
                        this._alt.clearAllMarkers(),
                        this._alt.clear(),
                        this._activeBuffer = this._normal,
                        this._onBufferActivate.fire({
                            activeBuffer: this._normal,
                            inactiveBuffer: this._alt
                        }))
                    }
                    activateAltBuffer(g) {
                        this._activeBuffer !== this._alt && (this._alt.fillViewportRows(g),
                        this._alt.x = this._normal.x,
                        this._alt.y = this._normal.y,
                        this._activeBuffer = this._alt,
                        this._onBufferActivate.fire({
                            activeBuffer: this._alt,
                            inactiveBuffer: this._normal
                        }))
                    }
                    resize(g, _) {
                        this._normal.resize(g, _),
                        this._alt.resize(g, _),
                        this.setupTabStops(g)
                    }
                    setupTabStops(g) {
                        this._normal.setupTabStops(g),
                        this._alt.setupTabStops(g)
                    }
                }
                a.BufferSet = d
            }
            ,
            511: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CellData = void 0;
                const c = l(482)
                  , u = l(643)
                  , h = l(3734);
                class d extends h.AttributeData {
                    constructor() {
                        super(...arguments),
                        this.content = 0,
                        this.fg = 0,
                        this.bg = 0,
                        this.extended = new h.ExtendedAttrs,
                        this.combinedData = ""
                    }
                    static fromCharData(g) {
                        const _ = new d;
                        return _.setFromCharData(g),
                        _
                    }
                    isCombined() {
                        return 2097152 & this.content
                    }
                    getWidth() {
                        return this.content >> 22
                    }
                    getChars() {
                        return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0,
                        c.stringFromCodePoint)(2097151 & this.content) : ""
                    }
                    getCode() {
                        return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content
                    }
                    setFromCharData(g) {
                        this.fg = g[u.CHAR_DATA_ATTR_INDEX],
                        this.bg = 0;
                        let _ = !1;
                        if (g[u.CHAR_DATA_CHAR_INDEX].length > 2)
                            _ = !0;
                        else if (g[u.CHAR_DATA_CHAR_INDEX].length === 2) {
                            const m = g[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                            if (55296 <= m && m <= 56319) {
                                const p = g[u.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                                56320 <= p && p <= 57343 ? this.content = 1024 * (m - 55296) + p - 56320 + 65536 | g[u.CHAR_DATA_WIDTH_INDEX] << 22 : _ = !0
                            } else
                                _ = !0
                        } else
                            this.content = g[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | g[u.CHAR_DATA_WIDTH_INDEX] << 22;
                        _ && (this.combinedData = g[u.CHAR_DATA_CHAR_INDEX],
                        this.content = 2097152 | g[u.CHAR_DATA_WIDTH_INDEX] << 22)
                    }
                    getAsCharData() {
                        return [this.fg, this.getChars(), this.getWidth(), this.getCode()]
                    }
                }
                a.CellData = d
            }
            ,
            643: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.WHITESPACE_CELL_CODE = a.WHITESPACE_CELL_WIDTH = a.WHITESPACE_CELL_CHAR = a.NULL_CELL_CODE = a.NULL_CELL_WIDTH = a.NULL_CELL_CHAR = a.CHAR_DATA_CODE_INDEX = a.CHAR_DATA_WIDTH_INDEX = a.CHAR_DATA_CHAR_INDEX = a.CHAR_DATA_ATTR_INDEX = a.DEFAULT_EXT = a.DEFAULT_ATTR = a.DEFAULT_COLOR = void 0,
                a.DEFAULT_COLOR = 0,
                a.DEFAULT_ATTR = 256 | a.DEFAULT_COLOR << 9,
                a.DEFAULT_EXT = 0,
                a.CHAR_DATA_ATTR_INDEX = 0,
                a.CHAR_DATA_CHAR_INDEX = 1,
                a.CHAR_DATA_WIDTH_INDEX = 2,
                a.CHAR_DATA_CODE_INDEX = 3,
                a.NULL_CELL_CHAR = "",
                a.NULL_CELL_WIDTH = 1,
                a.NULL_CELL_CODE = 0,
                a.WHITESPACE_CELL_CHAR = " ",
                a.WHITESPACE_CELL_WIDTH = 1,
                a.WHITESPACE_CELL_CODE = 32
            }
            ,
            4863: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Marker = void 0;
                const c = l(8460)
                  , u = l(844);
                class h {
                    get id() {
                        return this._id
                    }
                    constructor(f) {
                        this.line = f,
                        this.isDisposed = !1,
                        this._disposables = [],
                        this._id = h._nextId++,
                        this._onDispose = this.register(new c.EventEmitter),
                        this.onDispose = this._onDispose.event
                    }
                    dispose() {
                        this.isDisposed || (this.isDisposed = !0,
                        this.line = -1,
                        this._onDispose.fire(),
                        (0,
                        u.disposeArray)(this._disposables),
                        this._disposables.length = 0)
                    }
                    register(f) {
                        return this._disposables.push(f),
                        f
                    }
                }
                a.Marker = h,
                h._nextId = 1
            }
            ,
            7116: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.DEFAULT_CHARSET = a.CHARSETS = void 0,
                a.CHARSETS = {},
                a.DEFAULT_CHARSET = a.CHARSETS.B,
                a.CHARSETS[0] = {
                    "`": "",
                    a: "",
                    b: "",
                    c: "",
                    d: "",
                    e: "",
                    f: "",
                    g: "",
                    h: "",
                    i: "",
                    j: "",
                    k: "",
                    l: "",
                    m: "",
                    n: "",
                    o: "",
                    p: "",
                    q: "",
                    r: "",
                    s: "",
                    t: "",
                    u: "",
                    v: "",
                    w: "",
                    x: "",
                    y: "",
                    z: "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.A = {
                    "#": ""
                },
                a.CHARSETS.B = void 0,
                a.CHARSETS[4] = {
                    "#": "",
                    "@": "",
                    "[": "ij",
                    "\\": "",
                    "]": "|",
                    "{": "",
                    "|": "f",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.C = a.CHARSETS[5] = {
                    "[": "",
                    "\\": "",
                    "]": "",
                    "^": "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.R = {
                    "#": "",
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.Q = {
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "^": "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.K = {
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.Y = {
                    "#": "",
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.E = a.CHARSETS[6] = {
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "^": "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS.Z = {
                    "#": "",
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "{": "",
                    "|": "",
                    "}": ""
                },
                a.CHARSETS.H = a.CHARSETS[7] = {
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "^": "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                },
                a.CHARSETS["="] = {
                    "#": "",
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "^": "",
                    _: "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": ""
                }
            }
            ,
            2584: (o, a) => {
                var l, c, u;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.C1_ESCAPED = a.C1 = a.C0 = void 0,
                function(h) {
                    h.NUL = "\0",
                    h.SOH = "",
                    h.STX = "",
                    h.ETX = "",
                    h.EOT = "",
                    h.ENQ = "",
                    h.ACK = "",
                    h.BEL = "\x07",
                    h.BS = "\b",
                    h.HT = "	",
                    h.LF = `
`,
                    h.VT = "\v",
                    h.FF = "\f",
                    h.CR = "\r",
                    h.SO = "",
                    h.SI = "",
                    h.DLE = "",
                    h.DC1 = "",
                    h.DC2 = "",
                    h.DC3 = "",
                    h.DC4 = "",
                    h.NAK = "",
                    h.SYN = "",
                    h.ETB = "",
                    h.CAN = "",
                    h.EM = "",
                    h.SUB = "",
                    h.ESC = "\x1B",
                    h.FS = "",
                    h.GS = "",
                    h.RS = "",
                    h.US = "",
                    h.SP = " ",
                    h.DEL = ""
                }(l || (a.C0 = l = {})),
                function(h) {
                    h.PAD = "",
                    h.HOP = "",
                    h.BPH = "",
                    h.NBH = "",
                    h.IND = "",
                    h.NEL = "",
                    h.SSA = "",
                    h.ESA = "",
                    h.HTS = "",
                    h.HTJ = "",
                    h.VTS = "",
                    h.PLD = "",
                    h.PLU = "",
                    h.RI = "",
                    h.SS2 = "",
                    h.SS3 = "",
                    h.DCS = "",
                    h.PU1 = "",
                    h.PU2 = "",
                    h.STS = "",
                    h.CCH = "",
                    h.MW = "",
                    h.SPA = "",
                    h.EPA = "",
                    h.SOS = "",
                    h.SGCI = "",
                    h.SCI = "",
                    h.CSI = "",
                    h.ST = "",
                    h.OSC = "",
                    h.PM = "",
                    h.APC = ""
                }(c || (a.C1 = c = {})),
                function(h) {
                    h.ST = `${l.ESC}\\`
                }(u || (a.C1_ESCAPED = u = {}))
            }
            ,
            7399: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.evaluateKeyboardEvent = void 0;
                const c = l(2584)
                  , u = {
                    48: ["0", ")"],
                    49: ["1", "!"],
                    50: ["2", "@"],
                    51: ["3", "#"],
                    52: ["4", "$"],
                    53: ["5", "%"],
                    54: ["6", "^"],
                    55: ["7", "&"],
                    56: ["8", "*"],
                    57: ["9", "("],
                    186: [";", ":"],
                    187: ["=", "+"],
                    188: [",", "<"],
                    189: ["-", "_"],
                    190: [".", ">"],
                    191: ["/", "?"],
                    192: ["`", "~"],
                    219: ["[", "{"],
                    220: ["\\", "|"],
                    221: ["]", "}"],
                    222: ["'", '"']
                };
                a.evaluateKeyboardEvent = function(h, d, f, g) {
                    const _ = {
                        type: 0,
                        cancel: !1,
                        key: void 0
                    }
                      , m = (h.shiftKey ? 1 : 0) | (h.altKey ? 2 : 0) | (h.ctrlKey ? 4 : 0) | (h.metaKey ? 8 : 0);
                    switch (h.keyCode) {
                    case 0:
                        h.key === "UIKeyInputUpArrow" ? _.key = d ? c.C0.ESC + "OA" : c.C0.ESC + "[A" : h.key === "UIKeyInputLeftArrow" ? _.key = d ? c.C0.ESC + "OD" : c.C0.ESC + "[D" : h.key === "UIKeyInputRightArrow" ? _.key = d ? c.C0.ESC + "OC" : c.C0.ESC + "[C" : h.key === "UIKeyInputDownArrow" && (_.key = d ? c.C0.ESC + "OB" : c.C0.ESC + "[B");
                        break;
                    case 8:
                        _.key = h.ctrlKey ? "\b" : c.C0.DEL,
                        h.altKey && (_.key = c.C0.ESC + _.key);
                        break;
                    case 9:
                        if (h.shiftKey) {
                            _.key = c.C0.ESC + "[Z";
                            break
                        }
                        _.key = c.C0.HT,
                        _.cancel = !0;
                        break;
                    case 13:
                        _.key = h.altKey ? c.C0.ESC + c.C0.CR : c.C0.CR,
                        _.cancel = !0;
                        break;
                    case 27:
                        _.key = c.C0.ESC,
                        h.altKey && (_.key = c.C0.ESC + c.C0.ESC),
                        _.cancel = !0;
                        break;
                    case 37:
                        if (h.metaKey)
                            break;
                        m ? (_.key = c.C0.ESC + "[1;" + (m + 1) + "D",
                        _.key === c.C0.ESC + "[1;3D" && (_.key = c.C0.ESC + (f ? "b" : "[1;5D"))) : _.key = d ? c.C0.ESC + "OD" : c.C0.ESC + "[D";
                        break;
                    case 39:
                        if (h.metaKey)
                            break;
                        m ? (_.key = c.C0.ESC + "[1;" + (m + 1) + "C",
                        _.key === c.C0.ESC + "[1;3C" && (_.key = c.C0.ESC + (f ? "f" : "[1;5C"))) : _.key = d ? c.C0.ESC + "OC" : c.C0.ESC + "[C";
                        break;
                    case 38:
                        if (h.metaKey)
                            break;
                        m ? (_.key = c.C0.ESC + "[1;" + (m + 1) + "A",
                        f || _.key !== c.C0.ESC + "[1;3A" || (_.key = c.C0.ESC + "[1;5A")) : _.key = d ? c.C0.ESC + "OA" : c.C0.ESC + "[A";
                        break;
                    case 40:
                        if (h.metaKey)
                            break;
                        m ? (_.key = c.C0.ESC + "[1;" + (m + 1) + "B",
                        f || _.key !== c.C0.ESC + "[1;3B" || (_.key = c.C0.ESC + "[1;5B")) : _.key = d ? c.C0.ESC + "OB" : c.C0.ESC + "[B";
                        break;
                    case 45:
                        h.shiftKey || h.ctrlKey || (_.key = c.C0.ESC + "[2~");
                        break;
                    case 46:
                        _.key = m ? c.C0.ESC + "[3;" + (m + 1) + "~" : c.C0.ESC + "[3~";
                        break;
                    case 36:
                        _.key = m ? c.C0.ESC + "[1;" + (m + 1) + "H" : d ? c.C0.ESC + "OH" : c.C0.ESC + "[H";
                        break;
                    case 35:
                        _.key = m ? c.C0.ESC + "[1;" + (m + 1) + "F" : d ? c.C0.ESC + "OF" : c.C0.ESC + "[F";
                        break;
                    case 33:
                        h.shiftKey ? _.type = 2 : h.ctrlKey ? _.key = c.C0.ESC + "[5;" + (m + 1) + "~" : _.key = c.C0.ESC + "[5~";
                        break;
                    case 34:
                        h.shiftKey ? _.type = 3 : h.ctrlKey ? _.key = c.C0.ESC + "[6;" + (m + 1) + "~" : _.key = c.C0.ESC + "[6~";
                        break;
                    case 112:
                        _.key = m ? c.C0.ESC + "[1;" + (m + 1) + "P" : c.C0.ESC + "OP";
                        break;
                    case 113:
                        _.key = m ? c.C0.ESC + "[1;" + (m + 1) + "Q" : c.C0.ESC + "OQ";
                        break;
                    case 114:
                        _.key = m ? c.C0.ESC + "[1;" + (m + 1) + "R" : c.C0.ESC + "OR";
                        break;
                    case 115:
                        _.key = m ? c.C0.ESC + "[1;" + (m + 1) + "S" : c.C0.ESC + "OS";
                        break;
                    case 116:
                        _.key = m ? c.C0.ESC + "[15;" + (m + 1) + "~" : c.C0.ESC + "[15~";
                        break;
                    case 117:
                        _.key = m ? c.C0.ESC + "[17;" + (m + 1) + "~" : c.C0.ESC + "[17~";
                        break;
                    case 118:
                        _.key = m ? c.C0.ESC + "[18;" + (m + 1) + "~" : c.C0.ESC + "[18~";
                        break;
                    case 119:
                        _.key = m ? c.C0.ESC + "[19;" + (m + 1) + "~" : c.C0.ESC + "[19~";
                        break;
                    case 120:
                        _.key = m ? c.C0.ESC + "[20;" + (m + 1) + "~" : c.C0.ESC + "[20~";
                        break;
                    case 121:
                        _.key = m ? c.C0.ESC + "[21;" + (m + 1) + "~" : c.C0.ESC + "[21~";
                        break;
                    case 122:
                        _.key = m ? c.C0.ESC + "[23;" + (m + 1) + "~" : c.C0.ESC + "[23~";
                        break;
                    case 123:
                        _.key = m ? c.C0.ESC + "[24;" + (m + 1) + "~" : c.C0.ESC + "[24~";
                        break;
                    default:
                        if (!h.ctrlKey || h.shiftKey || h.altKey || h.metaKey)
                            if (f && !g || !h.altKey || h.metaKey)
                                !f || h.altKey || h.ctrlKey || h.shiftKey || !h.metaKey ? h.key && !h.ctrlKey && !h.altKey && !h.metaKey && h.keyCode >= 48 && h.key.length === 1 ? _.key = h.key : h.key && h.ctrlKey && (h.key === "_" && (_.key = c.C0.US),
                                h.key === "@" && (_.key = c.C0.NUL)) : h.keyCode === 65 && (_.type = 1);
                            else {
                                const p = u[h.keyCode]
                                  , b = p?.[h.shiftKey ? 1 : 0];
                                if (b)
                                    _.key = c.C0.ESC + b;
                                else if (h.keyCode >= 65 && h.keyCode <= 90) {
                                    const y = h.ctrlKey ? h.keyCode - 64 : h.keyCode + 32;
                                    let x = String.fromCharCode(y);
                                    h.shiftKey && (x = x.toUpperCase()),
                                    _.key = c.C0.ESC + x
                                } else if (h.keyCode === 32)
                                    _.key = c.C0.ESC + (h.ctrlKey ? c.C0.NUL : " ");
                                else if (h.key === "Dead" && h.code.startsWith("Key")) {
                                    let y = h.code.slice(3, 4);
                                    h.shiftKey || (y = y.toLowerCase()),
                                    _.key = c.C0.ESC + y,
                                    _.cancel = !0
                                }
                            }
                        else
                            h.keyCode >= 65 && h.keyCode <= 90 ? _.key = String.fromCharCode(h.keyCode - 64) : h.keyCode === 32 ? _.key = c.C0.NUL : h.keyCode >= 51 && h.keyCode <= 55 ? _.key = String.fromCharCode(h.keyCode - 51 + 27) : h.keyCode === 56 ? _.key = c.C0.DEL : h.keyCode === 219 ? _.key = c.C0.ESC : h.keyCode === 220 ? _.key = c.C0.FS : h.keyCode === 221 && (_.key = c.C0.GS)
                    }
                    return _
                }
            }
            ,
            482: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Utf8ToUtf32 = a.StringToUtf32 = a.utf32ToString = a.stringFromCodePoint = void 0,
                a.stringFromCodePoint = function(l) {
                    return l > 65535 ? (l -= 65536,
                    String.fromCharCode(55296 + (l >> 10)) + String.fromCharCode(l % 1024 + 56320)) : String.fromCharCode(l)
                }
                ,
                a.utf32ToString = function(l, c=0, u=l.length) {
                    let h = "";
                    for (let d = c; d < u; ++d) {
                        let f = l[d];
                        f > 65535 ? (f -= 65536,
                        h += String.fromCharCode(55296 + (f >> 10)) + String.fromCharCode(f % 1024 + 56320)) : h += String.fromCharCode(f)
                    }
                    return h
                }
                ,
                a.StringToUtf32 = class {
                    constructor() {
                        this._interim = 0
                    }
                    clear() {
                        this._interim = 0
                    }
                    decode(l, c) {
                        const u = l.length;
                        if (!u)
                            return 0;
                        let h = 0
                          , d = 0;
                        if (this._interim) {
                            const f = l.charCodeAt(d++);
                            56320 <= f && f <= 57343 ? c[h++] = 1024 * (this._interim - 55296) + f - 56320 + 65536 : (c[h++] = this._interim,
                            c[h++] = f),
                            this._interim = 0
                        }
                        for (let f = d; f < u; ++f) {
                            const g = l.charCodeAt(f);
                            if (55296 <= g && g <= 56319) {
                                if (++f >= u)
                                    return this._interim = g,
                                    h;
                                const _ = l.charCodeAt(f);
                                56320 <= _ && _ <= 57343 ? c[h++] = 1024 * (g - 55296) + _ - 56320 + 65536 : (c[h++] = g,
                                c[h++] = _)
                            } else
                                g !== 65279 && (c[h++] = g)
                        }
                        return h
                    }
                }
                ,
                a.Utf8ToUtf32 = class {
                    constructor() {
                        this.interim = new Uint8Array(3)
                    }
                    clear() {
                        this.interim.fill(0)
                    }
                    decode(l, c) {
                        const u = l.length;
                        if (!u)
                            return 0;
                        let h, d, f, g, _ = 0, m = 0, p = 0;
                        if (this.interim[0]) {
                            let x = !1
                              , E = this.interim[0];
                            E &= (224 & E) == 192 ? 31 : (240 & E) == 224 ? 15 : 7;
                            let w, A = 0;
                            for (; (w = 63 & this.interim[++A]) && A < 4; )
                                E <<= 6,
                                E |= w;
                            const C = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4
                              , k = C - A;
                            for (; p < k; ) {
                                if (p >= u)
                                    return 0;
                                if (w = l[p++],
                                (192 & w) != 128) {
                                    p--,
                                    x = !0;
                                    break
                                }
                                this.interim[A++] = w,
                                E <<= 6,
                                E |= 63 & w
                            }
                            x || (C === 2 ? E < 128 ? p-- : c[_++] = E : C === 3 ? E < 2048 || E >= 55296 && E <= 57343 || E === 65279 || (c[_++] = E) : E < 65536 || E > 1114111 || (c[_++] = E)),
                            this.interim.fill(0)
                        }
                        const b = u - 4;
                        let y = p;
                        for (; y < u; ) {
                            for (; !(!(y < b) || 128 & (h = l[y]) || 128 & (d = l[y + 1]) || 128 & (f = l[y + 2]) || 128 & (g = l[y + 3])); )
                                c[_++] = h,
                                c[_++] = d,
                                c[_++] = f,
                                c[_++] = g,
                                y += 4;
                            if (h = l[y++],
                            h < 128)
                                c[_++] = h;
                            else if ((224 & h) == 192) {
                                if (y >= u)
                                    return this.interim[0] = h,
                                    _;
                                if (d = l[y++],
                                (192 & d) != 128) {
                                    y--;
                                    continue
                                }
                                if (m = (31 & h) << 6 | 63 & d,
                                m < 128) {
                                    y--;
                                    continue
                                }
                                c[_++] = m
                            } else if ((240 & h) == 224) {
                                if (y >= u)
                                    return this.interim[0] = h,
                                    _;
                                if (d = l[y++],
                                (192 & d) != 128) {
                                    y--;
                                    continue
                                }
                                if (y >= u)
                                    return this.interim[0] = h,
                                    this.interim[1] = d,
                                    _;
                                if (f = l[y++],
                                (192 & f) != 128) {
                                    y--;
                                    continue
                                }
                                if (m = (15 & h) << 12 | (63 & d) << 6 | 63 & f,
                                m < 2048 || m >= 55296 && m <= 57343 || m === 65279)
                                    continue;
                                c[_++] = m
                            } else if ((248 & h) == 240) {
                                if (y >= u)
                                    return this.interim[0] = h,
                                    _;
                                if (d = l[y++],
                                (192 & d) != 128) {
                                    y--;
                                    continue
                                }
                                if (y >= u)
                                    return this.interim[0] = h,
                                    this.interim[1] = d,
                                    _;
                                if (f = l[y++],
                                (192 & f) != 128) {
                                    y--;
                                    continue
                                }
                                if (y >= u)
                                    return this.interim[0] = h,
                                    this.interim[1] = d,
                                    this.interim[2] = f,
                                    _;
                                if (g = l[y++],
                                (192 & g) != 128) {
                                    y--;
                                    continue
                                }
                                if (m = (7 & h) << 18 | (63 & d) << 12 | (63 & f) << 6 | 63 & g,
                                m < 65536 || m > 1114111)
                                    continue;
                                c[_++] = m
                            }
                        }
                        return _
                    }
                }
            }
            ,
            225: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.UnicodeV6 = void 0;
                const c = l(1480)
                  , u = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]]
                  , h = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
                let d;
                a.UnicodeV6 = class {
                    constructor() {
                        if (this.version = "6",
                        !d) {
                            d = new Uint8Array(65536),
                            d.fill(1),
                            d[0] = 0,
                            d.fill(0, 1, 32),
                            d.fill(0, 127, 160),
                            d.fill(2, 4352, 4448),
                            d[9001] = 2,
                            d[9002] = 2,
                            d.fill(2, 11904, 42192),
                            d[12351] = 1,
                            d.fill(2, 44032, 55204),
                            d.fill(2, 63744, 64256),
                            d.fill(2, 65040, 65050),
                            d.fill(2, 65072, 65136),
                            d.fill(2, 65280, 65377),
                            d.fill(2, 65504, 65511);
                            for (let f = 0; f < u.length; ++f)
                                d.fill(0, u[f][0], u[f][1] + 1)
                        }
                    }
                    wcwidth(f) {
                        return f < 32 ? 0 : f < 127 ? 1 : f < 65536 ? d[f] : function(g, _) {
                            let m, p = 0, b = _.length - 1;
                            if (g < _[0][0] || g > _[b][1])
                                return !1;
                            for (; b >= p; )
                                if (m = p + b >> 1,
                                g > _[m][1])
                                    p = m + 1;
                                else {
                                    if (!(g < _[m][0]))
                                        return !0;
                                    b = m - 1
                                }
                            return !1
                        }(f, h) ? 0 : f >= 131072 && f <= 196605 || f >= 196608 && f <= 262141 ? 2 : 1
                    }
                    charProperties(f, g) {
                        let _ = this.wcwidth(f)
                          , m = _ === 0 && g !== 0;
                        if (m) {
                            const p = c.UnicodeService.extractWidth(g);
                            p === 0 ? m = !1 : p > _ && (_ = p)
                        }
                        return c.UnicodeService.createPropertyValue(0, _, m)
                    }
                }
            }
            ,
            5981: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.WriteBuffer = void 0;
                const c = l(8460)
                  , u = l(844);
                class h extends u.Disposable {
                    constructor(f) {
                        super(),
                        this._action = f,
                        this._writeBuffer = [],
                        this._callbacks = [],
                        this._pendingData = 0,
                        this._bufferOffset = 0,
                        this._isSyncWriting = !1,
                        this._syncCalls = 0,
                        this._didUserInput = !1,
                        this._onWriteParsed = this.register(new c.EventEmitter),
                        this.onWriteParsed = this._onWriteParsed.event
                    }
                    handleUserInput() {
                        this._didUserInput = !0
                    }
                    writeSync(f, g) {
                        if (g !== void 0 && this._syncCalls > g)
                            return void (this._syncCalls = 0);
                        if (this._pendingData += f.length,
                        this._writeBuffer.push(f),
                        this._callbacks.push(void 0),
                        this._syncCalls++,
                        this._isSyncWriting)
                            return;
                        let _;
                        for (this._isSyncWriting = !0; _ = this._writeBuffer.shift(); ) {
                            this._action(_);
                            const m = this._callbacks.shift();
                            m && m()
                        }
                        this._pendingData = 0,
                        this._bufferOffset = 2147483647,
                        this._isSyncWriting = !1,
                        this._syncCalls = 0
                    }
                    write(f, g) {
                        if (this._pendingData > 5e7)
                            throw new Error("write data discarded, use flow control to avoid losing data");
                        if (!this._writeBuffer.length) {
                            if (this._bufferOffset = 0,
                            this._didUserInput)
                                return this._didUserInput = !1,
                                this._pendingData += f.length,
                                this._writeBuffer.push(f),
                                this._callbacks.push(g),
                                void this._innerWrite();
                            setTimeout( () => this._innerWrite())
                        }
                        this._pendingData += f.length,
                        this._writeBuffer.push(f),
                        this._callbacks.push(g)
                    }
                    _innerWrite(f=0, g=!0) {
                        const _ = f || Date.now();
                        for (; this._writeBuffer.length > this._bufferOffset; ) {
                            const m = this._writeBuffer[this._bufferOffset]
                              , p = this._action(m, g);
                            if (p) {
                                const y = x => Date.now() - _ >= 12 ? setTimeout( () => this._innerWrite(0, x)) : this._innerWrite(_, x);
                                return void p.catch(x => (queueMicrotask( () => {
                                    throw x
                                }
                                ),
                                Promise.resolve(!1))).then(y)
                            }
                            const b = this._callbacks[this._bufferOffset];
                            if (b && b(),
                            this._bufferOffset++,
                            this._pendingData -= m.length,
                            Date.now() - _ >= 12)
                                break
                        }
                        this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset),
                        this._callbacks = this._callbacks.slice(this._bufferOffset),
                        this._bufferOffset = 0),
                        setTimeout( () => this._innerWrite())) : (this._writeBuffer.length = 0,
                        this._callbacks.length = 0,
                        this._pendingData = 0,
                        this._bufferOffset = 0),
                        this._onWriteParsed.fire()
                    }
                }
                a.WriteBuffer = h
            }
            ,
            5941: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.toRgbString = a.parseColor = void 0;
                const l = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/
                  , c = /^[\da-f]+$/;
                function u(h, d) {
                    const f = h.toString(16)
                      , g = f.length < 2 ? "0" + f : f;
                    switch (d) {
                    case 4:
                        return f[0];
                    case 8:
                        return g;
                    case 12:
                        return (g + g).slice(0, 3);
                    default:
                        return g + g
                    }
                }
                a.parseColor = function(h) {
                    if (!h)
                        return;
                    let d = h.toLowerCase();
                    if (d.indexOf("rgb:") === 0) {
                        d = d.slice(4);
                        const f = l.exec(d);
                        if (f) {
                            const g = f[1] ? 15 : f[4] ? 255 : f[7] ? 4095 : 65535;
                            return [Math.round(parseInt(f[1] || f[4] || f[7] || f[10], 16) / g * 255), Math.round(parseInt(f[2] || f[5] || f[8] || f[11], 16) / g * 255), Math.round(parseInt(f[3] || f[6] || f[9] || f[12], 16) / g * 255)]
                        }
                    } else if (d.indexOf("#") === 0 && (d = d.slice(1),
                    c.exec(d) && [3, 6, 9, 12].includes(d.length))) {
                        const f = d.length / 3
                          , g = [0, 0, 0];
                        for (let _ = 0; _ < 3; ++_) {
                            const m = parseInt(d.slice(f * _, f * _ + f), 16);
                            g[_] = f === 1 ? m << 4 : f === 2 ? m : f === 3 ? m >> 4 : m >> 8
                        }
                        return g
                    }
                }
                ,
                a.toRgbString = function(h, d=16) {
                    const [f,g,_] = h;
                    return `rgb:${u(f, d)}/${u(g, d)}/${u(_, d)}`
                }
            }
            ,
            5770: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.PAYLOAD_LIMIT = void 0,
                a.PAYLOAD_LIMIT = 1e7
            }
            ,
            6351: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.DcsHandler = a.DcsParser = void 0;
                const c = l(482)
                  , u = l(8742)
                  , h = l(5770)
                  , d = [];
                a.DcsParser = class {
                    constructor() {
                        this._handlers = Object.create(null),
                        this._active = d,
                        this._ident = 0,
                        this._handlerFb = () => {}
                        ,
                        this._stack = {
                            paused: !1,
                            loopPosition: 0,
                            fallThrough: !1
                        }
                    }
                    dispose() {
                        this._handlers = Object.create(null),
                        this._handlerFb = () => {}
                        ,
                        this._active = d
                    }
                    registerHandler(g, _) {
                        this._handlers[g] === void 0 && (this._handlers[g] = []);
                        const m = this._handlers[g];
                        return m.push(_),
                        {
                            dispose: () => {
                                const p = m.indexOf(_);
                                p !== -1 && m.splice(p, 1)
                            }
                        }
                    }
                    clearHandler(g) {
                        this._handlers[g] && delete this._handlers[g]
                    }
                    setHandlerFallback(g) {
                        this._handlerFb = g
                    }
                    reset() {
                        if (this._active.length)
                            for (let g = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; g >= 0; --g)
                                this._active[g].unhook(!1);
                        this._stack.paused = !1,
                        this._active = d,
                        this._ident = 0
                    }
                    hook(g, _) {
                        if (this.reset(),
                        this._ident = g,
                        this._active = this._handlers[g] || d,
                        this._active.length)
                            for (let m = this._active.length - 1; m >= 0; m--)
                                this._active[m].hook(_);
                        else
                            this._handlerFb(this._ident, "HOOK", _)
                    }
                    put(g, _, m) {
                        if (this._active.length)
                            for (let p = this._active.length - 1; p >= 0; p--)
                                this._active[p].put(g, _, m);
                        else
                            this._handlerFb(this._ident, "PUT", (0,
                            c.utf32ToString)(g, _, m))
                    }
                    unhook(g, _=!0) {
                        if (this._active.length) {
                            let m = !1
                              , p = this._active.length - 1
                              , b = !1;
                            if (this._stack.paused && (p = this._stack.loopPosition - 1,
                            m = _,
                            b = this._stack.fallThrough,
                            this._stack.paused = !1),
                            !b && m === !1) {
                                for (; p >= 0 && (m = this._active[p].unhook(g),
                                m !== !0); p--)
                                    if (m instanceof Promise)
                                        return this._stack.paused = !0,
                                        this._stack.loopPosition = p,
                                        this._stack.fallThrough = !1,
                                        m;
                                p--
                            }
                            for (; p >= 0; p--)
                                if (m = this._active[p].unhook(!1),
                                m instanceof Promise)
                                    return this._stack.paused = !0,
                                    this._stack.loopPosition = p,
                                    this._stack.fallThrough = !0,
                                    m
                        } else
                            this._handlerFb(this._ident, "UNHOOK", g);
                        this._active = d,
                        this._ident = 0
                    }
                }
                ;
                const f = new u.Params;
                f.addParam(0),
                a.DcsHandler = class {
                    constructor(g) {
                        this._handler = g,
                        this._data = "",
                        this._params = f,
                        this._hitLimit = !1
                    }
                    hook(g) {
                        this._params = g.length > 1 || g.params[0] ? g.clone() : f,
                        this._data = "",
                        this._hitLimit = !1
                    }
                    put(g, _, m) {
                        this._hitLimit || (this._data += (0,
                        c.utf32ToString)(g, _, m),
                        this._data.length > h.PAYLOAD_LIMIT && (this._data = "",
                        this._hitLimit = !0))
                    }
                    unhook(g) {
                        let _ = !1;
                        if (this._hitLimit)
                            _ = !1;
                        else if (g && (_ = this._handler(this._data, this._params),
                        _ instanceof Promise))
                            return _.then(m => (this._params = f,
                            this._data = "",
                            this._hitLimit = !1,
                            m));
                        return this._params = f,
                        this._data = "",
                        this._hitLimit = !1,
                        _
                    }
                }
            }
            ,
            2015: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.EscapeSequenceParser = a.VT500_TRANSITION_TABLE = a.TransitionTable = void 0;
                const c = l(844)
                  , u = l(8742)
                  , h = l(6242)
                  , d = l(6351);
                class f {
                    constructor(p) {
                        this.table = new Uint8Array(p)
                    }
                    setDefault(p, b) {
                        this.table.fill(p << 4 | b)
                    }
                    add(p, b, y, x) {
                        this.table[b << 8 | p] = y << 4 | x
                    }
                    addMany(p, b, y, x) {
                        for (let E = 0; E < p.length; E++)
                            this.table[b << 8 | p[E]] = y << 4 | x
                    }
                }
                a.TransitionTable = f;
                const g = 160;
                a.VT500_TRANSITION_TABLE = function() {
                    const m = new f(4095)
                      , p = Array.apply(null, Array(256)).map( (A, C) => C)
                      , b = (A, C) => p.slice(A, C)
                      , y = b(32, 127)
                      , x = b(0, 24);
                    x.push(25),
                    x.push.apply(x, b(28, 32));
                    const E = b(0, 14);
                    let w;
                    for (w in m.setDefault(1, 0),
                    m.addMany(y, 0, 2, 0),
                    E)
                        m.addMany([24, 26, 153, 154], w, 3, 0),
                        m.addMany(b(128, 144), w, 3, 0),
                        m.addMany(b(144, 152), w, 3, 0),
                        m.add(156, w, 0, 0),
                        m.add(27, w, 11, 1),
                        m.add(157, w, 4, 8),
                        m.addMany([152, 158, 159], w, 0, 7),
                        m.add(155, w, 11, 3),
                        m.add(144, w, 11, 9);
                    return m.addMany(x, 0, 3, 0),
                    m.addMany(x, 1, 3, 1),
                    m.add(127, 1, 0, 1),
                    m.addMany(x, 8, 0, 8),
                    m.addMany(x, 3, 3, 3),
                    m.add(127, 3, 0, 3),
                    m.addMany(x, 4, 3, 4),
                    m.add(127, 4, 0, 4),
                    m.addMany(x, 6, 3, 6),
                    m.addMany(x, 5, 3, 5),
                    m.add(127, 5, 0, 5),
                    m.addMany(x, 2, 3, 2),
                    m.add(127, 2, 0, 2),
                    m.add(93, 1, 4, 8),
                    m.addMany(y, 8, 5, 8),
                    m.add(127, 8, 5, 8),
                    m.addMany([156, 27, 24, 26, 7], 8, 6, 0),
                    m.addMany(b(28, 32), 8, 0, 8),
                    m.addMany([88, 94, 95], 1, 0, 7),
                    m.addMany(y, 7, 0, 7),
                    m.addMany(x, 7, 0, 7),
                    m.add(156, 7, 0, 0),
                    m.add(127, 7, 0, 7),
                    m.add(91, 1, 11, 3),
                    m.addMany(b(64, 127), 3, 7, 0),
                    m.addMany(b(48, 60), 3, 8, 4),
                    m.addMany([60, 61, 62, 63], 3, 9, 4),
                    m.addMany(b(48, 60), 4, 8, 4),
                    m.addMany(b(64, 127), 4, 7, 0),
                    m.addMany([60, 61, 62, 63], 4, 0, 6),
                    m.addMany(b(32, 64), 6, 0, 6),
                    m.add(127, 6, 0, 6),
                    m.addMany(b(64, 127), 6, 0, 0),
                    m.addMany(b(32, 48), 3, 9, 5),
                    m.addMany(b(32, 48), 5, 9, 5),
                    m.addMany(b(48, 64), 5, 0, 6),
                    m.addMany(b(64, 127), 5, 7, 0),
                    m.addMany(b(32, 48), 4, 9, 5),
                    m.addMany(b(32, 48), 1, 9, 2),
                    m.addMany(b(32, 48), 2, 9, 2),
                    m.addMany(b(48, 127), 2, 10, 0),
                    m.addMany(b(48, 80), 1, 10, 0),
                    m.addMany(b(81, 88), 1, 10, 0),
                    m.addMany([89, 90, 92], 1, 10, 0),
                    m.addMany(b(96, 127), 1, 10, 0),
                    m.add(80, 1, 11, 9),
                    m.addMany(x, 9, 0, 9),
                    m.add(127, 9, 0, 9),
                    m.addMany(b(28, 32), 9, 0, 9),
                    m.addMany(b(32, 48), 9, 9, 12),
                    m.addMany(b(48, 60), 9, 8, 10),
                    m.addMany([60, 61, 62, 63], 9, 9, 10),
                    m.addMany(x, 11, 0, 11),
                    m.addMany(b(32, 128), 11, 0, 11),
                    m.addMany(b(28, 32), 11, 0, 11),
                    m.addMany(x, 10, 0, 10),
                    m.add(127, 10, 0, 10),
                    m.addMany(b(28, 32), 10, 0, 10),
                    m.addMany(b(48, 60), 10, 8, 10),
                    m.addMany([60, 61, 62, 63], 10, 0, 11),
                    m.addMany(b(32, 48), 10, 9, 12),
                    m.addMany(x, 12, 0, 12),
                    m.add(127, 12, 0, 12),
                    m.addMany(b(28, 32), 12, 0, 12),
                    m.addMany(b(32, 48), 12, 9, 12),
                    m.addMany(b(48, 64), 12, 0, 11),
                    m.addMany(b(64, 127), 12, 12, 13),
                    m.addMany(b(64, 127), 10, 12, 13),
                    m.addMany(b(64, 127), 9, 12, 13),
                    m.addMany(x, 13, 13, 13),
                    m.addMany(y, 13, 13, 13),
                    m.add(127, 13, 0, 13),
                    m.addMany([27, 156, 24, 26], 13, 14, 0),
                    m.add(g, 0, 2, 0),
                    m.add(g, 8, 5, 8),
                    m.add(g, 6, 0, 6),
                    m.add(g, 11, 0, 11),
                    m.add(g, 13, 13, 13),
                    m
                }();
                class _ extends c.Disposable {
                    constructor(p=a.VT500_TRANSITION_TABLE) {
                        super(),
                        this._transitions = p,
                        this._parseStack = {
                            state: 0,
                            handlers: [],
                            handlerPos: 0,
                            transition: 0,
                            chunkPos: 0
                        },
                        this.initialState = 0,
                        this.currentState = this.initialState,
                        this._params = new u.Params,
                        this._params.addParam(0),
                        this._collect = 0,
                        this.precedingJoinState = 0,
                        this._printHandlerFb = (b, y, x) => {}
                        ,
                        this._executeHandlerFb = b => {}
                        ,
                        this._csiHandlerFb = (b, y) => {}
                        ,
                        this._escHandlerFb = b => {}
                        ,
                        this._errorHandlerFb = b => b,
                        this._printHandler = this._printHandlerFb,
                        this._executeHandlers = Object.create(null),
                        this._csiHandlers = Object.create(null),
                        this._escHandlers = Object.create(null),
                        this.register((0,
                        c.toDisposable)( () => {
                            this._csiHandlers = Object.create(null),
                            this._executeHandlers = Object.create(null),
                            this._escHandlers = Object.create(null)
                        }
                        )),
                        this._oscParser = this.register(new h.OscParser),
                        this._dcsParser = this.register(new d.DcsParser),
                        this._errorHandler = this._errorHandlerFb,
                        this.registerEscHandler({
                            final: "\\"
                        }, () => !0)
                    }
                    _identifier(p, b=[64, 126]) {
                        let y = 0;
                        if (p.prefix) {
                            if (p.prefix.length > 1)
                                throw new Error("only one byte as prefix supported");
                            if (y = p.prefix.charCodeAt(0),
                            y && 60 > y || y > 63)
                                throw new Error("prefix must be in range 0x3c .. 0x3f")
                        }
                        if (p.intermediates) {
                            if (p.intermediates.length > 2)
                                throw new Error("only two bytes as intermediates are supported");
                            for (let E = 0; E < p.intermediates.length; ++E) {
                                const w = p.intermediates.charCodeAt(E);
                                if (32 > w || w > 47)
                                    throw new Error("intermediate must be in range 0x20 .. 0x2f");
                                y <<= 8,
                                y |= w
                            }
                        }
                        if (p.final.length !== 1)
                            throw new Error("final must be a single byte");
                        const x = p.final.charCodeAt(0);
                        if (b[0] > x || x > b[1])
                            throw new Error(`final must be in range ${b[0]} .. ${b[1]}`);
                        return y <<= 8,
                        y |= x,
                        y
                    }
                    identToString(p) {
                        const b = [];
                        for (; p; )
                            b.push(String.fromCharCode(255 & p)),
                            p >>= 8;
                        return b.reverse().join("")
                    }
                    setPrintHandler(p) {
                        this._printHandler = p
                    }
                    clearPrintHandler() {
                        this._printHandler = this._printHandlerFb
                    }
                    registerEscHandler(p, b) {
                        const y = this._identifier(p, [48, 126]);
                        this._escHandlers[y] === void 0 && (this._escHandlers[y] = []);
                        const x = this._escHandlers[y];
                        return x.push(b),
                        {
                            dispose: () => {
                                const E = x.indexOf(b);
                                E !== -1 && x.splice(E, 1)
                            }
                        }
                    }
                    clearEscHandler(p) {
                        this._escHandlers[this._identifier(p, [48, 126])] && delete this._escHandlers[this._identifier(p, [48, 126])]
                    }
                    setEscHandlerFallback(p) {
                        this._escHandlerFb = p
                    }
                    setExecuteHandler(p, b) {
                        this._executeHandlers[p.charCodeAt(0)] = b
                    }
                    clearExecuteHandler(p) {
                        this._executeHandlers[p.charCodeAt(0)] && delete this._executeHandlers[p.charCodeAt(0)]
                    }
                    setExecuteHandlerFallback(p) {
                        this._executeHandlerFb = p
                    }
                    registerCsiHandler(p, b) {
                        const y = this._identifier(p);
                        this._csiHandlers[y] === void 0 && (this._csiHandlers[y] = []);
                        const x = this._csiHandlers[y];
                        return x.push(b),
                        {
                            dispose: () => {
                                const E = x.indexOf(b);
                                E !== -1 && x.splice(E, 1)
                            }
                        }
                    }
                    clearCsiHandler(p) {
                        this._csiHandlers[this._identifier(p)] && delete this._csiHandlers[this._identifier(p)]
                    }
                    setCsiHandlerFallback(p) {
                        this._csiHandlerFb = p
                    }
                    registerDcsHandler(p, b) {
                        return this._dcsParser.registerHandler(this._identifier(p), b)
                    }
                    clearDcsHandler(p) {
                        this._dcsParser.clearHandler(this._identifier(p))
                    }
                    setDcsHandlerFallback(p) {
                        this._dcsParser.setHandlerFallback(p)
                    }
                    registerOscHandler(p, b) {
                        return this._oscParser.registerHandler(p, b)
                    }
                    clearOscHandler(p) {
                        this._oscParser.clearHandler(p)
                    }
                    setOscHandlerFallback(p) {
                        this._oscParser.setHandlerFallback(p)
                    }
                    setErrorHandler(p) {
                        this._errorHandler = p
                    }
                    clearErrorHandler() {
                        this._errorHandler = this._errorHandlerFb
                    }
                    reset() {
                        this.currentState = this.initialState,
                        this._oscParser.reset(),
                        this._dcsParser.reset(),
                        this._params.reset(),
                        this._params.addParam(0),
                        this._collect = 0,
                        this.precedingJoinState = 0,
                        this._parseStack.state !== 0 && (this._parseStack.state = 2,
                        this._parseStack.handlers = [])
                    }
                    _preserveStack(p, b, y, x, E) {
                        this._parseStack.state = p,
                        this._parseStack.handlers = b,
                        this._parseStack.handlerPos = y,
                        this._parseStack.transition = x,
                        this._parseStack.chunkPos = E
                    }
                    parse(p, b, y) {
                        let x, E = 0, w = 0, A = 0;
                        if (this._parseStack.state)
                            if (this._parseStack.state === 2)
                                this._parseStack.state = 0,
                                A = this._parseStack.chunkPos + 1;
                            else {
                                if (y === void 0 || this._parseStack.state === 1)
                                    throw this._parseStack.state = 1,
                                    new Error("improper continuation due to previous async handler, giving up parsing");
                                const C = this._parseStack.handlers;
                                let k = this._parseStack.handlerPos - 1;
                                switch (this._parseStack.state) {
                                case 3:
                                    if (y === !1 && k > -1) {
                                        for (; k >= 0 && (x = C[k](this._params),
                                        x !== !0); k--)
                                            if (x instanceof Promise)
                                                return this._parseStack.handlerPos = k,
                                                x
                                    }
                                    this._parseStack.handlers = [];
                                    break;
                                case 4:
                                    if (y === !1 && k > -1) {
                                        for (; k >= 0 && (x = C[k](),
                                        x !== !0); k--)
                                            if (x instanceof Promise)
                                                return this._parseStack.handlerPos = k,
                                                x
                                    }
                                    this._parseStack.handlers = [];
                                    break;
                                case 6:
                                    if (E = p[this._parseStack.chunkPos],
                                    x = this._dcsParser.unhook(E !== 24 && E !== 26, y),
                                    x)
                                        return x;
                                    E === 27 && (this._parseStack.transition |= 1),
                                    this._params.reset(),
                                    this._params.addParam(0),
                                    this._collect = 0;
                                    break;
                                case 5:
                                    if (E = p[this._parseStack.chunkPos],
                                    x = this._oscParser.end(E !== 24 && E !== 26, y),
                                    x)
                                        return x;
                                    E === 27 && (this._parseStack.transition |= 1),
                                    this._params.reset(),
                                    this._params.addParam(0),
                                    this._collect = 0
                                }
                                this._parseStack.state = 0,
                                A = this._parseStack.chunkPos + 1,
                                this.precedingJoinState = 0,
                                this.currentState = 15 & this._parseStack.transition
                            }
                        for (let C = A; C < b; ++C) {
                            switch (E = p[C],
                            w = this._transitions.table[this.currentState << 8 | (E < 160 ? E : g)],
                            w >> 4) {
                            case 2:
                                for (let M = C + 1; ; ++M) {
                                    if (M >= b || (E = p[M]) < 32 || E > 126 && E < g) {
                                        this._printHandler(p, C, M),
                                        C = M - 1;
                                        break
                                    }
                                    if (++M >= b || (E = p[M]) < 32 || E > 126 && E < g) {
                                        this._printHandler(p, C, M),
                                        C = M - 1;
                                        break
                                    }
                                    if (++M >= b || (E = p[M]) < 32 || E > 126 && E < g) {
                                        this._printHandler(p, C, M),
                                        C = M - 1;
                                        break
                                    }
                                    if (++M >= b || (E = p[M]) < 32 || E > 126 && E < g) {
                                        this._printHandler(p, C, M),
                                        C = M - 1;
                                        break
                                    }
                                }
                                break;
                            case 3:
                                this._executeHandlers[E] ? this._executeHandlers[E]() : this._executeHandlerFb(E),
                                this.precedingJoinState = 0;
                                break;
                            case 0:
                                break;
                            case 1:
                                if (this._errorHandler({
                                    position: C,
                                    code: E,
                                    currentState: this.currentState,
                                    collect: this._collect,
                                    params: this._params,
                                    abort: !1
                                }).abort)
                                    return;
                                break;
                            case 7:
                                const k = this._csiHandlers[this._collect << 8 | E];
                                let I = k ? k.length - 1 : -1;
                                for (; I >= 0 && (x = k[I](this._params),
                                x !== !0); I--)
                                    if (x instanceof Promise)
                                        return this._preserveStack(3, k, I, w, C),
                                        x;
                                I < 0 && this._csiHandlerFb(this._collect << 8 | E, this._params),
                                this.precedingJoinState = 0;
                                break;
                            case 8:
                                do
                                    switch (E) {
                                    case 59:
                                        this._params.addParam(0);
                                        break;
                                    case 58:
                                        this._params.addSubParam(-1);
                                        break;
                                    default:
                                        this._params.addDigit(E - 48)
                                    }
                                while (++C < b && (E = p[C]) > 47 && E < 60);
                                C--;
                                break;
                            case 9:
                                this._collect <<= 8,
                                this._collect |= E;
                                break;
                            case 10:
                                const N = this._escHandlers[this._collect << 8 | E];
                                let O = N ? N.length - 1 : -1;
                                for (; O >= 0 && (x = N[O](),
                                x !== !0); O--)
                                    if (x instanceof Promise)
                                        return this._preserveStack(4, N, O, w, C),
                                        x;
                                O < 0 && this._escHandlerFb(this._collect << 8 | E),
                                this.precedingJoinState = 0;
                                break;
                            case 11:
                                this._params.reset(),
                                this._params.addParam(0),
                                this._collect = 0;
                                break;
                            case 12:
                                this._dcsParser.hook(this._collect << 8 | E, this._params);
                                break;
                            case 13:
                                for (let M = C + 1; ; ++M)
                                    if (M >= b || (E = p[M]) === 24 || E === 26 || E === 27 || E > 127 && E < g) {
                                        this._dcsParser.put(p, C, M),
                                        C = M - 1;
                                        break
                                    }
                                break;
                            case 14:
                                if (x = this._dcsParser.unhook(E !== 24 && E !== 26),
                                x)
                                    return this._preserveStack(6, [], 0, w, C),
                                    x;
                                E === 27 && (w |= 1),
                                this._params.reset(),
                                this._params.addParam(0),
                                this._collect = 0,
                                this.precedingJoinState = 0;
                                break;
                            case 4:
                                this._oscParser.start();
                                break;
                            case 5:
                                for (let M = C + 1; ; M++)
                                    if (M >= b || (E = p[M]) < 32 || E > 127 && E < g) {
                                        this._oscParser.put(p, C, M),
                                        C = M - 1;
                                        break
                                    }
                                break;
                            case 6:
                                if (x = this._oscParser.end(E !== 24 && E !== 26),
                                x)
                                    return this._preserveStack(5, [], 0, w, C),
                                    x;
                                E === 27 && (w |= 1),
                                this._params.reset(),
                                this._params.addParam(0),
                                this._collect = 0,
                                this.precedingJoinState = 0
                            }
                            this.currentState = 15 & w
                        }
                    }
                }
                a.EscapeSequenceParser = _
            }
            ,
            6242: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.OscHandler = a.OscParser = void 0;
                const c = l(5770)
                  , u = l(482)
                  , h = [];
                a.OscParser = class {
                    constructor() {
                        this._state = 0,
                        this._active = h,
                        this._id = -1,
                        this._handlers = Object.create(null),
                        this._handlerFb = () => {}
                        ,
                        this._stack = {
                            paused: !1,
                            loopPosition: 0,
                            fallThrough: !1
                        }
                    }
                    registerHandler(d, f) {
                        this._handlers[d] === void 0 && (this._handlers[d] = []);
                        const g = this._handlers[d];
                        return g.push(f),
                        {
                            dispose: () => {
                                const _ = g.indexOf(f);
                                _ !== -1 && g.splice(_, 1)
                            }
                        }
                    }
                    clearHandler(d) {
                        this._handlers[d] && delete this._handlers[d]
                    }
                    setHandlerFallback(d) {
                        this._handlerFb = d
                    }
                    dispose() {
                        this._handlers = Object.create(null),
                        this._handlerFb = () => {}
                        ,
                        this._active = h
                    }
                    reset() {
                        if (this._state === 2)
                            for (let d = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; d >= 0; --d)
                                this._active[d].end(!1);
                        this._stack.paused = !1,
                        this._active = h,
                        this._id = -1,
                        this._state = 0
                    }
                    _start() {
                        if (this._active = this._handlers[this._id] || h,
                        this._active.length)
                            for (let d = this._active.length - 1; d >= 0; d--)
                                this._active[d].start();
                        else
                            this._handlerFb(this._id, "START")
                    }
                    _put(d, f, g) {
                        if (this._active.length)
                            for (let _ = this._active.length - 1; _ >= 0; _--)
                                this._active[_].put(d, f, g);
                        else
                            this._handlerFb(this._id, "PUT", (0,
                            u.utf32ToString)(d, f, g))
                    }
                    start() {
                        this.reset(),
                        this._state = 1
                    }
                    put(d, f, g) {
                        if (this._state !== 3) {
                            if (this._state === 1)
                                for (; f < g; ) {
                                    const _ = d[f++];
                                    if (_ === 59) {
                                        this._state = 2,
                                        this._start();
                                        break
                                    }
                                    if (_ < 48 || 57 < _)
                                        return void (this._state = 3);
                                    this._id === -1 && (this._id = 0),
                                    this._id = 10 * this._id + _ - 48
                                }
                            this._state === 2 && g - f > 0 && this._put(d, f, g)
                        }
                    }
                    end(d, f=!0) {
                        if (this._state !== 0) {
                            if (this._state !== 3)
                                if (this._state === 1 && this._start(),
                                this._active.length) {
                                    let g = !1
                                      , _ = this._active.length - 1
                                      , m = !1;
                                    if (this._stack.paused && (_ = this._stack.loopPosition - 1,
                                    g = f,
                                    m = this._stack.fallThrough,
                                    this._stack.paused = !1),
                                    !m && g === !1) {
                                        for (; _ >= 0 && (g = this._active[_].end(d),
                                        g !== !0); _--)
                                            if (g instanceof Promise)
                                                return this._stack.paused = !0,
                                                this._stack.loopPosition = _,
                                                this._stack.fallThrough = !1,
                                                g;
                                        _--
                                    }
                                    for (; _ >= 0; _--)
                                        if (g = this._active[_].end(!1),
                                        g instanceof Promise)
                                            return this._stack.paused = !0,
                                            this._stack.loopPosition = _,
                                            this._stack.fallThrough = !0,
                                            g
                                } else
                                    this._handlerFb(this._id, "END", d);
                            this._active = h,
                            this._id = -1,
                            this._state = 0
                        }
                    }
                }
                ,
                a.OscHandler = class {
                    constructor(d) {
                        this._handler = d,
                        this._data = "",
                        this._hitLimit = !1
                    }
                    start() {
                        this._data = "",
                        this._hitLimit = !1
                    }
                    put(d, f, g) {
                        this._hitLimit || (this._data += (0,
                        u.utf32ToString)(d, f, g),
                        this._data.length > c.PAYLOAD_LIMIT && (this._data = "",
                        this._hitLimit = !0))
                    }
                    end(d) {
                        let f = !1;
                        if (this._hitLimit)
                            f = !1;
                        else if (d && (f = this._handler(this._data),
                        f instanceof Promise))
                            return f.then(g => (this._data = "",
                            this._hitLimit = !1,
                            g));
                        return this._data = "",
                        this._hitLimit = !1,
                        f
                    }
                }
            }
            ,
            8742: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.Params = void 0;
                const l = 2147483647;
                class c {
                    static fromArray(h) {
                        const d = new c;
                        if (!h.length)
                            return d;
                        for (let f = Array.isArray(h[0]) ? 1 : 0; f < h.length; ++f) {
                            const g = h[f];
                            if (Array.isArray(g))
                                for (let _ = 0; _ < g.length; ++_)
                                    d.addSubParam(g[_]);
                            else
                                d.addParam(g)
                        }
                        return d
                    }
                    constructor(h=32, d=32) {
                        if (this.maxLength = h,
                        this.maxSubParamsLength = d,
                        d > 256)
                            throw new Error("maxSubParamsLength must not be greater than 256");
                        this.params = new Int32Array(h),
                        this.length = 0,
                        this._subParams = new Int32Array(d),
                        this._subParamsLength = 0,
                        this._subParamsIdx = new Uint16Array(h),
                        this._rejectDigits = !1,
                        this._rejectSubDigits = !1,
                        this._digitIsSub = !1
                    }
                    clone() {
                        const h = new c(this.maxLength,this.maxSubParamsLength);
                        return h.params.set(this.params),
                        h.length = this.length,
                        h._subParams.set(this._subParams),
                        h._subParamsLength = this._subParamsLength,
                        h._subParamsIdx.set(this._subParamsIdx),
                        h._rejectDigits = this._rejectDigits,
                        h._rejectSubDigits = this._rejectSubDigits,
                        h._digitIsSub = this._digitIsSub,
                        h
                    }
                    toArray() {
                        const h = [];
                        for (let d = 0; d < this.length; ++d) {
                            h.push(this.params[d]);
                            const f = this._subParamsIdx[d] >> 8
                              , g = 255 & this._subParamsIdx[d];
                            g - f > 0 && h.push(Array.prototype.slice.call(this._subParams, f, g))
                        }
                        return h
                    }
                    reset() {
                        this.length = 0,
                        this._subParamsLength = 0,
                        this._rejectDigits = !1,
                        this._rejectSubDigits = !1,
                        this._digitIsSub = !1
                    }
                    addParam(h) {
                        if (this._digitIsSub = !1,
                        this.length >= this.maxLength)
                            this._rejectDigits = !0;
                        else {
                            if (h < -1)
                                throw new Error("values lesser than -1 are not allowed");
                            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength,
                            this.params[this.length++] = h > l ? l : h
                        }
                    }
                    addSubParam(h) {
                        if (this._digitIsSub = !0,
                        this.length)
                            if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
                                this._rejectSubDigits = !0;
                            else {
                                if (h < -1)
                                    throw new Error("values lesser than -1 are not allowed");
                                this._subParams[this._subParamsLength++] = h > l ? l : h,
                                this._subParamsIdx[this.length - 1]++
                            }
                    }
                    hasSubParams(h) {
                        return (255 & this._subParamsIdx[h]) - (this._subParamsIdx[h] >> 8) > 0
                    }
                    getSubParams(h) {
                        const d = this._subParamsIdx[h] >> 8
                          , f = 255 & this._subParamsIdx[h];
                        return f - d > 0 ? this._subParams.subarray(d, f) : null
                    }
                    getSubParamsAll() {
                        const h = {};
                        for (let d = 0; d < this.length; ++d) {
                            const f = this._subParamsIdx[d] >> 8
                              , g = 255 & this._subParamsIdx[d];
                            g - f > 0 && (h[d] = this._subParams.slice(f, g))
                        }
                        return h
                    }
                    addDigit(h) {
                        let d;
                        if (this._rejectDigits || !(d = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
                            return;
                        const f = this._digitIsSub ? this._subParams : this.params
                          , g = f[d - 1];
                        f[d - 1] = ~g ? Math.min(10 * g + h, l) : h
                    }
                }
                a.Params = c
            }
            ,
            5741: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.AddonManager = void 0,
                a.AddonManager = class {
                    constructor() {
                        this._addons = []
                    }
                    dispose() {
                        for (let l = this._addons.length - 1; l >= 0; l--)
                            this._addons[l].instance.dispose()
                    }
                    loadAddon(l, c) {
                        const u = {
                            instance: c,
                            dispose: c.dispose,
                            isDisposed: !1
                        };
                        this._addons.push(u),
                        c.dispose = () => this._wrappedAddonDispose(u),
                        c.activate(l)
                    }
                    _wrappedAddonDispose(l) {
                        if (l.isDisposed)
                            return;
                        let c = -1;
                        for (let u = 0; u < this._addons.length; u++)
                            if (this._addons[u] === l) {
                                c = u;
                                break
                            }
                        if (c === -1)
                            throw new Error("Could not dispose an addon that has not been loaded");
                        l.isDisposed = !0,
                        l.dispose.apply(l.instance),
                        this._addons.splice(c, 1)
                    }
                }
            }
            ,
            8771: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferApiView = void 0;
                const c = l(3785)
                  , u = l(511);
                a.BufferApiView = class {
                    constructor(h, d) {
                        this._buffer = h,
                        this.type = d
                    }
                    init(h) {
                        return this._buffer = h,
                        this
                    }
                    get cursorY() {
                        return this._buffer.y
                    }
                    get cursorX() {
                        return this._buffer.x
                    }
                    get viewportY() {
                        return this._buffer.ydisp
                    }
                    get baseY() {
                        return this._buffer.ybase
                    }
                    get length() {
                        return this._buffer.lines.length
                    }
                    getLine(h) {
                        const d = this._buffer.lines.get(h);
                        if (d)
                            return new c.BufferLineApiView(d)
                    }
                    getNullCell() {
                        return new u.CellData
                    }
                }
            }
            ,
            3785: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferLineApiView = void 0;
                const c = l(511);
                a.BufferLineApiView = class {
                    constructor(u) {
                        this._line = u
                    }
                    get isWrapped() {
                        return this._line.isWrapped
                    }
                    get length() {
                        return this._line.length
                    }
                    getCell(u, h) {
                        if (!(u < 0 || u >= this._line.length))
                            return h ? (this._line.loadCell(u, h),
                            h) : this._line.loadCell(u, new c.CellData)
                    }
                    translateToString(u, h, d) {
                        return this._line.translateToString(u, h, d)
                    }
                }
            }
            ,
            8285: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferNamespaceApi = void 0;
                const c = l(8771)
                  , u = l(8460)
                  , h = l(844);
                class d extends h.Disposable {
                    constructor(g) {
                        super(),
                        this._core = g,
                        this._onBufferChange = this.register(new u.EventEmitter),
                        this.onBufferChange = this._onBufferChange.event,
                        this._normal = new c.BufferApiView(this._core.buffers.normal,"normal"),
                        this._alternate = new c.BufferApiView(this._core.buffers.alt,"alternate"),
                        this._core.buffers.onBufferActivate( () => this._onBufferChange.fire(this.active))
                    }
                    get active() {
                        if (this._core.buffers.active === this._core.buffers.normal)
                            return this.normal;
                        if (this._core.buffers.active === this._core.buffers.alt)
                            return this.alternate;
                        throw new Error("Active buffer is neither normal nor alternate")
                    }
                    get normal() {
                        return this._normal.init(this._core.buffers.normal)
                    }
                    get alternate() {
                        return this._alternate.init(this._core.buffers.alt)
                    }
                }
                a.BufferNamespaceApi = d
            }
            ,
            7975: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.ParserApi = void 0,
                a.ParserApi = class {
                    constructor(l) {
                        this._core = l
                    }
                    registerCsiHandler(l, c) {
                        return this._core.registerCsiHandler(l, u => c(u.toArray()))
                    }
                    addCsiHandler(l, c) {
                        return this.registerCsiHandler(l, c)
                    }
                    registerDcsHandler(l, c) {
                        return this._core.registerDcsHandler(l, (u, h) => c(u, h.toArray()))
                    }
                    addDcsHandler(l, c) {
                        return this.registerDcsHandler(l, c)
                    }
                    registerEscHandler(l, c) {
                        return this._core.registerEscHandler(l, c)
                    }
                    addEscHandler(l, c) {
                        return this.registerEscHandler(l, c)
                    }
                    registerOscHandler(l, c) {
                        return this._core.registerOscHandler(l, c)
                    }
                    addOscHandler(l, c) {
                        return this.registerOscHandler(l, c)
                    }
                }
            }
            ,
            7090: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.UnicodeApi = void 0,
                a.UnicodeApi = class {
                    constructor(l) {
                        this._core = l
                    }
                    register(l) {
                        this._core.unicodeService.register(l)
                    }
                    get versions() {
                        return this._core.unicodeService.versions
                    }
                    get activeVersion() {
                        return this._core.unicodeService.activeVersion
                    }
                    set activeVersion(l) {
                        this._core.unicodeService.activeVersion = l
                    }
                }
            }
            ,
            744: function(o, a, l) {
                var c = this && this.__decorate || function(m, p, b, y) {
                    var x, E = arguments.length, w = E < 3 ? p : y === null ? y = Object.getOwnPropertyDescriptor(p, b) : y;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        w = Reflect.decorate(m, p, b, y);
                    else
                        for (var A = m.length - 1; A >= 0; A--)
                            (x = m[A]) && (w = (E < 3 ? x(w) : E > 3 ? x(p, b, w) : x(p, b)) || w);
                    return E > 3 && w && Object.defineProperty(p, b, w),
                    w
                }
                  , u = this && this.__param || function(m, p) {
                    return function(b, y) {
                        p(b, y, m)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.BufferService = a.MINIMUM_ROWS = a.MINIMUM_COLS = void 0;
                const h = l(8460)
                  , d = l(844)
                  , f = l(5295)
                  , g = l(2585);
                a.MINIMUM_COLS = 2,
                a.MINIMUM_ROWS = 1;
                let _ = a.BufferService = class extends d.Disposable {
                    get buffer() {
                        return this.buffers.active
                    }
                    constructor(m) {
                        super(),
                        this.isUserScrolling = !1,
                        this._onResize = this.register(new h.EventEmitter),
                        this.onResize = this._onResize.event,
                        this._onScroll = this.register(new h.EventEmitter),
                        this.onScroll = this._onScroll.event,
                        this.cols = Math.max(m.rawOptions.cols || 0, a.MINIMUM_COLS),
                        this.rows = Math.max(m.rawOptions.rows || 0, a.MINIMUM_ROWS),
                        this.buffers = this.register(new f.BufferSet(m,this))
                    }
                    resize(m, p) {
                        this.cols = m,
                        this.rows = p,
                        this.buffers.resize(m, p),
                        this._onResize.fire({
                            cols: m,
                            rows: p
                        })
                    }
                    reset() {
                        this.buffers.reset(),
                        this.isUserScrolling = !1
                    }
                    scroll(m, p=!1) {
                        const b = this.buffer;
                        let y;
                        y = this._cachedBlankLine,
                        y && y.length === this.cols && y.getFg(0) === m.fg && y.getBg(0) === m.bg || (y = b.getBlankLine(m, p),
                        this._cachedBlankLine = y),
                        y.isWrapped = p;
                        const x = b.ybase + b.scrollTop
                          , E = b.ybase + b.scrollBottom;
                        if (b.scrollTop === 0) {
                            const w = b.lines.isFull;
                            E === b.lines.length - 1 ? w ? b.lines.recycle().copyFrom(y) : b.lines.push(y.clone()) : b.lines.splice(E + 1, 0, y.clone()),
                            w ? this.isUserScrolling && (b.ydisp = Math.max(b.ydisp - 1, 0)) : (b.ybase++,
                            this.isUserScrolling || b.ydisp++)
                        } else {
                            const w = E - x + 1;
                            b.lines.shiftElements(x + 1, w - 1, -1),
                            b.lines.set(E, y.clone())
                        }
                        this.isUserScrolling || (b.ydisp = b.ybase),
                        this._onScroll.fire(b.ydisp)
                    }
                    scrollLines(m, p, b) {
                        const y = this.buffer;
                        if (m < 0) {
                            if (y.ydisp === 0)
                                return;
                            this.isUserScrolling = !0
                        } else
                            m + y.ydisp >= y.ybase && (this.isUserScrolling = !1);
                        const x = y.ydisp;
                        y.ydisp = Math.max(Math.min(y.ydisp + m, y.ybase), 0),
                        x !== y.ydisp && (p || this._onScroll.fire(y.ydisp))
                    }
                }
                ;
                a.BufferService = _ = c([u(0, g.IOptionsService)], _)
            },
            7994: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CharsetService = void 0,
                a.CharsetService = class {
                    constructor() {
                        this.glevel = 0,
                        this._charsets = []
                    }
                    reset() {
                        this.charset = void 0,
                        this._charsets = [],
                        this.glevel = 0
                    }
                    setgLevel(l) {
                        this.glevel = l,
                        this.charset = this._charsets[l]
                    }
                    setgCharset(l, c) {
                        this._charsets[l] = c,
                        this.glevel === l && (this.charset = c)
                    }
                }
            }
            ,
            1753: function(o, a, l) {
                var c = this && this.__decorate || function(y, x, E, w) {
                    var A, C = arguments.length, k = C < 3 ? x : w === null ? w = Object.getOwnPropertyDescriptor(x, E) : w;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        k = Reflect.decorate(y, x, E, w);
                    else
                        for (var I = y.length - 1; I >= 0; I--)
                            (A = y[I]) && (k = (C < 3 ? A(k) : C > 3 ? A(x, E, k) : A(x, E)) || k);
                    return C > 3 && k && Object.defineProperty(x, E, k),
                    k
                }
                  , u = this && this.__param || function(y, x) {
                    return function(E, w) {
                        x(E, w, y)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CoreMouseService = void 0;
                const h = l(2585)
                  , d = l(8460)
                  , f = l(844)
                  , g = {
                    NONE: {
                        events: 0,
                        restrict: () => !1
                    },
                    X10: {
                        events: 1,
                        restrict: y => y.button !== 4 && y.action === 1 && (y.ctrl = !1,
                        y.alt = !1,
                        y.shift = !1,
                        !0)
                    },
                    VT200: {
                        events: 19,
                        restrict: y => y.action !== 32
                    },
                    DRAG: {
                        events: 23,
                        restrict: y => y.action !== 32 || y.button !== 3
                    },
                    ANY: {
                        events: 31,
                        restrict: y => !0
                    }
                };
                function _(y, x) {
                    let E = (y.ctrl ? 16 : 0) | (y.shift ? 4 : 0) | (y.alt ? 8 : 0);
                    return y.button === 4 ? (E |= 64,
                    E |= y.action) : (E |= 3 & y.button,
                    4 & y.button && (E |= 64),
                    8 & y.button && (E |= 128),
                    y.action === 32 ? E |= 32 : y.action !== 0 || x || (E |= 3)),
                    E
                }
                const m = String.fromCharCode
                  , p = {
                    DEFAULT: y => {
                        const x = [_(y, !1) + 32, y.col + 32, y.row + 32];
                        return x[0] > 255 || x[1] > 255 || x[2] > 255 ? "" : `\x1B[M${m(x[0])}${m(x[1])}${m(x[2])}`
                    }
                    ,
                    SGR: y => {
                        const x = y.action === 0 && y.button !== 4 ? "m" : "M";
                        return `\x1B[<${_(y, !0)};${y.col};${y.row}${x}`
                    }
                    ,
                    SGR_PIXELS: y => {
                        const x = y.action === 0 && y.button !== 4 ? "m" : "M";
                        return `\x1B[<${_(y, !0)};${y.x};${y.y}${x}`
                    }
                };
                let b = a.CoreMouseService = class extends f.Disposable {
                    constructor(y, x) {
                        super(),
                        this._bufferService = y,
                        this._coreService = x,
                        this._protocols = {},
                        this._encodings = {},
                        this._activeProtocol = "",
                        this._activeEncoding = "",
                        this._lastEvent = null,
                        this._onProtocolChange = this.register(new d.EventEmitter),
                        this.onProtocolChange = this._onProtocolChange.event;
                        for (const E of Object.keys(g))
                            this.addProtocol(E, g[E]);
                        for (const E of Object.keys(p))
                            this.addEncoding(E, p[E]);
                        this.reset()
                    }
                    addProtocol(y, x) {
                        this._protocols[y] = x
                    }
                    addEncoding(y, x) {
                        this._encodings[y] = x
                    }
                    get activeProtocol() {
                        return this._activeProtocol
                    }
                    get areMouseEventsActive() {
                        return this._protocols[this._activeProtocol].events !== 0
                    }
                    set activeProtocol(y) {
                        if (!this._protocols[y])
                            throw new Error(`unknown protocol "${y}"`);
                        this._activeProtocol = y,
                        this._onProtocolChange.fire(this._protocols[y].events)
                    }
                    get activeEncoding() {
                        return this._activeEncoding
                    }
                    set activeEncoding(y) {
                        if (!this._encodings[y])
                            throw new Error(`unknown encoding "${y}"`);
                        this._activeEncoding = y
                    }
                    reset() {
                        this.activeProtocol = "NONE",
                        this.activeEncoding = "DEFAULT",
                        this._lastEvent = null
                    }
                    triggerMouseEvent(y) {
                        if (y.col < 0 || y.col >= this._bufferService.cols || y.row < 0 || y.row >= this._bufferService.rows || y.button === 4 && y.action === 32 || y.button === 3 && y.action !== 32 || y.button !== 4 && (y.action === 2 || y.action === 3) || (y.col++,
                        y.row++,
                        y.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, y, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(y))
                            return !1;
                        const x = this._encodings[this._activeEncoding](y);
                        return x && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(x) : this._coreService.triggerDataEvent(x, !0)),
                        this._lastEvent = y,
                        !0
                    }
                    explainEvents(y) {
                        return {
                            down: !!(1 & y),
                            up: !!(2 & y),
                            drag: !!(4 & y),
                            move: !!(8 & y),
                            wheel: !!(16 & y)
                        }
                    }
                    _equalEvents(y, x, E) {
                        if (E) {
                            if (y.x !== x.x || y.y !== x.y)
                                return !1
                        } else if (y.col !== x.col || y.row !== x.row)
                            return !1;
                        return y.button === x.button && y.action === x.action && y.ctrl === x.ctrl && y.alt === x.alt && y.shift === x.shift
                    }
                }
                ;
                a.CoreMouseService = b = c([u(0, h.IBufferService), u(1, h.ICoreService)], b)
            },
            6975: function(o, a, l) {
                var c = this && this.__decorate || function(b, y, x, E) {
                    var w, A = arguments.length, C = A < 3 ? y : E === null ? E = Object.getOwnPropertyDescriptor(y, x) : E;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        C = Reflect.decorate(b, y, x, E);
                    else
                        for (var k = b.length - 1; k >= 0; k--)
                            (w = b[k]) && (C = (A < 3 ? w(C) : A > 3 ? w(y, x, C) : w(y, x)) || C);
                    return A > 3 && C && Object.defineProperty(y, x, C),
                    C
                }
                  , u = this && this.__param || function(b, y) {
                    return function(x, E) {
                        y(x, E, b)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.CoreService = void 0;
                const h = l(1439)
                  , d = l(8460)
                  , f = l(844)
                  , g = l(2585)
                  , _ = Object.freeze({
                    insertMode: !1
                })
                  , m = Object.freeze({
                    applicationCursorKeys: !1,
                    applicationKeypad: !1,
                    bracketedPasteMode: !1,
                    origin: !1,
                    reverseWraparound: !1,
                    sendFocus: !1,
                    wraparound: !0
                });
                let p = a.CoreService = class extends f.Disposable {
                    constructor(b, y, x) {
                        super(),
                        this._bufferService = b,
                        this._logService = y,
                        this._optionsService = x,
                        this.isCursorInitialized = !1,
                        this.isCursorHidden = !1,
                        this._onData = this.register(new d.EventEmitter),
                        this.onData = this._onData.event,
                        this._onUserInput = this.register(new d.EventEmitter),
                        this.onUserInput = this._onUserInput.event,
                        this._onBinary = this.register(new d.EventEmitter),
                        this.onBinary = this._onBinary.event,
                        this._onRequestScrollToBottom = this.register(new d.EventEmitter),
                        this.onRequestScrollToBottom = this._onRequestScrollToBottom.event,
                        this.modes = (0,
                        h.clone)(_),
                        this.decPrivateModes = (0,
                        h.clone)(m)
                    }
                    reset() {
                        this.modes = (0,
                        h.clone)(_),
                        this.decPrivateModes = (0,
                        h.clone)(m)
                    }
                    triggerDataEvent(b, y=!1) {
                        if (this._optionsService.rawOptions.disableStdin)
                            return;
                        const x = this._bufferService.buffer;
                        y && this._optionsService.rawOptions.scrollOnUserInput && x.ybase !== x.ydisp && this._onRequestScrollToBottom.fire(),
                        y && this._onUserInput.fire(),
                        this._logService.debug(`sending data "${b}"`, () => b.split("").map(E => E.charCodeAt(0))),
                        this._onData.fire(b)
                    }
                    triggerBinaryEvent(b) {
                        this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${b}"`, () => b.split("").map(y => y.charCodeAt(0))),
                        this._onBinary.fire(b))
                    }
                }
                ;
                a.CoreService = p = c([u(0, g.IBufferService), u(1, g.ILogService), u(2, g.IOptionsService)], p)
            },
            9074: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.DecorationService = void 0;
                const c = l(8055)
                  , u = l(8460)
                  , h = l(844)
                  , d = l(6106);
                let f = 0
                  , g = 0;
                class _ extends h.Disposable {
                    get decorations() {
                        return this._decorations.values()
                    }
                    constructor() {
                        super(),
                        this._decorations = new d.SortedList(b => b?.marker.line),
                        this._onDecorationRegistered = this.register(new u.EventEmitter),
                        this.onDecorationRegistered = this._onDecorationRegistered.event,
                        this._onDecorationRemoved = this.register(new u.EventEmitter),
                        this.onDecorationRemoved = this._onDecorationRemoved.event,
                        this.register((0,
                        h.toDisposable)( () => this.reset()))
                    }
                    registerDecoration(b) {
                        if (b.marker.isDisposed)
                            return;
                        const y = new m(b);
                        if (y) {
                            const x = y.marker.onDispose( () => y.dispose());
                            y.onDispose( () => {
                                y && (this._decorations.delete(y) && this._onDecorationRemoved.fire(y),
                                x.dispose())
                            }
                            ),
                            this._decorations.insert(y),
                            this._onDecorationRegistered.fire(y)
                        }
                        return y
                    }
                    reset() {
                        for (const b of this._decorations.values())
                            b.dispose();
                        this._decorations.clear()
                    }
                    *getDecorationsAtCell(b, y, x) {
                        let E = 0
                          , w = 0;
                        for (const A of this._decorations.getKeyIterator(y))
                            E = A.options.x ?? 0,
                            w = E + (A.options.width ?? 1),
                            b >= E && b < w && (!x || (A.options.layer ?? "bottom") === x) && (yield A)
                    }
                    forEachDecorationAtCell(b, y, x, E) {
                        this._decorations.forEachByKey(y, w => {
                            f = w.options.x ?? 0,
                            g = f + (w.options.width ?? 1),
                            b >= f && b < g && (!x || (w.options.layer ?? "bottom") === x) && E(w)
                        }
                        )
                    }
                }
                a.DecorationService = _;
                class m extends h.Disposable {
                    get isDisposed() {
                        return this._isDisposed
                    }
                    get backgroundColorRGB() {
                        return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = c.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0),
                        this._cachedBg
                    }
                    get foregroundColorRGB() {
                        return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = c.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0),
                        this._cachedFg
                    }
                    constructor(b) {
                        super(),
                        this.options = b,
                        this.onRenderEmitter = this.register(new u.EventEmitter),
                        this.onRender = this.onRenderEmitter.event,
                        this._onDispose = this.register(new u.EventEmitter),
                        this.onDispose = this._onDispose.event,
                        this._cachedBg = null,
                        this._cachedFg = null,
                        this.marker = b.marker,
                        this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full")
                    }
                    dispose() {
                        this._onDispose.fire(),
                        super.dispose()
                    }
                }
            }
            ,
            4348: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.InstantiationService = a.ServiceCollection = void 0;
                const c = l(2585)
                  , u = l(8343);
                class h {
                    constructor(...f) {
                        this._entries = new Map;
                        for (const [g,_] of f)
                            this.set(g, _)
                    }
                    set(f, g) {
                        const _ = this._entries.get(f);
                        return this._entries.set(f, g),
                        _
                    }
                    forEach(f) {
                        for (const [g,_] of this._entries.entries())
                            f(g, _)
                    }
                    has(f) {
                        return this._entries.has(f)
                    }
                    get(f) {
                        return this._entries.get(f)
                    }
                }
                a.ServiceCollection = h,
                a.InstantiationService = class {
                    constructor() {
                        this._services = new h,
                        this._services.set(c.IInstantiationService, this)
                    }
                    setService(d, f) {
                        this._services.set(d, f)
                    }
                    getService(d) {
                        return this._services.get(d)
                    }
                    createInstance(d, ...f) {
                        const g = (0,
                        u.getServiceDependencies)(d).sort( (p, b) => p.index - b.index)
                          , _ = [];
                        for (const p of g) {
                            const b = this._services.get(p.id);
                            if (!b)
                                throw new Error(`[createInstance] ${d.name} depends on UNKNOWN service ${p.id}.`);
                            _.push(b)
                        }
                        const m = g.length > 0 ? g[0].index : f.length;
                        if (f.length !== m)
                            throw new Error(`[createInstance] First service dependency of ${d.name} at position ${m + 1} conflicts with ${f.length} static arguments`);
                        return new d(...f,..._)
                    }
                }
            }
            ,
            7866: function(o, a, l) {
                var c = this && this.__decorate || function(m, p, b, y) {
                    var x, E = arguments.length, w = E < 3 ? p : y === null ? y = Object.getOwnPropertyDescriptor(p, b) : y;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        w = Reflect.decorate(m, p, b, y);
                    else
                        for (var A = m.length - 1; A >= 0; A--)
                            (x = m[A]) && (w = (E < 3 ? x(w) : E > 3 ? x(p, b, w) : x(p, b)) || w);
                    return E > 3 && w && Object.defineProperty(p, b, w),
                    w
                }
                  , u = this && this.__param || function(m, p) {
                    return function(b, y) {
                        p(b, y, m)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.traceCall = a.setTraceLogger = a.LogService = void 0;
                const h = l(844)
                  , d = l(2585)
                  , f = {
                    trace: d.LogLevelEnum.TRACE,
                    debug: d.LogLevelEnum.DEBUG,
                    info: d.LogLevelEnum.INFO,
                    warn: d.LogLevelEnum.WARN,
                    error: d.LogLevelEnum.ERROR,
                    off: d.LogLevelEnum.OFF
                };
                let g, _ = a.LogService = class extends h.Disposable {
                    get logLevel() {
                        return this._logLevel
                    }
                    constructor(m) {
                        super(),
                        this._optionsService = m,
                        this._logLevel = d.LogLevelEnum.OFF,
                        this._updateLogLevel(),
                        this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())),
                        g = this
                    }
                    _updateLogLevel() {
                        this._logLevel = f[this._optionsService.rawOptions.logLevel]
                    }
                    _evalLazyOptionalParams(m) {
                        for (let p = 0; p < m.length; p++)
                            typeof m[p] == "function" && (m[p] = m[p]())
                    }
                    _log(m, p, b) {
                        this._evalLazyOptionalParams(b),
                        m.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + p, ...b)
                    }
                    trace(m, ...p) {
                        this._logLevel <= d.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, m, p)
                    }
                    debug(m, ...p) {
                        this._logLevel <= d.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, m, p)
                    }
                    info(m, ...p) {
                        this._logLevel <= d.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, m, p)
                    }
                    warn(m, ...p) {
                        this._logLevel <= d.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, m, p)
                    }
                    error(m, ...p) {
                        this._logLevel <= d.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, m, p)
                    }
                }
                ;
                a.LogService = _ = c([u(0, d.IOptionsService)], _),
                a.setTraceLogger = function(m) {
                    g = m
                }
                ,
                a.traceCall = function(m, p, b) {
                    if (typeof b.value != "function")
                        throw new Error("not supported");
                    const y = b.value;
                    b.value = function(...x) {
                        if (g.logLevel !== d.LogLevelEnum.TRACE)
                            return y.apply(this, x);
                        g.trace(`GlyphRenderer#${y.name}(${x.map(w => JSON.stringify(w)).join(", ")})`);
                        const E = y.apply(this, x);
                        return g.trace(`GlyphRenderer#${y.name} return`, E),
                        E
                    }
                }
            },
            7302: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.OptionsService = a.DEFAULT_OPTIONS = void 0;
                const c = l(8460)
                  , u = l(844)
                  , h = l(6114);
                a.DEFAULT_OPTIONS = {
                    cols: 80,
                    rows: 24,
                    cursorBlink: !1,
                    cursorStyle: "block",
                    cursorWidth: 1,
                    cursorInactiveStyle: "outline",
                    customGlyphs: !0,
                    drawBoldTextInBrightColors: !0,
                    documentOverride: null,
                    fastScrollModifier: "alt",
                    fastScrollSensitivity: 5,
                    fontFamily: "courier-new, courier, monospace",
                    fontSize: 15,
                    fontWeight: "normal",
                    fontWeightBold: "bold",
                    ignoreBracketedPasteMode: !1,
                    lineHeight: 1,
                    letterSpacing: 0,
                    linkHandler: null,
                    logLevel: "info",
                    logger: null,
                    scrollback: 1e3,
                    scrollOnUserInput: !0,
                    scrollSensitivity: 1,
                    screenReaderMode: !1,
                    smoothScrollDuration: 0,
                    macOptionIsMeta: !1,
                    macOptionClickForcesSelection: !1,
                    minimumContrastRatio: 1,
                    disableStdin: !1,
                    allowProposedApi: !1,
                    allowTransparency: !1,
                    tabStopWidth: 8,
                    theme: {},
                    rescaleOverlappingGlyphs: !1,
                    rightClickSelectsWord: h.isMac,
                    windowOptions: {},
                    windowsMode: !1,
                    windowsPty: {},
                    wordSeparator: " ()[]{}',\"`",
                    altClickMovesCursor: !0,
                    convertEol: !1,
                    termName: "xterm",
                    cancelEvents: !1,
                    overviewRulerWidth: 0
                };
                const d = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
                class f extends u.Disposable {
                    constructor(_) {
                        super(),
                        this._onOptionChange = this.register(new c.EventEmitter),
                        this.onOptionChange = this._onOptionChange.event;
                        const m = {
                            ...a.DEFAULT_OPTIONS
                        };
                        for (const p in _)
                            if (p in m)
                                try {
                                    const b = _[p];
                                    m[p] = this._sanitizeAndValidateOption(p, b)
                                } catch (b) {
                                    console.error(b)
                                }
                        this.rawOptions = m,
                        this.options = {
                            ...m
                        },
                        this._setupOptions(),
                        this.register((0,
                        u.toDisposable)( () => {
                            this.rawOptions.linkHandler = null,
                            this.rawOptions.documentOverride = null
                        }
                        ))
                    }
                    onSpecificOptionChange(_, m) {
                        return this.onOptionChange(p => {
                            p === _ && m(this.rawOptions[_])
                        }
                        )
                    }
                    onMultipleOptionChange(_, m) {
                        return this.onOptionChange(p => {
                            _.indexOf(p) !== -1 && m()
                        }
                        )
                    }
                    _setupOptions() {
                        const _ = p => {
                            if (!(p in a.DEFAULT_OPTIONS))
                                throw new Error(`No option with key "${p}"`);
                            return this.rawOptions[p]
                        }
                          , m = (p, b) => {
                            if (!(p in a.DEFAULT_OPTIONS))
                                throw new Error(`No option with key "${p}"`);
                            b = this._sanitizeAndValidateOption(p, b),
                            this.rawOptions[p] !== b && (this.rawOptions[p] = b,
                            this._onOptionChange.fire(p))
                        }
                        ;
                        for (const p in this.rawOptions) {
                            const b = {
                                get: _.bind(this, p),
                                set: m.bind(this, p)
                            };
                            Object.defineProperty(this.options, p, b)
                        }
                    }
                    _sanitizeAndValidateOption(_, m) {
                        switch (_) {
                        case "cursorStyle":
                            if (m || (m = a.DEFAULT_OPTIONS[_]),
                            !function(p) {
                                return p === "block" || p === "underline" || p === "bar"
                            }(m))
                                throw new Error(`"${m}" is not a valid value for ${_}`);
                            break;
                        case "wordSeparator":
                            m || (m = a.DEFAULT_OPTIONS[_]);
                            break;
                        case "fontWeight":
                        case "fontWeightBold":
                            if (typeof m == "number" && 1 <= m && m <= 1e3)
                                break;
                            m = d.includes(m) ? m : a.DEFAULT_OPTIONS[_];
                            break;
                        case "cursorWidth":
                            m = Math.floor(m);
                        case "lineHeight":
                        case "tabStopWidth":
                            if (m < 1)
                                throw new Error(`${_} cannot be less than 1, value: ${m}`);
                            break;
                        case "minimumContrastRatio":
                            m = Math.max(1, Math.min(21, Math.round(10 * m) / 10));
                            break;
                        case "scrollback":
                            if ((m = Math.min(m, 4294967295)) < 0)
                                throw new Error(`${_} cannot be less than 0, value: ${m}`);
                            break;
                        case "fastScrollSensitivity":
                        case "scrollSensitivity":
                            if (m <= 0)
                                throw new Error(`${_} cannot be less than or equal to 0, value: ${m}`);
                            break;
                        case "rows":
                        case "cols":
                            if (!m && m !== 0)
                                throw new Error(`${_} must be numeric, value: ${m}`);
                            break;
                        case "windowsPty":
                            m = m ?? {}
                        }
                        return m
                    }
                }
                a.OptionsService = f
            }
            ,
            2660: function(o, a, l) {
                var c = this && this.__decorate || function(f, g, _, m) {
                    var p, b = arguments.length, y = b < 3 ? g : m === null ? m = Object.getOwnPropertyDescriptor(g, _) : m;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        y = Reflect.decorate(f, g, _, m);
                    else
                        for (var x = f.length - 1; x >= 0; x--)
                            (p = f[x]) && (y = (b < 3 ? p(y) : b > 3 ? p(g, _, y) : p(g, _)) || y);
                    return b > 3 && y && Object.defineProperty(g, _, y),
                    y
                }
                  , u = this && this.__param || function(f, g) {
                    return function(_, m) {
                        g(_, m, f)
                    }
                }
                ;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.OscLinkService = void 0;
                const h = l(2585);
                let d = a.OscLinkService = class {
                    constructor(f) {
                        this._bufferService = f,
                        this._nextId = 1,
                        this._entriesWithId = new Map,
                        this._dataByLinkId = new Map
                    }
                    registerLink(f) {
                        const g = this._bufferService.buffer;
                        if (f.id === void 0) {
                            const x = g.addMarker(g.ybase + g.y)
                              , E = {
                                data: f,
                                id: this._nextId++,
                                lines: [x]
                            };
                            return x.onDispose( () => this._removeMarkerFromLink(E, x)),
                            this._dataByLinkId.set(E.id, E),
                            E.id
                        }
                        const _ = f
                          , m = this._getEntryIdKey(_)
                          , p = this._entriesWithId.get(m);
                        if (p)
                            return this.addLineToLink(p.id, g.ybase + g.y),
                            p.id;
                        const b = g.addMarker(g.ybase + g.y)
                          , y = {
                            id: this._nextId++,
                            key: this._getEntryIdKey(_),
                            data: _,
                            lines: [b]
                        };
                        return b.onDispose( () => this._removeMarkerFromLink(y, b)),
                        this._entriesWithId.set(y.key, y),
                        this._dataByLinkId.set(y.id, y),
                        y.id
                    }
                    addLineToLink(f, g) {
                        const _ = this._dataByLinkId.get(f);
                        if (_ && _.lines.every(m => m.line !== g)) {
                            const m = this._bufferService.buffer.addMarker(g);
                            _.lines.push(m),
                            m.onDispose( () => this._removeMarkerFromLink(_, m))
                        }
                    }
                    getLinkData(f) {
                        return this._dataByLinkId.get(f)?.data
                    }
                    _getEntryIdKey(f) {
                        return `${f.id};;${f.uri}`
                    }
                    _removeMarkerFromLink(f, g) {
                        const _ = f.lines.indexOf(g);
                        _ !== -1 && (f.lines.splice(_, 1),
                        f.lines.length === 0 && (f.data.id !== void 0 && this._entriesWithId.delete(f.key),
                        this._dataByLinkId.delete(f.id)))
                    }
                }
                ;
                a.OscLinkService = d = c([u(0, h.IBufferService)], d)
            },
            8343: (o, a) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.createDecorator = a.getServiceDependencies = a.serviceRegistry = void 0;
                const l = "di$target"
                  , c = "di$dependencies";
                a.serviceRegistry = new Map,
                a.getServiceDependencies = function(u) {
                    return u[c] || []
                }
                ,
                a.createDecorator = function(u) {
                    if (a.serviceRegistry.has(u))
                        return a.serviceRegistry.get(u);
                    const h = function(d, f, g) {
                        if (arguments.length !== 3)
                            throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
                        (function(_, m, p) {
                            m[l] === m ? m[c].push({
                                id: _,
                                index: p
                            }) : (m[c] = [{
                                id: _,
                                index: p
                            }],
                            m[l] = m)
                        }
                        )(h, d, g)
                    };
                    return h.toString = () => u,
                    a.serviceRegistry.set(u, h),
                    h
                }
            }
            ,
            2585: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.IDecorationService = a.IUnicodeService = a.IOscLinkService = a.IOptionsService = a.ILogService = a.LogLevelEnum = a.IInstantiationService = a.ICharsetService = a.ICoreService = a.ICoreMouseService = a.IBufferService = void 0;
                const c = l(8343);
                var u;
                a.IBufferService = (0,
                c.createDecorator)("BufferService"),
                a.ICoreMouseService = (0,
                c.createDecorator)("CoreMouseService"),
                a.ICoreService = (0,
                c.createDecorator)("CoreService"),
                a.ICharsetService = (0,
                c.createDecorator)("CharsetService"),
                a.IInstantiationService = (0,
                c.createDecorator)("InstantiationService"),
                function(h) {
                    h[h.TRACE = 0] = "TRACE",
                    h[h.DEBUG = 1] = "DEBUG",
                    h[h.INFO = 2] = "INFO",
                    h[h.WARN = 3] = "WARN",
                    h[h.ERROR = 4] = "ERROR",
                    h[h.OFF = 5] = "OFF"
                }(u || (a.LogLevelEnum = u = {})),
                a.ILogService = (0,
                c.createDecorator)("LogService"),
                a.IOptionsService = (0,
                c.createDecorator)("OptionsService"),
                a.IOscLinkService = (0,
                c.createDecorator)("OscLinkService"),
                a.IUnicodeService = (0,
                c.createDecorator)("UnicodeService"),
                a.IDecorationService = (0,
                c.createDecorator)("DecorationService")
            }
            ,
            1480: (o, a, l) => {
                Object.defineProperty(a, "__esModule", {
                    value: !0
                }),
                a.UnicodeService = void 0;
                const c = l(8460)
                  , u = l(225);
                class h {
                    static extractShouldJoin(f) {
                        return (1 & f) != 0
                    }
                    static extractWidth(f) {
                        return f >> 1 & 3
                    }
                    static extractCharKind(f) {
                        return f >> 3
                    }
                    static createPropertyValue(f, g, _=!1) {
                        return (16777215 & f) << 3 | (3 & g) << 1 | (_ ? 1 : 0)
                    }
                    constructor() {
                        this._providers = Object.create(null),
                        this._active = "",
                        this._onChange = new c.EventEmitter,
                        this.onChange = this._onChange.event;
                        const f = new u.UnicodeV6;
                        this.register(f),
                        this._active = f.version,
                        this._activeProvider = f
                    }
                    dispose() {
                        this._onChange.dispose()
                    }
                    get versions() {
                        return Object.keys(this._providers)
                    }
                    get activeVersion() {
                        return this._active
                    }
                    set activeVersion(f) {
                        if (!this._providers[f])
                            throw new Error(`unknown Unicode version "${f}"`);
                        this._active = f,
                        this._activeProvider = this._providers[f],
                        this._onChange.fire(f)
                    }
                    register(f) {
                        this._providers[f.version] = f
                    }
                    wcwidth(f) {
                        return this._activeProvider.wcwidth(f)
                    }
                    getStringCellWidth(f) {
                        let g = 0
                          , _ = 0;
                        const m = f.length;
                        for (let p = 0; p < m; ++p) {
                            let b = f.charCodeAt(p);
                            if (55296 <= b && b <= 56319) {
                                if (++p >= m)
                                    return g + this.wcwidth(b);
                                const E = f.charCodeAt(p);
                                56320 <= E && E <= 57343 ? b = 1024 * (b - 55296) + E - 56320 + 65536 : g += this.wcwidth(E)
                            }
                            const y = this.charProperties(b, _);
                            let x = h.extractWidth(y);
                            h.extractShouldJoin(y) && (x -= h.extractWidth(_)),
                            g += x,
                            _ = y
                        }
                        return g
                    }
                    charProperties(f, g) {
                        return this._activeProvider.charProperties(f, g)
                    }
                }
                a.UnicodeService = h
            }
        }
          , r = {};
        function i(o) {
            var a = r[o];
            if (a !== void 0)
                return a.exports;
            var l = r[o] = {
                exports: {}
            };
            return n[o].call(l.exports, l, l.exports, i),
            l.exports
        }
        var s = {};
        return ( () => {
            var o = s;
            Object.defineProperty(o, "__esModule", {
                value: !0
            }),
            o.Terminal = void 0;
            const a = i(9042)
              , l = i(3236)
              , c = i(844)
              , u = i(5741)
              , h = i(8285)
              , d = i(7975)
              , f = i(7090)
              , g = ["cols", "rows"];
            class _ extends c.Disposable {
                constructor(p) {
                    super(),
                    this._core = this.register(new l.Terminal(p)),
                    this._addonManager = this.register(new u.AddonManager),
                    this._publicOptions = {
                        ...this._core.options
                    };
                    const b = x => this._core.options[x]
                      , y = (x, E) => {
                        this._checkReadonlyOptions(x),
                        this._core.options[x] = E
                    }
                    ;
                    for (const x in this._core.options) {
                        const E = {
                            get: b.bind(this, x),
                            set: y.bind(this, x)
                        };
                        Object.defineProperty(this._publicOptions, x, E)
                    }
                }
                _checkReadonlyOptions(p) {
                    if (g.includes(p))
                        throw new Error(`Option "${p}" can only be set in the constructor`)
                }
                _checkProposedApi() {
                    if (!this._core.optionsService.rawOptions.allowProposedApi)
                        throw new Error("You must set the allowProposedApi option to true to use proposed API")
                }
                get onBell() {
                    return this._core.onBell
                }
                get onBinary() {
                    return this._core.onBinary
                }
                get onCursorMove() {
                    return this._core.onCursorMove
                }
                get onData() {
                    return this._core.onData
                }
                get onKey() {
                    return this._core.onKey
                }
                get onLineFeed() {
                    return this._core.onLineFeed
                }
                get onRender() {
                    return this._core.onRender
                }
                get onResize() {
                    return this._core.onResize
                }
                get onScroll() {
                    return this._core.onScroll
                }
                get onSelectionChange() {
                    return this._core.onSelectionChange
                }
                get onTitleChange() {
                    return this._core.onTitleChange
                }
                get onWriteParsed() {
                    return this._core.onWriteParsed
                }
                get element() {
                    return this._core.element
                }
                get parser() {
                    return this._parser || (this._parser = new d.ParserApi(this._core)),
                    this._parser
                }
                get unicode() {
                    return this._checkProposedApi(),
                    new f.UnicodeApi(this._core)
                }
                get textarea() {
                    return this._core.textarea
                }
                get rows() {
                    return this._core.rows
                }
                get cols() {
                    return this._core.cols
                }
                get buffer() {
                    return this._buffer || (this._buffer = this.register(new h.BufferNamespaceApi(this._core))),
                    this._buffer
                }
                get markers() {
                    return this._checkProposedApi(),
                    this._core.markers
                }
                get modes() {
                    const p = this._core.coreService.decPrivateModes;
                    let b = "none";
                    switch (this._core.coreMouseService.activeProtocol) {
                    case "X10":
                        b = "x10";
                        break;
                    case "VT200":
                        b = "vt200";
                        break;
                    case "DRAG":
                        b = "drag";
                        break;
                    case "ANY":
                        b = "any"
                    }
                    return {
                        applicationCursorKeysMode: p.applicationCursorKeys,
                        applicationKeypadMode: p.applicationKeypad,
                        bracketedPasteMode: p.bracketedPasteMode,
                        insertMode: this._core.coreService.modes.insertMode,
                        mouseTrackingMode: b,
                        originMode: p.origin,
                        reverseWraparoundMode: p.reverseWraparound,
                        sendFocusMode: p.sendFocus,
                        wraparoundMode: p.wraparound
                    }
                }
                get options() {
                    return this._publicOptions
                }
                set options(p) {
                    for (const b in p)
                        this._publicOptions[b] = p[b]
                }
                blur() {
                    this._core.blur()
                }
                focus() {
                    this._core.focus()
                }
                input(p, b=!0) {
                    this._core.input(p, b)
                }
                resize(p, b) {
                    this._verifyIntegers(p, b),
                    this._core.resize(p, b)
                }
                open(p) {
                    this._core.open(p)
                }
                attachCustomKeyEventHandler(p) {
                    this._core.attachCustomKeyEventHandler(p)
                }
                attachCustomWheelEventHandler(p) {
                    this._core.attachCustomWheelEventHandler(p)
                }
                registerLinkProvider(p) {
                    return this._core.registerLinkProvider(p)
                }
                registerCharacterJoiner(p) {
                    return this._checkProposedApi(),
                    this._core.registerCharacterJoiner(p)
                }
                deregisterCharacterJoiner(p) {
                    this._checkProposedApi(),
                    this._core.deregisterCharacterJoiner(p)
                }
                registerMarker(p=0) {
                    return this._verifyIntegers(p),
                    this._core.registerMarker(p)
                }
                registerDecoration(p) {
                    return this._checkProposedApi(),
                    this._verifyPositiveIntegers(p.x ?? 0, p.width ?? 0, p.height ?? 0),
                    this._core.registerDecoration(p)
                }
                hasSelection() {
                    return this._core.hasSelection()
                }
                select(p, b, y) {
                    this._verifyIntegers(p, b, y),
                    this._core.select(p, b, y)
                }
                getSelection() {
                    return this._core.getSelection()
                }
                getSelectionPosition() {
                    return this._core.getSelectionPosition()
                }
                clearSelection() {
                    this._core.clearSelection()
                }
                selectAll() {
                    this._core.selectAll()
                }
                selectLines(p, b) {
                    this._verifyIntegers(p, b),
                    this._core.selectLines(p, b)
                }
                dispose() {
                    super.dispose()
                }
                scrollLines(p) {
                    this._verifyIntegers(p),
                    this._core.scrollLines(p)
                }
                scrollPages(p) {
                    this._verifyIntegers(p),
                    this._core.scrollPages(p)
                }
                scrollToTop() {
                    this._core.scrollToTop()
                }
                scrollToBottom() {
                    this._core.scrollToBottom()
                }
                scrollToLine(p) {
                    this._verifyIntegers(p),
                    this._core.scrollToLine(p)
                }
                clear() {
                    this._core.clear()
                }
                write(p, b) {
                    this._core.write(p, b)
                }
                writeln(p, b) {
                    this._core.write(p),
                    this._core.write(`\r
`, b)
                }
                paste(p) {
                    this._core.paste(p)
                }
                refresh(p, b) {
                    this._verifyIntegers(p, b),
                    this._core.refresh(p, b)
                }
                reset() {
                    this._core.reset()
                }
                clearTextureAtlas() {
                    this._core.clearTextureAtlas()
                }
                loadAddon(p) {
                    this._addonManager.loadAddon(this, p)
                }
                static get strings() {
                    return a
                }
                _verifyIntegers(...p) {
                    for (const b of p)
                        if (b === 1 / 0 || isNaN(b) || b % 1 != 0)
                            throw new Error("This API only accepts integers")
                }
                _verifyPositiveIntegers(...p) {
                    for (const b of p)
                        if (b && (b === 1 / 0 || isNaN(b) || b % 1 != 0 || b < 0))
                            throw new Error("This API only accepts positive integers")
                }
            }
            o.Terminal = _
        }
        )(),
        s
    }
    )())
}
)(TL);
var Rre = TL.exports;
const Ire = /^var\((--[^)]+)\)$/;
function kL(t) {
    const e = getComputedStyle(document.documentElement)
      , n = {
        cursor: "var(--bolt-elements-terminal-cursorColor)",
        cursorAccent: "var(--bolt-elements-terminal-cursorColorAccent)",
        foreground: "var(--bolt-elements-terminal-textColor)",
        background: "var(--bolt-elements-terminal-backgroundColor)",
        selectionBackground: "var(--bolt-elements-terminal-selection-backgroundColor)",
        selectionForeground: "var(--bolt-elements-terminal-selection-textColor)",
        selectionInactiveBackground: "var(--bolt-elements-terminal-selection-backgroundColorInactive)",
        black: "var(--bolt-elements-terminal-color-black)",
        red: "var(--bolt-elements-terminal-color-red)",
        green: "var(--bolt-elements-terminal-color-green)",
        yellow: "var(--bolt-elements-terminal-color-yellow)",
        blue: "var(--bolt-elements-terminal-color-blue)",
        magenta: "var(--bolt-elements-terminal-color-magenta)",
        cyan: "var(--bolt-elements-terminal-color-cyan)",
        white: "var(--bolt-elements-terminal-color-white)",
        brightBlack: "var(--bolt-elements-terminal-color-brightBlack)",
        brightRed: "var(--bolt-elements-terminal-color-brightRed)",
        brightGreen: "var(--bolt-elements-terminal-color-brightGreen)",
        brightYellow: "var(--bolt-elements-terminal-color-brightYellow)",
        brightBlue: "var(--bolt-elements-terminal-color-brightBlue)",
        brightMagenta: "var(--bolt-elements-terminal-color-brightMagenta)",
        brightCyan: "var(--bolt-elements-terminal-color-brightCyan)",
        brightWhite: "var(--bolt-elements-terminal-color-brightWhite)",
        ...t
    };
    return Object.fromEntries(Object.entries(n).flatMap( ([r,i]) => {
        if (typeof i == "string") {
            const [,s] = i.match(Ire) ?? [];
            if (s) {
                const o = s && e.getPropertyValue(s);
                if (!o)
                    return [];
                i = o
            }
        }
        return [[r, i]]
    }
    ))
}
const Pre = nr("Terminal")
  , d1 = S.memo(S.forwardRef( ({className: t, theme: e, children: n, readonly: r, webLinks: i=!0}, s) => {
    const o = S.useRef(null)
      , a = S.useRef()
      , l = Ie(da);
    return S.useEffect( () => {
        const c = o.current
          , {terminal: u, dispose: h} = Dre({
            parent: c,
            readonly: r,
            webLinks: i
        });
        return a.current = u,
        Pre.debug("Attach terminal"),
        h
    }
    , []),
    S.useEffect( () => {
        const c = a.current;
        c && (requestAnimationFrame( () => {
            c.options.theme = kL({
                ...r && {
                    cursor: "#00000000"
                },
                ...e
            })
        }
        ),
        c.options.disableStdin = r)
    }
    , [l, e, r]),
    S.useEffect( () => {
        const c = a.current;
        c && typeof n == "string" && (c.clear(),
        c.write(n))
    }
    , [n]),
    S.useImperativeHandle(s, () => ({
        get instance() {
            return a.current
        }
    }), []),
    v.jsx("div", {
        className: t,
        ref: o
    })
}
));
function Dre({readonly: t, webLinks: e, parent: n}) {
    const r = new Are.FitAddon
      , i = new Rre.Terminal({
        cursorBlink: !0,
        convertEol: !0,
        disableStdin: t,
        theme: kL(t ? {
            cursor: "#00000000"
        } : {}),
        fontSize: 12,
        fontFamily: "Menlo, courier-new, courier, monospace"
    });
    i.loadAddon(r),
    e && i.loadAddon(new kre.WebLinksAddon),
    i.open(n);
    const s = new ResizeObserver( () => {
        r.fit()
    }
    );
    return s.observe(n),
    {
        terminal: i,
        dispose: () => {
            s.disconnect(),
            i.dispose()
        }
    }
}
function Lre({scrollToBottom: t, ...e}) {
    return v.jsxs("div", {
        className: "flex flex-col gap-2",
        children: [v.jsxs("div", {
            className: "flex items-center gap-1",
            children: [v.jsx("div", {
                className: "text-lg i-ph:x text-bolt-elements-icon-error"
            }), "Command failed"]
        }), v.jsx(Dm, {
            defaultOpen: !1,
            toggleButton: "small",
            titleClassName: "flex-col",
            scrollToBottom: t,
            title: v.jsx(tP, {
                className: "[&>pre]:px-4 [&>pre]:py-5",
                code: e.command
            }),
            children: v.jsx(d1, {
                className: "grow-1 h-[150px]",
                readonly: !0,
                children: e.output
            })
        })]
    })
}
function Ore(t, e="0px") {
    const [n,r] = S.useState(!1);
    return S.useEffect( () => {
        const i = new IntersectionObserver( ([s]) => {
            r(s.isIntersecting)
        }
        ,{
            rootMargin: e
        });
        return t.current && i.observe(t.current),
        () => i.disconnect()
    }
    , [e]),
    n
}
let Nre = (t, e=21) => (n=e) => {
    let r = ""
      , i = n;
    for (; i--; )
        r += t[Math.random() * t.length | 0];
    return r
}
;
var Kl = {
    exports: {}
};
const Mre = typeof Qf < "u"
  , fC = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/
  , pC = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function RL(t, e, n) {
    n == null && e !== null && typeof e == "object" && (n = e,
    e = void 0),
    Mre && Qf.isBuffer(t) && (t = t.toString()),
    t && t.charCodeAt(0) === 65279 && (t = t.slice(1));
    const r = JSON.parse(t, e);
    if (r === null || typeof r != "object")
        return r;
    const i = n && n.protoAction || "error"
      , s = n && n.constructorAction || "error";
    if (i === "ignore" && s === "ignore")
        return r;
    if (i !== "ignore" && s !== "ignore") {
        if (fC.test(t) === !1 && pC.test(t) === !1)
            return r
    } else if (i !== "ignore" && s === "ignore") {
        if (fC.test(t) === !1)
            return r
    } else if (pC.test(t) === !1)
        return r;
    return IL(r, {
        protoAction: i,
        constructorAction: s,
        safe: n && n.safe
    })
}
function IL(t, {protoAction: e="error", constructorAction: n="error", safe: r}={}) {
    let i = [t];
    for (; i.length; ) {
        const s = i;
        i = [];
        for (const o of s) {
            if (e !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
                if (r === !0)
                    return null;
                if (e === "error")
                    throw new SyntaxError("Object contains forbidden prototype property");
                delete o.__proto__
            }
            if (n !== "ignore" && Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype")) {
                if (r === !0)
                    return null;
                if (n === "error")
                    throw new SyntaxError("Object contains forbidden prototype property");
                delete o.constructor
            }
            for (const a in o) {
                const l = o[a];
                l && typeof l == "object" && i.push(l)
            }
        }
    }
    return t
}
function f1(t, e, n) {
    const r = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
        return RL(t, e, n)
    } finally {
        Error.stackTraceLimit = r
    }
}
function Bre(t, e) {
    const n = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
        return RL(t, e, {
            safe: !0
        })
    } catch {
        return null
    } finally {
        Error.stackTraceLimit = n
    }
}
Kl.exports = f1;
Kl.exports.default = f1;
Kl.exports.parse = f1;
Kl.exports.safeParse = Bre;
Kl.exports.scan = IL;
var Fre = Kl.exports;
const mC = Eh(Fre);
var jre = ({prefix: t="", length: e=7, alphabet: n="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"}={}) => {
    const r = Nre(n, e);
    return () => `${t}${r()}`
}
  , Gh = jre()
  , Hre = function t(e, n) {
    if (e === n)
        return !0;
    if (e && n && typeof e == "object" && typeof n == "object") {
        if (e.constructor !== n.constructor)
            return !1;
        var r, i, s;
        if (Array.isArray(e)) {
            if (r = e.length,
            r != n.length)
                return !1;
            for (i = r; i-- !== 0; )
                if (!t(e[i], n[i]))
                    return !1;
            return !0
        }
        if (e.constructor === RegExp)
            return e.source === n.source && e.flags === n.flags;
        if (e.valueOf !== Object.prototype.valueOf)
            return e.valueOf() === n.valueOf();
        if (e.toString !== Object.prototype.toString)
            return e.toString() === n.toString();
        if (s = Object.keys(e),
        r = s.length,
        r !== Object.keys(n).length)
            return !1;
        for (i = r; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(n, s[i]))
                return !1;
        for (i = r; i-- !== 0; ) {
            var o = s[i];
            if (!t(e[o], n[o]))
                return !1
        }
        return !0
    }
    return e !== e && n !== n
};
const p1 = Eh(Hre);
function Ure({onlyFirst: t=!1}={}) {
    const e = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(e,t ? void 0 : "g")
}
const Vre = Ure();
function $re(t) {
    if (typeof t != "string")
        throw new TypeError(`Expected a \`string\`, got \`${typeof t}\``);
    return t.replace(Vre, "")
}
const zre = [Mo.UncaughtException, Mo.UnhandledRejection, Mo.ConsoleError];
function Id({problems: t=[], id: e=Gh(), resolved: n=!1}={}) {
    return {
        type: "problems",
        id: e,
        status: "unsent",
        problems: t,
        content: Wre(t),
        resolved: n,
        role: "user"
    }
}
function Wre(t) {
    return `The following errors occurred; if any of them are important based on the artifacts source code, then please fix them and make sure they never happen again for the user:

${qre(t)}`
}
const Gre = ["message", "count", "port", "pathname", "search", "hash"];
function qre(t) {
    return PL(t).map(n => {
        const r = Xre(n)
          , i = Yre(n).map( ([o,a]) => `${o}=${JSON.stringify(a)}`).join(" ")
          , s = cb(n);
        return `<${r} ${i}>
${s}
</${r}>`
    }
    ).join(`
`)
}
function Kre(t, e) {
    return t.type !== e.type ? !1 : t.type === "preview" && e.type === "preview" ? t.error.type !== e.error.type || t.error.stack !== e.error.stack ? !1 : t.error.type === Mo.ConsoleError && e.error.type === Mo.ConsoleError ? p1(t.error.args, e.error.args) : !0 : t.type === "shell" && e.type === "shell" ? cb(t) === cb(e) && t.exitCode === e.exitCode : !1
}
function PL(t) {
    const e = [];
    for (const n of t) {
        const r = e.find(i => Kre(n, i));
        r && r.type !== "shell" ? r.count++ : e.push({
            ...n,
            count: 1
        })
    }
    return e
}
function Yre(t) {
    if (t.type === "shell")
        return [["command", t.command], ["exit_code", t.exitCode]];
    const {error: e} = t;
    return Gre.map(n => n in e ? [n, e[n]] : null).filter(n => !!n)
}
function Xre(t) {
    return t.type === "shell" ? "shell_terminated" : t.error.type.toLowerCase().replace("preview_", "")
}
function cb(t) {
    if (t.type === "shell")
        return $re(t.output).trim();
    const {error: e} = t;
    return e.type === Mo.ConsoleError ? JSON.stringify(e.args) : e.stack
}
const Qre = "_StickyPotentialErrors_y32cp_1"
  , Jre = {
    StickyPotentialErrors: Qre
};
function Zre({problems: t, resolved: e, className: n, messageBoxHeight: r=0, isLast: i, consecutiveProblemCount: s, clearProblems: o, resolve: a, onStickyHeight: l, scrollToBottom: c, ...u}) {
    const h = S.useRef()
      , d = Ore(h, `0px 0px -${r}px 0px`)
      , f = S.useMemo( () => PL(t), [t])
      , [g,_] = S.useState(!1)
      , [m,p] = S.useState(!1)
      , [b,y] = S.useState(0)
      , x = S.useCallback(async I => {
        I && i && await c({
            animation: {
                mass: .9
            }
        }),
        _(I)
    }
    , [])
      , E = S.useMemo( () => new ResizeObserver( ([I]) => {
        y(I.contentRect.height)
    }
    ), [])
      , w = S.useCallback(I => {
        E.disconnect(),
        I ? E.observe(I) : y(0),
        h.current = I ?? void 0
    }
    , [])
      , A = i && !g && !e;
    S.useLayoutEffect( () => {
        l(A ? b && b + 14 : 0)
    }
    , [b, A]);
    const C = f.length > 1 ? "problems" : "problem"
      , k = () => m ? `Bolt is resolving the ${C}` : e ? `Bolt has resolved the ${C}.` : i ? `Potential ${C} detected.` : "May already be resolved or irrelevant.";
    return v.jsx(It.div, {
        ref: w,
        initial: !1,
        animate: {
            paddingTop: A ? "0.5rem" : "0px",
            paddingBottom: A ? "1rem" : "0px",
            marginBottom: A ? "-2.75rem" : "0px",
            paddingLeft: A ? "1.5rem" : "2.5rem",
            paddingRight: A ? "1.5rem" : "2.5rem"
        },
        transition: {
            duration: .2,
            ease: hv
        },
        className: be("potential-problems", {
            sticky: A,
            [Jre.StickyPotentialErrors]: A
        }, "bg-bolt-elements-background-depth-1", n),
        style: {
            bottom: r,
            background: A ? "linear-gradient(to bottom, transparent 0px, var(--bolt-elements-bg-depth-1) 38px)" : "none"
        },
        ...u,
        children: v.jsxs("div", {
            className: be("gap-3 flex flex-col p-4 w-full rounded-[calc(0.75rem-1px)] bg-bolt-elements-messages-background relative before:content-[''] before:pointer-events-none before:absolute overflow-hidden before:inset-0 before:border-bolt-elements-messages-error-borderColor", {
                "before:border-l-3": i && !e
            }),
            children: [v.jsxs("h4", {
                className: "flex items-center gap-2 text-bolt-elements-textPrimary font-medium text-sm",
                children: [v.jsx("div", {
                    className: be("text-lg", {
                        "i-svg-spinners:90-ring-with-bg text-bolt-elements-loader-progress": m,
                        "i-ph:check text-bolt-elements-icon-success": !m && e,
                        "i-ph:warning": !m && !e,
                        "text-bolt-elements-icon-error": i && !e
                    })
                }), k()]
            }), v.jsx(Dm, {
                title: v.jsxs("div", {
                    className: "flex items-center gap-2.5 p-3 grow text-bolt-elements-textPrimary leading-5 text-sm",
                    children: [v.jsx(SL, {
                        onChange: () => {
                            d || x(!1)
                        }
                        ,
                        children: t.length
                    }), g ? "Hide" : "Show", " ", C]
                }),
                titleClassName: "bg-bolt-elements-artifacts-background",
                open: g,
                scrollToBottom: c,
                onClick: () => x(!g),
                onToggle: x,
                toggleButton: "small",
                children: v.jsx("div", {
                    className: "flex flex-col gap-4 p-5 text-left bg-bolt-elements-artifacts-background",
                    children: f.map( (I, N) => v.jsx(S.Suspense, {
                        fallback: null,
                        children: I.type === "preview" ? v.jsx(Tre, {
                            ...I
                        }) : v.jsx(Lre, {
                            scrollToBottom: c,
                            ...I
                        })
                    }, N))
                })
            }), i && !e && v.jsxs("div", {
                className: "flex flex-col gap-2 justify-between",
                children: [v.jsx("div", {
                    className: "text-bolt-elements-textSecondary text-sm",
                    children: s >= 5 ? `Bolt tried to fix problems ${s} times but failed. To prevent spending more tokens, you might want to try to fix them manually or rollback to a previous checkpoint instead.` : `Should we try to fix ${f.length > 1 ? "these" : "this"}?`
                }), v.jsxs("div", {
                    className: "flex gap-2.5",
                    children: [a && v.jsxs(qi, {
                        variant: "secondary",
                        size: "sm",
                        onClick: () => {
                            c?.(),
                            x(!1),
                            p(!0),
                            a().finally( () => {
                                p(!1)
                            }
                            )
                        }
                        ,
                        children: ["Fix ", C]
                    }), v.jsx(qi, {
                        variant: "secondary",
                        size: "sm",
                        onClick: () => {
                            l(0),
                            o?.()
                        }
                        ,
                        children: "Clear"
                    })]
                })]
            })]
        })
    })
}
const DL = S.memo( ({className: t, backgroundColor: e="bg-white", textColor: n="text-bolt-elements-textSecondary", avatar: r}) => v.jsx("div", {
    className: be("flex select-none items-center justify-center size-8 overflow-hidden rounded-full shrink-0 self-start", e, n, t),
    children: r ? v.jsx("img", {
        className: "w-full h-full object-cover",
        src: r
    }) : v.jsx("div", {
        className: "i-ph:user-fill text-xl"
    })
}))
  , LL = "%[a-f0-9]{2}"
  , gC = new RegExp("(" + LL + ")|([^%]+?)","gi")
  , _C = new RegExp("(" + LL + ")+","gi");
function ub(t, e) {
    try {
        return [decodeURIComponent(t.join(""))]
    } catch {}
    if (t.length === 1)
        return t;
    e = e || 1;
    const n = t.slice(0, e)
      , r = t.slice(e);
    return Array.prototype.concat.call([], ub(n), ub(r))
}
function eie(t) {
    try {
        return decodeURIComponent(t)
    } catch {
        let e = t.match(gC) || [];
        for (let n = 1; n < e.length; n++)
            t = ub(e, n).join(""),
            e = t.match(gC) || [];
        return t
    }
}
function tie(t) {
    const e = {
        "%FE%FF": "",
        "%FF%FE": ""
    };
    let n = _C.exec(t);
    for (; n; ) {
        try {
            e[n[0]] = decodeURIComponent(n[0])
        } catch {
            const i = eie(n[0]);
            i !== n[0] && (e[n[0]] = i)
        }
        n = _C.exec(t)
    }
    e["%C2"] = "";
    const r = Object.keys(e);
    for (const i of r)
        t = t.replace(new RegExp(i,"g"), e[i]);
    return t
}
function nie(t) {
    if (typeof t != "string")
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
    try {
        return decodeURIComponent(t)
    } catch {
        return tie(t)
    }
}
function rie(t, e) {
    const n = {};
    if (Array.isArray(e))
        for (const r of e) {
            const i = Object.getOwnPropertyDescriptor(t, r);
            i?.enumerable && Object.defineProperty(n, r, i)
        }
    else
        for (const r of Reflect.ownKeys(t)) {
            const i = Object.getOwnPropertyDescriptor(t, r);
            if (i.enumerable) {
                const s = t[r];
                e(r, s, t) && Object.defineProperty(n, r, i)
            }
        }
    return n
}
function OL(t, e) {
    if (!(typeof t == "string" && typeof e == "string"))
        throw new TypeError("Expected the arguments to be of type `string`");
    if (t === "" || e === "")
        return [];
    const n = t.indexOf(e);
    return n === -1 ? [] : [t.slice(0, n), t.slice(n + e.length)]
}
const iie = t => t == null
  , sie = t => encodeURIComponent(t).replaceAll(/[!'()*]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`)
  , hb = Symbol("encodeFragmentIdentifier");
function oie(t) {
    switch (t.arrayFormat) {
    case "index":
        return e => (n, r) => {
            const i = n.length;
            return r === void 0 || t.skipNull && r === null || t.skipEmptyString && r === "" ? n : r === null ? [...n, [zt(e, t), "[", i, "]"].join("")] : [...n, [zt(e, t), "[", zt(i, t), "]=", zt(r, t)].join("")]
        }
        ;
    case "bracket":
        return e => (n, r) => r === void 0 || t.skipNull && r === null || t.skipEmptyString && r === "" ? n : r === null ? [...n, [zt(e, t), "[]"].join("")] : [...n, [zt(e, t), "[]=", zt(r, t)].join("")];
    case "colon-list-separator":
        return e => (n, r) => r === void 0 || t.skipNull && r === null || t.skipEmptyString && r === "" ? n : r === null ? [...n, [zt(e, t), ":list="].join("")] : [...n, [zt(e, t), ":list=", zt(r, t)].join("")];
    case "comma":
    case "separator":
    case "bracket-separator":
        {
            const e = t.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return n => (r, i) => i === void 0 || t.skipNull && i === null || t.skipEmptyString && i === "" ? r : (i = i === null ? "" : i,
            r.length === 0 ? [[zt(n, t), e, zt(i, t)].join("")] : [[r, zt(i, t)].join(t.arrayFormatSeparator)])
        }
    default:
        return e => (n, r) => r === void 0 || t.skipNull && r === null || t.skipEmptyString && r === "" ? n : r === null ? [...n, zt(e, t)] : [...n, [zt(e, t), "=", zt(r, t)].join("")]
    }
}
function aie(t) {
    let e;
    switch (t.arrayFormat) {
    case "index":
        return (n, r, i) => {
            if (e = /\[(\d*)]$/.exec(n),
            n = n.replace(/\[\d*]$/, ""),
            !e) {
                i[n] = r;
                return
            }
            i[n] === void 0 && (i[n] = {}),
            i[n][e[1]] = r
        }
        ;
    case "bracket":
        return (n, r, i) => {
            if (e = /(\[])$/.exec(n),
            n = n.replace(/\[]$/, ""),
            !e) {
                i[n] = r;
                return
            }
            if (i[n] === void 0) {
                i[n] = [r];
                return
            }
            i[n] = [...i[n], r]
        }
        ;
    case "colon-list-separator":
        return (n, r, i) => {
            if (e = /(:list)$/.exec(n),
            n = n.replace(/:list$/, ""),
            !e) {
                i[n] = r;
                return
            }
            if (i[n] === void 0) {
                i[n] = [r];
                return
            }
            i[n] = [...i[n], r]
        }
        ;
    case "comma":
    case "separator":
        return (n, r, i) => {
            const s = typeof r == "string" && r.includes(t.arrayFormatSeparator)
              , o = typeof r == "string" && !s && Ui(r, t).includes(t.arrayFormatSeparator);
            r = o ? Ui(r, t) : r;
            const a = s || o ? r.split(t.arrayFormatSeparator).map(l => Ui(l, t)) : r === null ? r : Ui(r, t);
            i[n] = a
        }
        ;
    case "bracket-separator":
        return (n, r, i) => {
            const s = /(\[])$/.test(n);
            if (n = n.replace(/\[]$/, ""),
            !s) {
                i[n] = r && Ui(r, t);
                return
            }
            const o = r === null ? [] : r.split(t.arrayFormatSeparator).map(a => Ui(a, t));
            if (i[n] === void 0) {
                i[n] = o;
                return
            }
            i[n] = [...i[n], ...o]
        }
        ;
    default:
        return (n, r, i) => {
            if (i[n] === void 0) {
                i[n] = r;
                return
            }
            i[n] = [...[i[n]].flat(), r]
        }
    }
}
function NL(t) {
    if (typeof t != "string" || t.length !== 1)
        throw new TypeError("arrayFormatSeparator must be single character string")
}
function zt(t, e) {
    return e.encode ? e.strict ? sie(t) : encodeURIComponent(t) : t
}
function Ui(t, e) {
    return e.decode ? nie(t) : t
}
function ML(t) {
    return Array.isArray(t) ? t.sort() : typeof t == "object" ? ML(Object.keys(t)).sort( (e, n) => Number(e) - Number(n)).map(e => t[e]) : t
}
function BL(t) {
    const e = t.indexOf("#");
    return e !== -1 && (t = t.slice(0, e)),
    t
}
function lie(t) {
    let e = "";
    const n = t.indexOf("#");
    return n !== -1 && (e = t.slice(n)),
    e
}
function bC(t, e, n) {
    return n === "string" && typeof t == "string" ? t : typeof n == "function" && typeof t == "string" ? n(t) : e.parseBooleans && t !== null && (t.toLowerCase() === "true" || t.toLowerCase() === "false") ? t.toLowerCase() === "true" : n === "number" && !Number.isNaN(Number(t)) && typeof t == "string" && t.trim() !== "" || e.parseNumbers && !Number.isNaN(Number(t)) && typeof t == "string" && t.trim() !== "" ? Number(t) : t
}
function m1(t) {
    t = BL(t);
    const e = t.indexOf("?");
    return e === -1 ? "" : t.slice(e + 1)
}
function g1(t, e) {
    e = {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
        types: Object.create(null),
        ...e
    },
    NL(e.arrayFormatSeparator);
    const n = aie(e)
      , r = Object.create(null);
    if (typeof t != "string" || (t = t.trim().replace(/^[?#&]/, ""),
    !t))
        return r;
    for (const i of t.split("&")) {
        if (i === "")
            continue;
        const s = e.decode ? i.replaceAll("+", " ") : i;
        let[o,a] = OL(s, "=");
        o === void 0 && (o = s),
        a = a === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(e.arrayFormat) ? a : Ui(a, e),
        n(Ui(o, e), a, r)
    }
    for (const [i,s] of Object.entries(r))
        if (typeof s == "object" && s !== null && e.types[i] !== "string")
            for (const [o,a] of Object.entries(s)) {
                const l = e.types[i] ? e.types[i].replace("[]", "") : void 0;
                s[o] = bC(a, e, l)
            }
        else
            typeof s == "object" && s !== null && e.types[i] === "string" ? r[i] = Object.values(s).join(e.arrayFormatSeparator) : r[i] = bC(s, e, e.types[i]);
    return e.sort === !1 ? r : (e.sort === !0 ? Object.keys(r).sort() : Object.keys(r).sort(e.sort)).reduce( (i, s) => {
        const o = r[s];
        return i[s] = o && typeof o == "object" && !Array.isArray(o) ? ML(o) : o,
        i
    }
    , Object.create(null))
}
function FL(t, e) {
    if (!t)
        return "";
    e = {
        encode: !0,
        strict: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        ...e
    },
    NL(e.arrayFormatSeparator);
    const n = o => e.skipNull && iie(t[o]) || e.skipEmptyString && t[o] === ""
      , r = oie(e)
      , i = {};
    for (const [o,a] of Object.entries(t))
        n(o) || (i[o] = a);
    const s = Object.keys(i);
    return e.sort !== !1 && s.sort(e.sort),
    s.map(o => {
        const a = t[o];
        return a === void 0 ? "" : a === null ? zt(o, e) : Array.isArray(a) ? a.length === 0 && e.arrayFormat === "bracket-separator" ? zt(o, e) + "[]" : a.reduce(r(o), []).join("&") : zt(o, e) + "=" + zt(a, e)
    }
    ).filter(o => o.length > 0).join("&")
}
function jL(t, e) {
    e = {
        decode: !0,
        ...e
    };
    let[n,r] = OL(t, "#");
    return n === void 0 && (n = t),
    {
        url: n?.split("?")?.[0] ?? "",
        query: g1(m1(t), e),
        ...e && e.parseFragmentIdentifier && r ? {
            fragmentIdentifier: Ui(r, e)
        } : {}
    }
}
function HL(t, e) {
    e = {
        encode: !0,
        strict: !0,
        [hb]: !0,
        ...e
    };
    const n = BL(t.url).split("?")[0] || ""
      , r = m1(t.url)
      , i = {
        ...g1(r, {
            sort: !1
        }),
        ...t.query
    };
    let s = FL(i, e);
    s &&= `?${s}`;
    let o = lie(t.url);
    if (typeof t.fragmentIdentifier == "string") {
        const a = new URL(n);
        a.hash = t.fragmentIdentifier,
        o = e[hb] ? a.hash : `#${t.fragmentIdentifier}`
    }
    return `${n}${s}${o}`
}
function UL(t, e, n) {
    n = {
        parseFragmentIdentifier: !0,
        [hb]: !1,
        ...n
    };
    const {url: r, query: i, fragmentIdentifier: s} = jL(t, n);
    return HL({
        url: r,
        query: rie(i, e),
        fragmentIdentifier: s
    }, n)
}
function cie(t, e, n) {
    const r = Array.isArray(e) ? i => !e.includes(i) : (i, s) => !e(i, s);
    return UL(t, r, n)
}
const uie = Object.freeze(Object.defineProperty({
    __proto__: null,
    exclude: cie,
    extract: m1,
    parse: g1,
    parseUrl: jL,
    pick: UL,
    stringify: FL,
    stringifyUrl: HL
}, Symbol.toStringTag, {
    value: "Module"
}));
function hie() {
    const t = navigator.userAgent;
    let e = navigator.appName, n = "" + parseFloat(navigator.appVersion), r = parseInt(navigator.appVersion, 10), i, s, o;
    (s = t.indexOf("Opera")) != -1 ? (e = "Opera",
    n = t.substring(s + 6),
    (s = t.indexOf("Version")) != -1 && (n = t.substring(s + 8))) : (s = t.indexOf("MSIE")) != -1 ? (e = "Microsoft Internet Explorer",
    n = t.substring(s + 5)) : (s = t.indexOf("Chrome")) != -1 ? (e = "Chrome",
    n = t.substring(s + 7)) : (s = t.indexOf("Safari")) != -1 ? (e = "Safari",
    n = t.substring(s + 7),
    (s = t.indexOf("Version")) != -1 && (n = t.substring(s + 8))) : (s = t.indexOf("Firefox")) != -1 ? (e = "Firefox",
    n = t.substring(s + 8)) : (i = t.lastIndexOf(" ") + 1) < (s = t.lastIndexOf("/")) && (e = t.substring(i, s),
    n = t.substring(s + 1),
    e.toLowerCase() == e.toUpperCase() && (e = navigator.appName)),
    (o = n.indexOf(";")) != -1 && (n = n.substring(0, o)),
    (o = n.indexOf(" ")) != -1 && (n = n.substring(0, o)),
    r = parseInt("" + n, 10),
    isNaN(r) && (n = "" + parseFloat(navigator.appVersion),
    r = parseInt(navigator.appVersion, 10));
    const a = window.performance?.memory
      , l = a ? {
        totalJSHeapSize: a.totalJSHeapSize,
        usedJSHeapSize: a.usedJSHeapSize,
        jsHeapSizeLimit: a.jsHeapSizeLimit
    } : void 0;
    return [`Browser name = ${e}`, `Full version = ${n}`, `Major version = ${r}`, `navigator.appName = ${navigator.appName}`, `navigator.userAgent = ${navigator.userAgent}`, `performance.memory = ${JSON.stringify(l, null, 2)}`].join(`
`)
}
function die(t) {
    const e = "https://github.com/stackblitz/bolt.new/issues/new"
      , n = ["bug"]
      , r = [hie()];
    t?.webcontainerVersion && r.push(`WebContainer version = ${t.webcontainerVersion}`),
    t?.username && r.push(`Username = ${t.username}`),
    t?.conversationId && r.push(`Chat ID = ${t.conversationId}`);
    const i = r.join(`
`)
      , s = [];
    return t?.error && s.push(`Error:
\`\`\`
${t.error}
\`\`\``),
    fie(e, "bug_report.yml", {
        labels: n,
        link: window.location.toString(),
        platform: `\`\`\`
${i}
\`\`\``,
        additional: s.join(`
`)
    })
}
function fie(t, e, n) {
    return `${t}?template=${e}&${uie.stringify(n, {
        arrayFormat: "comma"
    })}`
}
const pie = S.memo(Cr.forwardRef( (t, e) => {
    _r.trace("Messages");
    const {id: n, isStreaming: r=!1, isAtBottom: i=!0, messages: s=[], user: o, className: a, messageBoxHeight: l=0, onRollback: c, onUndo: u, scrollToBottom: h, resolveProblems: d, resubmit: f, clearProblems: g} = t
      , [_,m] = S.useState(0)
      , [p,b] = S.useState(!1)
      , [y,x] = S.useState(s.length === 0)
      , E = Ie(ea.snapshots)
      , w = Object.keys(E).length > 0
      , A = l + _;
    S.useEffect( () => {
        !r && !i && b(!0)
    }
    , [r]),
    S.useEffect( () => {
        i && setTimeout( () => b(!1), 150)
    }
    , [i]),
    S.useEffect( () => {
        s.length > 0 && x(!1)
    }
    , [s]);
    const C = S.useCallback(O => {
        window.open(die({
            conversationId: He.conversationId,
            username: o?.username,
            error: O.error?.message
        }), "_blank")
    }
    , [o])
      , k = s.reduce( (O, M) => M.role !== "user" ? O : M.type !== "problems" ? 0 : M.resolved ? O + 1 : O, 0)
      , I = s.findLastIndex( ({role: O, type: M}) => M === "chat" && O === "assistant")
      , N = O => {
        const M = s.findLast( (H, $) => $ < O && !!E[H.messageId ?? H.id]);
        M && u?.(M)
    }
    ;
    return v.jsxs(v.Fragment, {
        children: [v.jsxs("div", {
            id: n,
            ref: e,
            className: a,
            children: [y && s.length === 0 && v.jsx(sS, {}), s.map( (O, M) => {
                const {role: H} = O
                  , $ = H === "user"
                  , J = M === s.length - 1
                  , Q = O.experimental_attachments?.map(B => ({
                    url: `${location.origin}/api/upload/${encodeURIComponent(B.url)}`,
                    name: B.name,
                    contentType: B.contentType
                }))
                  , ee = $ ? O.status === "unsent" : O.status === "incomplete"
                  , D = M === I && !r || !$ && O.status === "incomplete"
                  , L = E[O.messageId ?? O.id] && !r && !J
                  , z = w && J && H === "assistant" && !r && s.findLast( ({id: B, messageId: Z}, se) => se < s.length - 1 && E[Z ?? B])
                  , V = O.error?.isRetryable ?? ee;
                return O.type === "problems" ? v.jsx(Zre, {
                    isLast: J,
                    consecutiveProblemCount: k,
                    resolved: O.resolved,
                    problems: O.problems,
                    clearProblems: g,
                    onStickyHeight: m,
                    scrollToBottom: h,
                    messageBoxHeight: l,
                    resolve: d
                }, O.id) : v.jsx("div", {
                    className: "relative flex flex-col mx-10 rounded-[calc(0.75rem-1px)]",
                    "data-message-id": O.id,
                    style: {
                        "--gradient-end": !$ && r && J ? "transparent" : "var(--bolt-elements-messages-background)",
                        transition: "--gradient-end 0.4s ease",
                        background: "linear-gradient(var(--bolt-elements-messages-background) max(calc(100% - 100vh), 30%), var(--gradient-end) 100%)"
                    },
                    children: v.jsxs("div", {
                        className: "rounded-[calc(0.75rem-1px)] overflow-hidden",
                        children: [O.content && v.jsxs("div", {
                            className: be("flex gap-4 p-6 w-full", {
                                "py-5": $
                            }),
                            children: [$ && v.jsx(DL, {
                                avatar: o?.avatar
                            }), v.jsx("div", {
                                className: "grid grid-col-1 w-full",
                                children: $ ? v.jsx(Ere, {
                                    attachments: Q,
                                    fileSelections: O.fileSelections,
                                    className: "py-1",
                                    content: O.input ?? O.content
                                }) : v.jsx(mne, {
                                    content: O.content,
                                    scrollToBottom: h
                                })
                            })]
                        }), ee && v.jsxs("div", {
                            className: be("flex px-[var(--chat-padding)] pt-4 pb-6 gap-2 items-center -mt-4 bg-gradient-to-t from-bolt-elements-messages-retryBackground from-30% to-transparent", {
                                "pt-6 mt-0": !O.content
                            }),
                            children: [v.jsx("div", {
                                className: "self-start mt-1 text-xl shrink-0 text-bolt-elements-icon-error i-ph:warning"
                            }), v.jsx("div", {
                                className: "py-1 text-sm text-bolt-elements-textPrimary h-full",
                                children: v.jsx(s1, {
                                    html: !0,
                                    children: O.error?.message ?? (O.status === "unsent" ? "This message was not sent." : "This message didn't complete its response.")
                                })
                            })]
                        }), (D || V || L) && v.jsxs("div", {
                            className: "absolute bottom-0 -right-2 translate-y-1/3 bg-bolt-elements-messages-actions-background border border-bolt-elements-borderColor rounded-lg p-0.5 flex gap-0.5",
                            children: [D && v.jsxs(tn, {
                                className: "flex gap-1 text-xs py-0.5",
                                onClick: () => C(O),
                                children: [v.jsx("div", {
                                    className: "i-ph:bug-beetle-duotone"
                                }), "Report Issue"]
                            }), (L || z) && v.jsxs(tn, {
                                className: "flex gap-1 text-xs py-0.5",
                                disabled: r,
                                onClick: () => {
                                    L ? c?.(O) : N(M)
                                }
                                ,
                                children: [v.jsx("div", {
                                    className: "i-ph:arrow-u-down-left-fill"
                                }), L ? "Rollback to Checkpoint" : "Undo"]
                            }), V && v.jsxs(tn, {
                                className: "flex gap-1 text-xs py-0.5",
                                disabled: r,
                                onClick: () => {
                                    f?.(O)
                                }
                                ,
                                children: [v.jsx("div", {
                                    className: "i-ph:arrow-counter-clockwise"
                                }), "Retry"]
                            })]
                        })]
                    })
                }, O.id)
            }
            ), v.jsx(sS, {
                spin: r,
                style: {
                    bottom: A
                }
            })]
        }), h && v.jsx(It.div, {
            className: "sticky h-0 mx-auto z-scroller",
            initial: !1,
            style: {
                bottom: 32 + A + (r ? 40 : 12)
            },
            transition: {
                duration: .1
            },
            animate: {
                opacity: i ? 0 : 1,
                translateY: i ? 32 : 0
            },
            children: v.jsx("button", {
                className: be("flex items-center justify-center size-8 rounded-full shadow shadow-bolt-elements-messages-scroller-shadow", {
                    "bg-bolt-elements-messages-scroller-background text-bolt-elements-messages-scroller-icon": !p,
                    "bg-bolt-elements-messages-scroller-finishedBackground text-bolt-elements-messages-scroller-finishedIcon": p
                }),
                onClick: () => h({
                    animation: {
                        damping: 1,
                        mass: 1.1
                    }
                }),
                children: v.jsx("div", {
                    className: "i-ph:arrow-down size-4.5"
                })
            })
        })]
    })
}
))
  , mie = S.memo( ({className: t, attachments: e=[], onRemoveAttachment: n}) => v.jsx("div", {
    className: t,
    children: v.jsx(hs, {
        children: e.map(r => v.jsx(It.div, {
            layoutId: r.id,
            exit: {
                opacity: 0
            },
            transition: {
                duration: .15
            },
            children: v.jsx(xL, {
                attachment: r,
                allowRemove: !0,
                showWarning: !0,
                onRemove: n
            })
        }, r.id))
    })
}))
  , gie = {
    duration: .2,
    ease: Ft
}
  , _ie = S.memo( ({hasAttachments: t}) => {
    const e = S.useRef(null)
      , n = Ie(me.lockedFiles)
      , r = Ie(me.targetedFiles)
      , [i,s] = S.useState(0)
      , o = S.useCallback( () => me.currentFileTreeView.set("focused"), []);
    S.useEffect( () => {
        e.current && s(e.current.getBoundingClientRect().height)
    }
    , []);
    const a = Object.keys(n).reduce( (h, d) => n[d]?.type === "file" ? h + 1 : h, 0)
      , l = Object.keys(r).reduce( (h, d) => r[d]?.type === "file" ? h + 1 : h, 0)
      , c = a > 0 || l > 0
      , u = `${a} file${a > 1 ? "s" : ""} ${a > 1 ? "are" : "is"} locked from AI changes`;
    return v.jsx(It.div, {
        transition: gie,
        animate: {
            height: c ? i : 0
        },
        initial: !1,
        className: be("border-b-px", {
            "bg-bolt-elements-background-depth-1": t,
            "border-bolt-elements-borderColor": t && !c,
            "border-transparent": !t || c,
            "relative -top-px": t && c
        }),
        children: v.jsx("div", {
            className: be("overflow-hidden h-full border-bolt-elements-borderColor relative bg-bolt-elements-background-depth-2 transition-opacity duration-200", {
                "rounded-t-[0.44rem]": !0,
                "border-px -left-px w-[calc(100%+2px)] h-[calc(100%+1px)]": t,
                "border-b-px left-0 right-0": !t,
                "opacity-0": !c,
                "opacity-100": c
            }),
            children: v.jsxs("div", {
                ref: e,
                className: "flex text-xs py-1.5 px-2.5 font-medium",
                children: [l > 0 && v.jsxs("div", {
                    children: ["AI changes limited to ", l, " file", l > 1 ? "s" : ""]
                }), l === 0 && a >= 1 && v.jsx("div", {
                    children: u
                }), v.jsx("div", {
                    className: "flex-grow"
                }), v.jsx("button", {
                    className: "bg-transparent text-bolt-elements-link hover:underline",
                    onClick: o,
                    children: "Update"
                })]
            })
        })
    })
}
)
  , Tc = {
    pro_1: {
        name: "Pro",
        namePrice: void 0,
        level: "pro_1"
    },
    pro_2: {
        name: "Pro",
        namePrice: "50",
        level: "pro_2"
    },
    pro_3: {
        name: "Pro",
        namePrice: "100",
        level: "pro_3"
    },
    pro_4: {
        name: "Pro",
        namePrice: "200",
        level: "pro_4"
    }
};
function bie() {
    He.subscribeDismissed.set(!0)
}
const yie = S.memo( () => {
    const t = S.useRef(null)
      , [e,n] = S.useState(0)
      , {tokenStats: r} = Fl()
      , i = Ie(He.tokenStats)
      , o = Ie(Kt.user) !== void 0
      , a = Ie(He.started)
      , l = Ie(He.subscribeDismissed);
    S.useEffect( () => {
        r && !He.tokenStats.get() && He.tokenStats.set(r),
        t.current && n(t.current.getBoundingClientRect().height - 1)
    }
    , [t.current]);
    const {closeToMax: c, period: u, remainingTokens: h=0} = xie(i)
      , d = a && !l && !!i && !!c
      , f = !!i?.nextTier
      , g = i?.nextTier?.type
      , _ = i?.nextTier?.level ?? 0
      , m = i?.nextTier ? Math.max(Math.floor(i.nextTier.limits.perDay / i.maxPerDay), Math.floor(i.nextTier.limits.perMonth / i.maxPerMonth)) : 1;
    return o ? v.jsx(It.div, {
        transition: {
            duration: .2,
            ease: Ft
        },
        animate: {
            height: d ? e : 0
        },
        className: "relative",
        children: v.jsxs("div", {
            ref: t,
            className: be("py-1 px-2 top-0 absolute left-2 w-[calc(100%-1rem)] transition-opacity duration-350 border border-bolt-elements-borderColor bg-bolt-elements-prompt-subscribeButton-background backdrop-blur rounded-t-lg text-xs truncate flex justify-between", {
                "opacity-0": !d,
                "opacity-100": d
            }),
            children: [h <= 0 ? v.jsx(v.Fragment, {
                children: "You've used all your remaining tokens."
            }) : v.jsxs(v.Fragment, {
                children: [vie(h), " ", f ? u : "", " tokens remaining."]
            }), f ? v.jsxs("button", {
                className: "bg-transparent font-medium inline-block mr-4 text-bolt-elements-link hover:underline",
                onClick: () => He.showPricingOverlay(),
                children: ["Subscribe to ", Eie(g, _), " for ", m, "x more usage"]
            }) : v.jsx(v.Fragment, {
                children: v.jsx("button", {
                    className: "bg-transparent font-medium inline-block mr-4 text-bolt-elements-link hover:underline",
                    onClick: () => He.showPricingOverlay(),
                    children: "Buy more"
                })
            }), v.jsx(tn, {
                onClick: bie,
                icon: "i-ph:x",
                size: "xs",
                className: "absolute top-1 right-1"
            })]
        })
    }) : null
}
);
function vie(t) {
    return typeof t > "u" ? "" : t >= 1e6 ? `${(t / 1e6).toFixed(1)}M` : t >= 1e3 ? `${Math.floor(t / 1e3)}K` : t.toString(10)
}
function xie(t) {
    if (!t)
        return {};
    const e = t.maxPerDay - t.totalToday
      , n = t.maxPerMonth - t.totalThisMonth
      , r = t.overflow.available - Math.min(t.overflow.used, t.overflow.available);
    return n < e ? {
        period: "monthly",
        closeToMax: n / t.maxPerMonth < .33,
        remainingTokens: t.maxPerMonth - Math.min(t.totalThisMonth, t.maxPerMonth) + r,
        maxTokens: t.maxPerMonth
    } : {
        period: "daily",
        closeToMax: e / t.maxPerDay < .33,
        remainingTokens: t.maxPerDay - Math.min(t.totalToday, t.maxPerDay) + r,
        maxTokens: t.maxPerDay
    }
}
function Eie(t, e) {
    if (!t)
        return;
    const {name: n, namePrice: r=""} = Tc[`${t}_${e}`] ?? {};
    return n ? `${n} ${r}` : `${t.charAt(0).toUpperCase()}${t.slice(1)}`
}
const Sie = ba(.4, 0, .2, 1);
function wie({show: t, isStreaming: e, onClick: n}) {
    return v.jsx(hs, {
        children: t ? v.jsx(It.button, {
            className: "absolute flex justify-center items-center top-[18px] right-[22px] p-1 bg-accent-500 hover:brightness-94 color-white rounded-md w-[34px] h-[34px] transition-theme",
            transition: {
                ease: Sie,
                duration: .17
            },
            initial: {
                opacity: 0,
                y: 10
            },
            animate: {
                opacity: 1,
                y: 0
            },
            exit: {
                opacity: 0,
                y: 10
            },
            onClick: r => {
                r.preventDefault(),
                n?.(r)
            }
            ,
            children: v.jsx("div", {
                className: "text-lg",
                children: e ? v.jsx("div", {
                    className: "i-ph:stop-circle-bold"
                }) : v.jsx("div", {
                    className: "i-ph:arrow-right"
                })
            })
        }) : null
    })
}
const Cie = {
    duration: .15,
    ease: Ft
}
  , Tie = S.memo( ({show: t, onDrop: e}) => {
    _r.trace("PromptDropZone");
    const [n,r] = S.useState(!1)
      , i = S.useRef(null)
      , s = S.useCallback(l => {
        l.preventDefault(),
        r(!0)
    }
    , [])
      , o = S.useCallback(l => {
        l.preventDefault(),
        i.current?.contains(l.relatedTarget) || r(!1)
    }
    , [])
      , a = S.useCallback(l => {
        l.preventDefault(),
        r(!1),
        e?.(l)
    }
    , [e]);
    return v.jsx(hs, {
        children: t && v.jsx(It.div, {
            className: "absolute rounded-lg inset-0 bg-bolt-elements-background-depth-1 z-2 p-3",
            initial: {
                opacity: 0
            },
            animate: {
                opacity: 1
            },
            transition: Cie,
            children: v.jsxs("div", {
                ref: i,
                className: be("flex flex-col items-center justify-center gap-1.5 w-full h-full border border-dashed rounded-lg p-4", {
                    "border-bolt-elements-borderColor bg-bolt-elements-prompt-background text-bolt-elements-textTertiary": !n,
                    "border-bolt-elements-borderColorActive bg-alpha-accent-10 text-accent-500": n
                }),
                onDragOver: s,
                onDragLeave: o,
                onDrop: a,
                children: [v.jsxs("div", {
                    className: "flex items-center gap-3",
                    children: [v.jsx("span", {
                        className: "i-ph:image text-xl -rotate-10 opacity-80"
                    }), v.jsx("span", {
                        className: be({
                            "text-bolt-elements-textSecondary": !n,
                            "text-accent-500": n
                        }),
                        children: "Drop files here to add to chat"
                    }), v.jsx("span", {
                        className: "i-ph:file-duotone text-xl rotate-10 opacity-80"
                    })]
                }), v.jsxs("span", {
                    className: "text-xs opacity-80",
                    children: ["A maximum of ", h_, " uploads per message at ", Dy, " MiB each"]
                })]
            })
        })
    })
}
);
function VL(t) {
    if (!t)
        return !1;
    if (!t?.name)
        return ct.error(v.jsx(K_, {
            title: "Failed to upload file",
            message: "File name missing"
        })),
        !1;
    const e = Hn.extname(t.name).toLowerCase();
    return !e || !_k.has(e) ? (ct.error(v.jsx(K_, {
        title: "Failed to upload file",
        message: "Unsupported file type"
    })),
    !1) : !0
}
const Aie = "_PromptEffectContainer_1nqq4_1"
  , kie = "_PromptEffectLine_1nqq4_10"
  , Rie = "_PromptShine_1nqq4_22"
  , w0 = {
    PromptEffectContainer: Aie,
    PromptEffectLine: kie,
    PromptShine: Rie
}
  , Iie = 76
  , Pie = S.memo(S.forwardRef( (t, e) => {
    const {textareaRef: n, chatStarted: r=!1, isDragging: i=!1, isStreaming: s=!1, enhancingPrompt: o=!1, promptEnhanced: a=!1, disableInput: l=!1, fileSelections: c=[], attachments: u=[], input: h="", handleDrop: d, onUploadFile: f, onRemoveFileSelection: g, onRemoveAttachment: _, sendMessage: m, handleInputChange: p, enhancePrompt: b, handleStop: y} = t
      , x = r ? 400 : 200
      , E = S.useRef(null)
      , w = S.useCallback(async I => {
        const {items: N} = I.clipboardData;
        for (let O = 0; O < N.length; O++)
            if (N[O].type.includes("image")) {
                const M = N[O].getAsFile();
                if (!VL(M))
                    break;
                if (M) {
                    I.preventDefault(),
                    f?.(M);
                    break
                }
            }
    }
    , [f])
      , A = S.useCallback( () => {
        E.current?.click()
    }
    , [E])
      , C = S.useCallback(I => {
        const N = I.target.files;
        if (N)
            for (const O of Array.from(N))
                f?.(O);
        I.target.value = ""
    }
    , [f])
      , k = c.length > 0 || u.length > 0;
    return v.jsxs("div", {
        className: be("relative px-[var(--chat-padding)] w-full max-w-chat mx-auto z-prompt", {
            "sticky bottom-0": r
        }),
        ref: e,
        children: [v.jsx(hr, {
            children: () => v.jsx(yie, {})
        }), v.jsxs("div", {
            className: "relative shadow-xs border border-bolt-elements-borderColor bg-bolt-elements-prompt-background backdrop-blur rounded-lg",
            children: [v.jsxs("svg", {
                className: w0.PromptEffectContainer,
                children: [v.jsxs("defs", {
                    children: [v.jsxs("linearGradient", {
                        id: "line-gradient",
                        x1: "20%",
                        y1: "0%",
                        x2: "-14%",
                        y2: "10%",
                        gradientUnits: "userSpaceOnUse",
                        gradientTransform: "rotate(-45)",
                        children: [v.jsx("stop", {
                            offset: "0%",
                            stopColor: "#1488fc",
                            stopOpacity: "0%"
                        }), v.jsx("stop", {
                            offset: "40%",
                            stopColor: "#1488fc",
                            stopOpacity: "80%"
                        }), v.jsx("stop", {
                            offset: "50%",
                            stopColor: "#1488fc",
                            stopOpacity: "80%"
                        }), v.jsx("stop", {
                            offset: "100%",
                            stopColor: "#1488fc",
                            stopOpacity: "0%"
                        })]
                    }), v.jsxs("linearGradient", {
                        id: "shine-gradient",
                        children: [v.jsx("stop", {
                            offset: "0%",
                            stopColor: "white",
                            stopOpacity: "0%"
                        }), v.jsx("stop", {
                            offset: "40%",
                            stopColor: "#8adaff",
                            stopOpacity: "80%"
                        }), v.jsx("stop", {
                            offset: "50%",
                            stopColor: "#8adaff",
                            stopOpacity: "80%"
                        }), v.jsx("stop", {
                            offset: "100%",
                            stopColor: "white",
                            stopOpacity: "0%"
                        })]
                    })]
                }), v.jsx("rect", {
                    className: w0.PromptEffectLine,
                    pathLength: "100",
                    strokeLinecap: "round"
                }), v.jsx("rect", {
                    className: w0.PromptShine,
                    x: "48",
                    y: "24",
                    width: "70",
                    height: "1"
                })]
            }), v.jsx(hr, {
                children: () => v.jsx(Tie, {
                    show: i,
                    onDrop: d
                })
            }), v.jsx(hr, {
                children: () => c.length > 0 || u.length > 0 ? v.jsxs("div", {
                    className: "flex flex-col gap-5 bg-bolt-elements-background-depth-1 py-5 rounded-t-lg",
                    children: [c.length > 0 && v.jsx("div", {
                        className: " max-h-[50vh] overflow-y-auto",
                        children: v.jsx(EL, {
                            className: "px-5",
                            itemClassName: "bg-bolt-elements-prompt-selections-background",
                            buttonClassName: "text-bolt-elements-prompt-selections-text hover:text-bolt-elements-prompt-selections-textHover",
                            fileSelections: c,
                            allowDelete: !0,
                            onFileSelectionDelete: g
                        })
                    }), u.length > 0 && v.jsx(mie, {
                        className: "px-5 flex gap-5",
                        attachments: u,
                        onRemoveAttachment: _
                    })]
                }) : null
            }), v.jsx(hr, {
                children: () => v.jsx(_ie, {
                    hasAttachments: k
                })
            }), v.jsxs("div", {
                className: "relative select-none",
                children: [v.jsx("textarea", {
                    ref: n,
                    disabled: l,
                    className: be("w-full pl-4 pt-4 pr-16 focus:outline-none resize-none text-md text-bolt-elements-textPrimary placeholder-bolt-elements-textTertiary bg-transparent text-sm", {
                        "hover:cursor-not-allowed": l
                    }),
                    onPaste: w,
                    onKeyDown: I => {
                        I.key !== "Enter" || I.shiftKey || I.nativeEvent.isComposing || I.keyCode === 229 || (I.preventDefault(),
                        m?.())
                    }
                    ,
                    value: h,
                    onChange: I => {
                        p?.(I)
                    }
                    ,
                    style: {
                        minHeight: Iie,
                        maxHeight: x
                    },
                    placeholder: "How can Bolt help you today?",
                    translate: "no"
                }), v.jsx(hr, {
                    children: () => v.jsx(wie, {
                        show: !l && (h.length > 0 || s),
                        isStreaming: s,
                        onClick: () => {
                            if (s) {
                                y?.();
                                return
                            }
                            m?.()
                        }
                    })
                })]
            }), v.jsxs("div", {
                className: "flex justify-between text-sm p-4 pt-2",
                children: [v.jsxs("div", {
                    className: "flex gap-1 items-center",
                    children: [v.jsx("input", {
                        type: "file",
                        "aria-hidden": "true",
                        tabIndex: -1,
                        ref: E,
                        style: {
                            display: "none",
                            visibility: "hidden"
                        },
                        accept: P6,
                        multiple: !0,
                        onChange: C
                    }), v.jsx(tn, {
                        title: "Upload files",
                        disabled: s,
                        onClick: A,
                        children: v.jsx("div", {
                            className: "i-ph:link-simple text-xl"
                        })
                    }), v.jsx(tn, {
                        title: "Enhance prompt",
                        disabled: h.length === 0 || o,
                        className: be({
                            "opacity-100!": o,
                            "text-bolt-elements-item-contentAccent! pr-1.5 enabled:hover:bg-bolt-elements-item-backgroundAccent!": a
                        }),
                        onClick: () => b?.(),
                        children: o ? v.jsxs(v.Fragment, {
                            children: [v.jsx("div", {
                                className: "i-svg-spinners:90-ring-with-bg text-bolt-elements-loader-progress text-xl"
                            }), v.jsx("div", {
                                className: "ml-1.5",
                                children: "Enhancing prompt..."
                            })]
                        }) : v.jsxs(v.Fragment, {
                            children: [v.jsx("div", {
                                className: "i-bolt:stars text-xl"
                            }), a && v.jsx("div", {
                                className: "ml-1.5",
                                children: "Prompt enhanced"
                            })]
                        })
                    })]
                }), h.length > 3 && v.jsxs("div", {
                    className: "flex items-center gap-1 text-xs text-bolt-elements-textTertiary",
                    children: ["Use ", v.jsx("kbd", {
                        className: "kdb",
                        children: "Shift"
                    }), " + ", v.jsx("kbd", {
                        className: "kdb",
                        children: "Return"
                    }), " for a new line"]
                })]
            })]
        }), v.jsx("div", {
            className: be("pb-[var(--chat-padding)]", {
                "bg-bolt-elements-background-depth-1": r,
                "bg-transparent": !r
            })
        })]
    })
}
));
function Die({item: t, onDelete: e}) {
    const [n,r] = S.useState(!1)
      , i = S.useRef(null);
    return S.useEffect( () => {
        function s() {
            r(!0)
        }
        function o() {
            r(!1)
        }
        return i.current?.addEventListener("mouseenter", s),
        i.current?.addEventListener("mouseleave", o),
        () => {
            i.current?.removeEventListener("mouseenter", s),
            i.current?.removeEventListener("mouseleave", o)
        }
    }
    , []),
    v.jsx("div", {
        ref: i,
        className: "group rounded-md text-bolt-elements-textSecondary hover:text-bolt-elements-textPrimary hover:bg-bolt-elements-background-depth-3 overflow-hidden flex justify-between items-center px-2 py-1",
        children: v.jsxs("a", {
            href: `/p/${t.projectId}`,
            className: "flex w-full relative truncate block",
            children: [t.description, v.jsx("div", {
                className: "absolute right-0 z-1 top-0 bottom-0 bg-gradient-to-l from-bolt-elements-background-depth-2 group-hover:from-bolt-elements-background-depth-3 to-transparent w-10 flex justify-end group-hover:w-15 group-hover:from-45%",
                children: n && v.jsx("div", {
                    className: "flex items-center p-1 text-bolt-elements-textSecondary hover:text-bolt-elements-item-contentDanger",
                    children: v.jsx("button", {
                        className: "i-ph:trash scale-110",
                        onClick: s => {
                            s.preventDefault(),
                            e?.(s)
                        }
                    })
                })
            })]
        })
    })
}
function pt(t) {
    const e = Object.prototype.toString.call(t);
    return t instanceof Date || typeof t == "object" && e === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || e === "[object Number]" || typeof t == "string" || e === "[object String]" ? new Date(t) : new Date(NaN)
}
function ss(t, e) {
    return t instanceof Date ? new t.constructor(e) : new Date(e)
}
function Lie(t, e) {
    const n = pt(t);
    return isNaN(e) ? ss(t, NaN) : (e && n.setDate(n.getDate() + e),
    n)
}
const $L = 6048e5
  , Oie = 864e5
  , Pd = 43200
  , yC = 1440;
let Nie = {};
function qh() {
    return Nie
}
function ra(t, e) {
    const n = qh()
      , r = e?.weekStartsOn ?? e?.locale?.options?.weekStartsOn ?? n.weekStartsOn ?? n.locale?.options?.weekStartsOn ?? 0
      , i = pt(t)
      , s = i.getDay()
      , o = (s < r ? 7 : 0) + s - r;
    return i.setDate(i.getDate() - o),
    i.setHours(0, 0, 0, 0),
    i
}
function xp(t) {
    return ra(t, {
        weekStartsOn: 1
    })
}
function zL(t) {
    const e = pt(t)
      , n = e.getFullYear()
      , r = ss(t, 0);
    r.setFullYear(n + 1, 0, 4),
    r.setHours(0, 0, 0, 0);
    const i = xp(r)
      , s = ss(t, 0);
    s.setFullYear(n, 0, 4),
    s.setHours(0, 0, 0, 0);
    const o = xp(s);
    return e.getTime() >= i.getTime() ? n + 1 : e.getTime() >= o.getTime() ? n : n - 1
}
function Ep(t) {
    const e = pt(t);
    return e.setHours(0, 0, 0, 0),
    e
}
function Sp(t) {
    const e = pt(t)
      , n = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return n.setUTCFullYear(e.getFullYear()),
    +t - +n
}
function Mie(t, e) {
    const n = Ep(t)
      , r = Ep(e)
      , i = +n - Sp(n)
      , s = +r - Sp(r);
    return Math.round((i - s) / Oie)
}
function Bie(t) {
    const e = zL(t)
      , n = ss(t, 0);
    return n.setFullYear(e, 0, 4),
    n.setHours(0, 0, 0, 0),
    xp(n)
}
function Ef(t, e) {
    const n = pt(t)
      , r = pt(e)
      , i = n.getTime() - r.getTime();
    return i < 0 ? -1 : i > 0 ? 1 : i
}
function Kh(t) {
    return ss(t, Date.now())
}
function WL(t, e) {
    const n = Ep(t)
      , r = Ep(e);
    return +n == +r
}
function Fie(t) {
    return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]"
}
function jie(t) {
    if (!Fie(t) && typeof t != "number")
        return !1;
    const e = pt(t);
    return !isNaN(Number(e))
}
function Hie(t, e) {
    const n = pt(t)
      , r = pt(e)
      , i = n.getFullYear() - r.getFullYear()
      , s = n.getMonth() - r.getMonth();
    return i * 12 + s
}
function Uie(t) {
    return e => {
        const r = (t ? Math[t] : Math.trunc)(e);
        return r === 0 ? 0 : r
    }
}
function Vie(t, e) {
    return +pt(t) - +pt(e)
}
function $ie(t) {
    const e = pt(t);
    return e.setHours(23, 59, 59, 999),
    e
}
function zie(t) {
    const e = pt(t)
      , n = e.getMonth();
    return e.setFullYear(e.getFullYear(), n + 1, 0),
    e.setHours(23, 59, 59, 999),
    e
}
function Wie(t) {
    const e = pt(t);
    return +$ie(e) == +zie(e)
}
function Gie(t, e) {
    const n = pt(t)
      , r = pt(e)
      , i = Ef(n, r)
      , s = Math.abs(Hie(n, r));
    let o;
    if (s < 1)
        o = 0;
    else {
        n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30),
        n.setMonth(n.getMonth() - i * s);
        let a = Ef(n, r) === -i;
        Wie(pt(t)) && s === 1 && Ef(t, r) === 1 && (a = !1),
        o = i * (s - Number(a))
    }
    return o === 0 ? 0 : o
}
function qie(t, e, n) {
    const r = Vie(t, e) / 1e3;
    return Uie(n?.roundingMethod)(r)
}
function Kie(t) {
    const e = pt(t)
      , n = ss(t, 0);
    return n.setFullYear(e.getFullYear(), 0, 1),
    n.setHours(0, 0, 0, 0),
    n
}
const Yie = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , Xie = (t, e, n) => {
    let r;
    const i = Yie[t];
    return typeof i == "string" ? r = i : e === 1 ? r = i.one : r = i.other.replace("{{count}}", e.toString()),
    n?.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r
}
;
function C0(t) {
    return (e={}) => {
        const n = e.width ? String(e.width) : t.defaultWidth;
        return t.formats[n] || t.formats[t.defaultWidth]
    }
}
const Qie = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , Jie = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , Zie = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , ese = {
    date: C0({
        formats: Qie,
        defaultWidth: "full"
    }),
    time: C0({
        formats: Jie,
        defaultWidth: "full"
    }),
    dateTime: C0({
        formats: Zie,
        defaultWidth: "full"
    })
}
  , tse = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , nse = (t, e, n, r) => tse[t];
function lc(t) {
    return (e, n) => {
        const r = n?.context ? String(n.context) : "standalone";
        let i;
        if (r === "formatting" && t.formattingValues) {
            const o = t.defaultFormattingWidth || t.defaultWidth
              , a = n?.width ? String(n.width) : o;
            i = t.formattingValues[a] || t.formattingValues[o]
        } else {
            const o = t.defaultWidth
              , a = n?.width ? String(n.width) : t.defaultWidth;
            i = t.values[a] || t.values[o]
        }
        const s = t.argumentCallback ? t.argumentCallback(e) : e;
        return i[s]
    }
}
const rse = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , ise = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , sse = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , ose = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , ase = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , lse = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , cse = (t, e) => {
    const n = Number(t)
      , r = n % 100;
    if (r > 20 || r < 10)
        switch (r % 10) {
        case 1:
            return n + "st";
        case 2:
            return n + "nd";
        case 3:
            return n + "rd"
        }
    return n + "th"
}
  , use = {
    ordinalNumber: cse,
    era: lc({
        values: rse,
        defaultWidth: "wide"
    }),
    quarter: lc({
        values: ise,
        defaultWidth: "wide",
        argumentCallback: t => t - 1
    }),
    month: lc({
        values: sse,
        defaultWidth: "wide"
    }),
    day: lc({
        values: ose,
        defaultWidth: "wide"
    }),
    dayPeriod: lc({
        values: ase,
        defaultWidth: "wide",
        formattingValues: lse,
        defaultFormattingWidth: "wide"
    })
};
function cc(t) {
    return (e, n={}) => {
        const r = n.width
          , i = r && t.matchPatterns[r] || t.matchPatterns[t.defaultMatchWidth]
          , s = e.match(i);
        if (!s)
            return null;
        const o = s[0]
          , a = r && t.parsePatterns[r] || t.parsePatterns[t.defaultParseWidth]
          , l = Array.isArray(a) ? dse(a, h => h.test(o)) : hse(a, h => h.test(o));
        let c;
        c = t.valueCallback ? t.valueCallback(l) : l,
        c = n.valueCallback ? n.valueCallback(c) : c;
        const u = e.slice(o.length);
        return {
            value: c,
            rest: u
        }
    }
}
function hse(t, e) {
    for (const n in t)
        if (Object.prototype.hasOwnProperty.call(t, n) && e(t[n]))
            return n
}
function dse(t, e) {
    for (let n = 0; n < t.length; n++)
        if (e(t[n]))
            return n
}
function fse(t) {
    return (e, n={}) => {
        const r = e.match(t.matchPattern);
        if (!r)
            return null;
        const i = r[0]
          , s = e.match(t.parsePattern);
        if (!s)
            return null;
        let o = t.valueCallback ? t.valueCallback(s[0]) : s[0];
        o = n.valueCallback ? n.valueCallback(o) : o;
        const a = e.slice(i.length);
        return {
            value: o,
            rest: a
        }
    }
}
const pse = /^(\d+)(th|st|nd|rd)?/i
  , mse = /\d+/i
  , gse = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , _se = {
    any: [/^b/i, /^(a|c)/i]
}
  , bse = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , yse = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , vse = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , xse = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , Ese = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , Sse = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , wse = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , Cse = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , Tse = {
    ordinalNumber: fse({
        matchPattern: pse,
        parsePattern: mse,
        valueCallback: t => parseInt(t, 10)
    }),
    era: cc({
        matchPatterns: gse,
        defaultMatchWidth: "wide",
        parsePatterns: _se,
        defaultParseWidth: "any"
    }),
    quarter: cc({
        matchPatterns: bse,
        defaultMatchWidth: "wide",
        parsePatterns: yse,
        defaultParseWidth: "any",
        valueCallback: t => t + 1
    }),
    month: cc({
        matchPatterns: vse,
        defaultMatchWidth: "wide",
        parsePatterns: xse,
        defaultParseWidth: "any"
    }),
    day: cc({
        matchPatterns: Ese,
        defaultMatchWidth: "wide",
        parsePatterns: Sse,
        defaultParseWidth: "any"
    }),
    dayPeriod: cc({
        matchPatterns: wse,
        defaultMatchWidth: "any",
        parsePatterns: Cse,
        defaultParseWidth: "any"
    })
}
  , GL = {
    code: "en-US",
    formatDistance: Xie,
    formatLong: ese,
    formatRelative: nse,
    localize: use,
    match: Tse,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function Ase(t) {
    const e = pt(t);
    return Mie(e, Kie(e)) + 1
}
function kse(t) {
    const e = pt(t)
      , n = +xp(e) - +Bie(e);
    return Math.round(n / $L) + 1
}
function qL(t, e) {
    const n = pt(t)
      , r = n.getFullYear()
      , i = qh()
      , s = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? i.firstWeekContainsDate ?? i.locale?.options?.firstWeekContainsDate ?? 1
      , o = ss(t, 0);
    o.setFullYear(r + 1, 0, s),
    o.setHours(0, 0, 0, 0);
    const a = ra(o, e)
      , l = ss(t, 0);
    l.setFullYear(r, 0, s),
    l.setHours(0, 0, 0, 0);
    const c = ra(l, e);
    return n.getTime() >= a.getTime() ? r + 1 : n.getTime() >= c.getTime() ? r : r - 1
}
function Rse(t, e) {
    const n = qh()
      , r = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? n.firstWeekContainsDate ?? n.locale?.options?.firstWeekContainsDate ?? 1
      , i = qL(t, e)
      , s = ss(t, 0);
    return s.setFullYear(i, 0, r),
    s.setHours(0, 0, 0, 0),
    ra(s, e)
}
function Ise(t, e) {
    const n = pt(t)
      , r = +ra(n, e) - +Rse(n, e);
    return Math.round(r / $L) + 1
}
function xt(t, e) {
    const n = t < 0 ? "-" : ""
      , r = Math.abs(t).toString().padStart(e, "0");
    return n + r
}
const ms = {
    y(t, e) {
        const n = t.getFullYear()
          , r = n > 0 ? n : 1 - n;
        return xt(e === "yy" ? r % 100 : r, e.length)
    },
    M(t, e) {
        const n = t.getMonth();
        return e === "M" ? String(n + 1) : xt(n + 1, 2)
    },
    d(t, e) {
        return xt(t.getDate(), e.length)
    },
    a(t, e) {
        const n = t.getHours() / 12 >= 1 ? "pm" : "am";
        switch (e) {
        case "a":
        case "aa":
            return n.toUpperCase();
        case "aaa":
            return n;
        case "aaaaa":
            return n[0];
        case "aaaa":
        default:
            return n === "am" ? "a.m." : "p.m."
        }
    },
    h(t, e) {
        return xt(t.getHours() % 12 || 12, e.length)
    },
    H(t, e) {
        return xt(t.getHours(), e.length)
    },
    m(t, e) {
        return xt(t.getMinutes(), e.length)
    },
    s(t, e) {
        return xt(t.getSeconds(), e.length)
    },
    S(t, e) {
        const n = e.length
          , r = t.getMilliseconds()
          , i = Math.trunc(r * Math.pow(10, n - 3));
        return xt(i, e.length)
    }
}
  , Na = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , vC = {
    G: function(t, e, n) {
        const r = t.getFullYear() > 0 ? 1 : 0;
        switch (e) {
        case "G":
        case "GG":
        case "GGG":
            return n.era(r, {
                width: "abbreviated"
            });
        case "GGGGG":
            return n.era(r, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return n.era(r, {
                width: "wide"
            })
        }
    },
    y: function(t, e, n) {
        if (e === "yo") {
            const r = t.getFullYear()
              , i = r > 0 ? r : 1 - r;
            return n.ordinalNumber(i, {
                unit: "year"
            })
        }
        return ms.y(t, e)
    },
    Y: function(t, e, n, r) {
        const i = qL(t, r)
          , s = i > 0 ? i : 1 - i;
        if (e === "YY") {
            const o = s % 100;
            return xt(o, 2)
        }
        return e === "Yo" ? n.ordinalNumber(s, {
            unit: "year"
        }) : xt(s, e.length)
    },
    R: function(t, e) {
        const n = zL(t);
        return xt(n, e.length)
    },
    u: function(t, e) {
        const n = t.getFullYear();
        return xt(n, e.length)
    },
    Q: function(t, e, n) {
        const r = Math.ceil((t.getMonth() + 1) / 3);
        switch (e) {
        case "Q":
            return String(r);
        case "QQ":
            return xt(r, 2);
        case "Qo":
            return n.ordinalNumber(r, {
                unit: "quarter"
            });
        case "QQQ":
            return n.quarter(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return n.quarter(r, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return n.quarter(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(t, e, n) {
        const r = Math.ceil((t.getMonth() + 1) / 3);
        switch (e) {
        case "q":
            return String(r);
        case "qq":
            return xt(r, 2);
        case "qo":
            return n.ordinalNumber(r, {
                unit: "quarter"
            });
        case "qqq":
            return n.quarter(r, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return n.quarter(r, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return n.quarter(r, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(t, e, n) {
        const r = t.getMonth();
        switch (e) {
        case "M":
        case "MM":
            return ms.M(t, e);
        case "Mo":
            return n.ordinalNumber(r + 1, {
                unit: "month"
            });
        case "MMM":
            return n.month(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return n.month(r, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return n.month(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(t, e, n) {
        const r = t.getMonth();
        switch (e) {
        case "L":
            return String(r + 1);
        case "LL":
            return xt(r + 1, 2);
        case "Lo":
            return n.ordinalNumber(r + 1, {
                unit: "month"
            });
        case "LLL":
            return n.month(r, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return n.month(r, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return n.month(r, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(t, e, n, r) {
        const i = Ise(t, r);
        return e === "wo" ? n.ordinalNumber(i, {
            unit: "week"
        }) : xt(i, e.length)
    },
    I: function(t, e, n) {
        const r = kse(t);
        return e === "Io" ? n.ordinalNumber(r, {
            unit: "week"
        }) : xt(r, e.length)
    },
    d: function(t, e, n) {
        return e === "do" ? n.ordinalNumber(t.getDate(), {
            unit: "date"
        }) : ms.d(t, e)
    },
    D: function(t, e, n) {
        const r = Ase(t);
        return e === "Do" ? n.ordinalNumber(r, {
            unit: "dayOfYear"
        }) : xt(r, e.length)
    },
    E: function(t, e, n) {
        const r = t.getDay();
        switch (e) {
        case "E":
        case "EE":
        case "EEE":
            return n.day(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return n.day(r, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return n.day(r, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return n.day(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(t, e, n, r) {
        const i = t.getDay()
          , s = (i - r.weekStartsOn + 8) % 7 || 7;
        switch (e) {
        case "e":
            return String(s);
        case "ee":
            return xt(s, 2);
        case "eo":
            return n.ordinalNumber(s, {
                unit: "day"
            });
        case "eee":
            return n.day(i, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return n.day(i, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return n.day(i, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return n.day(i, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(t, e, n, r) {
        const i = t.getDay()
          , s = (i - r.weekStartsOn + 8) % 7 || 7;
        switch (e) {
        case "c":
            return String(s);
        case "cc":
            return xt(s, e.length);
        case "co":
            return n.ordinalNumber(s, {
                unit: "day"
            });
        case "ccc":
            return n.day(i, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return n.day(i, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return n.day(i, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return n.day(i, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(t, e, n) {
        const r = t.getDay()
          , i = r === 0 ? 7 : r;
        switch (e) {
        case "i":
            return String(i);
        case "ii":
            return xt(i, e.length);
        case "io":
            return n.ordinalNumber(i, {
                unit: "day"
            });
        case "iii":
            return n.day(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return n.day(r, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return n.day(r, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return n.day(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(t, e, n) {
        const i = t.getHours() / 12 >= 1 ? "pm" : "am";
        switch (e) {
        case "a":
        case "aa":
            return n.dayPeriod(i, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return n.dayPeriod(i, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return n.dayPeriod(i, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return n.dayPeriod(i, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(t, e, n) {
        const r = t.getHours();
        let i;
        switch (r === 12 ? i = Na.noon : r === 0 ? i = Na.midnight : i = r / 12 >= 1 ? "pm" : "am",
        e) {
        case "b":
        case "bb":
            return n.dayPeriod(i, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return n.dayPeriod(i, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return n.dayPeriod(i, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return n.dayPeriod(i, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(t, e, n) {
        const r = t.getHours();
        let i;
        switch (r >= 17 ? i = Na.evening : r >= 12 ? i = Na.afternoon : r >= 4 ? i = Na.morning : i = Na.night,
        e) {
        case "B":
        case "BB":
        case "BBB":
            return n.dayPeriod(i, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return n.dayPeriod(i, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return n.dayPeriod(i, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(t, e, n) {
        if (e === "ho") {
            let r = t.getHours() % 12;
            return r === 0 && (r = 12),
            n.ordinalNumber(r, {
                unit: "hour"
            })
        }
        return ms.h(t, e)
    },
    H: function(t, e, n) {
        return e === "Ho" ? n.ordinalNumber(t.getHours(), {
            unit: "hour"
        }) : ms.H(t, e)
    },
    K: function(t, e, n) {
        const r = t.getHours() % 12;
        return e === "Ko" ? n.ordinalNumber(r, {
            unit: "hour"
        }) : xt(r, e.length)
    },
    k: function(t, e, n) {
        let r = t.getHours();
        return r === 0 && (r = 24),
        e === "ko" ? n.ordinalNumber(r, {
            unit: "hour"
        }) : xt(r, e.length)
    },
    m: function(t, e, n) {
        return e === "mo" ? n.ordinalNumber(t.getMinutes(), {
            unit: "minute"
        }) : ms.m(t, e)
    },
    s: function(t, e, n) {
        return e === "so" ? n.ordinalNumber(t.getSeconds(), {
            unit: "second"
        }) : ms.s(t, e)
    },
    S: function(t, e) {
        return ms.S(t, e)
    },
    X: function(t, e, n) {
        const r = t.getTimezoneOffset();
        if (r === 0)
            return "Z";
        switch (e) {
        case "X":
            return EC(r);
        case "XXXX":
        case "XX":
            return Eo(r);
        case "XXXXX":
        case "XXX":
        default:
            return Eo(r, ":")
        }
    },
    x: function(t, e, n) {
        const r = t.getTimezoneOffset();
        switch (e) {
        case "x":
            return EC(r);
        case "xxxx":
        case "xx":
            return Eo(r);
        case "xxxxx":
        case "xxx":
        default:
            return Eo(r, ":")
        }
    },
    O: function(t, e, n) {
        const r = t.getTimezoneOffset();
        switch (e) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + xC(r, ":");
        case "OOOO":
        default:
            return "GMT" + Eo(r, ":")
        }
    },
    z: function(t, e, n) {
        const r = t.getTimezoneOffset();
        switch (e) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + xC(r, ":");
        case "zzzz":
        default:
            return "GMT" + Eo(r, ":")
        }
    },
    t: function(t, e, n) {
        const r = Math.trunc(t.getTime() / 1e3);
        return xt(r, e.length)
    },
    T: function(t, e, n) {
        const r = t.getTime();
        return xt(r, e.length)
    }
};
function xC(t, e="") {
    const n = t > 0 ? "-" : "+"
      , r = Math.abs(t)
      , i = Math.trunc(r / 60)
      , s = r % 60;
    return s === 0 ? n + String(i) : n + String(i) + e + xt(s, 2)
}
function EC(t, e) {
    return t % 60 === 0 ? (t > 0 ? "-" : "+") + xt(Math.abs(t) / 60, 2) : Eo(t, e)
}
function Eo(t, e="") {
    const n = t > 0 ? "-" : "+"
      , r = Math.abs(t)
      , i = xt(Math.trunc(r / 60), 2)
      , s = xt(r % 60, 2);
    return n + i + e + s
}
const SC = (t, e) => {
    switch (t) {
    case "P":
        return e.date({
            width: "short"
        });
    case "PP":
        return e.date({
            width: "medium"
        });
    case "PPP":
        return e.date({
            width: "long"
        });
    case "PPPP":
    default:
        return e.date({
            width: "full"
        })
    }
}
  , KL = (t, e) => {
    switch (t) {
    case "p":
        return e.time({
            width: "short"
        });
    case "pp":
        return e.time({
            width: "medium"
        });
    case "ppp":
        return e.time({
            width: "long"
        });
    case "pppp":
    default:
        return e.time({
            width: "full"
        })
    }
}
  , Pse = (t, e) => {
    const n = t.match(/(P+)(p+)?/) || []
      , r = n[1]
      , i = n[2];
    if (!i)
        return SC(t, e);
    let s;
    switch (r) {
    case "P":
        s = e.dateTime({
            width: "short"
        });
        break;
    case "PP":
        s = e.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        s = e.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        s = e.dateTime({
            width: "full"
        });
        break
    }
    return s.replace("{{date}}", SC(r, e)).replace("{{time}}", KL(i, e))
}
  , Dse = {
    p: KL,
    P: Pse
}
  , Lse = /^D+$/
  , Ose = /^Y+$/
  , Nse = ["D", "DD", "YY", "YYYY"];
function Mse(t) {
    return Lse.test(t)
}
function Bse(t) {
    return Ose.test(t)
}
function Fse(t, e, n) {
    const r = jse(t, e, n);
    if (console.warn(r),
    Nse.includes(t))
        throw new RangeError(r)
}
function jse(t, e, n) {
    const r = t[0] === "Y" ? "years" : "days of the month";
    return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${e}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const Hse = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , Use = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , Vse = /^'([^]*?)'?$/
  , $se = /''/g
  , zse = /[a-zA-Z]/;
function Zc(t, e, n) {
    const r = qh()
      , i = r.locale ?? GL
      , s = r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1
      , o = r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0
      , a = pt(t);
    if (!jie(a))
        throw new RangeError("Invalid time value");
    let l = e.match(Use).map(u => {
        const h = u[0];
        if (h === "p" || h === "P") {
            const d = Dse[h];
            return d(u, i.formatLong)
        }
        return u
    }
    ).join("").match(Hse).map(u => {
        if (u === "''")
            return {
                isToken: !1,
                value: "'"
            };
        const h = u[0];
        if (h === "'")
            return {
                isToken: !1,
                value: Wse(u)
            };
        if (vC[h])
            return {
                isToken: !0,
                value: u
            };
        if (h.match(zse))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + h + "`");
        return {
            isToken: !1,
            value: u
        }
    }
    );
    i.localize.preprocessor && (l = i.localize.preprocessor(a, l));
    const c = {
        firstWeekContainsDate: s,
        weekStartsOn: o,
        locale: i
    };
    return l.map(u => {
        if (!u.isToken)
            return u.value;
        const h = u.value;
        (Bse(h) || Mse(h)) && Fse(h, e, String(t));
        const d = vC[h[0]];
        return d(a, h, i.localize, c)
    }
    ).join("")
}
function Wse(t) {
    const e = t.match(Vse);
    return e ? e[1].replace($se, "'") : t
}
function Gse(t, e, n) {
    const r = qh()
      , i = n?.locale ?? r.locale ?? GL
      , s = 2520
      , o = Ef(t, e);
    if (isNaN(o))
        throw new RangeError("Invalid time value");
    const a = Object.assign({}, n, {
        addSuffix: n?.addSuffix,
        comparison: o
    });
    let l, c;
    o > 0 ? (l = pt(e),
    c = pt(t)) : (l = pt(t),
    c = pt(e));
    const u = qie(c, l)
      , h = (Sp(c) - Sp(l)) / 1e3
      , d = Math.round((u - h) / 60);
    let f;
    if (d < 2)
        return n?.includeSeconds ? u < 5 ? i.formatDistance("lessThanXSeconds", 5, a) : u < 10 ? i.formatDistance("lessThanXSeconds", 10, a) : u < 20 ? i.formatDistance("lessThanXSeconds", 20, a) : u < 40 ? i.formatDistance("halfAMinute", 0, a) : u < 60 ? i.formatDistance("lessThanXMinutes", 1, a) : i.formatDistance("xMinutes", 1, a) : d === 0 ? i.formatDistance("lessThanXMinutes", 1, a) : i.formatDistance("xMinutes", d, a);
    if (d < 45)
        return i.formatDistance("xMinutes", d, a);
    if (d < 90)
        return i.formatDistance("aboutXHours", 1, a);
    if (d < yC) {
        const g = Math.round(d / 60);
        return i.formatDistance("aboutXHours", g, a)
    } else {
        if (d < s)
            return i.formatDistance("xDays", 1, a);
        if (d < Pd) {
            const g = Math.round(d / yC);
            return i.formatDistance("xDays", g, a)
        } else if (d < Pd * 2)
            return f = Math.round(d / Pd),
            i.formatDistance("aboutXMonths", f, a)
    }
    if (f = Gie(c, l),
    f < 12) {
        const g = Math.round(d / Pd);
        return i.formatDistance("xMonths", g, a)
    } else {
        const g = f % 12
          , _ = Math.trunc(f / 12);
        return g < 3 ? i.formatDistance("aboutXYears", _, a) : g < 9 ? i.formatDistance("overXYears", _, a) : i.formatDistance("almostXYears", _ + 1, a)
    }
}
function _1(t, e) {
    return Gse(t, Kh(t), e)
}
function qse(t, e) {
    const n = pt(t)
      , r = pt(e);
    return n.getTime() > r.getTime()
}
function Kse(t, e, n) {
    const r = ra(t, n)
      , i = ra(e, n);
    return +r == +i
}
function Yse(t, e) {
    const n = pt(t)
      , r = pt(e);
    return n.getFullYear() === r.getFullYear()
}
function Xse(t, e) {
    return Kse(t, Kh(t), e)
}
function Qse(t) {
    return Yse(t, Kh(t))
}
function Jse(t) {
    return WL(t, Kh(t))
}
function YL(t, e) {
    return Lie(t, -e)
}
function Zse(t) {
    return WL(t, YL(Kh(t), 1))
}
function eoe(t) {
    const e = t.toSorted( (i, s) => new Date(s.timestamp).getTime() - new Date(i.timestamp).getTime())
      , n = {}
      , r = [];
    return e.forEach(i => {
        const s = toe(new Date(i.timestamp));
        if (s in n)
            n[s].items.push(i);
        else {
            const o = {
                category: s,
                items: [i]
            };
            n[s] = o,
            r.push(o)
        }
    }
    ),
    r
}
function toe(t) {
    if (Jse(t))
        return "Today";
    if (Zse(t))
        return "Yesterday";
    if (Xse(t))
        return Zc(t, "eeee");
    const e = YL(new Date, 30);
    return qse(t, e) ? "Last 30 Days" : Qse(t) ? Zc(t, "MMMM") : Zc(t, "MMMM yyyy")
}
function wC(t, [e,n]) {
    return Math.min(n, Math.max(e, t))
}
function Wm(t) {
    const e = t + "CollectionProvider"
      , [n,r] = cs(e)
      , [i,s] = n(e, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , o = f => {
        const {scope: g, children: _} = f
          , m = Cr.useRef(null)
          , p = Cr.useRef(new Map).current;
        return v.jsx(i, {
            scope: g,
            itemMap: p,
            collectionRef: m,
            children: _
        })
    }
    ;
    o.displayName = e;
    const a = t + "CollectionSlot"
      , l = Cr.forwardRef( (f, g) => {
        const {scope: _, children: m} = f
          , p = s(a, _)
          , b = rt(g, p.collectionRef);
        return v.jsx(Fs, {
            ref: b,
            children: m
        })
    }
    );
    l.displayName = a;
    const c = t + "CollectionItemSlot"
      , u = "data-radix-collection-item"
      , h = Cr.forwardRef( (f, g) => {
        const {scope: _, children: m, ...p} = f
          , b = Cr.useRef(null)
          , y = rt(g, b)
          , x = s(c, _);
        return Cr.useEffect( () => (x.itemMap.set(b, {
            ref: b,
            ...p
        }),
        () => void x.itemMap.delete(b))),
        v.jsx(Fs, {
            [u]: "",
            ref: y,
            children: m
        })
    }
    );
    h.displayName = c;
    function d(f) {
        const g = s(t + "CollectionConsumer", f);
        return Cr.useCallback( () => {
            const m = g.collectionRef.current;
            if (!m)
                return [];
            const p = Array.from(m.querySelectorAll(`[${u}]`));
            return Array.from(g.itemMap.values()).sort( (x, E) => p.indexOf(x.ref.current) - p.indexOf(E.ref.current))
        }
        , [g.collectionRef, g.itemMap])
    }
    return [{
        Provider: o,
        Slot: l,
        ItemSlot: h
    }, d, r]
}
var noe = S.createContext(void 0);
function Gm(t) {
    const e = S.useContext(noe);
    return t || e || "ltr"
}
function XL(t) {
    const e = S.useRef({
        value: t,
        previous: t
    });
    return S.useMemo( () => (e.current.value !== t && (e.current.previous = e.current.value,
    e.current.value = t),
    e.current.previous), [t])
}
var roe = [" ", "Enter", "ArrowUp", "ArrowDown"]
  , ioe = [" ", "Enter"]
  , Yh = "Select"
  , [qm,Km,soe] = Wm(Yh)
  , [Yl,sve] = cs(Yh, [soe, ro])
  , Ym = ro()
  , [ooe,ao] = Yl(Yh)
  , [aoe,loe] = Yl(Yh)
  , QL = t => {
    const {__scopeSelect: e, children: n, open: r, defaultOpen: i, onOpenChange: s, value: o, defaultValue: a, onValueChange: l, dir: c, name: u, autoComplete: h, disabled: d, required: f} = t
      , g = Ym(e)
      , [_,m] = S.useState(null)
      , [p,b] = S.useState(null)
      , [y,x] = S.useState(!1)
      , E = Gm(c)
      , [w=!1,A] = Go({
        prop: r,
        defaultProp: i,
        onChange: s
    })
      , [C,k] = Go({
        prop: o,
        defaultProp: a,
        onChange: l
    })
      , I = S.useRef(null)
      , N = _ ? !!_.closest("form") : !0
      , [O,M] = S.useState(new Set)
      , H = Array.from(O).map($ => $.props.value).join(";");
    return v.jsx(um, {
        ...g,
        children: v.jsxs(ooe, {
            required: f,
            scope: e,
            trigger: _,
            onTriggerChange: m,
            valueNode: p,
            onValueNodeChange: b,
            valueNodeHasChildren: y,
            onValueNodeHasChildrenChange: x,
            contentId: Ci(),
            value: C,
            onValueChange: k,
            open: w,
            onOpenChange: A,
            dir: E,
            triggerPointerDownPosRef: I,
            disabled: d,
            children: [v.jsx(qm.Provider, {
                scope: e,
                children: v.jsx(aoe, {
                    scope: t.__scopeSelect,
                    onNativeOptionAdd: S.useCallback($ => {
                        M(J => new Set(J).add($))
                    }
                    , []),
                    onNativeOptionRemove: S.useCallback($ => {
                        M(J => {
                            const Q = new Set(J);
                            return Q.delete($),
                            Q
                        }
                        )
                    }
                    , []),
                    children: n
                })
            }), N ? v.jsxs(bO, {
                "aria-hidden": !0,
                required: f,
                tabIndex: -1,
                name: u,
                autoComplete: h,
                value: C,
                onChange: $ => k($.target.value),
                disabled: d,
                children: [C === void 0 ? v.jsx("option", {
                    value: ""
                }) : null, Array.from(O)]
            }, H) : null]
        })
    })
}
;
QL.displayName = Yh;
var JL = "SelectTrigger"
  , ZL = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, disabled: r=!1, ...i} = t
      , s = Ym(n)
      , o = ao(JL, n)
      , a = o.disabled || r
      , l = rt(e, o.onTriggerChange)
      , c = Km(n)
      , [u,h,d] = yO(g => {
        const _ = c().filter(b => !b.disabled)
          , m = _.find(b => b.value === o.value)
          , p = vO(_, g, m);
        p !== void 0 && o.onValueChange(p.value)
    }
    )
      , f = () => {
        a || (o.onOpenChange(!0),
        d())
    }
    ;
    return v.jsx(hm, {
        asChild: !0,
        ...s,
        children: v.jsx(We.button, {
            type: "button",
            role: "combobox",
            "aria-controls": o.contentId,
            "aria-expanded": o.open,
            "aria-required": o.required,
            "aria-autocomplete": "none",
            dir: o.dir,
            "data-state": o.open ? "open" : "closed",
            disabled: a,
            "data-disabled": a ? "" : void 0,
            "data-placeholder": _O(o.value) ? "" : void 0,
            ...i,
            ref: l,
            onClick: Ee(i.onClick, g => {
                g.currentTarget.focus()
            }
            ),
            onPointerDown: Ee(i.onPointerDown, g => {
                const _ = g.target;
                _.hasPointerCapture(g.pointerId) && _.releasePointerCapture(g.pointerId),
                g.button === 0 && g.ctrlKey === !1 && (f(),
                o.triggerPointerDownPosRef.current = {
                    x: Math.round(g.pageX),
                    y: Math.round(g.pageY)
                },
                g.preventDefault())
            }
            ),
            onKeyDown: Ee(i.onKeyDown, g => {
                const _ = u.current !== "";
                !(g.ctrlKey || g.altKey || g.metaKey) && g.key.length === 1 && h(g.key),
                !(_ && g.key === " ") && roe.includes(g.key) && (f(),
                g.preventDefault())
            }
            )
        })
    })
}
);
ZL.displayName = JL;
var eO = "SelectValue"
  , tO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, className: r, style: i, children: s, placeholder: o="", ...a} = t
      , l = ao(eO, n)
      , {onValueNodeHasChildrenChange: c} = l
      , u = s !== void 0
      , h = rt(e, l.onValueNodeChange);
    return hn( () => {
        c(u)
    }
    , [c, u]),
    v.jsx(We.span, {
        ...a,
        ref: h,
        style: {
            pointerEvents: "none"
        },
        children: _O(l.value) ? v.jsx(v.Fragment, {
            children: o
        }) : s
    })
}
);
tO.displayName = eO;
var coe = "SelectIcon"
  , nO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, children: r, ...i} = t;
    return v.jsx(We.span, {
        "aria-hidden": !0,
        ...i,
        ref: e,
        children: r || ""
    })
}
);
nO.displayName = coe;
var uoe = "SelectPortal"
  , rO = t => v.jsx(Th, {
    asChild: !0,
    ...t
});
rO.displayName = uoe;
var ia = "SelectContent"
  , iO = S.forwardRef( (t, e) => {
    const n = ao(ia, t.__scopeSelect)
      , [r,i] = S.useState();
    if (hn( () => {
        i(new DocumentFragment)
    }
    , []),
    !n.open) {
        const s = r;
        return s ? fa.createPortal(v.jsx(sO, {
            scope: t.__scopeSelect,
            children: v.jsx(qm.Slot, {
                scope: t.__scopeSelect,
                children: v.jsx("div", {
                    children: t.children
                })
            })
        }), s) : null
    }
    return v.jsx(oO, {
        ...t,
        ref: e
    })
}
);
iO.displayName = ia;
var ji = 10
  , [sO,lo] = Yl(ia)
  , hoe = "SelectContentImpl"
  , oO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, position: r="item-aligned", onCloseAutoFocus: i, onEscapeKeyDown: s, onPointerDownOutside: o, side: a, sideOffset: l, align: c, alignOffset: u, arrowPadding: h, collisionBoundary: d, collisionPadding: f, sticky: g, hideWhenDetached: _, avoidCollisions: m, ...p} = t
      , b = ao(ia, n)
      , [y,x] = S.useState(null)
      , [E,w] = S.useState(null)
      , A = rt(e, G => x(G))
      , [C,k] = S.useState(null)
      , [I,N] = S.useState(null)
      , O = Km(n)
      , [M,H] = S.useState(!1)
      , $ = S.useRef(!1);
    S.useEffect( () => {
        if (y)
            return zm(y)
    }
    , [y]),
    o1();
    const J = S.useCallback(G => {
        const [j,...oe] = O().map(ne => ne.ref.current)
          , [le] = oe.slice(-1)
          , de = document.activeElement;
        for (const ne of G)
            if (ne === de || (ne?.scrollIntoView({
                block: "nearest"
            }),
            ne === j && E && (E.scrollTop = 0),
            ne === le && E && (E.scrollTop = E.scrollHeight),
            ne?.focus(),
            document.activeElement !== de))
                return
    }
    , [O, E])
      , Q = S.useCallback( () => J([C, y]), [J, C, y]);
    S.useEffect( () => {
        M && Q()
    }
    , [M, Q]);
    const {onOpenChange: ee, triggerPointerDownPosRef: D} = b;
    S.useEffect( () => {
        if (y) {
            let G = {
                x: 0,
                y: 0
            };
            const j = le => {
                G = {
                    x: Math.abs(Math.round(le.pageX) - (D.current?.x ?? 0)),
                    y: Math.abs(Math.round(le.pageY) - (D.current?.y ?? 0))
                }
            }
              , oe = le => {
                G.x <= 10 && G.y <= 10 ? le.preventDefault() : y.contains(le.target) || ee(!1),
                document.removeEventListener("pointermove", j),
                D.current = null
            }
            ;
            return D.current !== null && (document.addEventListener("pointermove", j),
            document.addEventListener("pointerup", oe, {
                capture: !0,
                once: !0
            })),
            () => {
                document.removeEventListener("pointermove", j),
                document.removeEventListener("pointerup", oe, {
                    capture: !0
                })
            }
        }
    }
    , [y, ee, D]),
    S.useEffect( () => {
        const G = () => ee(!1);
        return window.addEventListener("blur", G),
        window.addEventListener("resize", G),
        () => {
            window.removeEventListener("blur", G),
            window.removeEventListener("resize", G)
        }
    }
    , [ee]);
    const [L,z] = yO(G => {
        const j = O().filter(de => !de.disabled)
          , oe = j.find(de => de.ref.current === document.activeElement)
          , le = vO(j, G, oe);
        le && setTimeout( () => le.ref.current.focus())
    }
    )
      , V = S.useCallback( (G, j, oe) => {
        const le = !$.current && !oe;
        (b.value !== void 0 && b.value === j || le) && (k(G),
        le && ($.current = !0))
    }
    , [b.value])
      , B = S.useCallback( () => y?.focus(), [y])
      , Z = S.useCallback( (G, j, oe) => {
        const le = !$.current && !oe;
        (b.value !== void 0 && b.value === j || le) && N(G)
    }
    , [b.value])
      , se = r === "popper" ? db : aO
      , ae = se === db ? {
        side: a,
        sideOffset: l,
        align: c,
        alignOffset: u,
        arrowPadding: h,
        collisionBoundary: d,
        collisionPadding: f,
        sticky: g,
        hideWhenDetached: _,
        avoidCollisions: m
    } : {};
    return v.jsx(sO, {
        scope: n,
        content: y,
        viewport: E,
        onViewportChange: w,
        itemRefCallback: V,
        selectedItem: C,
        onItemLeave: B,
        itemTextRefCallback: Z,
        focusSelectedItem: Q,
        selectedItemText: I,
        position: r,
        isPositioned: M,
        searchRef: L,
        children: v.jsx($m, {
            as: Fs,
            allowPinchZoom: !0,
            children: v.jsx(Wh, {
                asChild: !0,
                trapped: b.open,
                onMountAutoFocus: G => {
                    G.preventDefault()
                }
                ,
                onUnmountAutoFocus: Ee(i, G => {
                    b.trigger?.focus({
                        preventScroll: !0
                    }),
                    G.preventDefault()
                }
                ),
                children: v.jsx(wh, {
                    asChild: !0,
                    disableOutsidePointerEvents: !0,
                    onEscapeKeyDown: s,
                    onPointerDownOutside: o,
                    onFocusOutside: G => G.preventDefault(),
                    onDismiss: () => b.onOpenChange(!1),
                    children: v.jsx(se, {
                        role: "listbox",
                        id: b.contentId,
                        "data-state": b.open ? "open" : "closed",
                        dir: b.dir,
                        onContextMenu: G => G.preventDefault(),
                        ...p,
                        ...ae,
                        onPlaced: () => H(!0),
                        ref: A,
                        style: {
                            display: "flex",
                            flexDirection: "column",
                            outline: "none",
                            ...p.style
                        },
                        onKeyDown: Ee(p.onKeyDown, G => {
                            const j = G.ctrlKey || G.altKey || G.metaKey;
                            if (G.key === "Tab" && G.preventDefault(),
                            !j && G.key.length === 1 && z(G.key),
                            ["ArrowUp", "ArrowDown", "Home", "End"].includes(G.key)) {
                                let le = O().filter(de => !de.disabled).map(de => de.ref.current);
                                if (["ArrowUp", "End"].includes(G.key) && (le = le.slice().reverse()),
                                ["ArrowUp", "ArrowDown"].includes(G.key)) {
                                    const de = G.target
                                      , ne = le.indexOf(de);
                                    le = le.slice(ne + 1)
                                }
                                setTimeout( () => J(le)),
                                G.preventDefault()
                            }
                        }
                        )
                    })
                })
            })
        })
    })
}
);
oO.displayName = hoe;
var doe = "SelectItemAlignedPosition"
  , aO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, onPlaced: r, ...i} = t
      , s = ao(ia, n)
      , o = lo(ia, n)
      , [a,l] = S.useState(null)
      , [c,u] = S.useState(null)
      , h = rt(e, A => u(A))
      , d = Km(n)
      , f = S.useRef(!1)
      , g = S.useRef(!0)
      , {viewport: _, selectedItem: m, selectedItemText: p, focusSelectedItem: b} = o
      , y = S.useCallback( () => {
        if (s.trigger && s.valueNode && a && c && _ && m && p) {
            const A = s.trigger.getBoundingClientRect()
              , C = c.getBoundingClientRect()
              , k = s.valueNode.getBoundingClientRect()
              , I = p.getBoundingClientRect();
            if (s.dir !== "rtl") {
                const de = I.left - C.left
                  , ne = k.left - de
                  , pe = A.left - ne
                  , Te = A.width + pe
                  , Ce = Math.max(Te, C.width)
                  , Re = window.innerWidth - ji
                  , we = wC(ne, [ji, Re - Ce]);
                a.style.minWidth = Te + "px",
                a.style.left = we + "px"
            } else {
                const de = C.right - I.right
                  , ne = window.innerWidth - k.right - de
                  , pe = window.innerWidth - A.right - ne
                  , Te = A.width + pe
                  , Ce = Math.max(Te, C.width)
                  , Re = window.innerWidth - ji
                  , we = wC(ne, [ji, Re - Ce]);
                a.style.minWidth = Te + "px",
                a.style.right = we + "px"
            }
            const N = d()
              , O = window.innerHeight - ji * 2
              , M = _.scrollHeight
              , H = window.getComputedStyle(c)
              , $ = parseInt(H.borderTopWidth, 10)
              , J = parseInt(H.paddingTop, 10)
              , Q = parseInt(H.borderBottomWidth, 10)
              , ee = parseInt(H.paddingBottom, 10)
              , D = $ + J + M + ee + Q
              , L = Math.min(m.offsetHeight * 5, D)
              , z = window.getComputedStyle(_)
              , V = parseInt(z.paddingTop, 10)
              , B = parseInt(z.paddingBottom, 10)
              , Z = A.top + A.height / 2 - ji
              , se = O - Z
              , ae = m.offsetHeight / 2
              , G = m.offsetTop + ae
              , j = $ + J + G
              , oe = D - j;
            if (j <= Z) {
                const de = m === N[N.length - 1].ref.current;
                a.style.bottom = "0px";
                const ne = c.clientHeight - _.offsetTop - _.offsetHeight
                  , pe = Math.max(se, ae + (de ? B : 0) + ne + Q)
                  , Te = j + pe;
                a.style.height = Te + "px"
            } else {
                const de = m === N[0].ref.current;
                a.style.top = "0px";
                const pe = Math.max(Z, $ + _.offsetTop + (de ? V : 0) + ae) + oe;
                a.style.height = pe + "px",
                _.scrollTop = j - Z + _.offsetTop
            }
            a.style.margin = `${ji}px 0`,
            a.style.minHeight = L + "px",
            a.style.maxHeight = O + "px",
            r?.(),
            requestAnimationFrame( () => f.current = !0)
        }
    }
    , [d, s.trigger, s.valueNode, a, c, _, m, p, s.dir, r]);
    hn( () => y(), [y]);
    const [x,E] = S.useState();
    hn( () => {
        c && E(window.getComputedStyle(c).zIndex)
    }
    , [c]);
    const w = S.useCallback(A => {
        A && g.current === !0 && (y(),
        b?.(),
        g.current = !1)
    }
    , [y, b]);
    return v.jsx(poe, {
        scope: n,
        contentWrapper: a,
        shouldExpandOnScrollRef: f,
        onScrollButtonChange: w,
        children: v.jsx("div", {
            ref: l,
            style: {
                display: "flex",
                flexDirection: "column",
                position: "fixed",
                zIndex: x
            },
            children: v.jsx(We.div, {
                ...i,
                ref: h,
                style: {
                    boxSizing: "border-box",
                    maxHeight: "100%",
                    ...i.style
                }
            })
        })
    })
}
);
aO.displayName = doe;
var foe = "SelectPopperPosition"
  , db = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, align: r="start", collisionPadding: i=ji, ...s} = t
      , o = Ym(n);
    return v.jsx(dm, {
        ...o,
        ...s,
        ref: e,
        align: r,
        collisionPadding: i,
        style: {
            boxSizing: "border-box",
            ...s.style,
            "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-select-content-available-width": "var(--radix-popper-available-width)",
            "--radix-select-content-available-height": "var(--radix-popper-available-height)",
            "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
db.displayName = foe;
var [poe,b1] = Yl(ia, {})
  , fb = "SelectViewport"
  , lO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, nonce: r, ...i} = t
      , s = lo(fb, n)
      , o = b1(fb, n)
      , a = rt(e, s.onViewportChange)
      , l = S.useRef(0);
    return v.jsxs(v.Fragment, {
        children: [v.jsx("style", {
            dangerouslySetInnerHTML: {
                __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
            },
            nonce: r
        }), v.jsx(qm.Slot, {
            scope: n,
            children: v.jsx(We.div, {
                "data-radix-select-viewport": "",
                role: "presentation",
                ...i,
                ref: a,
                style: {
                    position: "relative",
                    flex: 1,
                    overflow: "auto",
                    ...i.style
                },
                onScroll: Ee(i.onScroll, c => {
                    const u = c.currentTarget
                      , {contentWrapper: h, shouldExpandOnScrollRef: d} = o;
                    if (d?.current && h) {
                        const f = Math.abs(l.current - u.scrollTop);
                        if (f > 0) {
                            const g = window.innerHeight - ji * 2
                              , _ = parseFloat(h.style.minHeight)
                              , m = parseFloat(h.style.height)
                              , p = Math.max(_, m);
                            if (p < g) {
                                const b = p + f
                                  , y = Math.min(g, b)
                                  , x = b - y;
                                h.style.height = y + "px",
                                h.style.bottom === "0px" && (u.scrollTop = x > 0 ? x : 0,
                                h.style.justifyContent = "flex-end")
                            }
                        }
                    }
                    l.current = u.scrollTop
                }
                )
            })
        })]
    })
}
);
lO.displayName = fb;
var cO = "SelectGroup"
  , [moe,goe] = Yl(cO)
  , _oe = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, ...r} = t
      , i = Ci();
    return v.jsx(moe, {
        scope: n,
        id: i,
        children: v.jsx(We.div, {
            role: "group",
            "aria-labelledby": i,
            ...r,
            ref: e
        })
    })
}
);
_oe.displayName = cO;
var uO = "SelectLabel"
  , boe = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, ...r} = t
      , i = goe(uO, n);
    return v.jsx(We.div, {
        id: i.id,
        ...r,
        ref: e
    })
}
);
boe.displayName = uO;
var wp = "SelectItem"
  , [yoe,hO] = Yl(wp)
  , dO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, value: r, disabled: i=!1, textValue: s, ...o} = t
      , a = ao(wp, n)
      , l = lo(wp, n)
      , c = a.value === r
      , [u,h] = S.useState(s ?? "")
      , [d,f] = S.useState(!1)
      , g = rt(e, p => l.itemRefCallback?.(p, r, i))
      , _ = Ci()
      , m = () => {
        i || (a.onValueChange(r),
        a.onOpenChange(!1))
    }
    ;
    if (r === "")
        throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return v.jsx(yoe, {
        scope: n,
        value: r,
        disabled: i,
        textId: _,
        isSelected: c,
        onItemTextChange: S.useCallback(p => {
            h(b => b || (p?.textContent ?? "").trim())
        }
        , []),
        children: v.jsx(qm.ItemSlot, {
            scope: n,
            value: r,
            disabled: i,
            textValue: u,
            children: v.jsx(We.div, {
                role: "option",
                "aria-labelledby": _,
                "data-highlighted": d ? "" : void 0,
                "aria-selected": c && d,
                "data-state": c ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...o,
                ref: g,
                onFocus: Ee(o.onFocus, () => f(!0)),
                onBlur: Ee(o.onBlur, () => f(!1)),
                onPointerUp: Ee(o.onPointerUp, m),
                onPointerMove: Ee(o.onPointerMove, p => {
                    i ? l.onItemLeave?.() : p.currentTarget.focus({
                        preventScroll: !0
                    })
                }
                ),
                onPointerLeave: Ee(o.onPointerLeave, p => {
                    p.currentTarget === document.activeElement && l.onItemLeave?.()
                }
                ),
                onKeyDown: Ee(o.onKeyDown, p => {
                    l.searchRef?.current !== "" && p.key === " " || (ioe.includes(p.key) && m(),
                    p.key === " " && p.preventDefault())
                }
                )
            })
        })
    })
}
);
dO.displayName = wp;
var Ac = "SelectItemText"
  , fO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, className: r, style: i, ...s} = t
      , o = ao(Ac, n)
      , a = lo(Ac, n)
      , l = hO(Ac, n)
      , c = loe(Ac, n)
      , [u,h] = S.useState(null)
      , d = rt(e, p => h(p), l.onItemTextChange, p => a.itemTextRefCallback?.(p, l.value, l.disabled))
      , f = u?.textContent
      , g = S.useMemo( () => v.jsx("option", {
        value: l.value,
        disabled: l.disabled,
        children: f
    }, l.value), [l.disabled, l.value, f])
      , {onNativeOptionAdd: _, onNativeOptionRemove: m} = c;
    return hn( () => (_(g),
    () => m(g)), [_, m, g]),
    v.jsxs(v.Fragment, {
        children: [v.jsx(We.span, {
            id: l.textId,
            ...s,
            ref: d
        }), l.isSelected && o.valueNode && !o.valueNodeHasChildren ? fa.createPortal(s.children, o.valueNode) : null]
    })
}
);
fO.displayName = Ac;
var pO = "SelectItemIndicator"
  , mO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, ...r} = t;
    return hO(pO, n).isSelected ? v.jsx(We.span, {
        "aria-hidden": !0,
        ...r,
        ref: e
    }) : null
}
);
mO.displayName = pO;
var pb = "SelectScrollUpButton"
  , voe = S.forwardRef( (t, e) => {
    const n = lo(pb, t.__scopeSelect)
      , r = b1(pb, t.__scopeSelect)
      , [i,s] = S.useState(!1)
      , o = rt(e, r.onScrollButtonChange);
    return hn( () => {
        if (n.viewport && n.isPositioned) {
            let a = function() {
                const c = l.scrollTop > 0;
                s(c)
            };
            const l = n.viewport;
            return a(),
            l.addEventListener("scroll", a),
            () => l.removeEventListener("scroll", a)
        }
    }
    , [n.viewport, n.isPositioned]),
    i ? v.jsx(gO, {
        ...t,
        ref: o,
        onAutoScroll: () => {
            const {viewport: a, selectedItem: l} = n;
            a && l && (a.scrollTop = a.scrollTop - l.offsetHeight)
        }
    }) : null
}
);
voe.displayName = pb;
var mb = "SelectScrollDownButton"
  , xoe = S.forwardRef( (t, e) => {
    const n = lo(mb, t.__scopeSelect)
      , r = b1(mb, t.__scopeSelect)
      , [i,s] = S.useState(!1)
      , o = rt(e, r.onScrollButtonChange);
    return hn( () => {
        if (n.viewport && n.isPositioned) {
            let a = function() {
                const c = l.scrollHeight - l.clientHeight
                  , u = Math.ceil(l.scrollTop) < c;
                s(u)
            };
            const l = n.viewport;
            return a(),
            l.addEventListener("scroll", a),
            () => l.removeEventListener("scroll", a)
        }
    }
    , [n.viewport, n.isPositioned]),
    i ? v.jsx(gO, {
        ...t,
        ref: o,
        onAutoScroll: () => {
            const {viewport: a, selectedItem: l} = n;
            a && l && (a.scrollTop = a.scrollTop + l.offsetHeight)
        }
    }) : null
}
);
xoe.displayName = mb;
var gO = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, onAutoScroll: r, ...i} = t
      , s = lo("SelectScrollButton", n)
      , o = S.useRef(null)
      , a = Km(n)
      , l = S.useCallback( () => {
        o.current !== null && (window.clearInterval(o.current),
        o.current = null)
    }
    , []);
    return S.useEffect( () => () => l(), [l]),
    hn( () => {
        a().find(u => u.ref.current === document.activeElement)?.ref.current?.scrollIntoView({
            block: "nearest"
        })
    }
    , [a]),
    v.jsx(We.div, {
        "aria-hidden": !0,
        ...i,
        ref: e,
        style: {
            flexShrink: 0,
            ...i.style
        },
        onPointerDown: Ee(i.onPointerDown, () => {
            o.current === null && (o.current = window.setInterval(r, 50))
        }
        ),
        onPointerMove: Ee(i.onPointerMove, () => {
            s.onItemLeave?.(),
            o.current === null && (o.current = window.setInterval(r, 50))
        }
        ),
        onPointerLeave: Ee(i.onPointerLeave, () => {
            l()
        }
        )
    })
}
)
  , Eoe = "SelectSeparator"
  , Soe = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, ...r} = t;
    return v.jsx(We.div, {
        "aria-hidden": !0,
        ...r,
        ref: e
    })
}
);
Soe.displayName = Eoe;
var gb = "SelectArrow"
  , woe = S.forwardRef( (t, e) => {
    const {__scopeSelect: n, ...r} = t
      , i = Ym(n)
      , s = ao(gb, n)
      , o = lo(gb, n);
    return s.open && o.position === "popper" ? v.jsx(fm, {
        ...i,
        ...r,
        ref: e
    }) : null
}
);
woe.displayName = gb;
function _O(t) {
    return t === "" || t === void 0
}
var bO = S.forwardRef( (t, e) => {
    const {value: n, ...r} = t
      , i = S.useRef(null)
      , s = rt(e, i)
      , o = XL(n);
    return S.useEffect( () => {
        const a = i.current
          , l = window.HTMLSelectElement.prototype
          , u = Object.getOwnPropertyDescriptor(l, "value").set;
        if (o !== n && u) {
            const h = new Event("change",{
                bubbles: !0
            });
            u.call(a, n),
            a.dispatchEvent(h)
        }
    }
    , [o, n]),
    v.jsx(Ah, {
        asChild: !0,
        children: v.jsx("select", {
            ...r,
            ref: s,
            defaultValue: n
        })
    })
}
);
bO.displayName = "BubbleSelect";
function yO(t) {
    const e = vn(t)
      , n = S.useRef("")
      , r = S.useRef(0)
      , i = S.useCallback(o => {
        const a = n.current + o;
        e(a),
        function l(c) {
            n.current = c,
            window.clearTimeout(r.current),
            c !== "" && (r.current = window.setTimeout( () => l(""), 1e3))
        }(a)
    }
    , [e])
      , s = S.useCallback( () => {
        n.current = "",
        window.clearTimeout(r.current)
    }
    , []);
    return S.useEffect( () => () => window.clearTimeout(r.current), []),
    [n, i, s]
}
function vO(t, e, n) {
    const i = e.length > 1 && Array.from(e).every(c => c === e[0]) ? e[0] : e
      , s = n ? t.indexOf(n) : -1;
    let o = Coe(t, Math.max(s, 0));
    i.length === 1 && (o = o.filter(c => c !== n));
    const l = o.find(c => c.textValue.toLowerCase().startsWith(i.toLowerCase()));
    return l !== n ? l : void 0
}
function Coe(t, e) {
    return t.map( (n, r) => t[(e + r) % t.length])
}
var Toe = QL
  , Aoe = ZL
  , koe = tO
  , Roe = nO
  , Ioe = rO
  , Poe = iO
  , Doe = lO
  , Loe = dO
  , Ooe = fO
  , Noe = mO
  , y1 = "Switch"
  , [Moe,ove] = cs(y1)
  , [Boe,Foe] = Moe(y1)
  , xO = S.forwardRef( (t, e) => {
    const {__scopeSwitch: n, name: r, checked: i, defaultChecked: s, required: o, disabled: a, value: l="on", onCheckedChange: c, ...u} = t
      , [h,d] = S.useState(null)
      , f = rt(e, b => d(b))
      , g = S.useRef(!1)
      , _ = h ? !!h.closest("form") : !0
      , [m=!1,p] = Go({
        prop: i,
        defaultProp: s,
        onChange: c
    });
    return v.jsxs(Boe, {
        scope: n,
        checked: m,
        disabled: a,
        children: [v.jsx(We.button, {
            type: "button",
            role: "switch",
            "aria-checked": m,
            "aria-required": o,
            "data-state": wO(m),
            "data-disabled": a ? "" : void 0,
            disabled: a,
            value: l,
            ...u,
            ref: f,
            onClick: Ee(t.onClick, b => {
                p(y => !y),
                _ && (g.current = b.isPropagationStopped(),
                g.current || b.stopPropagation())
            }
            )
        }), _ && v.jsx(joe, {
            control: h,
            bubbles: !g.current,
            name: r,
            value: l,
            checked: m,
            required: o,
            disabled: a,
            style: {
                transform: "translateX(-100%)"
            }
        })]
    })
}
);
xO.displayName = y1;
var EO = "SwitchThumb"
  , SO = S.forwardRef( (t, e) => {
    const {__scopeSwitch: n, ...r} = t
      , i = Foe(EO, n);
    return v.jsx(We.span, {
        "data-state": wO(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: e
    })
}
);
SO.displayName = EO;
var joe = t => {
    const {control: e, checked: n, bubbles: r=!0, ...i} = t
      , s = S.useRef(null)
      , o = XL(n)
      , a = Ok(e);
    return S.useEffect( () => {
        const l = s.current
          , c = window.HTMLInputElement.prototype
          , h = Object.getOwnPropertyDescriptor(c, "checked").set;
        if (o !== n && h) {
            const d = new Event("click",{
                bubbles: r
            });
            h.call(l, n),
            l.dispatchEvent(d)
        }
    }
    , [o, n, r]),
    v.jsx("input", {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: s,
        style: {
            ...t.style,
            ...a,
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
        }
    })
}
;
function wO(t) {
    return t ? "checked" : "unchecked"
}
var Hoe = xO
  , Uoe = SO;
const el = S.memo( ({title: t, children: e, className: n}) => v.jsxs(v.Fragment, {
    children: [v.jsx("h2", {
        className: "pt-6 text-lg font-medium mb-4 sticky bg-bolt-elements-background-depth-2 top-0",
        children: t
    }), v.jsx("div", {
        className: be("flex flex-col gap-4", n),
        children: e
    })]
}))
  , Vr = S.memo( ({title: t, action: e, layout: n="horizontal", className: r, tooltip: i}) => v.jsxs(Vs, {
    children: [v.jsxs("div", {
        className: be("flex text-sm w-full min-h-[35px]", {
            "flex-row justify-between items-center": n === "horizontal",
            "flex-col items-start": n !== "horizontal"
        }, r),
        children: [v.jsx("span", {
            className: be("text-bolt-elements-textSecondary", n === "vertical" ? "mb-2" : void 0),
            children: t
        }), i ? v.jsx(qo, {
            asChild: !0,
            children: v.jsx("span", {
                children: e
            })
        }) : e]
    }), i && v.jsx(Ko, {
        children: v.jsx(na, {
            side: "top",
            align: "center",
            children: i
        })
    })]
}))
  , Voe = nr("Backups")
  , $oe = S.memo( ({}) => {
    const [t,e] = S.useState(!1)
      , [n,r] = S.useState(void 0)
      , i = Ne.getProjectId()
      , {snapshots: s} = Woe(i)
      , o = n !== void 0;
    async function a() {
        if (n) {
            e(!0);
            try {
                await zoe(n)
            } finally {
                e(!1),
                r(void 0)
            }
        }
    }
    return s.length > 0 ? v.jsxs(el, {
        title: "Backups",
        className: "pb-6",
        children: [s.map(l => v.jsx(Vr, {
            title: Zc(new Date(l.createdAt), "d MMMM yyyy 'at' HH:mm"),
            action: v.jsx(qi, {
                minHeight: 35,
                className: "px-4",
                variant: "primary-light",
                onClick: () => r(l),
                children: "Load"
            })
        }, l.id)), v.jsxs(Vo, {
            open: o,
            maxWidth: 600,
            showCloseButton: !1,
            closeOnBackdropClick: !t,
            onClose: () => r(void 0),
            children: [v.jsx(Os, {
                children: "Recover to Previous Backup"
            }), v.jsxs(Ns, {
                children: [v.jsx("p", {
                    children: "You are about to create a project based on a previous state."
                }), v.jsx("p", {
                    className: "my-6 bg-alpha-orange-10 border-l border-l-2 border-orange-500 p-2 px-4 text-orange-600 dark:text-orange-500",
                    children: "This action will redirect you to the newly created project but your current project will still be reachable at the current URL."
                }), v.jsx("p", {
                    children: "Are you sure you want to proceed?"
                })]
            }), v.jsxs(Mu, {
                children: [v.jsx(Gi, {
                    type: "secondary",
                    disabled: t,
                    onClick: () => r(void 0),
                    children: "Cancel"
                }), v.jsx(Gi, {
                    type: "warn",
                    disabled: t,
                    minWidth: 30,
                    onClick: a,
                    children: t ? v.jsxs("div", {
                        className: "flex items-center gap-1.5",
                        children: [v.jsx("div", {
                            className: "i-svg-spinners:90-ring-with-bg text-lg"
                        }), "Creating fork"]
                    }) : "Create fork"
                })]
            })]
        })]
    }) : v.jsx(el, {
        title: "Backups",
        children: v.jsx(Vr, {
            title: "Start chatting with Bolt and your backups will show up here"
        })
    })
}
);
async function zoe(t) {
    const e = Ne.getSlug();
    if (!e)
        throw new Error("No slug defined");
    const n = await t.getAsFileMap()
      , {slug: r} = await PP({
        slug: e,
        files: n
    });
    window.location.href = new URL(`/~/${r}`,window.origin).toString()
}
function Woe(t) {
    const e = Ie(ea.snapshots)
      , n = Object.values(e).sort(Goe);
    return S.useEffect( () => {
        if (!t)
            return;
        const r = new AbortController;
        return ea.fetchSnapshots(t, r.signal).catch(i => {
            i instanceof DOMException && i.name === "AbortError" || Voe.error(i)
        }
        ),
        () => {
            r.abort()
        }
    }
    , [t]),
    {
        snapshots: n
    }
}
function Goe(t, e) {
    return e.createdAt - t.createdAt
}
async function CO() {
    const t = await IP()
      , e = new URL("/api/bolt/tokens_reload",om);
    e.searchParams.set("success_url", window.origin),
    e.searchParams.set("cancel_url", window.origin);
    const r = await (await fetch(e, {
        method: "POST",
        headers: {
            authorization: `Bearer ${t}`,
            "Content-Type": "application/json"
        }
    })).json();
    window.open(r.sessionUrl, "_blank")
}
let CC = t => t
  , kc = {}
  , vs = {
    addEventListener() {},
    removeEventListener() {}
};
function qoe() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
qoe() && (kc = localStorage);
let Koe = {
    addEventListener(t, e, n) {
        window.addEventListener("storage", e),
        window.addEventListener("pageshow", n)
    },
    removeEventListener(t, e, n) {
        window.removeEventListener("storage", e),
        window.removeEventListener("pageshow", n)
    }
};
typeof window < "u" && (vs = Koe);
function Yoe(t, e={}, n={}) {
    let r = n.encode || CC
      , i = n.decode || CC
      , s = ma()
      , o = s.setKey
      , a = (h, d) => {
        typeof d > "u" ? (n.listen !== !1 && vs.perKey && vs.removeEventListener(t + h, c, u),
        delete kc[t + h]) : (n.listen !== !1 && vs.perKey && !(h in s.value) && vs.addEventListener(t + h, c, u),
        kc[t + h] = r(d))
    }
    ;
    s.setKey = (h, d) => {
        a(h, d),
        o(h, d)
    }
    ;
    let l = s.set;
    s.set = function(h) {
        for (let d in h)
            a(d, h[d]);
        for (let d in s.value)
            d in h || a(d, void 0);
        l(h)
    }
    ;
    function c(h) {
        h.key ? h.key.startsWith(t) && (h.newValue === null ? o(h.key.slice(t.length), void 0) : o(h.key.slice(t.length), i(h.newValue))) : l({})
    }
    function u() {
        let h = {
            ...e
        };
        for (let d in kc)
            d.startsWith(t) && (h[d.slice(t.length)] = i(kc[d]));
        for (let d in h)
            s.setKey(d, h[d])
    }
    return hk(s, () => {
        if (u(),
        n.listen !== !1)
            return vs.addEventListener(t, c, u),
            () => {
                vs.removeEventListener(t, c, u);
                for (let h in s.value)
                    vs.removeEventListener(t + h, c, u)
            }
    }
    ),
    s
}
const TO = "bolt_settings:"
  , v1 = AO("shortcuts", {
    toggleTerminal: {
        key: "j",
        ctrlOrMetaKey: !0
    }
})
  , Pl = AO("editor", {
    lineWrapping: !0
})
  , Cp = Yoe(TO, {
    shortcuts: v1.get(),
    editor: Pl.get()
}, {
    encode: JSON.stringify,
    decode: JSON.parse
});
v1.subscribe(t => {
    Cp.set({
        ...Cp.get(),
        shortcuts: t
    })
}
);
Pl.subscribe(t => {
    Cp.set({
        ...Cp.get(),
        editor: t
    })
}
);
function AO(t, e) {
    const n = localStorage.getItem(`${TO}${t}`);
    return ma(n ? JSON.parse(n) : e)
}
function _b(t) {
    return new Intl.NumberFormat(navigator.language).format(t)
}
function TC(t) {
    if (typeof t > "u")
        return "";
    if (t >= 1e6) {
        let e = (t / 1e6).toFixed(1);
        return e.endsWith(".0") && (e = e.slice(0, -2)),
        `${e}M`
    }
    return t >= 1e3 ? `${Math.floor(t / 1e3)}K` : t.toString(10)
}
function kO(t) {
    return t.plan === "pro" && t.level >= QF.PRO
}
async function Bu({action: t, onStateUpdate: e, minDuration: n=350, spinnerDelay: r=100}) {
    let i, s;
    const o = () => {
        i = Date.now(),
        e(!0)
    }
      , a = () => {
        clearTimeout(s),
        e(!1)
    }
    ;
    try {
        r > 0 ? s = setTimeout(o, r) : o();
        const l = await t();
        if (i) {
            const c = Date.now() - i;
            c < n && await new Promise(u => setTimeout(u, n - c))
        }
        return l
    } finally {
        a()
    }
}
const Xoe = [{
    icon: "i-ph:gear-six-duotone",
    text: "General"
}, {
    icon: "i-ph:paint-brush-fill",
    text: "Appearance"
}, {
    icon: "i-ph:code-simple",
    text: "Editor"
}, {
    icon: "i-ph:coin-vertical",
    text: "Tokens"
}, {
    icon: "i-ph:clock-counter-clockwise",
    text: "Backups"
}]
  , Qoe = ["light", "dark", "system"]
  , Joe = S.memo( ({closeDialog: t}) => {
    const [e,n] = S.useState(0)
      , [r,i] = S.useState(!1)
      , [s,o] = S.useState( () => WF())
      , [a,l] = S.useState(!1)
      , c = Ie(Kt.getTierStore())
      , u = c && kO(c)
      , h = Ie(Pl)
      , d = Ie(He.tokenStats)
      , f = async () => {
        if (!a) {
            if (!Un) {
                ct.error("Chat persistence is unavailable");
                return
            }
            try {
                await Bu({
                    action: async () => {
                        await zq(Un),
                        Ne.getSlug() !== void 0 && (window.location.pathname = "/"),
                        ct.success("All chats deleted")
                    }
                    ,
                    onStateUpdate: l
                })
            } catch (_) {
                ct.error("Failed to delete chats"),
                pa.error(_)
            }
        }
    }
    ;
    async function g() {
        i(!0);
        try {
            await CO()
        } catch {}
        i(!1)
    }
    return v.jsxs(v.Fragment, {
        children: [v.jsx(Ah, {
            children: v.jsx(Os, {
                children: "Settings"
            })
        }), v.jsx(Ns, {
            noPadding: !0,
            children: v.jsx(ga, {
                children: v.jsxs("div", {
                    className: "flex h-[400px] overflow-hidden",
                    children: [v.jsx("aside", {
                        className: "bg-bolt-elements-background-depth-1 border-r border-bolt-elements-borderColor p-4 min-w-[25%] space-y-1.5",
                        children: Xoe.map( ({icon: _, text: m}, p) => {
                            const b = e === p;
                            return v.jsx(S.Fragment, {
                                children: v.jsxs("button", {
                                    className: be("flex items-center gap-2 w-full px-4 py-2 rounded-lg text-sm", {
                                        "bg-bolt-elements-item-backgroundActive": b,
                                        "bg-transparent hover:bg-bolt-elements-item-backgroundActive": !b
                                    }),
                                    onClick: () => n(p),
                                    children: [v.jsx("span", {
                                        className: `${_} scale-120`
                                    }), m]
                                })
                            }, p)
                        }
                        )
                    }), v.jsxs("div", {
                        className: "px-6 flex-1 relative overflow-y-auto",
                        children: [e === 0 && v.jsx(el, {
                            title: "Chat",
                            children: v.jsx(Vr, {
                                title: "Delete all chats",
                                action: v.jsxs(qi, {
                                    minHeight: 35,
                                    className: "px-4",
                                    variant: "danger",
                                    disabled: a,
                                    onClick: f,
                                    children: [a && v.jsx("span", {
                                        className: "i-svg-spinners:90-ring-with-bg inline-block scale-110"
                                    }), "Delete all"]
                                })
                            })
                        }), e === 1 && v.jsx(el, {
                            title: "Appearance",
                            children: v.jsx(Vr, {
                                title: "Theme",
                                action: v.jsxs(Toe, {
                                    value: s,
                                    onValueChange: _ => {
                                        const m = _;
                                        o(m),
                                        GF(m)
                                    }
                                    ,
                                    children: [v.jsxs(Aoe, {
                                        className: "flex items-center gap-2 h-[35px] bg-bolt-elements-background-depth-3 text-bolt-elements-textSecondary px-4 rounded-lg focus:outline-none capitalize",
                                        children: [v.jsx(koe, {}), v.jsx(Roe, {
                                            asChild: !0,
                                            children: v.jsx("span", {
                                                className: "i-ph:caret-down inline-block"
                                            })
                                        })]
                                    }), v.jsx(Ioe, {
                                        children: v.jsx(Poe, {
                                            className: "overflow-hidden bg-bolt-elements-background-depth-1 rounded-lg shadow z-dialog",
                                            children: v.jsx(Doe, {
                                                className: "p-2 space-y-1",
                                                children: Qoe.map(_ => v.jsxs(Loe, {
                                                    value: _,
                                                    className: "relative flex items-center px-8 py-2 text-sm cursor-pointer hover:bg-bolt-elements-item-backgroundActive text-bolt-elements-textSecondary rounded-lg capitalize",
                                                    children: [v.jsx(Ooe, {
                                                        children: _
                                                    }), v.jsx(Noe, {
                                                        className: "absolute left-2 inline-flex items-center",
                                                        children: v.jsx("span", {
                                                            className: "i-ph:check"
                                                        })
                                                    })]
                                                }, _))
                                            })
                                        })
                                    })]
                                })
                            })
                        }), e === 2 && v.jsx(el, {
                            title: "Editor",
                            children: v.jsx(Vr, {
                                title: "Line Wrapping",
                                action: v.jsx(Hoe, {
                                    checked: h.lineWrapping,
                                    onCheckedChange: _ => {
                                        Pl.setKey("lineWrapping", _)
                                    }
                                    ,
                                    className: "w-[44px] h-[25px] bg-gray-300 rounded-full relative data-[state=checked]:bg-accent-600 outline-none cursor-pointer",
                                    style: {
                                        WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
                                    },
                                    children: v.jsx(Uoe, {
                                        className: "block w-[21px] h-[21px] bg-white rounded-full shadow transition-transform duration-100 translate-x-0.5 will-change-transform data-[state=checked]:translate-x-[21px]"
                                    })
                                })
                            })
                        }), e === 3 && d && v.jsxs(el, {
                            title: "Usage",
                            children: [typeof d.billingPeriod?.to == "number" && v.jsx(Vr, {
                                title: "Billing period",
                                action: v.jsx(v.Fragment, {
                                    children: Zc(d.billingPeriod.to, "d MMMM yyyy")
                                }),
                                tooltip: "End date of your current billing period"
                            }), typeof d.billingPeriod?.to == "number" && v.jsx(Vr, {
                                title: "Monthly tokens reset in",
                                action: v.jsx(v.Fragment, {
                                    children: _1(d.billingPeriod.to)
                                }),
                                tooltip: "When your monthly tokens will be reset"
                            }), d.maxPerDay !== d.maxPerMonth && v.jsx(Vr, {
                                title: "Per day",
                                action: v.jsx(AC, {
                                    from: Math.min(d.totalToday, d.maxPerDay),
                                    to: d.maxPerDay
                                }),
                                tooltip: "Tokens used today / Max tokens per day"
                            }), v.jsx(Vr, {
                                title: "Per month",
                                action: v.jsx(AC, {
                                    from: Math.min(Math.max(d.totalThisMonth, d.totalToday), d.maxPerMonth),
                                    to: d.maxPerMonth
                                }),
                                tooltip: "Tokens used this month / Max tokens per month"
                            }), (d.overflow.available !== 0 || u && d.billingPeriod) && v.jsx(Vr, {
                                title: "Purchased tokens remaining",
                                action: v.jsx(v.Fragment, {
                                    children: _b(Math.max(d.overflow.available - d.overflow.used, 0))
                                })
                            }), v.jsx(Vr, {
                                title: "",
                                action: u ? v.jsx(qi, {
                                    disabled: r,
                                    minWidth: 135,
                                    minHeight: 30,
                                    className: be("rounded-lg mt-auto text-center transition-theme text-white", {
                                        "bg-accent-600 enabled:hover:bg-accent-700": !r
                                    }),
                                    onClick: g,
                                    variant: "secondary",
                                    children: v.jsx("div", {
                                        className: "flex items-center gap-2",
                                        children: r ? v.jsx(v.Fragment, {
                                            children: v.jsx("span", {
                                                className: "i-svg-spinners:90-ring-with-bg inline-block scale-115"
                                            })
                                        }) : "Buy more tokens"
                                    })
                                }) : v.jsx(qi, {
                                    variant: "primary",
                                    minWidth: 135,
                                    minHeight: 30,
                                    disabled: r,
                                    onClick: () => {
                                        He.showPricingOverlay(),
                                        t()
                                    }
                                    ,
                                    children: v.jsx("div", {
                                        className: "flex items-center gap-2",
                                        children: "Upgrade for more tokens"
                                    })
                                })
                            })]
                        }), e === 4 && v.jsx($oe, {})]
                    })]
                })
            })
        })]
    })
}
)
  , AC = S.memo( ({from: t, to: e}) => v.jsxs("div", {
    className: "flex items-center justify-center",
    children: [v.jsx("span", {
        children: _b(t)
    }), v.jsx("span", {
        className: "w-4 text-center",
        children: "/"
    }), v.jsx("span", {
        children: _b(e)
    })]
}))
  , Zoe = S.memo
  , RO = Zoe( ({selected: t, options: e, setSelected: n, withBorder: r=!1}) => {
    const i = t === e.left.value;
    return v.jsxs("div", {
        className: be("flex items-center flex-wrap shrink-0 gap-1 bg-bolt-elements-background-depth-1 overflow-hidden rounded-full p-1", {
            "border border-bolt-elements-borderColor": r
        }),
        children: [v.jsx(kC, {
            selected: i,
            setSelected: () => n?.(e.left.value),
            children: e.left.text
        }), v.jsx(kC, {
            selected: !i,
            setSelected: () => n?.(e.right.value),
            children: e.right.text
        })]
    })
}
)
  , kC = S.memo( ({selected: t, children: e, setSelected: n}) => v.jsxs("button", {
    onClick: n,
    className: be("bg-transparent text-sm px-2.5 py-0.5 rounded-full relative", t ? "text-bolt-elements-item-contentAccent" : "text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive"),
    children: [v.jsx("span", {
        className: "relative z-10",
        children: e
    }), t && v.jsx(It.span, {
        layoutId: "pill-tab",
        transition: {
            duration: .2,
            ease: Ft
        },
        className: "absolute inset-0 z-0 bg-bolt-elements-item-backgroundAccent rounded-full"
    })]
}))
  , IO = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAYAAACohjseAAALJUlEQVR4Ac1aWWxUyRWt3twGTAM2OwbMjrARIIgwwyAWCTTiIx8Q/pJIBARC4mMGkgz5An4y0UQwP/CTDCOQEgkNGiBBASQkFhHMDh9gIAQIYLNvxizeu3PO7bqP6sV2d3uBK12/18/16tWpe+tuVcZ0D/lcjsViPud5l3+4K/pzr77p06fL74sXL7ptY841lvT70yFKw0rEv3HjRj+uIXAeOAzuablAecCAAQXOb/6vh23Ld4LggNPnRycBZuIDIzAOthc4Au4HLgIP6NWr1yBcyYMtD7LPBvTu3bvItuU7BJwPzps3b17Q9k2wJlcKZtmeEjM+kAMuYJl9BQsKCoJDhw4tnDRp0heBQKAsGAwO9/v9k/AKAUTs++ynOhqNVjc3N1eSnz59eurKlSt3375924R2zcePH2/GtQUc3bRpUxTto/HPZke5qIFfeciQIcG6urq8mpqa4IQJE4rKyspWAdBnGEg5Bm9aWloMrwTFe5UEBwrQwpgEYd6j7bX6+vrvnz179u+Kioo7aNpkmWAVZFbizAagGowAjIVIC5wHYP0BbHUoFFoBSUSampoMubGxUa54ZhRswiwBECZDwOXl5QmjD2E+R/sfq6qqtpw+ffo2mjdajpq4VF2j1O6gMwZn4qoY6tu3L6UWXrp06e8xoJUAE2loaDCQpoEEBByBuRLkNaHDJCkquHA4bHr06CFM0Ojvu3379n2LV+osSJGmBZrRwNskWjOQf+zYscFbt25RauHy8vJxI0eO3AEQpQT17t07AUeQlBrBJANqcxAAS1Z1JciePXsaGCIBCuBV9+7d+wWkect8kKasT9OOJNsDqJKjhQzB4uXDuv0SH90MQBEYBEOm1FQVO2LxlFSi+fn5AhKGi/e1+NZXhw4d+iea1JsPa7OlPQBtkbiA/v37h58/f56/ZMmSr6FS6wmqtrbWvH//XqSWvL46i7gWCZQAMblyxURu3b9//zcmDlJUNhZXs7QzG2ilb9cFhDGj+YsXL96A+/UEhvUnkiO4bFQxW1JVd40VtGcWDFvwwYMHZ7DWY3BHsbVr17ZqdPyt9O2DKmpUEp45c+bPMUPrX79+bV69eiXgaEg6Qx3bIwXIb/LbZNC62bNn/4pju3btmgQENopKoXQSFB939+5dMSgzZswYh/Dq7wAXpuSoll2lkm2Ruhr9NtR1Ftbnv2ALagYPHhyFxY0CbMp7yah9y5YtU3cg8eTw4cN/wuxFqJq0lF2pku0RwXEMHAvHVFxc/APdFYQRqqysDECKahQ9SvhhXYKC64l19wcAWke1ePPmjayDT4FofGhdi4qK6Ee3njx58o8Yn/pJDQSEEiRo/Z048ylTpozG73Vcd/RzuYDbtWuXuX79uqHqkHl/9uxZ01HiWChJTjrGuBKxb38Tj6wkOHfbegBteuKDMw/AJIfw0m8JjGuOizwXwmR5EQ2vZKiS6QxiXzQ8GF8Ey2g1x2ziSysBpAfQZghiOceMGTMKqrmMAHO1ljBOEoUoMDInqjMkSKIt4Ng4RqjpikgkwrSLUvTZtSjkqqjn+/r06fM5VYCcq8Wk9FRy6sf4+8KFC6aziCBt/BuZOHHiaoAUKW7evFk10gMo4OAOJEtgAM0XO2JUpk2blgBO72/evGk6i6hZuh5Bn8G6am7qCU4TXll/yMP8MC4leGkSxd8RlzBq1Cj5uJPgGqxvMQwEP2fOHAm9SJcvXxZ+/PixyZZUVaEd5chPix49elSP6IYAW1yAxqIOQsyzNSvIleB4DbRB+nCzcIRXZsOGDWbRokUJ7RcuXCjgtm3bZk6dOmWyIZUiQY4ePfoLANyJe5+1KTERpXXuPlgi1j9K7YyYXAlGyltzqqK8IuQzCxYsSDA8+j/6NJQmOEiTLfE7HDMwleGnH5riWVIBuGfPHgEI9fEToKpWroQM32hmn7wO1fC4rsP9vWrVKpMtqRTRR7FJ8u3JKupno47GmkiG5YO69pIp3XNVZawfiVJo/jMlBUjhmA81I6EEI2O5uKPxJky2B1AHQDp27Jg5d+6c3C9fvtwMHDgw/nGnHe9LSkqyDghsYSuCyfFjcrzCc0LZkDNHdeqIepaWlqZ1LwcPHjQ7d+70fl+9etVs375dShOdQbaaEHEk761BuUHWLk8JriMAR4wYkWJEqPLJEQwHcubMmbRtc/m+M27+YT4rz4P2gUFJImYb1pp4lTknGj9+fFoJomiU8ozFJbetrk3GmNmSA1DcAwrH8ltVVKcMko7WUtQmR0oGyEHfuHFDgnaXqDFTp05NmYwXL16Y+/fvm1wI0q/GJTZo0KDYkydP+O2YG3lLXQONruWqoojqpUiUrHaIbQWMEhJVs2bNmhRfSPXsSLaB96twiQIcAYilVBXVB1E2as28t0eFhYUp0QsJhWLxb4wZKUk6dZIaNK2LEuCBAwdMtqR9oD/WLKKwwlFk+T4FKG34D8w0VfSq6nO2mx2TJ0/2IiB3kvSe0qU0VS2TJ/Lw4cOiorkSvn2VOADO26xxAcaQvbfAbB9GyPZdLgAZg2aagbB/lu0VIONUupKOEIxThbFBto7d9YOioghWXyLKP4MPl2cDksktHXcywNu3b4vq9uvXL+UdlTbLGbt37za5kGobNK8SAfv/jK3J2GJwogSx+Fuqq6ub8eEKboFlAxCpSlrpnT9/3ly6dMmgjmmwMyVSZr/MWB4+fGiOHj1q7ty5Y3IlBYhv7zB2YwbJg7eX6I5e9yDyYcKHYK0wpopQjTIBOX/+fGElrAOzd+9eqYJ3Fbm7VggcfgYJMpvWfQvR/eQdXoq3BU7/BcK2HQD3lVq49kjzP/qwEydOCMCuJpUe+EerngSWkCkkV7Z9MLF+zjos3n8Qafwaz8KZgGQGf+TIEQHXlVJTcqUH97Mcle2nGEMTqhIJddGU0r0dnB8bLo3YsuKBglkKsC2QrLWwhtodpODsdSvy2H9g3A2IP5thsBIceHLpPoaSG6elCS81In78MzqpdHdqPzYpOGuBuTH6LaQnqonEPWWXKZ1IuD/hR2M5FoKoYxz84hGektAt51xOO3QGKTjL3BBdiMDAMyzpDin403QSA7goxY2fjejgNozHRqfjjyLJJHA0aF/CNfwXrq3BWPeQbhM0BaCVTmzu3LlRlA8o+gZEGX+jruv2VXeDdNXS1m62wIcewJpvRBWwzb36bLawewwbNuxrGJ91qqqqrl2lsk6U4jEAbsGE/wn/Zv2zEUaF0st6h1dJjmsAHCVZh46/weytpP671bHOlqgLytGaWvCXHIOx+/OwFXqkpNWPZzr1AR4jgUqE4GfCUIsx4J8gwWI97+JepeMspeqWSlyAGmfC1/2G9gD/5ppzz8u0PXCTGcVevnwZQy4nATniyBrsA/yAoJwaMMuJKFoddFugXE46AkapbcfErsLkPanneZUP0UpGpb+sptnZAdbThZTmKLiR32EAy6RDJyhw12c6iSaDI9nohMC+x9L4CybzuUk9ypVxXTNb6yC1U5b64UoEqD3WFQLQEqRMn8PprsDzUu+FNoxQsoRxfxpcAWB/JTCkWU3QHKqid/LQZjgZL/hczZ9bKNaDebIzjAEEIM0SBOs8dVgG5lHK4fh/sfeyz0cJ1aIdo6QqcCXU/xCip5fIYpqhks1Iv1qQm8o6Y3SFPT8vx+tu8tvDqzy44B6I7QupFgI0C64sYXsHYgF+sH3G/xWC+4B7G3sgFnljCFqSsM/3sck9IBvkAE38mDIBc9AEXQB/ShDkAvtMAMFCh+07oglOf580+ezpo4QTwQ67u7FavvzkQbVH3Q7g/31G54lgYptiAAAAAElFTkSuQmCC"
  , PO = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAG3klEQVR4Ac1aO28TSxj9bMz7oYVIICBIRoRQQXwrBM2NRcXzJkBDl/yC5CJq4kj8gNAgJAqggSYQUiAKhIAGQRUHCiQCiiWIEFISzCu8k3vOMJ/veL2xvbuO4EiTWY9nd8755sxjx0lIA/D27Vvv58+fHXNzc234mE4kEhnkHj57WgdlBXwu4DKfSqXyyO+vXbu2IDGRkIgg6R8/fvTi8m+kdpAz5ZoHNpZI+K/zyAcWLVoUWUxoAUocDffMzs56LvFq5EsNWhFubtMlCOkPKySUgDdv3uTQSIm4m1REXY1Wki8lPLt/w4YNOakTdQl4/fp1GsSHcJlRwmgoFOl5CVgxyWSyJALXhe/fv2c3btxYqHV/slYFkO/CoBsB0QxJY7CaVK9lasENCJ9rcwZsBD3eUev+qgKsZS7igR4fzNQI0kFwhdh2PPTGEAKYq3bfvBbijSDft9DE54NaijkC2A875YLqBQqYmJjoWLx48dDvIq9QAUxA1/r16y9X1PEXcMDiBnre+53kFSoCeRF8/vIP7KAxcPdPIU/ouNAx4f++TACsk0Ol9J9CXuHMeBk4pM/9rmQhWgeVxu1iIlFw7tw5efHiRVnZ8uXL5cyZMxIXukaAY/Hr169bgSLLSz2Akd5nK0hUoAfFv0Jv2rRJGgF9Hjh6S5Ys6dFyI2B8fJw7yK44i9Pz58/l8+fPFduKbdu2SaPgPLsXnM1O1wjAfN/eqOj7GpKWlhZpJLQXMDOZXkjawh6JCfaANuAKaJSFFFYA83Z+Tj19+lRfQGLh1atXrk9NvnnzZjOIKe7x48fy5csXU5e9wrRu3TqJCrTRPjIy4qUaYZ/p6WmTFPos7O3lypUr8ujRo7L6/EzyR48elZ07d0pYaJBWr179TxIXbRITbvTFsdCTJ0/k4cOHpkwb1jQ9NSUXLlyQCdwbBXa6zyS5TZaYUP8rSZcsMevObvq9rX/t+nWJCi66SahIS0y4PTBnSQa9rc0F9MTY2JiZfqMAa1cmhYekJSaePXtmcn27mrUe3b17t+zatctcXxsclEnYRljHCtX6DMD27dslDGwAvFTUbYOCEXQfai+kPZuVY8eOlb7jrHP69OmyaMfdb/HdPBl341ZmH8dGjLwLTqf+Momx8hPkTgHFOA9R+/jR3NxcUTYzM1MhlKC4sCB5HO9IEn+KfJmOijEK8PUA/ewnNQX/j46OltXldRPWgyCx1eC8OxcoIK+nDGHx8uVLmeEGzj5UyU1OTv4ia0GbnT9//n/L2MTB3hJy8CrsCUYhhfOXArtCV7cwYFRd4Xo1BQEkvGLFCtMTrBcI3Hvw4EEJC7YJ3oL3gjxnodFv3779GhDJmsdEZWCU/T2XUCEo//Tpk0nz4dChQ9LU1CRhweiTM/J8En9ucGqjorA2ooXcbYLJ9csaMwx9TwFhwWfSMdwYYlK4n8xms0WouceCMGsCZxQKKPnf5hzA3KjNOQ2aZKdrpra2Njl58qREATmSK+2zf//+QoqF+HAPhNrpVz1QqgUTfYe8Wmfvnj2yZ+9euXPnjjx48MDU4/M4Hpq3bJHDhw9La2urRIF6n8GDkAGWGQEfP348i4OsXjTi4RxUmGqB879rkdYdO6Srq6vk6X379pnUSDD6tDsFFIvF+yUBnZ2dxdu3bw98+PAht3TpUvc0bF4Y+0DADhA/cuRI5KiGIQ+nmEkBlr8EzoWSAIK9ANK9qGB6AT1S1Uq026lTp4yAhYZah+QRZOb9+l0Zw1u3bvXBRjnaAG87dVlpoaGzDgJs1hPkOawdwQKImzdvjniel6EIDrx6B/VCgOQ555M8X1kR/cKBAwe2unUqjA7Cne/fv8cYKepoj73tjQIlbweskBPGQNZfr0IA51bMs//ixzxzI30Xda8UFUqebZPHu3fvOPt068B1ETjVoOIljPQcb7ZdZwZR3JefesA2uE1AxE3bDCIinzt+/PiNoPpVzT08PNyHY5ccB/SaNWtk1apVotNso8eFRp1TJT1PAcwRuBwC2j/ffTVZDA4OduAw9SKmTY9CKGLZsmWCsoYI0b29rrAkzR6HjYv8PRpnR5er3V9X61evXk1DwF2sDWnOTEwrV640vcH1Ar3062H2CLwWYUJ/viJxuzEznudKCwvlUdZ54sSJQg1q4X7oHhoa4hF8jqTZCxTC3BXi/CRUQVxJ0yokTq+TMBNFoIxvhwM4DOivl1Po/mdvgHQfLvn7sbGSJopgmQpRES55EufCRPKaQNoQh+/Pdnd3F8PwiWxgCgFpnqv28HCYpJkY/SABKoLktRdQdo8pCvHYAvxieEiM1GZPutM2KXjyQYL8N5sCrvMYqMNRSbv4DySzjo65mKQSAAAAAElFTkSuQmCC"
  , eae = [{
    group: "pro",
    ...Tc.pro_1,
    tier: 1,
    rateMonthly: {
        month: 20,
        year: 18
    },
    tokens: "10M",
    description: "Ideal for hobbyists and casual users for light, exploratory use."
}, {
    group: "pro",
    ...Tc.pro_2,
    tier: 2,
    rateMonthly: {
        month: 50,
        year: 45
    },
    discountRate: {
        month: 3,
        year: 13
    },
    tokens: "26M",
    prevTokens: "25M",
    description: "Designed for professionals who need to use Bolt a few times per week."
}, {
    group: "pro",
    ...Tc.pro_3,
    tier: 3,
    rateMonthly: {
        month: 100,
        year: 90
    },
    discountRate: {
        month: 9,
        year: 18
    },
    tokens: "55M",
    prevTokens: "50M",
    description: "Perfect for heavy users looking to enhance daily workflows."
}, {
    group: "pro",
    ...Tc.pro_4,
    tier: 4,
    rateMonthly: {
        month: 200,
        year: 180
    },
    discountRate: {
        month: 17,
        year: 25
    },
    tokens: "120M",
    prevTokens: "100M",
    description: "Best for power users relying on Bolt as a core tool for continuous use."
}]
  , tae = S.memo( ({show: t, user: e, onClose: n}) => {
    const r = lk(e)
      , i = r.plan !== "personal"
      , s = kO(r)
      , o = Ie(He.tokenStats)
      , [a,l] = S.useState(!1)
      , [c,u] = S.useState()
      , h = Ie(da)
      , [d,f] = S.useState("monthly")
      , g = async ({level: p, interval: b}) => {
        const y = await Bu({
            action: async () => iae(p, b),
            onStateUpdate: x => {
                u(x ? p : null)
            }
        });
        y && window.open(y.sessionUrl, "_self")
    }
    ;
    async function _() {
        l(!0);
        try {
            await CO()
        } catch {}
        l(!1)
    }
    const m = {
        left: {
            value: "monthly",
            text: "Monthly"
        },
        right: {
            value: "yearly",
            text: "Yearly"
        }
    };
    return t && v.jsxs("div", {
        className: "fixed inset-0 bg-bolt-elements-background-depth-1 text-bolt-elements-textPrimary z-max overflow-y-auto",
        children: [v.jsx(tn, {
            className: "absolute right-6 top-6",
            icon: "i-ph:x",
            onClick: n
        }), v.jsx("div", {
            className: "flex items-center min-h-screen px-10 py-20",
            children: v.jsxs("div", {
                className: "mx-auto max-w-[1280px] flex flex-col gap-8",
                children: [v.jsxs(It.div, {
                    initial: {
                        opacity: 0
                    },
                    animate: {
                        opacity: 1
                    },
                    transition: {
                        duration: .15,
                        ease: Ft
                    },
                    className: "flex flex-col gap-3 py-4",
                    children: [v.jsx("h1", {
                        className: "text-center text-5xl font-semibold",
                        children: "Pricing"
                    }), v.jsx("p", {
                        className: "text-center max-w-[600px] w-[90%] mx-auto text-bolt-elements-textSecondary text-base",
                        children: "Start with a free account to speed up your workflow on public projects or boost your entire team with instantly-opening production environments."
                    })]
                }), i && o?.billingPeriod && v.jsxs("div", {
                    className: "flex flex-1 items-center px-6 py-4 border bg-bolt-elements-background-depth-2 border-bolt-elements-borderColor rounded-lg",
                    children: [v.jsx("div", {
                        className: "flex flex-col w-[60%]",
                        children: o && v.jsxs("div", {
                            children: [v.jsx("img", {
                                className: "h-6 w-6 mr-2 align-top inline-block",
                                src: h === "dark" ? IO : PO
                            }), v.jsx("span", {
                                className: "font-bold",
                                children: TC(Math.max(o.maxPerMonth - o.totalThisMonth, 0) + Math.max(o.overflow.available - o.overflow.used, 0))
                            }), " ", "tokens left.", v.jsxs("span", {
                                className: "ml-2 text-bolt-elements-textTertiary",
                                children: [TC(o.maxPerMonth), " will be added in", " ", _1(new Date(o.billingPeriod.to)), "."]
                            })]
                        })
                    }), v.jsxs("div", {
                        className: "ml-auto text-right text-sm",
                        children: [v.jsx("div", {
                            className: "font-bold mb-1",
                            children: "Need more tokens?"
                        }), s ? v.jsxs(v.Fragment, {
                            children: [v.jsx("span", {
                                children: "Upgrade your plan below or buy a "
                            }), v.jsx("button", {
                                className: "border-none bg-transparent p-0 text-accent-600 dark:text-accent-500 text-sm",
                                disabled: a,
                                onClick: _,
                                children: "token reload"
                            })]
                        }) : v.jsx(v.Fragment, {
                            children: v.jsx("span", {
                                children: "Upgrade your plan below"
                            })
                        })]
                    })]
                }), v.jsx("div", {
                    className: "flex justify-center",
                    children: v.jsx(RO, {
                        options: m,
                        selected: d,
                        setSelected: f,
                        withBorder: !0
                    })
                }), v.jsx(It.div, {
                    className: "grid md:max-[1360px]:grid-cols-2 min-[1360px]:grid-cols-4 gap-8",
                    initial: {
                        opacity: 0,
                        scale: .96,
                        y: 12
                    },
                    animate: {
                        opacity: 1,
                        scale: 1,
                        y: 0
                    },
                    transition: {
                        duration: .15,
                        ease: Ft
                    },
                    children: eae.map( (p, b) => v.jsx(nae, {
                        plan: p,
                        active: r.plan === p.group && r.level === p.tier,
                        disabled: c ? c !== p.level : !1,
                        loading: c === p.level,
                        onChangePlan: g,
                        selectedInterval: d,
                        theme: h
                    }, b))
                }), v.jsxs("div", {
                    className: "flex flex-col items-center text-sm",
                    children: [v.jsx("div", {
                        "aria-hidden": !0,
                        className: "i-bolt:enterprise text-2xl"
                    }), v.jsxs("p", {
                        className: "mt-3",
                        children: ["Looking for ", v.jsx("span", {
                            className: "font-bold",
                            children: "Team"
                        }), " or ", v.jsx("span", {
                            className: "font-bold",
                            children: "Enterprise"
                        }), " ", "plans?"]
                    }), v.jsx("a", {
                        href: "https://stackblitz.com/pricing",
                        className: "font-bold mt-1 text-bolt-elements-item-contentAccent",
                        children: "Check out StackBlitz pricing"
                    })]
                })]
            })
        })]
    })
}
)
  , nae = S.memo( ({plan: t, active: e=!1, disabled: n, loading: r, selectedInterval: i, theme: s, onChangePlan: o}) => {
    const {name: a, namePrice: l, description: c, rateMonthly: u, discountRate: h, tokens: d, prevTokens: f} = t;
    return v.jsxs("div", {
        className: be("border rounded-lg bg-bolt-elements-background-depth-2", e ? "border-bolt-elements-borderColorActive" : "border-bolt-elements-borderColor"),
        children: [v.jsxs("div", {
            className: "flex flex-col gap-2.5 p-5.5 min-h-[132px] relative",
            children: [v.jsxs("div", {
                className: "text-3xl",
                children: [a, " ", l && v.jsx("span", {
                    className: "font-extrabold",
                    children: l
                })]
            }), v.jsxs("div", {
                children: [v.jsxs("div", {
                    className: "flex items-center text-base",
                    children: [v.jsxs("span", {
                        className: be("font-semibold flex items-center gap-1", {
                            "text-color-green-500": !!f
                        }),
                        children: [v.jsx("img", {
                            className: "w-6 h-6 me-2",
                            src: s === "dark" ? IO : PO
                        }), v.jsxs("span", {
                            children: [d, " tokens"]
                        })]
                    }), f && v.jsxs("span", {
                        className: "line-through ml-2",
                        children: [f, " tokens"]
                    })]
                }), v.jsx("p", {
                    className: "mt-4 text-sm text-bolt-elements-textSecondary",
                    children: c
                })]
            }), h && v.jsxs("div", {
                className: "px-2.5 py-1.5 bg-bolt-elements-pricing-promo-background text-bolt-elements-pricing-promo-text font-italic font-semibold text-xs rounded-full absolute top-4 right-4",
                children: ["Save ", i === "monthly" ? h.month : h.year, "%"]
            })]
        }), v.jsxs("div", {
            className: "flex flex-col justify-center items-center gap-2 border-t border-bolt-elements-borderColor min-h-[120px]",
            children: [v.jsxs("div", {
                className: "relative leading-none pl-5",
                children: [v.jsx("span", {
                    className: "absolute left-1 top-0.5 text-base",
                    children: "$"
                }), v.jsx("span", {
                    className: "text-4xl",
                    children: i === "monthly" ? u.month : u.year
                }), v.jsx("span", {
                    className: "text-sm",
                    children: " / month"
                })]
            }), v.jsxs("div", {
                className: "text-sm text-bolt-elements-textSecondary",
                children: ["Billed ", i === "monthly" ? "monthly" : "yearly"]
            })]
        }), v.jsx("div", {
            className: "border-t border-bolt-elements-borderColor text-sm"
        }), v.jsx("div", {
            className: "flex justify-center p-6",
            children: v.jsx("button", {
                disabled: r || n,
                className: be("px-3 py-2 rounded-lg mt-auto text-center text-xs transition-theme flex-1 self-stretch", {
                    "bg-bolt-elements-button-secondary-background": e,
                    "bg-bolt-elements-button-primary-background text-bolt-elements-button-primary-text enabled:hover:bg-accent-700": !e && !r,
                    "cursor-not-allowed": n && !r,
                    "bg-alpha-gray-10 dark:bg-alpha-white-10": r
                }),
                onClick: () => e ? rae() : o({
                    level: t.level,
                    interval: i
                }),
                children: v.jsxs("span", {
                    className: "relative",
                    children: [v.jsx(hs, {
                        children: r && v.jsx(It.span, {
                            className: "absolute top-[50%] translate-y-[-50%] -left-6.5 i-svg-spinners:90-ring-with-bg text-lg inline-block",
                            initial: {
                                opacity: 0
                            },
                            animate: {
                                opacity: 1
                            },
                            transition: {
                                duration: .15,
                                ease: Ft
                            }
                        })
                    }), e ? "Manage current plan" : `Upgrade to ${a}${l ? " " + l : ""}`]
                })
            })
        })]
    })
}
);
function rae() {
    window.open(`${om}/settings/membership/billing`, "_blank")
}
async function iae(t, e) {
    const n = new URLSearchParams
      , r = new URL(window.location.origin);
    r.searchParams.set("showPricing", "true"),
    n.set("success_url", r.href);
    try {
        const i = await fetch(`/api/checkout/${t}/${e === "monthly" ? "monthly" : "yearly"}?${n.toString()}`);
        if (!i.ok) {
            ct.error("Failed to initiate checkout. Please try again later.");
            return
        }
        return i.json()
    } catch (i) {
        console.log(i),
        ct.error("Checkout failed");
        return
    }
}
const uc = "flex items-center gap-2 p-2 rounded-lg bg-transparent hover:bg-bolt-elements-item-backgroundActive"
  , sae = {
    closed: {
        opacity: 0,
        visibility: "hidden",
        left: "-150px",
        transition: {
            duration: .2,
            ease: Ft
        }
    },
    open: {
        opacity: 1,
        visibility: "initial",
        left: 0,
        transition: {
            duration: .2,
            ease: Ft
        }
    }
}
  , oae = S.memo( ({loggedIn: t, user: e}) => {
    _r.trace("Menu");
    const n = ky()
      , [r,i] = uk()
      , s = S.useRef(null)
      , [o,a] = S.useState([])
      , [l,c] = S.useState(!1)
      , [u,h] = S.useState(null)
      , [d,f] = S.useState( () => r.has("showPricing"))
      , g = Ie(da)
      , _ = S.useCallback(async () => {
        try {
            const E = await uX();
            a(E.filter(w => w.projectId && w.description))
        } catch {
            ct.error("Failed to load the chats.")
        }
    }
    , [])
      , m = S.useCallback(async () => {
        if (Un)
            try {
                const E = await $q(Un);
                await Promise.allSettled(E.map(async w => {
                    if (w.slug && w.description) {
                        const A = {
                            slug: w.slug,
                            title: w.description,
                            timestamp: w.timestamp
                        };
                        if (!(await fetch("/api/chats", {
                            method: "POST",
                            body: JSON.stringify(A)
                        })).ok)
                            return
                    }
                    await Wq(Un, w.slug)
                }
                ))
            } catch {}
    }
    , [])
      , p = S.useCallback(async (E, w) => {
        E.preventDefault();
        try {
            await dX(w.projectId),
            a(A => A.filter(C => C.projectId !== w.projectId)),
            Ne.getProjectId() === w.projectId && (window.location.pathname = "/"),
            ct.success("Chat deleted")
        } catch (A) {
            ct.error("Failed to delete chat"),
            pa.error(A)
        }
    }
    , [])
      , b = S.useCallback( () => {
        c(!0)
    }
    , [])
      , y = S.useCallback( () => {
        h(null)
    }
    , []);
    S.useEffect( () => {
        l && t ? _() : t || a([])
    }
    , [l, t]),
    S.useEffect( () => {
        t && m()
    }
    , [t]),
    S.useEffect( () => {
        function A(k) {
            He.showChat.get() && k.pageX < 15 && c(!0),
            s.current && k.clientX > s.current.getBoundingClientRect().right + 40 && c(!1)
        }
        window.addEventListener("mousemove", A);
        const C = He.events.on("showPricingOverlay", () => {
            const k = new URL(window.location.href);
            k.searchParams.set("showPricing", "true"),
            n(k.pathname + k.search),
            f(!0)
        }
        );
        return () => {
            C(),
            window.removeEventListener("mousemove", A)
        }
    }
    , []),
    S.useEffect( () => {
        f(r.has("showPricing"))
    }
    , [r]);
    const x = S.useCallback( () => {
        i(E => (E.delete("showPricing"),
        E)),
        f(!1)
    }
    , []);
    return v.jsxs(v.Fragment, {
        children: [v.jsx("div", {
            className: "fixed top-[var(--header-height)] bottom-0 z-10 flex flex-col items-center justify-end px-2.5 p-3",
            children: v.jsx("button", {
                className: "bg-transparent text-bolt-elements-textSecondary cursor-none",
                onMouseOver: b,
                onClick: b,
                children: v.jsx("div", {
                    className: "i-ph:sidebar-simple-duotone text-xl"
                })
            })
        }), v.jsxs(It.div, {
            ref: s,
            initial: "closed",
            animate: l ? "open" : "closed",
            variants: sae,
            className: "flex selection-accent flex-col side-menu fixed top-0 w-[350px] h-full bg-bolt-elements-background-depth-2 border-r rounded-r-3xl border-bolt-elements-borderColor z-sidebar shadow-xl shadow-bolt-elements-sidebar-dropdownShadow text-sm",
            children: [v.jsx("div", {
                className: "flex items-center h-[var(--header-height)]"
            }), v.jsxs("div", {
                className: "flex-1 flex flex-col h-full w-full overflow-hidden",
                children: [t && e && v.jsx(aae, {
                    user: e,
                    setDialogContent: h,
                    theme: g,
                    list: o
                }), !t && v.jsx("div", {
                    className: "pl-4 pr-4 my-2",
                    children: v.jsxs("div", {
                        className: "pl-2 text-bolt-elements-textTertiary",
                        children: ["To see your previous chats, please", " ", v.jsx(Lf, {
                            children: ({onLogin: E}) => v.jsx("button", {
                                className: "bg-transparent font-medium inline-block text-bolt-elements-link hover:underline",
                                onClick: E,
                                children: "log in"
                            })
                        }), "."]
                    })
                })]
            })]
        }), v.jsxs(Vo, {
            open: !!u,
            maxWidth: u?.type === "settings" ? 700 : void 0,
            onClose: y,
            children: [u?.type === "delete" && v.jsx(lae, {
                item: u.item,
                onDeleteItem: E => {
                    p(E, u.item),
                    y()
                }
                ,
                onClose: y
            }), u?.type === "settings" && v.jsx(Joe, {
                closeDialog: y
            })]
        }), e && v.jsx(tae, {
            show: d,
            user: e,
            onClose: x
        })]
    })
}
);
function aae({list: t, setDialogContent: e, theme: n, user: r}) {
    const [i,s] = S.useState("");
    return v.jsxs(v.Fragment, {
        children: [v.jsx("div", {
            className: "p-4 select-none",
            children: v.jsxs("a", {
                href: "/",
                className: "flex gap-2 items-center bg-bolt-elements-sidebar-buttonBackgroundDefault text-bolt-elements-sidebar-buttonText hover:bg-bolt-elements-sidebar-buttonBackgroundHover rounded-md p-2 transition-theme",
                children: [v.jsx("span", {
                    className: "inline-block i-bolt:chat scale-110"
                }), "Start new chat"]
            })
        }), v.jsx("div", {
            className: "pl-4 pr-4 my-2",
            children: v.jsxs("div", {
                className: "relative w-full",
                children: [v.jsx("input", {
                    className: be("w-full bg-white dark:bg-bolt-elements-background-depth-4 relative px-2 py-1.5 rounded-md focus:outline-none placeholder-bolt-elements-textTertiary border border-bolt-elements-borderColor", {
                        "pr-6.5": !!i
                    }),
                    type: "text",
                    placeholder: "Search",
                    value: i,
                    onChange: ({target: o}) => s(o.value)
                }), i && v.jsx("button", {
                    className: "i-ph:x-bold absolute right-2 top-1/2 -translate-y-1/2 bg-none cursor-pointer text-bolt-elements-textTertiary hover:text-bolt-elements-textPrimary transition-theme",
                    onClick: () => s("")
                })]
            })
        }), v.jsx("div", {
            className: "text-bolt-elements-textPrimary font-medium pl-6 pr-5 my-2",
            children: "Your Chats"
        }), v.jsxs("div", {
            className: "flex-1 overflow-y-auto pl-4 pr-5 pb-5",
            children: [t.length === 0 && v.jsx("div", {
                className: "pl-2 text-bolt-elements-textTertiary",
                children: "No previous conversations"
            }), eoe(cae(i, t)).map( ({category: o, items: a}) => v.jsxs("div", {
                className: "mt-4 first:mt-0 space-y-1",
                children: [v.jsx("div", {
                    className: "text-bolt-elements-textTertiary sticky top-0 z-1 bg-bolt-elements-background-depth-2 pl-2 pt-2 pb-1",
                    children: o
                }), a.map(l => v.jsx(Die, {
                    item: l,
                    onDelete: () => e({
                        type: "delete",
                        item: l
                    })
                }, l.projectId))]
            }, o))]
        }), v.jsxs("div", {
            className: "select-none",
            children: [v.jsx("div", {
                className: "bg-bolt-elements-background-depth-1 border-t border-bolt-elements-borderColor overflow-hidden",
                children: v.jsxs("div", {
                    className: "flex flex-col p-2 space-y-2",
                    children: [v.jsxs("button", {
                        className: uc,
                        onClick: o => {
                            o.preventDefault(),
                            e({
                                type: "settings"
                            })
                        }
                        ,
                        children: [v.jsx("span", {
                            className: "i-ph:gear-six-duotone text-lg"
                        }), "Settings"]
                    }), v.jsxs("a", {
                        href: "https://github.com/stackblitz/bolt.new/issues/new/choose",
                        target: "_blank",
                        className: uc,
                        children: [v.jsx("span", {
                            className: "i-ph:chat-centered-dots-duotone text-lg"
                        }), "Give Feedback"]
                    }), v.jsxs("button", {
                        className: uc,
                        onClick: qF,
                        children: [v.jsx("span", {
                            className: `${n === "dark" ? "i-ph-sun-dim-duotone" : "i-ph-moon-stars-duotone"} text-lg`
                        }), "Toggle Theme"]
                    }), v.jsx("div", {
                        className: "h-px bg-bolt-elements-borderColor"
                    }), v.jsxs("button", {
                        className: uc,
                        onClick: () => He.showPricingOverlay(),
                        children: [v.jsx("span", {
                            className: "i-ph:credit-card-duotone text-lg"
                        }), "My Subscription"]
                    }), v.jsxs("a", {
                        href: "/logout",
                        className: uc,
                        children: [v.jsx("span", {
                            className: "i-ph:sign-out text-lg"
                        }), "Sign Out"]
                    })]
                })
            }), v.jsxs("div", {
                className: "flex items-center p-4 border-t border-bolt-elements-borderColor",
                children: [v.jsx(DL, {
                    avatar: r?.avatar,
                    backgroundColor: "bg-bolt-elements-background-depth-4"
                }), v.jsx("span", {
                    className: "flex-1 ml-2.5",
                    children: r.name || r.username
                })]
            })]
        })]
    })
}
const lae = S.memo( ({item: t, onDeleteItem: e, onClose: n}) => v.jsxs(v.Fragment, {
    children: [v.jsx(Os, {
        children: "Delete Chat?"
    }), v.jsxs(Ns, {
        children: [v.jsxs("p", {
            children: ["You are about to delete ", v.jsx("strong", {
                children: t.description
            }), "."]
        }), v.jsx("p", {
            className: "mt-1",
            children: "Are you sure you want to delete this chat?"
        })]
    }), v.jsxs(Mu, {
        children: [v.jsx(Gi, {
            type: "secondary",
            onClick: n,
            children: "Cancel"
        }), v.jsx(Gi, {
            type: "danger",
            onClick: e,
            children: "Delete"
        })]
    })]
}));
function cae(t, e) {
    return e.filter(n => n.description?.toLowerCase().includes(t.toLowerCase()))
}
const {createElement: Dl, createContext: uae, createRef: ave, forwardRef: DO, useCallback: rr, useContext: LO, useEffect: $o, useImperativeHandle: OO, useLayoutEffect: hae, useMemo: dae, useRef: Yn, useState: eu} = Ay
  , RC = Ay.useId
  , fae = hae
  , Xm = uae(null);
Xm.displayName = "PanelGroupContext";
const zo = fae
  , pae = typeof RC == "function" ? RC : () => null;
let mae = 0;
function x1(t=null) {
    const e = pae()
      , n = Yn(t || e || null);
    return n.current === null && (n.current = "" + mae++),
    t ?? n.current
}
function NO({children: t, className: e="", collapsedSize: n, collapsible: r, defaultSize: i, forwardedRef: s, id: o, maxSize: a, minSize: l, onCollapse: c, onExpand: u, onResize: h, order: d, style: f, tagName: g="div", ..._}) {
    const m = LO(Xm);
    if (m === null)
        throw Error("Panel components must be rendered within a PanelGroup container");
    const {collapsePanel: p, expandPanel: b, getPanelSize: y, getPanelStyle: x, groupId: E, isPanelCollapsed: w, reevaluatePanelConstraints: A, registerPanel: C, resizePanel: k, unregisterPanel: I} = m
      , N = x1(o)
      , O = Yn({
        callbacks: {
            onCollapse: c,
            onExpand: u,
            onResize: h
        },
        constraints: {
            collapsedSize: n,
            collapsible: r,
            defaultSize: i,
            maxSize: a,
            minSize: l
        },
        id: N,
        idIsFromProps: o !== void 0,
        order: d
    });
    Yn({
        didLogMissingDefaultSizeWarning: !1
    }),
    zo( () => {
        const {callbacks: H, constraints: $} = O.current
          , J = {
            ...$
        };
        O.current.id = N,
        O.current.idIsFromProps = o !== void 0,
        O.current.order = d,
        H.onCollapse = c,
        H.onExpand = u,
        H.onResize = h,
        $.collapsedSize = n,
        $.collapsible = r,
        $.defaultSize = i,
        $.maxSize = a,
        $.minSize = l,
        (J.collapsedSize !== $.collapsedSize || J.collapsible !== $.collapsible || J.maxSize !== $.maxSize || J.minSize !== $.minSize) && A(O.current, J)
    }
    ),
    zo( () => {
        const H = O.current;
        return C(H),
        () => {
            I(H)
        }
    }
    , [d, N, C, I]),
    OO(s, () => ({
        collapse: () => {
            p(O.current)
        }
        ,
        expand: H => {
            b(O.current, H)
        }
        ,
        getId() {
            return N
        },
        getSize() {
            return y(O.current)
        },
        isCollapsed() {
            return w(O.current)
        },
        isExpanded() {
            return !w(O.current)
        },
        resize: H => {
            k(O.current, H)
        }
    }), [p, b, y, w, N, k]);
    const M = x(O.current, i);
    return Dl(g, {
        ..._,
        children: t,
        className: e,
        id: o,
        style: {
            ...M,
            ...f
        },
        "data-panel": "",
        "data-panel-collapsible": r || void 0,
        "data-panel-group-id": E,
        "data-panel-id": N,
        "data-panel-size": parseFloat("" + M.flexGrow).toFixed(1)
    })
}
const Io = DO( (t, e) => Dl(NO, {
    ...t,
    forwardedRef: e
}));
NO.displayName = "Panel";
Io.displayName = "forwardRef(Panel)";
let bb = null
  , Po = null;
function gae(t, e) {
    if (e) {
        const n = (e & HO) !== 0
          , r = (e & UO) !== 0
          , i = (e & VO) !== 0
          , s = (e & $O) !== 0;
        if (n)
            return i ? "se-resize" : s ? "ne-resize" : "e-resize";
        if (r)
            return i ? "sw-resize" : s ? "nw-resize" : "w-resize";
        if (i)
            return "s-resize";
        if (s)
            return "n-resize"
    }
    switch (t) {
    case "horizontal":
        return "ew-resize";
    case "intersection":
        return "move";
    case "vertical":
        return "ns-resize"
    }
}
function _ae() {
    Po !== null && (document.head.removeChild(Po),
    bb = null,
    Po = null)
}
function T0(t, e) {
    const n = gae(t, e);
    bb !== n && (bb = n,
    Po === null && (Po = document.createElement("style"),
    document.head.appendChild(Po)),
    Po.innerHTML = `*{cursor: ${n}!important;}`)
}
function MO(t) {
    return t.type === "keydown"
}
function BO(t) {
    return t.type.startsWith("pointer")
}
function FO(t) {
    return t.type.startsWith("mouse")
}
function Qm(t) {
    if (BO(t)) {
        if (t.isPrimary)
            return {
                x: t.clientX,
                y: t.clientY
            }
    } else if (FO(t))
        return {
            x: t.clientX,
            y: t.clientY
        };
    return {
        x: 1 / 0,
        y: 1 / 0
    }
}
function bae() {
    if (typeof matchMedia == "function")
        return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine"
}
function yae(t, e, n) {
    return t.x < e.x + e.width && t.x + t.width > e.x && t.y < e.y + e.height && t.y + t.height > e.y
}
function vae(t, e) {
    if (t === e)
        throw new Error("Cannot compare node with itself");
    const n = {
        a: DC(t),
        b: DC(e)
    };
    let r;
    for (; n.a.at(-1) === n.b.at(-1); )
        t = n.a.pop(),
        e = n.b.pop(),
        r = t;
    nt(r, "Stacking order can only be calculated for elements with a common ancestor");
    const i = {
        a: PC(IC(n.a)),
        b: PC(IC(n.b))
    };
    if (i.a === i.b) {
        const s = r.childNodes
          , o = {
            a: n.a.at(-1),
            b: n.b.at(-1)
        };
        let a = s.length;
        for (; a--; ) {
            const l = s[a];
            if (l === o.a)
                return 1;
            if (l === o.b)
                return -1
        }
    }
    return Math.sign(i.a - i.b)
}
const xae = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function Eae(t) {
    var e;
    const n = getComputedStyle((e = jO(t)) !== null && e !== void 0 ? e : t).display;
    return n === "flex" || n === "inline-flex"
}
function Sae(t) {
    const e = getComputedStyle(t);
    return !!(e.position === "fixed" || e.zIndex !== "auto" && (e.position !== "static" || Eae(t)) || +e.opacity < 1 || "transform"in e && e.transform !== "none" || "webkitTransform"in e && e.webkitTransform !== "none" || "mixBlendMode"in e && e.mixBlendMode !== "normal" || "filter"in e && e.filter !== "none" || "webkitFilter"in e && e.webkitFilter !== "none" || "isolation"in e && e.isolation === "isolate" || xae.test(e.willChange) || e.webkitOverflowScrolling === "touch")
}
function IC(t) {
    let e = t.length;
    for (; e--; ) {
        const n = t[e];
        if (nt(n, "Missing node"),
        Sae(n))
            return n
    }
    return null
}
function PC(t) {
    return t && Number(getComputedStyle(t).zIndex) || 0
}
function DC(t) {
    const e = [];
    for (; t; )
        e.push(t),
        t = jO(t);
    return e
}
function jO(t) {
    const {parentNode: e} = t;
    return e && e instanceof ShadowRoot ? e.host : e
}
const HO = 1
  , UO = 2
  , VO = 4
  , $O = 8
  , wae = bae() === "coarse";
let Jr = []
  , Jm = !1
  , Ts = new Map
  , Zm = new Map;
const Fu = new Set;
function Cae(t, e, n, r, i) {
    var s;
    const {ownerDocument: o} = e
      , a = {
        direction: n,
        element: e,
        hitAreaMargins: r,
        setResizeHandlerState: i
    }
      , l = (s = Ts.get(o)) !== null && s !== void 0 ? s : 0;
    return Ts.set(o, l + 1),
    Fu.add(a),
    Tp(),
    function() {
        var u;
        Zm.delete(t),
        Fu.delete(a);
        const h = (u = Ts.get(o)) !== null && u !== void 0 ? u : 1;
        if (Ts.set(o, h - 1),
        Tp(),
        h === 1 && Ts.delete(o),
        Jr.includes(a)) {
            const d = Jr.indexOf(a);
            d >= 0 && Jr.splice(d, 1),
            S1()
        }
    }
}
function LC(t) {
    const {target: e} = t
      , {x: n, y: r} = Qm(t);
    Jm = !0,
    E1({
        target: e,
        x: n,
        y: r
    }),
    Tp(),
    Jr.length > 0 && (w1("down", t),
    t.preventDefault(),
    t.stopPropagation())
}
function hc(t) {
    const {x: e, y: n} = Qm(t);
    if (!Jm) {
        const {target: r} = t;
        E1({
            target: r,
            x: e,
            y: n
        })
    }
    w1("move", t),
    S1(),
    Jr.length > 0 && t.preventDefault()
}
function Ma(t) {
    const {target: e} = t
      , {x: n, y: r} = Qm(t);
    Zm.clear(),
    Jm = !1,
    Jr.length > 0 && t.preventDefault(),
    w1("up", t),
    E1({
        target: e,
        x: n,
        y: r
    }),
    S1(),
    Tp()
}
function E1({target: t, x: e, y: n}) {
    Jr.splice(0);
    let r = null;
    t instanceof HTMLElement && (r = t),
    Fu.forEach(i => {
        const {element: s, hitAreaMargins: o} = i
          , a = s.getBoundingClientRect()
          , {bottom: l, left: c, right: u, top: h} = a
          , d = wae ? o.coarse : o.fine;
        if (e >= c - d && e <= u + d && n >= h - d && n <= l + d) {
            if (r !== null && s !== r && !s.contains(r) && !r.contains(s) && vae(r, s) > 0) {
                let g = r
                  , _ = !1;
                for (; g && !g.contains(s); ) {
                    if (yae(g.getBoundingClientRect(), a)) {
                        _ = !0;
                        break
                    }
                    g = g.parentElement
                }
                if (_)
                    return
            }
            Jr.push(i)
        }
    }
    )
}
function A0(t, e) {
    Zm.set(t, e)
}
function S1() {
    let t = !1
      , e = !1;
    Jr.forEach(r => {
        const {direction: i} = r;
        i === "horizontal" ? t = !0 : e = !0
    }
    );
    let n = 0;
    Zm.forEach(r => {
        n |= r
    }
    ),
    t && e ? T0("intersection", n) : t ? T0("horizontal", n) : e ? T0("vertical", n) : _ae()
}
function Tp() {
    Ts.forEach( (t, e) => {
        const {body: n} = e;
        n.removeEventListener("contextmenu", Ma),
        n.removeEventListener("pointerdown", LC),
        n.removeEventListener("pointerleave", hc),
        n.removeEventListener("pointermove", hc)
    }
    ),
    window.removeEventListener("pointerup", Ma),
    window.removeEventListener("pointercancel", Ma),
    Fu.size > 0 && (Jm ? (Jr.length > 0 && Ts.forEach( (t, e) => {
        const {body: n} = e;
        t > 0 && (n.addEventListener("contextmenu", Ma),
        n.addEventListener("pointerleave", hc),
        n.addEventListener("pointermove", hc))
    }
    ),
    window.addEventListener("pointerup", Ma),
    window.addEventListener("pointercancel", Ma)) : Ts.forEach( (t, e) => {
        const {body: n} = e;
        t > 0 && (n.addEventListener("pointerdown", LC, {
            capture: !0
        }),
        n.addEventListener("pointermove", hc))
    }
    ))
}
function w1(t, e) {
    Fu.forEach(n => {
        const {setResizeHandlerState: r} = n
          , i = Jr.includes(n);
        r(t, i, e)
    }
    )
}
function nt(t, e) {
    if (!t)
        throw console.error(e),
        Error(e)
}
const C1 = 10;
function sa(t, e, n=C1) {
    return t.toFixed(n) === e.toFixed(n) ? 0 : t > e ? 1 : -1
}
function $i(t, e, n=C1) {
    return sa(t, e, n) === 0
}
function ar(t, e, n) {
    return sa(t, e, n) === 0
}
function Tae(t, e, n) {
    if (t.length !== e.length)
        return !1;
    for (let r = 0; r < t.length; r++) {
        const i = t[r]
          , s = e[r];
        if (!ar(i, s, n))
            return !1
    }
    return !0
}
function tl({panelConstraints: t, panelIndex: e, size: n}) {
    const r = t[e];
    nt(r != null, `Panel constraints not found for index ${e}`);
    let {collapsedSize: i=0, collapsible: s, maxSize: o=100, minSize: a=0} = r;
    if (sa(n, a) < 0)
        if (s) {
            const l = (i + a) / 2;
            sa(n, l) < 0 ? n = i : n = a
        } else
            n = a;
    return n = Math.min(o, n),
    n = parseFloat(n.toFixed(C1)),
    n
}
function Rc({delta: t, initialLayout: e, panelConstraints: n, pivotIndices: r, prevLayout: i, trigger: s}) {
    if (ar(t, 0))
        return e;
    const o = [...e]
      , [a,l] = r;
    nt(a != null, "Invalid first pivot index"),
    nt(l != null, "Invalid second pivot index");
    let c = 0;
    if (s === "keyboard") {
        {
            const h = t < 0 ? l : a
              , d = n[h];
            nt(d, `Panel constraints not found for index ${h}`);
            const {collapsedSize: f=0, collapsible: g, minSize: _=0} = d;
            if (g) {
                const m = e[h];
                if (nt(m != null, `Previous layout not found for panel index ${h}`),
                ar(m, f)) {
                    const p = _ - m;
                    sa(p, Math.abs(t)) > 0 && (t = t < 0 ? 0 - p : p)
                }
            }
        }
        {
            const h = t < 0 ? a : l
              , d = n[h];
            nt(d, `No panel constraints found for index ${h}`);
            const {collapsedSize: f=0, collapsible: g, minSize: _=0} = d;
            if (g) {
                const m = e[h];
                if (nt(m != null, `Previous layout not found for panel index ${h}`),
                ar(m, _)) {
                    const p = m - f;
                    sa(p, Math.abs(t)) > 0 && (t = t < 0 ? 0 - p : p)
                }
            }
        }
    }
    {
        const h = t < 0 ? 1 : -1;
        let d = t < 0 ? l : a
          , f = 0;
        for (; ; ) {
            const _ = e[d];
            nt(_ != null, `Previous layout not found for panel index ${d}`);
            const p = tl({
                panelConstraints: n,
                panelIndex: d,
                size: 100
            }) - _;
            if (f += p,
            d += h,
            d < 0 || d >= n.length)
                break
        }
        const g = Math.min(Math.abs(t), Math.abs(f));
        t = t < 0 ? 0 - g : g
    }
    {
        let d = t < 0 ? a : l;
        for (; d >= 0 && d < n.length; ) {
            const f = Math.abs(t) - Math.abs(c)
              , g = e[d];
            nt(g != null, `Previous layout not found for panel index ${d}`);
            const _ = g - f
              , m = tl({
                panelConstraints: n,
                panelIndex: d,
                size: _
            });
            if (!ar(g, m) && (c += g - m,
            o[d] = m,
            c.toPrecision(3).localeCompare(Math.abs(t).toPrecision(3), void 0, {
                numeric: !0
            }) >= 0))
                break;
            t < 0 ? d-- : d++
        }
    }
    if (Tae(i, o))
        return i;
    {
        const h = t < 0 ? l : a
          , d = e[h];
        nt(d != null, `Previous layout not found for panel index ${h}`);
        const f = d + c
          , g = tl({
            panelConstraints: n,
            panelIndex: h,
            size: f
        });
        if (o[h] = g,
        !ar(g, f)) {
            let _ = f - g
              , p = t < 0 ? l : a;
            for (; p >= 0 && p < n.length; ) {
                const b = o[p];
                nt(b != null, `Previous layout not found for panel index ${p}`);
                const y = b + _
                  , x = tl({
                    panelConstraints: n,
                    panelIndex: p,
                    size: y
                });
                if (ar(b, x) || (_ -= x - b,
                o[p] = x),
                ar(_, 0))
                    break;
                t > 0 ? p-- : p++
            }
        }
    }
    const u = o.reduce( (h, d) => d + h, 0);
    return ar(u, 100) ? o : i
}
function Aae({layout: t, panelsArray: e, pivotIndices: n}) {
    let r = 0
      , i = 100
      , s = 0
      , o = 0;
    const a = n[0];
    nt(a != null, "No pivot index found"),
    e.forEach( (h, d) => {
        const {constraints: f} = h
          , {maxSize: g=100, minSize: _=0} = f;
        d === a ? (r = _,
        i = g) : (s += _,
        o += g)
    }
    );
    const l = Math.min(i, 100 - s)
      , c = Math.max(r, 100 - o)
      , u = t[a];
    return {
        valueMax: l,
        valueMin: c,
        valueNow: u
    }
}
function ju(t, e=document) {
    return Array.from(e.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${t}"]`))
}
function zO(t, e, n=document) {
    const i = ju(t, n).findIndex(s => s.getAttribute("data-panel-resize-handle-id") === e);
    return i ?? null
}
function WO(t, e, n) {
    const r = zO(t, e, n);
    return r != null ? [r, r + 1] : [-1, -1]
}
function GO(t, e=document) {
    var n;
    if (e instanceof HTMLElement && (e == null || (n = e.dataset) === null || n === void 0 ? void 0 : n.panelGroupId) == t)
        return e;
    const r = e.querySelector(`[data-panel-group][data-panel-group-id="${t}"]`);
    return r || null
}
function eg(t, e=document) {
    const n = e.querySelector(`[data-panel-resize-handle-id="${t}"]`);
    return n || null
}
function kae(t, e, n, r=document) {
    var i, s, o, a;
    const l = eg(e, r)
      , c = ju(t, r)
      , u = l ? c.indexOf(l) : -1
      , h = (i = (s = n[u]) === null || s === void 0 ? void 0 : s.id) !== null && i !== void 0 ? i : null
      , d = (o = (a = n[u + 1]) === null || a === void 0 ? void 0 : a.id) !== null && o !== void 0 ? o : null;
    return [h, d]
}
function Rae({committedValuesRef: t, eagerValuesRef: e, groupId: n, layout: r, panelDataArray: i, panelGroupElement: s, setLayout: o}) {
    Yn({
        didWarnAboutMissingResizeHandle: !1
    }),
    zo( () => {
        if (!s)
            return;
        const a = ju(n, s);
        for (let l = 0; l < i.length - 1; l++) {
            const {valueMax: c, valueMin: u, valueNow: h} = Aae({
                layout: r,
                panelsArray: i,
                pivotIndices: [l, l + 1]
            })
              , d = a[l];
            if (d != null) {
                const f = i[l];
                nt(f, `No panel data found for index "${l}"`),
                d.setAttribute("aria-controls", f.id),
                d.setAttribute("aria-valuemax", "" + Math.round(c)),
                d.setAttribute("aria-valuemin", "" + Math.round(u)),
                d.setAttribute("aria-valuenow", h != null ? "" + Math.round(h) : "")
            }
        }
        return () => {
            a.forEach( (l, c) => {
                l.removeAttribute("aria-controls"),
                l.removeAttribute("aria-valuemax"),
                l.removeAttribute("aria-valuemin"),
                l.removeAttribute("aria-valuenow")
            }
            )
        }
    }
    , [n, r, i, s]),
    $o( () => {
        if (!s)
            return;
        const a = e.current;
        nt(a, "Eager values not found");
        const {panelDataArray: l} = a
          , c = GO(n, s);
        nt(c != null, `No group found for id "${n}"`);
        const u = ju(n, s);
        nt(u, `No resize handles found for group id "${n}"`);
        const h = u.map(d => {
            const f = d.getAttribute("data-panel-resize-handle-id");
            nt(f, "Resize handle element has no handle id attribute");
            const [g,_] = kae(n, f, l, s);
            if (g == null || _ == null)
                return () => {}
                ;
            const m = p => {
                if (!p.defaultPrevented)
                    switch (p.key) {
                    case "Enter":
                        {
                            p.preventDefault();
                            const b = l.findIndex(y => y.id === g);
                            if (b >= 0) {
                                const y = l[b];
                                nt(y, `No panel data found for index ${b}`);
                                const x = r[b]
                                  , {collapsedSize: E=0, collapsible: w, minSize: A=0} = y.constraints;
                                if (x != null && w) {
                                    const C = Rc({
                                        delta: ar(x, E) ? A - E : E - x,
                                        initialLayout: r,
                                        panelConstraints: l.map(k => k.constraints),
                                        pivotIndices: WO(n, f, s),
                                        prevLayout: r,
                                        trigger: "keyboard"
                                    });
                                    r !== C && o(C)
                                }
                            }
                            break
                        }
                    }
            }
            ;
            return d.addEventListener("keydown", m),
            () => {
                d.removeEventListener("keydown", m)
            }
        }
        );
        return () => {
            h.forEach(d => d())
        }
    }
    , [s, t, e, n, r, i, o])
}
function OC(t, e) {
    if (t.length !== e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n])
            return !1;
    return !0
}
function qO(t, e) {
    const n = t === "horizontal"
      , {x: r, y: i} = Qm(e);
    return n ? r : i
}
function Iae(t, e, n, r, i) {
    const s = n === "horizontal"
      , o = eg(e, i);
    nt(o, `No resize handle element found for id "${e}"`);
    const a = o.getAttribute("data-panel-group-id");
    nt(a, "Resize handle element has no group id attribute");
    let {initialCursorPosition: l} = r;
    const c = qO(n, t)
      , u = GO(a, i);
    nt(u, `No group element found for id "${a}"`);
    const h = u.getBoundingClientRect()
      , d = s ? h.width : h.height;
    return (c - l) / d * 100
}
function Pae(t, e, n, r, i, s) {
    if (MO(t)) {
        const o = n === "horizontal";
        let a = 0;
        t.shiftKey ? a = 100 : i != null ? a = i : a = 10;
        let l = 0;
        switch (t.key) {
        case "ArrowDown":
            l = o ? 0 : a;
            break;
        case "ArrowLeft":
            l = o ? -a : 0;
            break;
        case "ArrowRight":
            l = o ? a : 0;
            break;
        case "ArrowUp":
            l = o ? 0 : -a;
            break;
        case "End":
            l = 100;
            break;
        case "Home":
            l = -100;
            break
        }
        return l
    } else
        return r == null ? 0 : Iae(t, e, n, r, s)
}
function Dae({panelDataArray: t}) {
    const e = Array(t.length)
      , n = t.map(s => s.constraints);
    let r = 0
      , i = 100;
    for (let s = 0; s < t.length; s++) {
        const o = n[s];
        nt(o, `Panel constraints not found for index ${s}`);
        const {defaultSize: a} = o;
        a != null && (r++,
        e[s] = a,
        i -= a)
    }
    for (let s = 0; s < t.length; s++) {
        const o = n[s];
        nt(o, `Panel constraints not found for index ${s}`);
        const {defaultSize: a} = o;
        if (a != null)
            continue;
        const l = t.length - r
          , c = i / l;
        r++,
        e[s] = c,
        i -= c
    }
    return e
}
function Ba(t, e, n) {
    e.forEach( (r, i) => {
        const s = t[i];
        nt(s, `Panel data not found for index ${i}`);
        const {callbacks: o, constraints: a, id: l} = s
          , {collapsedSize: c=0, collapsible: u} = a
          , h = n[l];
        if (h == null || r !== h) {
            n[l] = r;
            const {onCollapse: d, onExpand: f, onResize: g} = o;
            g && g(r, h),
            u && (d || f) && (f && (h == null || $i(h, c)) && !$i(r, c) && f(),
            d && (h == null || !$i(h, c)) && $i(r, c) && d())
        }
    }
    )
}
function Dd(t, e) {
    if (t.length !== e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] != e[n])
            return !1;
    return !0
}
function Lae({defaultSize: t, dragState: e, layout: n, panelData: r, panelIndex: i, precision: s=3}) {
    const o = n[i];
    let a;
    return o == null ? a = t != null ? t.toPrecision(s) : "1" : r.length === 1 ? a = "1" : a = o.toPrecision(s),
    {
        flexBasis: 0,
        flexGrow: a,
        flexShrink: 1,
        overflow: "hidden",
        pointerEvents: e !== null ? "none" : void 0
    }
}
function Oae(t, e=10) {
    let n = null;
    return (...i) => {
        n !== null && clearTimeout(n),
        n = setTimeout( () => {
            t(...i)
        }
        , e)
    }
}
function NC(t) {
    try {
        if (typeof localStorage < "u")
            t.getItem = e => localStorage.getItem(e),
            t.setItem = (e, n) => {
                localStorage.setItem(e, n)
            }
            ;
        else
            throw new Error("localStorage not supported in this environment")
    } catch (e) {
        console.error(e),
        t.getItem = () => null,
        t.setItem = () => {}
    }
}
function KO(t) {
    return `react-resizable-panels:${t}`
}
function YO(t) {
    return t.map(e => {
        const {constraints: n, id: r, idIsFromProps: i, order: s} = e;
        return i ? r : s ? `${s}:${JSON.stringify(n)}` : JSON.stringify(n)
    }
    ).sort( (e, n) => e.localeCompare(n)).join(",")
}
function XO(t, e) {
    try {
        const n = KO(t)
          , r = e.getItem(n);
        if (r) {
            const i = JSON.parse(r);
            if (typeof i == "object" && i != null)
                return i
        }
    } catch {}
    return null
}
function Nae(t, e, n) {
    var r, i;
    const s = (r = XO(t, n)) !== null && r !== void 0 ? r : {}
      , o = YO(e);
    return (i = s[o]) !== null && i !== void 0 ? i : null
}
function Mae(t, e, n, r, i) {
    var s;
    const o = KO(t)
      , a = YO(e)
      , l = (s = XO(t, i)) !== null && s !== void 0 ? s : {};
    l[a] = {
        expandToSizes: Object.fromEntries(n.entries()),
        layout: r
    };
    try {
        i.setItem(o, JSON.stringify(l))
    } catch (c) {
        console.error(c)
    }
}
function MC({layout: t, panelConstraints: e}) {
    const n = [...t]
      , r = n.reduce( (s, o) => s + o, 0);
    if (n.length !== e.length)
        throw Error(`Invalid ${e.length} panel layout: ${n.map(s => `${s}%`).join(", ")}`);
    if (!ar(r, 100))
        for (let s = 0; s < e.length; s++) {
            const o = n[s];
            nt(o != null, `No layout data found for index ${s}`);
            const a = 100 / r * o;
            n[s] = a
        }
    let i = 0;
    for (let s = 0; s < e.length; s++) {
        const o = n[s];
        nt(o != null, `No layout data found for index ${s}`);
        const a = tl({
            panelConstraints: e,
            panelIndex: s,
            size: o
        });
        o != a && (i += o - a,
        n[s] = a)
    }
    if (!ar(i, 0))
        for (let s = 0; s < e.length; s++) {
            const o = n[s];
            nt(o != null, `No layout data found for index ${s}`);
            const a = o + i
              , l = tl({
                panelConstraints: e,
                panelIndex: s,
                size: a
            });
            if (o !== l && (i -= l - o,
            n[s] = l,
            ar(i, 0)))
                break
        }
    return n
}
const Bae = 100
  , Ic = {
    getItem: t => (NC(Ic),
    Ic.getItem(t)),
    setItem: (t, e) => {
        NC(Ic),
        Ic.setItem(t, e)
    }
}
  , BC = {};
function QO({autoSaveId: t=null, children: e, className: n="", direction: r, forwardedRef: i, id: s=null, onLayout: o=null, keyboardResizeBy: a=null, storage: l=Ic, style: c, tagName: u="div", ...h}) {
    const d = x1(s)
      , f = Yn(null)
      , [g,_] = eu(null)
      , [m,p] = eu([])
      , b = Yn({})
      , y = Yn(new Map)
      , x = Yn(0)
      , E = Yn({
        autoSaveId: t,
        direction: r,
        dragState: g,
        id: d,
        keyboardResizeBy: a,
        onLayout: o,
        storage: l
    })
      , w = Yn({
        layout: m,
        panelDataArray: [],
        panelDataArrayChanged: !1
    });
    Yn({
        didLogIdAndOrderWarning: !1,
        didLogPanelConstraintsWarning: !1,
        prevPanelIds: []
    }),
    OO(i, () => ({
        getId: () => E.current.id,
        getLayout: () => {
            const {layout: V} = w.current;
            return V
        }
        ,
        setLayout: V => {
            const {onLayout: B} = E.current
              , {layout: Z, panelDataArray: se} = w.current
              , ae = MC({
                layout: V,
                panelConstraints: se.map(G => G.constraints)
            });
            OC(Z, ae) || (p(ae),
            w.current.layout = ae,
            B && B(ae),
            Ba(se, ae, b.current))
        }
    }), []),
    zo( () => {
        E.current.autoSaveId = t,
        E.current.direction = r,
        E.current.dragState = g,
        E.current.id = d,
        E.current.onLayout = o,
        E.current.storage = l
    }
    ),
    Rae({
        committedValuesRef: E,
        eagerValuesRef: w,
        groupId: d,
        layout: m,
        panelDataArray: w.current.panelDataArray,
        setLayout: p,
        panelGroupElement: f.current
    }),
    $o( () => {
        const {panelDataArray: V} = w.current;
        if (t) {
            if (m.length === 0 || m.length !== V.length)
                return;
            let B = BC[t];
            B == null && (B = Oae(Mae, Bae),
            BC[t] = B);
            const Z = [...V]
              , se = new Map(y.current);
            B(t, Z, se, m, l)
        }
    }
    , [t, m, l]),
    $o( () => {}
    );
    const A = rr(V => {
        const {onLayout: B} = E.current
          , {layout: Z, panelDataArray: se} = w.current;
        if (V.constraints.collapsible) {
            const ae = se.map(le => le.constraints)
              , {collapsedSize: G=0, panelSize: j, pivotIndices: oe} = _o(se, V, Z);
            if (nt(j != null, `Panel size not found for panel "${V.id}"`),
            !$i(j, G)) {
                y.current.set(V.id, j);
                const de = za(se, V) === se.length - 1 ? j - G : G - j
                  , ne = Rc({
                    delta: de,
                    initialLayout: Z,
                    panelConstraints: ae,
                    pivotIndices: oe,
                    prevLayout: Z,
                    trigger: "imperative-api"
                });
                Dd(Z, ne) || (p(ne),
                w.current.layout = ne,
                B && B(ne),
                Ba(se, ne, b.current))
            }
        }
    }
    , [])
      , C = rr( (V, B) => {
        const {onLayout: Z} = E.current
          , {layout: se, panelDataArray: ae} = w.current;
        if (V.constraints.collapsible) {
            const G = ae.map(pe => pe.constraints)
              , {collapsedSize: j=0, panelSize: oe=0, minSize: le=0, pivotIndices: de} = _o(ae, V, se)
              , ne = B ?? le;
            if ($i(oe, j)) {
                const pe = y.current.get(V.id)
                  , Te = pe != null && pe >= ne ? pe : ne
                  , Re = za(ae, V) === ae.length - 1 ? oe - Te : Te - oe
                  , we = Rc({
                    delta: Re,
                    initialLayout: se,
                    panelConstraints: G,
                    pivotIndices: de,
                    prevLayout: se,
                    trigger: "imperative-api"
                });
                Dd(se, we) || (p(we),
                w.current.layout = we,
                Z && Z(we),
                Ba(ae, we, b.current))
            }
        }
    }
    , [])
      , k = rr(V => {
        const {layout: B, panelDataArray: Z} = w.current
          , {panelSize: se} = _o(Z, V, B);
        return nt(se != null, `Panel size not found for panel "${V.id}"`),
        se
    }
    , [])
      , I = rr( (V, B) => {
        const {panelDataArray: Z} = w.current
          , se = za(Z, V);
        return Lae({
            defaultSize: B,
            dragState: g,
            layout: m,
            panelData: Z,
            panelIndex: se
        })
    }
    , [g, m])
      , N = rr(V => {
        const {layout: B, panelDataArray: Z} = w.current
          , {collapsedSize: se=0, collapsible: ae, panelSize: G} = _o(Z, V, B);
        return nt(G != null, `Panel size not found for panel "${V.id}"`),
        ae === !0 && $i(G, se)
    }
    , [])
      , O = rr(V => {
        const {layout: B, panelDataArray: Z} = w.current
          , {collapsedSize: se=0, collapsible: ae, panelSize: G} = _o(Z, V, B);
        return nt(G != null, `Panel size not found for panel "${V.id}"`),
        !ae || sa(G, se) > 0
    }
    , [])
      , M = rr(V => {
        const {panelDataArray: B} = w.current;
        B.push(V),
        B.sort( (Z, se) => {
            const ae = Z.order
              , G = se.order;
            return ae == null && G == null ? 0 : ae == null ? -1 : G == null ? 1 : ae - G
        }
        ),
        w.current.panelDataArrayChanged = !0
    }
    , []);
    zo( () => {
        if (w.current.panelDataArrayChanged) {
            w.current.panelDataArrayChanged = !1;
            const {autoSaveId: V, onLayout: B, storage: Z} = E.current
              , {layout: se, panelDataArray: ae} = w.current;
            let G = null;
            if (V) {
                const oe = Nae(V, ae, Z);
                oe && (y.current = new Map(Object.entries(oe.expandToSizes)),
                G = oe.layout)
            }
            G == null && (G = Dae({
                panelDataArray: ae
            }));
            const j = MC({
                layout: G,
                panelConstraints: ae.map(oe => oe.constraints)
            });
            OC(se, j) || (p(j),
            w.current.layout = j,
            B && B(j),
            Ba(ae, j, b.current))
        }
    }
    ),
    zo( () => {
        const V = w.current;
        return () => {
            V.layout = []
        }
    }
    , []);
    const H = rr(V => function(Z) {
        Z.preventDefault();
        const se = f.current;
        if (!se)
            return () => null;
        const {direction: ae, dragState: G, id: j, keyboardResizeBy: oe, onLayout: le} = E.current
          , {layout: de, panelDataArray: ne} = w.current
          , {initialLayout: pe} = G ?? {}
          , Te = WO(j, V, se);
        let Ce = Pae(Z, V, ae, G, oe, se);
        if (Ce === 0)
            return;
        const Re = ae === "horizontal";
        document.dir === "rtl" && Re && (Ce = -Ce);
        const we = ne.map(et => et.constraints)
          , ze = Rc({
            delta: Ce,
            initialLayout: pe ?? de,
            panelConstraints: we,
            pivotIndices: Te,
            prevLayout: de,
            trigger: MO(Z) ? "keyboard" : "mouse-or-touch"
        })
          , qe = !Dd(de, ze);
        (BO(Z) || FO(Z)) && x.current != Ce && (x.current = Ce,
        qe ? A0(V, 0) : Re ? A0(V, Ce < 0 ? HO : UO) : A0(V, Ce < 0 ? VO : $O)),
        qe && (p(ze),
        w.current.layout = ze,
        le && le(ze),
        Ba(ne, ze, b.current))
    }
    , [])
      , $ = rr( (V, B) => {
        const {onLayout: Z} = E.current
          , {layout: se, panelDataArray: ae} = w.current
          , G = ae.map(pe => pe.constraints)
          , {panelSize: j, pivotIndices: oe} = _o(ae, V, se);
        nt(j != null, `Panel size not found for panel "${V.id}"`);
        const de = za(ae, V) === ae.length - 1 ? j - B : B - j
          , ne = Rc({
            delta: de,
            initialLayout: se,
            panelConstraints: G,
            pivotIndices: oe,
            prevLayout: se,
            trigger: "imperative-api"
        });
        Dd(se, ne) || (p(ne),
        w.current.layout = ne,
        Z && Z(ne),
        Ba(ae, ne, b.current))
    }
    , [])
      , J = rr( (V, B) => {
        const {layout: Z, panelDataArray: se} = w.current
          , {collapsedSize: ae=0, collapsible: G} = B
          , {collapsedSize: j=0, collapsible: oe, maxSize: le=100, minSize: de=0} = V.constraints
          , {panelSize: ne} = _o(se, V, Z);
        ne != null && (G && oe && $i(ne, ae) ? $i(ae, j) || $(V, j) : ne < de ? $(V, de) : ne > le && $(V, le))
    }
    , [$])
      , Q = rr( (V, B) => {
        const {direction: Z} = E.current
          , {layout: se} = w.current;
        if (!f.current)
            return;
        const ae = eg(V, f.current);
        nt(ae, `Drag handle element not found for id "${V}"`);
        const G = qO(Z, B);
        _({
            dragHandleId: V,
            dragHandleRect: ae.getBoundingClientRect(),
            initialCursorPosition: G,
            initialLayout: se
        })
    }
    , [])
      , ee = rr( () => {
        _(null)
    }
    , [])
      , D = rr(V => {
        const {panelDataArray: B} = w.current
          , Z = za(B, V);
        Z >= 0 && (B.splice(Z, 1),
        delete b.current[V.id],
        w.current.panelDataArrayChanged = !0)
    }
    , [])
      , L = dae( () => ({
        collapsePanel: A,
        direction: r,
        dragState: g,
        expandPanel: C,
        getPanelSize: k,
        getPanelStyle: I,
        groupId: d,
        isPanelCollapsed: N,
        isPanelExpanded: O,
        reevaluatePanelConstraints: J,
        registerPanel: M,
        registerResizeHandle: H,
        resizePanel: $,
        startDragging: Q,
        stopDragging: ee,
        unregisterPanel: D,
        panelGroupElement: f.current
    }), [A, g, r, C, k, I, d, N, O, J, M, H, $, Q, ee, D])
      , z = {
        display: "flex",
        flexDirection: r === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
    };
    return Dl(Xm.Provider, {
        value: L
    }, Dl(u, {
        ...h,
        children: e,
        className: n,
        id: s,
        ref: f,
        style: {
            ...z,
            ...c
        },
        "data-panel-group": "",
        "data-panel-group-direction": r,
        "data-panel-group-id": d
    }))
}
const Ap = DO( (t, e) => Dl(QO, {
    ...t,
    forwardedRef: e
}));
QO.displayName = "PanelGroup";
Ap.displayName = "forwardRef(PanelGroup)";
function za(t, e) {
    return t.findIndex(n => n === e || n.id === e.id)
}
function _o(t, e, n) {
    const r = za(t, e)
      , s = r === t.length - 1 ? [r - 1, r] : [r, r + 1]
      , o = n[r];
    return {
        ...e.constraints,
        panelSize: o,
        pivotIndices: s
    }
}
function Fae({disabled: t, handleId: e, resizeHandler: n, panelGroupElement: r}) {
    $o( () => {
        if (t || n == null || r == null)
            return;
        const i = eg(e, r);
        if (i == null)
            return;
        const s = o => {
            if (!o.defaultPrevented)
                switch (o.key) {
                case "ArrowDown":
                case "ArrowLeft":
                case "ArrowRight":
                case "ArrowUp":
                case "End":
                case "Home":
                    {
                        o.preventDefault(),
                        n(o);
                        break
                    }
                case "F6":
                    {
                        o.preventDefault();
                        const a = i.getAttribute("data-panel-group-id");
                        nt(a, `No group element found for id "${a}"`);
                        const l = ju(a, r)
                          , c = zO(a, e, r);
                        nt(c !== null, `No resize element found for id "${e}"`);
                        const u = o.shiftKey ? c > 0 ? c - 1 : l.length - 1 : c + 1 < l.length ? c + 1 : 0;
                        l[u].focus();
                        break
                    }
                }
        }
        ;
        return i.addEventListener("keydown", s),
        () => {
            i.removeEventListener("keydown", s)
        }
    }
    , [r, t, e, n])
}
function kp({children: t=null, className: e="", disabled: n=!1, hitAreaMargins: r, id: i, onBlur: s, onDragging: o, onFocus: a, style: l={}, tabIndex: c=0, tagName: u="div", ...h}) {
    var d, f;
    const g = Yn(null)
      , _ = Yn({
        onDragging: o
    });
    $o( () => {
        _.current.onDragging = o
    }
    );
    const m = LO(Xm);
    if (m === null)
        throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const {direction: p, groupId: b, registerResizeHandle: y, startDragging: x, stopDragging: E, panelGroupElement: w} = m
      , A = x1(i)
      , [C,k] = eu("inactive")
      , [I,N] = eu(!1)
      , [O,M] = eu(null)
      , H = Yn({
        state: C
    });
    zo( () => {
        H.current.state = C
    }
    ),
    $o( () => {
        if (n)
            M(null);
        else {
            const ee = y(A);
            M( () => ee)
        }
    }
    , [n, A, y]);
    const $ = (d = r?.coarse) !== null && d !== void 0 ? d : 15
      , J = (f = r?.fine) !== null && f !== void 0 ? f : 5;
    return $o( () => {
        if (n || O == null)
            return;
        const ee = g.current;
        return nt(ee, "Element ref not attached"),
        Cae(A, ee, p, {
            coarse: $,
            fine: J
        }, (L, z, V) => {
            if (z)
                switch (L) {
                case "down":
                    {
                        k("drag"),
                        x(A, V);
                        const {onDragging: B} = _.current;
                        B && B(!0);
                        break
                    }
                case "move":
                    {
                        const {state: B} = H.current;
                        B !== "drag" && k("hover"),
                        O(V);
                        break
                    }
                case "up":
                    {
                        k("hover"),
                        E();
                        const {onDragging: B} = _.current;
                        B && B(!1);
                        break
                    }
                }
            else
                k("inactive")
        }
        )
    }
    , [$, p, n, J, y, A, O, x, E]),
    Fae({
        disabled: n,
        handleId: A,
        resizeHandler: O,
        panelGroupElement: w
    }),
    Dl(u, {
        ...h,
        children: t,
        className: e,
        id: i,
        onBlur: () => {
            N(!1),
            s?.()
        }
        ,
        onFocus: () => {
            N(!0),
            a?.()
        }
        ,
        ref: g,
        role: "separator",
        style: {
            ...{
                touchAction: "none",
                userSelect: "none"
            },
            ...l
        },
        tabIndex: c,
        "data-panel-group-direction": p,
        "data-panel-group-id": b,
        "data-resize-handle": "",
        "data-resize-handle-active": C === "drag" ? "pointer" : I ? "keyboard" : void 0,
        "data-resize-handle-state": C,
        "data-panel-resize-handle-enabled": !n,
        "data-panel-resize-handle-id": A
    })
}
kp.displayName = "PanelResizeHandle";
var k0 = "rovingFocusGroup.onEntryFocus"
  , jae = {
    bubbles: !1,
    cancelable: !0
}
  , tg = "RovingFocusGroup"
  , [yb,JO,Hae] = Wm(tg)
  , [Uae,ng] = cs(tg, [Hae])
  , [Vae,$ae] = Uae(tg)
  , ZO = S.forwardRef( (t, e) => v.jsx(yb.Provider, {
    scope: t.__scopeRovingFocusGroup,
    children: v.jsx(yb.Slot, {
        scope: t.__scopeRovingFocusGroup,
        children: v.jsx(zae, {
            ...t,
            ref: e
        })
    })
}));
ZO.displayName = tg;
var zae = S.forwardRef( (t, e) => {
    const {__scopeRovingFocusGroup: n, orientation: r, loop: i=!1, dir: s, currentTabStopId: o, defaultCurrentTabStopId: a, onCurrentTabStopIdChange: l, onEntryFocus: c, preventScrollOnEntryFocus: u=!1, ...h} = t
      , d = S.useRef(null)
      , f = rt(e, d)
      , g = Gm(s)
      , [_=null,m] = Go({
        prop: o,
        defaultProp: a,
        onChange: l
    })
      , [p,b] = S.useState(!1)
      , y = vn(c)
      , x = JO(n)
      , E = S.useRef(!1)
      , [w,A] = S.useState(0);
    return S.useEffect( () => {
        const C = d.current;
        if (C)
            return C.addEventListener(k0, y),
            () => C.removeEventListener(k0, y)
    }
    , [y]),
    v.jsx(Vae, {
        scope: n,
        orientation: r,
        dir: g,
        loop: i,
        currentTabStopId: _,
        onItemFocus: S.useCallback(C => m(C), [m]),
        onItemShiftTab: S.useCallback( () => b(!0), []),
        onFocusableItemAdd: S.useCallback( () => A(C => C + 1), []),
        onFocusableItemRemove: S.useCallback( () => A(C => C - 1), []),
        children: v.jsx(We.div, {
            tabIndex: p || w === 0 ? -1 : 0,
            "data-orientation": r,
            ...h,
            ref: f,
            style: {
                outline: "none",
                ...t.style
            },
            onMouseDown: Ee(t.onMouseDown, () => {
                E.current = !0
            }
            ),
            onFocus: Ee(t.onFocus, C => {
                const k = !E.current;
                if (C.target === C.currentTarget && k && !p) {
                    const I = new CustomEvent(k0,jae);
                    if (C.currentTarget.dispatchEvent(I),
                    !I.defaultPrevented) {
                        const N = x().filter(J => J.focusable)
                          , O = N.find(J => J.active)
                          , M = N.find(J => J.id === _)
                          , $ = [O, M, ...N].filter(Boolean).map(J => J.ref.current);
                        nN($, u)
                    }
                }
                E.current = !1
            }
            ),
            onBlur: Ee(t.onBlur, () => b(!1))
        })
    })
}
)
  , eN = "RovingFocusGroupItem"
  , tN = S.forwardRef( (t, e) => {
    const {__scopeRovingFocusGroup: n, focusable: r=!0, active: i=!1, tabStopId: s, ...o} = t
      , a = Ci()
      , l = s || a
      , c = $ae(eN, n)
      , u = c.currentTabStopId === l
      , h = JO(n)
      , {onFocusableItemAdd: d, onFocusableItemRemove: f} = c;
    return S.useEffect( () => {
        if (r)
            return d(),
            () => f()
    }
    , [r, d, f]),
    v.jsx(yb.ItemSlot, {
        scope: n,
        id: l,
        focusable: r,
        active: i,
        children: v.jsx(We.span, {
            tabIndex: u ? 0 : -1,
            "data-orientation": c.orientation,
            ...o,
            ref: e,
            onMouseDown: Ee(t.onMouseDown, g => {
                r ? c.onItemFocus(l) : g.preventDefault()
            }
            ),
            onFocus: Ee(t.onFocus, () => c.onItemFocus(l)),
            onKeyDown: Ee(t.onKeyDown, g => {
                if (g.key === "Tab" && g.shiftKey) {
                    c.onItemShiftTab();
                    return
                }
                if (g.target !== g.currentTarget)
                    return;
                const _ = qae(g, c.orientation, c.dir);
                if (_ !== void 0) {
                    if (g.metaKey || g.ctrlKey || g.altKey || g.shiftKey)
                        return;
                    g.preventDefault();
                    let p = h().filter(b => b.focusable).map(b => b.ref.current);
                    if (_ === "last")
                        p.reverse();
                    else if (_ === "prev" || _ === "next") {
                        _ === "prev" && p.reverse();
                        const b = p.indexOf(g.currentTarget);
                        p = c.loop ? Kae(p, b + 1) : p.slice(b + 1)
                    }
                    setTimeout( () => nN(p))
                }
            }
            )
        })
    })
}
);
tN.displayName = eN;
var Wae = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
};
function Gae(t, e) {
    return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t
}
function qae(t, e, n) {
    const r = Gae(t.key, n);
    if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
        return Wae[r]
}
function nN(t, e=!1) {
    const n = document.activeElement;
    for (const r of t)
        if (r === n || (r.focus({
            preventScroll: e
        }),
        document.activeElement !== n))
            return
}
function Kae(t, e) {
    return t.map( (n, r) => t[(e + r) % t.length])
}
var rN = ZO
  , iN = tN
  , vb = ["Enter", " "]
  , Yae = ["ArrowDown", "PageUp", "Home"]
  , sN = ["ArrowUp", "PageDown", "End"]
  , Xae = [...Yae, ...sN]
  , Qae = {
    ltr: [...vb, "ArrowRight"],
    rtl: [...vb, "ArrowLeft"]
}
  , Jae = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
}
  , Xh = "Menu"
  , [Hu,Zae,ele] = Wm(Xh)
  , [Sa,oN] = cs(Xh, [ele, ro, ng])
  , rg = ro()
  , aN = ng()
  , [tle,wa] = Sa(Xh)
  , [nle,Qh] = Sa(Xh)
  , lN = t => {
    const {__scopeMenu: e, open: n=!1, children: r, dir: i, onOpenChange: s, modal: o=!0} = t
      , a = rg(e)
      , [l,c] = S.useState(null)
      , u = S.useRef(!1)
      , h = vn(s)
      , d = Gm(i);
    return S.useEffect( () => {
        const f = () => {
            u.current = !0,
            document.addEventListener("pointerdown", g, {
                capture: !0,
                once: !0
            }),
            document.addEventListener("pointermove", g, {
                capture: !0,
                once: !0
            })
        }
          , g = () => u.current = !1;
        return document.addEventListener("keydown", f, {
            capture: !0
        }),
        () => {
            document.removeEventListener("keydown", f, {
                capture: !0
            }),
            document.removeEventListener("pointerdown", g, {
                capture: !0
            }),
            document.removeEventListener("pointermove", g, {
                capture: !0
            })
        }
    }
    , []),
    v.jsx(um, {
        ...a,
        children: v.jsx(tle, {
            scope: e,
            open: n,
            onOpenChange: h,
            content: l,
            onContentChange: c,
            children: v.jsx(nle, {
                scope: e,
                onClose: S.useCallback( () => h(!1), [h]),
                isUsingKeyboardRef: u,
                dir: d,
                modal: o,
                children: r
            })
        })
    })
}
;
lN.displayName = Xh;
var rle = "MenuAnchor"
  , T1 = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t
      , i = rg(n);
    return v.jsx(hm, {
        ...i,
        ...r,
        ref: e
    })
}
);
T1.displayName = rle;
var A1 = "MenuPortal"
  , [ile,cN] = Sa(A1, {
    forceMount: void 0
})
  , uN = t => {
    const {__scopeMenu: e, forceMount: n, children: r, container: i} = t
      , s = wa(A1, e);
    return v.jsx(ile, {
        scope: e,
        forceMount: n,
        children: v.jsx(Li, {
            present: n || s.open,
            children: v.jsx(Th, {
                asChild: !0,
                container: i,
                children: r
            })
        })
    })
}
;
uN.displayName = A1;
var Dr = "MenuContent"
  , [sle,k1] = Sa(Dr)
  , hN = S.forwardRef( (t, e) => {
    const n = cN(Dr, t.__scopeMenu)
      , {forceMount: r=n.forceMount, ...i} = t
      , s = wa(Dr, t.__scopeMenu)
      , o = Qh(Dr, t.__scopeMenu);
    return v.jsx(Hu.Provider, {
        scope: t.__scopeMenu,
        children: v.jsx(Li, {
            present: r || s.open,
            children: v.jsx(Hu.Slot, {
                scope: t.__scopeMenu,
                children: o.modal ? v.jsx(ole, {
                    ...i,
                    ref: e
                }) : v.jsx(ale, {
                    ...i,
                    ref: e
                })
            })
        })
    })
}
)
  , ole = S.forwardRef( (t, e) => {
    const n = wa(Dr, t.__scopeMenu)
      , r = S.useRef(null)
      , i = rt(e, r);
    return S.useEffect( () => {
        const s = r.current;
        if (s)
            return zm(s)
    }
    , []),
    v.jsx(R1, {
        ...t,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ee(t.onFocusOutside, s => s.preventDefault(), {
            checkForDefaultPrevented: !1
        }),
        onDismiss: () => n.onOpenChange(!1)
    })
}
)
  , ale = S.forwardRef( (t, e) => {
    const n = wa(Dr, t.__scopeMenu);
    return v.jsx(R1, {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1)
    })
}
)
  , R1 = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, loop: r=!1, trapFocus: i, onOpenAutoFocus: s, onCloseAutoFocus: o, disableOutsidePointerEvents: a, onEntryFocus: l, onEscapeKeyDown: c, onPointerDownOutside: u, onFocusOutside: h, onInteractOutside: d, onDismiss: f, disableOutsideScroll: g, ..._} = t
      , m = wa(Dr, n)
      , p = Qh(Dr, n)
      , b = rg(n)
      , y = aN(n)
      , x = Zae(n)
      , [E,w] = S.useState(null)
      , A = S.useRef(null)
      , C = rt(e, A, m.onContentChange)
      , k = S.useRef(0)
      , I = S.useRef("")
      , N = S.useRef(0)
      , O = S.useRef(null)
      , M = S.useRef("right")
      , H = S.useRef(0)
      , $ = g ? $m : S.Fragment
      , J = g ? {
        as: Fs,
        allowPinchZoom: !0
    } : void 0
      , Q = D => {
        const L = I.current + D
          , z = x().filter(G => !G.disabled)
          , V = document.activeElement
          , B = z.find(G => G.ref.current === V)?.textValue
          , Z = z.map(G => G.textValue)
          , se = yle(Z, L, B)
          , ae = z.find(G => G.textValue === se)?.ref.current;
        (function G(j) {
            I.current = j,
            window.clearTimeout(k.current),
            j !== "" && (k.current = window.setTimeout( () => G(""), 1e3))
        }
        )(L),
        ae && setTimeout( () => ae.focus())
    }
    ;
    S.useEffect( () => () => window.clearTimeout(k.current), []),
    o1();
    const ee = S.useCallback(D => M.current === O.current?.side && xle(D, O.current?.area), []);
    return v.jsx(sle, {
        scope: n,
        searchRef: I,
        onItemEnter: S.useCallback(D => {
            ee(D) && D.preventDefault()
        }
        , [ee]),
        onItemLeave: S.useCallback(D => {
            ee(D) || (A.current?.focus(),
            w(null))
        }
        , [ee]),
        onTriggerLeave: S.useCallback(D => {
            ee(D) && D.preventDefault()
        }
        , [ee]),
        pointerGraceTimerRef: N,
        onPointerGraceIntentChange: S.useCallback(D => {
            O.current = D
        }
        , []),
        children: v.jsx($, {
            ...J,
            children: v.jsx(Wh, {
                asChild: !0,
                trapped: i,
                onMountAutoFocus: Ee(s, D => {
                    D.preventDefault(),
                    A.current?.focus({
                        preventScroll: !0
                    })
                }
                ),
                onUnmountAutoFocus: o,
                children: v.jsx(wh, {
                    asChild: !0,
                    disableOutsidePointerEvents: a,
                    onEscapeKeyDown: c,
                    onPointerDownOutside: u,
                    onFocusOutside: h,
                    onInteractOutside: d,
                    onDismiss: f,
                    children: v.jsx(rN, {
                        asChild: !0,
                        ...y,
                        dir: p.dir,
                        orientation: "vertical",
                        loop: r,
                        currentTabStopId: E,
                        onCurrentTabStopIdChange: w,
                        onEntryFocus: Ee(l, D => {
                            p.isUsingKeyboardRef.current || D.preventDefault()
                        }
                        ),
                        preventScrollOnEntryFocus: !0,
                        children: v.jsx(dm, {
                            role: "menu",
                            "aria-orientation": "vertical",
                            "data-state": AN(m.open),
                            "data-radix-menu-content": "",
                            dir: p.dir,
                            ...b,
                            ..._,
                            ref: C,
                            style: {
                                outline: "none",
                                ..._.style
                            },
                            onKeyDown: Ee(_.onKeyDown, D => {
                                const z = D.target.closest("[data-radix-menu-content]") === D.currentTarget
                                  , V = D.ctrlKey || D.altKey || D.metaKey
                                  , B = D.key.length === 1;
                                z && (D.key === "Tab" && D.preventDefault(),
                                !V && B && Q(D.key));
                                const Z = A.current;
                                if (D.target !== Z || !Xae.includes(D.key))
                                    return;
                                D.preventDefault();
                                const ae = x().filter(G => !G.disabled).map(G => G.ref.current);
                                sN.includes(D.key) && ae.reverse(),
                                _le(ae)
                            }
                            ),
                            onBlur: Ee(t.onBlur, D => {
                                D.currentTarget.contains(D.target) || (window.clearTimeout(k.current),
                                I.current = "")
                            }
                            ),
                            onPointerMove: Ee(t.onPointerMove, Uu(D => {
                                const L = D.target
                                  , z = H.current !== D.clientX;
                                if (D.currentTarget.contains(L) && z) {
                                    const V = D.clientX > H.current ? "right" : "left";
                                    M.current = V,
                                    H.current = D.clientX
                                }
                            }
                            ))
                        })
                    })
                })
            })
        })
    })
}
);
hN.displayName = Dr;
var lle = "MenuGroup"
  , I1 = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t;
    return v.jsx(We.div, {
        role: "group",
        ...r,
        ref: e
    })
}
);
I1.displayName = lle;
var cle = "MenuLabel"
  , dN = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t;
    return v.jsx(We.div, {
        ...r,
        ref: e
    })
}
);
dN.displayName = cle;
var Rp = "MenuItem"
  , FC = "menu.itemSelect"
  , ig = S.forwardRef( (t, e) => {
    const {disabled: n=!1, onSelect: r, ...i} = t
      , s = S.useRef(null)
      , o = Qh(Rp, t.__scopeMenu)
      , a = k1(Rp, t.__scopeMenu)
      , l = rt(e, s)
      , c = S.useRef(!1)
      , u = () => {
        const h = s.current;
        if (!n && h) {
            const d = new CustomEvent(FC,{
                bubbles: !0,
                cancelable: !0
            });
            h.addEventListener(FC, f => r?.(f), {
                once: !0
            }),
            am(h, d),
            d.defaultPrevented ? c.current = !1 : o.onClose()
        }
    }
    ;
    return v.jsx(fN, {
        ...i,
        ref: l,
        disabled: n,
        onClick: Ee(t.onClick, u),
        onPointerDown: h => {
            t.onPointerDown?.(h),
            c.current = !0
        }
        ,
        onPointerUp: Ee(t.onPointerUp, h => {
            c.current || h.currentTarget?.click()
        }
        ),
        onKeyDown: Ee(t.onKeyDown, h => {
            const d = a.searchRef.current !== "";
            n || d && h.key === " " || vb.includes(h.key) && (h.currentTarget.click(),
            h.preventDefault())
        }
        )
    })
}
);
ig.displayName = Rp;
var fN = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, disabled: r=!1, textValue: i, ...s} = t
      , o = k1(Rp, n)
      , a = aN(n)
      , l = S.useRef(null)
      , c = rt(e, l)
      , [u,h] = S.useState(!1)
      , [d,f] = S.useState("");
    return S.useEffect( () => {
        const g = l.current;
        g && f((g.textContent ?? "").trim())
    }
    , [s.children]),
    v.jsx(Hu.ItemSlot, {
        scope: n,
        disabled: r,
        textValue: i ?? d,
        children: v.jsx(iN, {
            asChild: !0,
            ...a,
            focusable: !r,
            children: v.jsx(We.div, {
                role: "menuitem",
                "data-highlighted": u ? "" : void 0,
                "aria-disabled": r || void 0,
                "data-disabled": r ? "" : void 0,
                ...s,
                ref: c,
                onPointerMove: Ee(t.onPointerMove, Uu(g => {
                    r ? o.onItemLeave(g) : (o.onItemEnter(g),
                    g.defaultPrevented || g.currentTarget.focus({
                        preventScroll: !0
                    }))
                }
                )),
                onPointerLeave: Ee(t.onPointerLeave, Uu(g => o.onItemLeave(g))),
                onFocus: Ee(t.onFocus, () => h(!0)),
                onBlur: Ee(t.onBlur, () => h(!1))
            })
        })
    })
}
)
  , ule = "MenuCheckboxItem"
  , pN = S.forwardRef( (t, e) => {
    const {checked: n=!1, onCheckedChange: r, ...i} = t;
    return v.jsx(yN, {
        scope: t.__scopeMenu,
        checked: n,
        children: v.jsx(ig, {
            role: "menuitemcheckbox",
            "aria-checked": Ip(n) ? "mixed" : n,
            ...i,
            ref: e,
            "data-state": D1(n),
            onSelect: Ee(i.onSelect, () => r?.(Ip(n) ? !0 : !n), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
pN.displayName = ule;
var mN = "MenuRadioGroup"
  , [hle,dle] = Sa(mN, {
    value: void 0,
    onValueChange: () => {}
})
  , gN = S.forwardRef( (t, e) => {
    const {value: n, onValueChange: r, ...i} = t
      , s = vn(r);
    return v.jsx(hle, {
        scope: t.__scopeMenu,
        value: n,
        onValueChange: s,
        children: v.jsx(I1, {
            ...i,
            ref: e
        })
    })
}
);
gN.displayName = mN;
var _N = "MenuRadioItem"
  , bN = S.forwardRef( (t, e) => {
    const {value: n, ...r} = t
      , i = dle(_N, t.__scopeMenu)
      , s = n === i.value;
    return v.jsx(yN, {
        scope: t.__scopeMenu,
        checked: s,
        children: v.jsx(ig, {
            role: "menuitemradio",
            "aria-checked": s,
            ...r,
            ref: e,
            "data-state": D1(s),
            onSelect: Ee(r.onSelect, () => i.onValueChange?.(n), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
bN.displayName = _N;
var P1 = "MenuItemIndicator"
  , [yN,fle] = Sa(P1, {
    checked: !1
})
  , vN = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, forceMount: r, ...i} = t
      , s = fle(P1, n);
    return v.jsx(Li, {
        present: r || Ip(s.checked) || s.checked === !0,
        children: v.jsx(We.span, {
            ...i,
            ref: e,
            "data-state": D1(s.checked)
        })
    })
}
);
vN.displayName = P1;
var ple = "MenuSeparator"
  , xN = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t;
    return v.jsx(We.div, {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
    })
}
);
xN.displayName = ple;
var mle = "MenuArrow"
  , EN = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t
      , i = rg(n);
    return v.jsx(fm, {
        ...i,
        ...r,
        ref: e
    })
}
);
EN.displayName = mle;
var gle = "MenuSub"
  , [lve,SN] = Sa(gle)
  , Pc = "MenuSubTrigger"
  , wN = S.forwardRef( (t, e) => {
    const n = wa(Pc, t.__scopeMenu)
      , r = Qh(Pc, t.__scopeMenu)
      , i = SN(Pc, t.__scopeMenu)
      , s = k1(Pc, t.__scopeMenu)
      , o = S.useRef(null)
      , {pointerGraceTimerRef: a, onPointerGraceIntentChange: l} = s
      , c = {
        __scopeMenu: t.__scopeMenu
    }
      , u = S.useCallback( () => {
        o.current && window.clearTimeout(o.current),
        o.current = null
    }
    , []);
    return S.useEffect( () => u, [u]),
    S.useEffect( () => {
        const h = a.current;
        return () => {
            window.clearTimeout(h),
            l(null)
        }
    }
    , [a, l]),
    v.jsx(T1, {
        asChild: !0,
        ...c,
        children: v.jsx(fN, {
            id: i.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": n.open,
            "aria-controls": i.contentId,
            "data-state": AN(n.open),
            ...t,
            ref: Sh(e, i.onTriggerChange),
            onClick: h => {
                t.onClick?.(h),
                !(t.disabled || h.defaultPrevented) && (h.currentTarget.focus(),
                n.open || n.onOpenChange(!0))
            }
            ,
            onPointerMove: Ee(t.onPointerMove, Uu(h => {
                s.onItemEnter(h),
                !h.defaultPrevented && !t.disabled && !n.open && !o.current && (s.onPointerGraceIntentChange(null),
                o.current = window.setTimeout( () => {
                    n.onOpenChange(!0),
                    u()
                }
                , 100))
            }
            )),
            onPointerLeave: Ee(t.onPointerLeave, Uu(h => {
                u();
                const d = n.content?.getBoundingClientRect();
                if (d) {
                    const f = n.content?.dataset.side
                      , g = f === "right"
                      , _ = g ? -5 : 5
                      , m = d[g ? "left" : "right"]
                      , p = d[g ? "right" : "left"];
                    s.onPointerGraceIntentChange({
                        area: [{
                            x: h.clientX + _,
                            y: h.clientY
                        }, {
                            x: m,
                            y: d.top
                        }, {
                            x: p,
                            y: d.top
                        }, {
                            x: p,
                            y: d.bottom
                        }, {
                            x: m,
                            y: d.bottom
                        }],
                        side: f
                    }),
                    window.clearTimeout(a.current),
                    a.current = window.setTimeout( () => s.onPointerGraceIntentChange(null), 300)
                } else {
                    if (s.onTriggerLeave(h),
                    h.defaultPrevented)
                        return;
                    s.onPointerGraceIntentChange(null)
                }
            }
            )),
            onKeyDown: Ee(t.onKeyDown, h => {
                const d = s.searchRef.current !== "";
                t.disabled || d && h.key === " " || Qae[r.dir].includes(h.key) && (n.onOpenChange(!0),
                n.content?.focus(),
                h.preventDefault())
            }
            )
        })
    })
}
);
wN.displayName = Pc;
var CN = "MenuSubContent"
  , TN = S.forwardRef( (t, e) => {
    const n = cN(Dr, t.__scopeMenu)
      , {forceMount: r=n.forceMount, ...i} = t
      , s = wa(Dr, t.__scopeMenu)
      , o = Qh(Dr, t.__scopeMenu)
      , a = SN(CN, t.__scopeMenu)
      , l = S.useRef(null)
      , c = rt(e, l);
    return v.jsx(Hu.Provider, {
        scope: t.__scopeMenu,
        children: v.jsx(Li, {
            present: r || s.open,
            children: v.jsx(Hu.Slot, {
                scope: t.__scopeMenu,
                children: v.jsx(R1, {
                    id: a.contentId,
                    "aria-labelledby": a.triggerId,
                    ...i,
                    ref: c,
                    align: "start",
                    side: o.dir === "rtl" ? "left" : "right",
                    disableOutsidePointerEvents: !1,
                    disableOutsideScroll: !1,
                    trapFocus: !1,
                    onOpenAutoFocus: u => {
                        o.isUsingKeyboardRef.current && l.current?.focus(),
                        u.preventDefault()
                    }
                    ,
                    onCloseAutoFocus: u => u.preventDefault(),
                    onFocusOutside: Ee(t.onFocusOutside, u => {
                        u.target !== a.trigger && s.onOpenChange(!1)
                    }
                    ),
                    onEscapeKeyDown: Ee(t.onEscapeKeyDown, u => {
                        o.onClose(),
                        u.preventDefault()
                    }
                    ),
                    onKeyDown: Ee(t.onKeyDown, u => {
                        const h = u.currentTarget.contains(u.target)
                          , d = Jae[o.dir].includes(u.key);
                        h && d && (s.onOpenChange(!1),
                        a.trigger?.focus(),
                        u.preventDefault())
                    }
                    )
                })
            })
        })
    })
}
);
TN.displayName = CN;
function AN(t) {
    return t ? "open" : "closed"
}
function Ip(t) {
    return t === "indeterminate"
}
function D1(t) {
    return Ip(t) ? "indeterminate" : t ? "checked" : "unchecked"
}
function _le(t) {
    const e = document.activeElement;
    for (const n of t)
        if (n === e || (n.focus(),
        document.activeElement !== e))
            return
}
function ble(t, e) {
    return t.map( (n, r) => t[(e + r) % t.length])
}
function yle(t, e, n) {
    const i = e.length > 1 && Array.from(e).every(c => c === e[0]) ? e[0] : e
      , s = n ? t.indexOf(n) : -1;
    let o = ble(t, Math.max(s, 0));
    i.length === 1 && (o = o.filter(c => c !== n));
    const l = o.find(c => c.toLowerCase().startsWith(i.toLowerCase()));
    return l !== n ? l : void 0
}
function vle(t, e) {
    const {x: n, y: r} = t;
    let i = !1;
    for (let s = 0, o = e.length - 1; s < e.length; o = s++) {
        const a = e[s].x
          , l = e[s].y
          , c = e[o].x
          , u = e[o].y;
        l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (i = !i)
    }
    return i
}
function xle(t, e) {
    if (!e)
        return !1;
    const n = {
        x: t.clientX,
        y: t.clientY
    };
    return vle(n, e)
}
function Uu(t) {
    return e => e.pointerType === "mouse" ? t(e) : void 0
}
var Ele = lN
  , Sle = T1
  , wle = uN
  , Cle = hN
  , Tle = I1
  , Ale = dN
  , kle = ig
  , Rle = pN
  , Ile = gN
  , Ple = bN
  , Dle = vN
  , Lle = xN
  , Ole = EN
  , Nle = wN
  , Mle = TN
  , L1 = "DropdownMenu"
  , [Ble,cve] = cs(L1, [oN])
  , Wn = oN()
  , [Fle,kN] = Ble(L1)
  , RN = t => {
    const {__scopeDropdownMenu: e, children: n, dir: r, open: i, defaultOpen: s, onOpenChange: o, modal: a=!0} = t
      , l = Wn(e)
      , c = S.useRef(null)
      , [u=!1,h] = Go({
        prop: i,
        defaultProp: s,
        onChange: o
    });
    return v.jsx(Fle, {
        scope: e,
        triggerId: Ci(),
        triggerRef: c,
        contentId: Ci(),
        open: u,
        onOpenChange: h,
        onOpenToggle: S.useCallback( () => h(d => !d), [h]),
        modal: a,
        children: v.jsx(Ele, {
            ...l,
            open: u,
            onOpenChange: h,
            dir: r,
            modal: a,
            children: n
        })
    })
}
;
RN.displayName = L1;
var IN = "DropdownMenuTrigger"
  , PN = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, disabled: r=!1, ...i} = t
      , s = kN(IN, n)
      , o = Wn(n);
    return v.jsx(Sle, {
        asChild: !0,
        ...o,
        children: v.jsx(We.button, {
            type: "button",
            id: s.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": s.open,
            "aria-controls": s.open ? s.contentId : void 0,
            "data-state": s.open ? "open" : "closed",
            "data-disabled": r ? "" : void 0,
            disabled: r,
            ...i,
            ref: Sh(e, s.triggerRef),
            onPointerDown: Ee(t.onPointerDown, a => {
                !r && a.button === 0 && a.ctrlKey === !1 && (s.onOpenToggle(),
                s.open || a.preventDefault())
            }
            ),
            onKeyDown: Ee(t.onKeyDown, a => {
                r || (["Enter", " "].includes(a.key) && s.onOpenToggle(),
                a.key === "ArrowDown" && s.onOpenChange(!0),
                ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault())
            }
            )
        })
    })
}
);
PN.displayName = IN;
var jle = "DropdownMenuPortal"
  , DN = t => {
    const {__scopeDropdownMenu: e, ...n} = t
      , r = Wn(e);
    return v.jsx(wle, {
        ...r,
        ...n
    })
}
;
DN.displayName = jle;
var LN = "DropdownMenuContent"
  , ON = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = kN(LN, n)
      , s = Wn(n)
      , o = S.useRef(!1);
    return v.jsx(Cle, {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...s,
        ...r,
        ref: e,
        onCloseAutoFocus: Ee(t.onCloseAutoFocus, a => {
            o.current || i.triggerRef.current?.focus(),
            o.current = !1,
            a.preventDefault()
        }
        ),
        onInteractOutside: Ee(t.onInteractOutside, a => {
            const l = a.detail.originalEvent
              , c = l.button === 0 && l.ctrlKey === !0
              , u = l.button === 2 || c;
            (!i.modal || u) && (o.current = !0)
        }
        ),
        style: {
            ...t.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
ON.displayName = LN;
var Hle = "DropdownMenuGroup"
  , Ule = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Tle, {
        ...i,
        ...r,
        ref: e
    })
}
);
Ule.displayName = Hle;
var Vle = "DropdownMenuLabel"
  , $le = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Ale, {
        ...i,
        ...r,
        ref: e
    })
}
);
$le.displayName = Vle;
var zle = "DropdownMenuItem"
  , Wle = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(kle, {
        ...i,
        ...r,
        ref: e
    })
}
);
Wle.displayName = zle;
var Gle = "DropdownMenuCheckboxItem"
  , qle = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Rle, {
        ...i,
        ...r,
        ref: e
    })
}
);
qle.displayName = Gle;
var Kle = "DropdownMenuRadioGroup"
  , Yle = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Ile, {
        ...i,
        ...r,
        ref: e
    })
}
);
Yle.displayName = Kle;
var Xle = "DropdownMenuRadioItem"
  , Qle = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Ple, {
        ...i,
        ...r,
        ref: e
    })
}
);
Qle.displayName = Xle;
var Jle = "DropdownMenuItemIndicator"
  , Zle = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Dle, {
        ...i,
        ...r,
        ref: e
    })
}
);
Zle.displayName = Jle;
var ece = "DropdownMenuSeparator"
  , tce = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Lle, {
        ...i,
        ...r,
        ref: e
    })
}
);
tce.displayName = ece;
var nce = "DropdownMenuArrow"
  , NN = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Ole, {
        ...i,
        ...r,
        ref: e
    })
}
);
NN.displayName = nce;
var rce = "DropdownMenuSubTrigger"
  , ice = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Nle, {
        ...i,
        ...r,
        ref: e
    })
}
);
ice.displayName = rce;
var sce = "DropdownMenuSubContent"
  , oce = S.forwardRef( (t, e) => {
    const {__scopeDropdownMenu: n, ...r} = t
      , i = Wn(n);
    return v.jsx(Mle, {
        ...i,
        ...r,
        ref: e,
        style: {
            ...t.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
oce.displayName = sce;
var MN = RN
  , BN = PN
  , FN = DN
  , jN = ON
  , HN = NN;
function UN(t, e=[]) {
    let n = [];
    function r(s, o) {
        const a = S.createContext(o)
          , l = n.length;
        n = [...n, o];
        const c = h => {
            const {scope: d, children: f, ...g} = h
              , _ = d?.[t]?.[l] || a
              , m = S.useMemo( () => g, Object.values(g));
            return v.jsx(_.Provider, {
                value: m,
                children: f
            })
        }
        ;
        c.displayName = s + "Provider";
        function u(h, d) {
            const f = d?.[t]?.[l] || a
              , g = S.useContext(f);
            if (g)
                return g;
            if (o !== void 0)
                return o;
            throw new Error(`\`${h}\` must be used within \`${s}\``)
        }
        return [c, u]
    }
    const i = () => {
        const s = n.map(o => S.createContext(o));
        return function(a) {
            const l = a?.[t] || s;
            return S.useMemo( () => ({
                [`__scope${t}`]: {
                    ...a,
                    [t]: l
                }
            }), [a, l])
        }
    }
    ;
    return i.scopeName = t,
    [r, ace(i, ...e)]
}
function ace(...t) {
    const e = t[0];
    if (t.length === 1)
        return e;
    const n = () => {
        const r = t.map(i => ({
            useScope: i(),
            scopeName: i.scopeName
        }));
        return function(s) {
            const o = r.reduce( (a, {useScope: l, scopeName: c}) => {
                const h = l(s)[`__scope${c}`];
                return {
                    ...a,
                    ...h
                }
            }
            , {});
            return S.useMemo( () => ({
                [`__scope${e.scopeName}`]: o
            }), [o])
        }
    }
    ;
    return n.scopeName = e.scopeName,
    n
}
var lce = "DismissableLayer", xb = "dismissableLayer.update", cce = "dismissableLayer.pointerDownOutside", uce = "dismissableLayer.focusOutside", jC, VN = S.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), $N = S.forwardRef( (t, e) => {
    const {disableOutsidePointerEvents: n=!1, onEscapeKeyDown: r, onPointerDownOutside: i, onFocusOutside: s, onInteractOutside: o, onDismiss: a, ...l} = t
      , c = S.useContext(VN)
      , [u,h] = S.useState(null)
      , d = u?.ownerDocument ?? globalThis?.document
      , [,f] = S.useState({})
      , g = rt(e, A => h(A))
      , _ = Array.from(c.layers)
      , [m] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1)
      , p = _.indexOf(m)
      , b = u ? _.indexOf(u) : -1
      , y = c.layersWithOutsidePointerEventsDisabled.size > 0
      , x = b >= p
      , E = fce(A => {
        const C = A.target
          , k = [...c.branches].some(I => I.contains(C));
        !x || k || (i?.(A),
        o?.(A),
        A.defaultPrevented || a?.())
    }
    , d)
      , w = pce(A => {
        const C = A.target;
        [...c.branches].some(I => I.contains(C)) || (s?.(A),
        o?.(A),
        A.defaultPrevented || a?.())
    }
    , d);
    return xk(A => {
        b === c.layers.size - 1 && (r?.(A),
        !A.defaultPrevented && a && (A.preventDefault(),
        a()))
    }
    , d),
    S.useEffect( () => {
        if (u)
            return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (jC = d.body.style.pointerEvents,
            d.body.style.pointerEvents = "none"),
            c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            HC(),
            () => {
                n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = jC)
            }
    }
    , [u, d, n, c]),
    S.useEffect( () => () => {
        u && (c.layers.delete(u),
        c.layersWithOutsidePointerEventsDisabled.delete(u),
        HC())
    }
    , [u, c]),
    S.useEffect( () => {
        const A = () => f({});
        return document.addEventListener(xb, A),
        () => document.removeEventListener(xb, A)
    }
    , []),
    v.jsx(We.div, {
        ...l,
        ref: g,
        style: {
            pointerEvents: y ? x ? "auto" : "none" : void 0,
            ...t.style
        },
        onFocusCapture: Ee(t.onFocusCapture, w.onFocusCapture),
        onBlurCapture: Ee(t.onBlurCapture, w.onBlurCapture),
        onPointerDownCapture: Ee(t.onPointerDownCapture, E.onPointerDownCapture)
    })
}
);
$N.displayName = lce;
var hce = "DismissableLayerBranch"
  , dce = S.forwardRef( (t, e) => {
    const n = S.useContext(VN)
      , r = S.useRef(null)
      , i = rt(e, r);
    return S.useEffect( () => {
        const s = r.current;
        if (s)
            return n.branches.add(s),
            () => {
                n.branches.delete(s)
            }
    }
    , [n.branches]),
    v.jsx(We.div, {
        ...t,
        ref: i
    })
}
);
dce.displayName = hce;
function fce(t, e=globalThis?.document) {
    const n = vn(t)
      , r = S.useRef(!1)
      , i = S.useRef( () => {}
    );
    return S.useEffect( () => {
        const s = a => {
            if (a.target && !r.current) {
                let l = function() {
                    zN(cce, n, c, {
                        discrete: !0
                    })
                };
                const c = {
                    originalEvent: a
                };
                a.pointerType === "touch" ? (e.removeEventListener("click", i.current),
                i.current = l,
                e.addEventListener("click", i.current, {
                    once: !0
                })) : l()
            } else
                e.removeEventListener("click", i.current);
            r.current = !1
        }
          , o = window.setTimeout( () => {
            e.addEventListener("pointerdown", s)
        }
        , 0);
        return () => {
            window.clearTimeout(o),
            e.removeEventListener("pointerdown", s),
            e.removeEventListener("click", i.current)
        }
    }
    , [e, n]),
    {
        onPointerDownCapture: () => r.current = !0
    }
}
function pce(t, e=globalThis?.document) {
    const n = vn(t)
      , r = S.useRef(!1);
    return S.useEffect( () => {
        const i = s => {
            s.target && !r.current && zN(uce, n, {
                originalEvent: s
            }, {
                discrete: !1
            })
        }
        ;
        return e.addEventListener("focusin", i),
        () => e.removeEventListener("focusin", i)
    }
    , [e, n]),
    {
        onFocusCapture: () => r.current = !0,
        onBlurCapture: () => r.current = !1
    }
}
function HC() {
    const t = new CustomEvent(xb);
    document.dispatchEvent(t)
}
function zN(t, e, n, {discrete: r}) {
    const i = n.originalEvent.target
      , s = new CustomEvent(t,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    e && i.addEventListener(t, e, {
        once: !0
    }),
    r ? am(i, s) : i.dispatchEvent(s)
}
var R0 = 0;
function mce() {
    S.useEffect( () => {
        const t = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", t[0] ?? UC()),
        document.body.insertAdjacentElement("beforeend", t[1] ?? UC()),
        R0++,
        () => {
            R0 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()),
            R0--
        }
    }
    , [])
}
function UC() {
    const t = document.createElement("span");
    return t.setAttribute("data-radix-focus-guard", ""),
    t.tabIndex = 0,
    t.style.outline = "none",
    t.style.opacity = "0",
    t.style.position = "fixed",
    t.style.pointerEvents = "none",
    t
}
var gce = "Portal"
  , WN = S.forwardRef( (t, e) => {
    const {container: n, ...r} = t
      , [i,s] = S.useState(!1);
    hn( () => s(!0), []);
    const o = n || i && globalThis?.document?.body;
    return o ? ck.createPortal(v.jsx(We.div, {
        ...r,
        ref: e
    }), o) : null
}
);
WN.displayName = gce;
function _ce(t, e) {
    return S.useReducer( (n, r) => e[n][r] ?? n, t)
}
var Jh = t => {
    const {present: e, children: n} = t
      , r = bce(e)
      , i = typeof n == "function" ? n({
        present: r.isPresent
    }) : S.Children.only(n)
      , s = rt(r.ref, yce(i));
    return typeof n == "function" || r.isPresent ? S.cloneElement(i, {
        ref: s
    }) : null
}
;
Jh.displayName = "Presence";
function bce(t) {
    const [e,n] = S.useState()
      , r = S.useRef({})
      , i = S.useRef(t)
      , s = S.useRef("none")
      , o = t ? "mounted" : "unmounted"
      , [a,l] = _ce(o, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return S.useEffect( () => {
        const c = Ld(r.current);
        s.current = a === "mounted" ? c : "none"
    }
    , [a]),
    hn( () => {
        const c = r.current
          , u = i.current;
        if (u !== t) {
            const d = s.current
              , f = Ld(c);
            t ? l("MOUNT") : f === "none" || c?.display === "none" ? l("UNMOUNT") : l(u && d !== f ? "ANIMATION_OUT" : "UNMOUNT"),
            i.current = t
        }
    }
    , [t, l]),
    hn( () => {
        if (e) {
            let c;
            const u = e.ownerDocument.defaultView ?? window
              , h = f => {
                const _ = Ld(r.current).includes(f.animationName);
                if (f.target === e && _ && (l("ANIMATION_END"),
                !i.current)) {
                    const m = e.style.animationFillMode;
                    e.style.animationFillMode = "forwards",
                    c = u.setTimeout( () => {
                        e.style.animationFillMode === "forwards" && (e.style.animationFillMode = m)
                    }
                    )
                }
            }
              , d = f => {
                f.target === e && (s.current = Ld(r.current))
            }
            ;
            return e.addEventListener("animationstart", d),
            e.addEventListener("animationcancel", h),
            e.addEventListener("animationend", h),
            () => {
                u.clearTimeout(c),
                e.removeEventListener("animationstart", d),
                e.removeEventListener("animationcancel", h),
                e.removeEventListener("animationend", h)
            }
        } else
            l("ANIMATION_END")
    }
    , [e, l]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: S.useCallback(c => {
            c && (r.current = getComputedStyle(c)),
            n(c)
        }
        , [])
    }
}
function Ld(t) {
    return t?.animationName || "none"
}
function yce(t) {
    let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get
      , n = e && "isReactWarning"in e && e.isReactWarning;
    return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get,
    n = e && "isReactWarning"in e && e.isReactWarning,
    n ? t.props.ref : t.props.ref || t.ref)
}
var GN = QD()
  , I0 = function() {}
  , sg = S.forwardRef(function(t, e) {
    var n = S.useRef(null)
      , r = S.useState({
        onScrollCapture: I0,
        onWheelCapture: I0,
        onTouchMoveCapture: I0
    })
      , i = r[0]
      , s = r[1]
      , o = t.forwardProps
      , a = t.children
      , l = t.className
      , c = t.removeScrollBar
      , u = t.enabled
      , h = t.shards
      , d = t.sideCar
      , f = t.noIsolation
      , g = t.inert
      , _ = t.allowPinchZoom
      , m = t.as
      , p = m === void 0 ? "div" : m
      , b = t.gapMode
      , y = Iy(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , x = d
      , E = XD([n, e])
      , w = An(An({}, y), i);
    return S.createElement(S.Fragment, null, u && S.createElement(x, {
        sideCar: GN,
        removeScrollBar: c,
        shards: h,
        noIsolation: f,
        inert: g,
        setCallbacks: s,
        allowPinchZoom: !!_,
        lockRef: n,
        gapMode: b
    }), o ? S.cloneElement(S.Children.only(a), An(An({}, w), {
        ref: E
    })) : S.createElement(p, An({}, w, {
        className: l,
        ref: E
    }), a))
});
sg.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
sg.classNames = {
    fullWidth: Jc,
    zeroRight: Qc
};
var Eb = !1;
if (typeof window < "u")
    try {
        var Od = Object.defineProperty({}, "passive", {
            get: function() {
                return Eb = !0,
                !0
            }
        });
        window.addEventListener("test", Od, Od),
        window.removeEventListener("test", Od, Od)
    } catch {
        Eb = !1
    }
var Fa = Eb ? {
    passive: !1
} : !1
  , vce = function(t) {
    return t.tagName === "TEXTAREA"
}
  , qN = function(t, e) {
    if (!(t instanceof Element))
        return !1;
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !vce(t) && n[e] === "visible")
}
  , xce = function(t) {
    return qN(t, "overflowY")
}
  , Ece = function(t) {
    return qN(t, "overflowX")
}
  , VC = function(t, e) {
    var n = e.ownerDocument
      , r = e;
    do {
        typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
        var i = KN(t, r);
        if (i) {
            var s = YN(t, r)
              , o = s[1]
              , a = s[2];
            if (o > a)
                return !0
        }
        r = r.parentNode
    } while (r && r !== n.body);
    return !1
}
  , Sce = function(t) {
    var e = t.scrollTop
      , n = t.scrollHeight
      , r = t.clientHeight;
    return [e, n, r]
}
  , wce = function(t) {
    var e = t.scrollLeft
      , n = t.scrollWidth
      , r = t.clientWidth;
    return [e, n, r]
}
  , KN = function(t, e) {
    return t === "v" ? xce(e) : Ece(e)
}
  , YN = function(t, e) {
    return t === "v" ? Sce(e) : wce(e)
}
  , Cce = function(t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
}
  , Tce = function(t, e, n, r, i) {
    var s = Cce(t, window.getComputedStyle(e).direction)
      , o = s * r
      , a = n.target
      , l = e.contains(a)
      , c = !1
      , u = o > 0
      , h = 0
      , d = 0;
    do {
        var f = YN(t, a)
          , g = f[0]
          , _ = f[1]
          , m = f[2]
          , p = _ - m - s * g;
        (g || p) && KN(t, a) && (h += p,
        d += g),
        a instanceof ShadowRoot ? a = a.host : a = a.parentNode
    } while (!l && a !== document.body || l && (e.contains(a) || e === a));
    return (u && (Math.abs(h) < 1 || !i) || !u && (Math.abs(d) < 1 || !i)) && (c = !0),
    c
}
  , Nd = function(t) {
    return "changedTouches"in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
}
  , $C = function(t) {
    return [t.deltaX, t.deltaY]
}
  , zC = function(t) {
    return t && "current"in t ? t.current : t
}
  , Ace = function(t, e) {
    return t[0] === e[0] && t[1] === e[1]
}
  , kce = function(t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}
  , Rce = 0
  , ja = [];
function Ice(t) {
    var e = S.useRef([])
      , n = S.useRef([0, 0])
      , r = S.useRef()
      , i = S.useState(Rce++)[0]
      , s = S.useState(a1)[0]
      , o = S.useRef(t);
    S.useEffect(function() {
        o.current = t
    }, [t]),
    S.useEffect(function() {
        if (t.inert) {
            document.body.classList.add("block-interactivity-".concat(i));
            var _ = dk([t.lockRef.current], (t.shards || []).map(zC), !0).filter(Boolean);
            return _.forEach(function(m) {
                return m.classList.add("allow-interactivity-".concat(i))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(i)),
                _.forEach(function(m) {
                    return m.classList.remove("allow-interactivity-".concat(i))
                })
            }
        }
    }, [t.inert, t.lockRef.current, t.shards]);
    var a = S.useCallback(function(_, m) {
        if ("touches"in _ && _.touches.length === 2 || _.type === "wheel" && _.ctrlKey)
            return !o.current.allowPinchZoom;
        var p = Nd(_), b = n.current, y = "deltaX"in _ ? _.deltaX : b[0] - p[0], x = "deltaY"in _ ? _.deltaY : b[1] - p[1], E, w = _.target, A = Math.abs(y) > Math.abs(x) ? "h" : "v";
        if ("touches"in _ && A === "h" && w.type === "range")
            return !1;
        var C = VC(A, w);
        if (!C)
            return !0;
        if (C ? E = A : (E = A === "v" ? "h" : "v",
        C = VC(A, w)),
        !C)
            return !1;
        if (!r.current && "changedTouches"in _ && (y || x) && (r.current = E),
        !E)
            return !0;
        var k = r.current || E;
        return Tce(k, m, _, k === "h" ? y : x, !0)
    }, [])
      , l = S.useCallback(function(_) {
        var m = _;
        if (!(!ja.length || ja[ja.length - 1] !== s)) {
            var p = "deltaY"in m ? $C(m) : Nd(m)
              , b = e.current.filter(function(E) {
                return E.name === m.type && (E.target === m.target || m.target === E.shadowParent) && Ace(E.delta, p)
            })[0];
            if (b && b.should) {
                m.cancelable && m.preventDefault();
                return
            }
            if (!b) {
                var y = (o.current.shards || []).map(zC).filter(Boolean).filter(function(E) {
                    return E.contains(m.target)
                })
                  , x = y.length > 0 ? a(m, y[0]) : !o.current.noIsolation;
                x && m.cancelable && m.preventDefault()
            }
        }
    }, [])
      , c = S.useCallback(function(_, m, p, b) {
        var y = {
            name: _,
            delta: m,
            target: p,
            should: b,
            shadowParent: Pce(p)
        };
        e.current.push(y),
        setTimeout(function() {
            e.current = e.current.filter(function(x) {
                return x !== y
            })
        }, 1)
    }, [])
      , u = S.useCallback(function(_) {
        n.current = Nd(_),
        r.current = void 0
    }, [])
      , h = S.useCallback(function(_) {
        c(_.type, $C(_), _.target, a(_, t.lockRef.current))
    }, [])
      , d = S.useCallback(function(_) {
        c(_.type, Nd(_), _.target, a(_, t.lockRef.current))
    }, []);
    S.useEffect(function() {
        return ja.push(s),
        t.setCallbacks({
            onScrollCapture: h,
            onWheelCapture: h,
            onTouchMoveCapture: d
        }),
        document.addEventListener("wheel", l, Fa),
        document.addEventListener("touchmove", l, Fa),
        document.addEventListener("touchstart", u, Fa),
        function() {
            ja = ja.filter(function(_) {
                return _ !== s
            }),
            document.removeEventListener("wheel", l, Fa),
            document.removeEventListener("touchmove", l, Fa),
            document.removeEventListener("touchstart", u, Fa)
        }
    }, []);
    var f = t.removeScrollBar
      , g = t.inert;
    return S.createElement(S.Fragment, null, g ? S.createElement(s, {
        styles: kce(i)
    }) : null, f ? S.createElement(tL, {
        gapMode: t.gapMode
    }) : null)
}
function Pce(t) {
    for (var e = null; t !== null; )
        t instanceof ShadowRoot && (e = t.host,
        t = t.host),
        t = t.parentNode;
    return e
}
const Dce = ZD(GN, Ice);
var XN = S.forwardRef(function(t, e) {
    return S.createElement(sg, An({}, t, {
        ref: e,
        sideCar: Dce
    }))
});
XN.classNames = sg.classNames;
var Sb = ["Enter", " "]
  , Lce = ["ArrowDown", "PageUp", "Home"]
  , QN = ["ArrowUp", "PageDown", "End"]
  , Oce = [...Lce, ...QN]
  , Nce = {
    ltr: [...Sb, "ArrowRight"],
    rtl: [...Sb, "ArrowLeft"]
}
  , Mce = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
}
  , Zh = "Menu"
  , [Vu,Bce,Fce] = Wm(Zh)
  , [Ca,JN] = UN(Zh, [Fce, ro, ng])
  , og = ro()
  , ZN = ng()
  , [jce,Ta] = Ca(Zh)
  , [Hce,ed] = Ca(Zh)
  , eM = t => {
    const {__scopeMenu: e, open: n=!1, children: r, dir: i, onOpenChange: s, modal: o=!0} = t
      , a = og(e)
      , [l,c] = S.useState(null)
      , u = S.useRef(!1)
      , h = vn(s)
      , d = Gm(i);
    return S.useEffect( () => {
        const f = () => {
            u.current = !0,
            document.addEventListener("pointerdown", g, {
                capture: !0,
                once: !0
            }),
            document.addEventListener("pointermove", g, {
                capture: !0,
                once: !0
            })
        }
          , g = () => u.current = !1;
        return document.addEventListener("keydown", f, {
            capture: !0
        }),
        () => {
            document.removeEventListener("keydown", f, {
                capture: !0
            }),
            document.removeEventListener("pointerdown", g, {
                capture: !0
            }),
            document.removeEventListener("pointermove", g, {
                capture: !0
            })
        }
    }
    , []),
    v.jsx(um, {
        ...a,
        children: v.jsx(jce, {
            scope: e,
            open: n,
            onOpenChange: h,
            content: l,
            onContentChange: c,
            children: v.jsx(Hce, {
                scope: e,
                onClose: S.useCallback( () => h(!1), [h]),
                isUsingKeyboardRef: u,
                dir: d,
                modal: o,
                children: r
            })
        })
    })
}
;
eM.displayName = Zh;
var Uce = "MenuAnchor"
  , O1 = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t
      , i = og(n);
    return v.jsx(hm, {
        ...i,
        ...r,
        ref: e
    })
}
);
O1.displayName = Uce;
var N1 = "MenuPortal"
  , [Vce,tM] = Ca(N1, {
    forceMount: void 0
})
  , nM = t => {
    const {__scopeMenu: e, forceMount: n, children: r, container: i} = t
      , s = Ta(N1, e);
    return v.jsx(Vce, {
        scope: e,
        forceMount: n,
        children: v.jsx(Jh, {
            present: n || s.open,
            children: v.jsx(WN, {
                asChild: !0,
                container: i,
                children: r
            })
        })
    })
}
;
nM.displayName = N1;
var Lr = "MenuContent"
  , [$ce,M1] = Ca(Lr)
  , rM = S.forwardRef( (t, e) => {
    const n = tM(Lr, t.__scopeMenu)
      , {forceMount: r=n.forceMount, ...i} = t
      , s = Ta(Lr, t.__scopeMenu)
      , o = ed(Lr, t.__scopeMenu);
    return v.jsx(Vu.Provider, {
        scope: t.__scopeMenu,
        children: v.jsx(Jh, {
            present: r || s.open,
            children: v.jsx(Vu.Slot, {
                scope: t.__scopeMenu,
                children: o.modal ? v.jsx(zce, {
                    ...i,
                    ref: e
                }) : v.jsx(Wce, {
                    ...i,
                    ref: e
                })
            })
        })
    })
}
)
  , zce = S.forwardRef( (t, e) => {
    const n = Ta(Lr, t.__scopeMenu)
      , r = S.useRef(null)
      , i = rt(e, r);
    return S.useEffect( () => {
        const s = r.current;
        if (s)
            return zm(s)
    }
    , []),
    v.jsx(B1, {
        ...t,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ee(t.onFocusOutside, s => s.preventDefault(), {
            checkForDefaultPrevented: !1
        }),
        onDismiss: () => n.onOpenChange(!1)
    })
}
)
  , Wce = S.forwardRef( (t, e) => {
    const n = Ta(Lr, t.__scopeMenu);
    return v.jsx(B1, {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1)
    })
}
)
  , B1 = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, loop: r=!1, trapFocus: i, onOpenAutoFocus: s, onCloseAutoFocus: o, disableOutsidePointerEvents: a, onEntryFocus: l, onEscapeKeyDown: c, onPointerDownOutside: u, onFocusOutside: h, onInteractOutside: d, onDismiss: f, disableOutsideScroll: g, ..._} = t
      , m = Ta(Lr, n)
      , p = ed(Lr, n)
      , b = og(n)
      , y = ZN(n)
      , x = Bce(n)
      , [E,w] = S.useState(null)
      , A = S.useRef(null)
      , C = rt(e, A, m.onContentChange)
      , k = S.useRef(0)
      , I = S.useRef("")
      , N = S.useRef(0)
      , O = S.useRef(null)
      , M = S.useRef("right")
      , H = S.useRef(0)
      , $ = g ? XN : S.Fragment
      , J = g ? {
        as: Fs,
        allowPinchZoom: !0
    } : void 0
      , Q = D => {
        const L = I.current + D
          , z = x().filter(G => !G.disabled)
          , V = document.activeElement
          , B = z.find(G => G.ref.current === V)?.textValue
          , Z = z.map(G => G.textValue)
          , se = rue(Z, L, B)
          , ae = z.find(G => G.textValue === se)?.ref.current;
        (function G(j) {
            I.current = j,
            window.clearTimeout(k.current),
            j !== "" && (k.current = window.setTimeout( () => G(""), 1e3))
        }
        )(L),
        ae && setTimeout( () => ae.focus())
    }
    ;
    S.useEffect( () => () => window.clearTimeout(k.current), []),
    mce();
    const ee = S.useCallback(D => M.current === O.current?.side && sue(D, O.current?.area), []);
    return v.jsx($ce, {
        scope: n,
        searchRef: I,
        onItemEnter: S.useCallback(D => {
            ee(D) && D.preventDefault()
        }
        , [ee]),
        onItemLeave: S.useCallback(D => {
            ee(D) || (A.current?.focus(),
            w(null))
        }
        , [ee]),
        onTriggerLeave: S.useCallback(D => {
            ee(D) && D.preventDefault()
        }
        , [ee]),
        pointerGraceTimerRef: N,
        onPointerGraceIntentChange: S.useCallback(D => {
            O.current = D
        }
        , []),
        children: v.jsx($, {
            ...J,
            children: v.jsx(Wh, {
                asChild: !0,
                trapped: i,
                onMountAutoFocus: Ee(s, D => {
                    D.preventDefault(),
                    A.current?.focus({
                        preventScroll: !0
                    })
                }
                ),
                onUnmountAutoFocus: o,
                children: v.jsx($N, {
                    asChild: !0,
                    disableOutsidePointerEvents: a,
                    onEscapeKeyDown: c,
                    onPointerDownOutside: u,
                    onFocusOutside: h,
                    onInteractOutside: d,
                    onDismiss: f,
                    children: v.jsx(rN, {
                        asChild: !0,
                        ...y,
                        dir: p.dir,
                        orientation: "vertical",
                        loop: r,
                        currentTabStopId: E,
                        onCurrentTabStopIdChange: w,
                        onEntryFocus: Ee(l, D => {
                            p.isUsingKeyboardRef.current || D.preventDefault()
                        }
                        ),
                        preventScrollOnEntryFocus: !0,
                        children: v.jsx(dm, {
                            role: "menu",
                            "aria-orientation": "vertical",
                            "data-state": yM(m.open),
                            "data-radix-menu-content": "",
                            dir: p.dir,
                            ...b,
                            ..._,
                            ref: C,
                            style: {
                                outline: "none",
                                ..._.style
                            },
                            onKeyDown: Ee(_.onKeyDown, D => {
                                const z = D.target.closest("[data-radix-menu-content]") === D.currentTarget
                                  , V = D.ctrlKey || D.altKey || D.metaKey
                                  , B = D.key.length === 1;
                                z && (D.key === "Tab" && D.preventDefault(),
                                !V && B && Q(D.key));
                                const Z = A.current;
                                if (D.target !== Z || !Oce.includes(D.key))
                                    return;
                                D.preventDefault();
                                const ae = x().filter(G => !G.disabled).map(G => G.ref.current);
                                QN.includes(D.key) && ae.reverse(),
                                tue(ae)
                            }
                            ),
                            onBlur: Ee(t.onBlur, D => {
                                D.currentTarget.contains(D.target) || (window.clearTimeout(k.current),
                                I.current = "")
                            }
                            ),
                            onPointerMove: Ee(t.onPointerMove, $u(D => {
                                const L = D.target
                                  , z = H.current !== D.clientX;
                                if (D.currentTarget.contains(L) && z) {
                                    const V = D.clientX > H.current ? "right" : "left";
                                    M.current = V,
                                    H.current = D.clientX
                                }
                            }
                            ))
                        })
                    })
                })
            })
        })
    })
}
);
rM.displayName = Lr;
var Gce = "MenuGroup"
  , F1 = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t;
    return v.jsx(We.div, {
        role: "group",
        ...r,
        ref: e
    })
}
);
F1.displayName = Gce;
var qce = "MenuLabel"
  , iM = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t;
    return v.jsx(We.div, {
        ...r,
        ref: e
    })
}
);
iM.displayName = qce;
var Pp = "MenuItem"
  , WC = "menu.itemSelect"
  , ag = S.forwardRef( (t, e) => {
    const {disabled: n=!1, onSelect: r, ...i} = t
      , s = S.useRef(null)
      , o = ed(Pp, t.__scopeMenu)
      , a = M1(Pp, t.__scopeMenu)
      , l = rt(e, s)
      , c = S.useRef(!1)
      , u = () => {
        const h = s.current;
        if (!n && h) {
            const d = new CustomEvent(WC,{
                bubbles: !0,
                cancelable: !0
            });
            h.addEventListener(WC, f => r?.(f), {
                once: !0
            }),
            am(h, d),
            d.defaultPrevented ? c.current = !1 : o.onClose()
        }
    }
    ;
    return v.jsx(sM, {
        ...i,
        ref: l,
        disabled: n,
        onClick: Ee(t.onClick, u),
        onPointerDown: h => {
            t.onPointerDown?.(h),
            c.current = !0
        }
        ,
        onPointerUp: Ee(t.onPointerUp, h => {
            c.current || h.currentTarget?.click()
        }
        ),
        onKeyDown: Ee(t.onKeyDown, h => {
            const d = a.searchRef.current !== "";
            n || d && h.key === " " || Sb.includes(h.key) && (h.currentTarget.click(),
            h.preventDefault())
        }
        )
    })
}
);
ag.displayName = Pp;
var sM = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, disabled: r=!1, textValue: i, ...s} = t
      , o = M1(Pp, n)
      , a = ZN(n)
      , l = S.useRef(null)
      , c = rt(e, l)
      , [u,h] = S.useState(!1)
      , [d,f] = S.useState("");
    return S.useEffect( () => {
        const g = l.current;
        g && f((g.textContent ?? "").trim())
    }
    , [s.children]),
    v.jsx(Vu.ItemSlot, {
        scope: n,
        disabled: r,
        textValue: i ?? d,
        children: v.jsx(iN, {
            asChild: !0,
            ...a,
            focusable: !r,
            children: v.jsx(We.div, {
                role: "menuitem",
                "data-highlighted": u ? "" : void 0,
                "aria-disabled": r || void 0,
                "data-disabled": r ? "" : void 0,
                ...s,
                ref: c,
                onPointerMove: Ee(t.onPointerMove, $u(g => {
                    r ? o.onItemLeave(g) : (o.onItemEnter(g),
                    g.defaultPrevented || g.currentTarget.focus({
                        preventScroll: !0
                    }))
                }
                )),
                onPointerLeave: Ee(t.onPointerLeave, $u(g => o.onItemLeave(g))),
                onFocus: Ee(t.onFocus, () => h(!0)),
                onBlur: Ee(t.onBlur, () => h(!1))
            })
        })
    })
}
)
  , Kce = "MenuCheckboxItem"
  , oM = S.forwardRef( (t, e) => {
    const {checked: n=!1, onCheckedChange: r, ...i} = t;
    return v.jsx(hM, {
        scope: t.__scopeMenu,
        checked: n,
        children: v.jsx(ag, {
            role: "menuitemcheckbox",
            "aria-checked": Dp(n) ? "mixed" : n,
            ...i,
            ref: e,
            "data-state": H1(n),
            onSelect: Ee(i.onSelect, () => r?.(Dp(n) ? !0 : !n), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
oM.displayName = Kce;
var aM = "MenuRadioGroup"
  , [Yce,Xce] = Ca(aM, {
    value: void 0,
    onValueChange: () => {}
})
  , lM = S.forwardRef( (t, e) => {
    const {value: n, onValueChange: r, ...i} = t
      , s = vn(r);
    return v.jsx(Yce, {
        scope: t.__scopeMenu,
        value: n,
        onValueChange: s,
        children: v.jsx(F1, {
            ...i,
            ref: e
        })
    })
}
);
lM.displayName = aM;
var cM = "MenuRadioItem"
  , uM = S.forwardRef( (t, e) => {
    const {value: n, ...r} = t
      , i = Xce(cM, t.__scopeMenu)
      , s = n === i.value;
    return v.jsx(hM, {
        scope: t.__scopeMenu,
        checked: s,
        children: v.jsx(ag, {
            role: "menuitemradio",
            "aria-checked": s,
            ...r,
            ref: e,
            "data-state": H1(s),
            onSelect: Ee(r.onSelect, () => i.onValueChange?.(n), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
uM.displayName = cM;
var j1 = "MenuItemIndicator"
  , [hM,Qce] = Ca(j1, {
    checked: !1
})
  , dM = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, forceMount: r, ...i} = t
      , s = Qce(j1, n);
    return v.jsx(Jh, {
        present: r || Dp(s.checked) || s.checked === !0,
        children: v.jsx(We.span, {
            ...i,
            ref: e,
            "data-state": H1(s.checked)
        })
    })
}
);
dM.displayName = j1;
var Jce = "MenuSeparator"
  , fM = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t;
    return v.jsx(We.div, {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
    })
}
);
fM.displayName = Jce;
var Zce = "MenuArrow"
  , pM = S.forwardRef( (t, e) => {
    const {__scopeMenu: n, ...r} = t
      , i = og(n);
    return v.jsx(fm, {
        ...i,
        ...r,
        ref: e
    })
}
);
pM.displayName = Zce;
var eue = "MenuSub"
  , [uve,mM] = Ca(eue)
  , Dc = "MenuSubTrigger"
  , gM = S.forwardRef( (t, e) => {
    const n = Ta(Dc, t.__scopeMenu)
      , r = ed(Dc, t.__scopeMenu)
      , i = mM(Dc, t.__scopeMenu)
      , s = M1(Dc, t.__scopeMenu)
      , o = S.useRef(null)
      , {pointerGraceTimerRef: a, onPointerGraceIntentChange: l} = s
      , c = {
        __scopeMenu: t.__scopeMenu
    }
      , u = S.useCallback( () => {
        o.current && window.clearTimeout(o.current),
        o.current = null
    }
    , []);
    return S.useEffect( () => u, [u]),
    S.useEffect( () => {
        const h = a.current;
        return () => {
            window.clearTimeout(h),
            l(null)
        }
    }
    , [a, l]),
    v.jsx(O1, {
        asChild: !0,
        ...c,
        children: v.jsx(sM, {
            id: i.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": n.open,
            "aria-controls": i.contentId,
            "data-state": yM(n.open),
            ...t,
            ref: Sh(e, i.onTriggerChange),
            onClick: h => {
                t.onClick?.(h),
                !(t.disabled || h.defaultPrevented) && (h.currentTarget.focus(),
                n.open || n.onOpenChange(!0))
            }
            ,
            onPointerMove: Ee(t.onPointerMove, $u(h => {
                s.onItemEnter(h),
                !h.defaultPrevented && !t.disabled && !n.open && !o.current && (s.onPointerGraceIntentChange(null),
                o.current = window.setTimeout( () => {
                    n.onOpenChange(!0),
                    u()
                }
                , 100))
            }
            )),
            onPointerLeave: Ee(t.onPointerLeave, $u(h => {
                u();
                const d = n.content?.getBoundingClientRect();
                if (d) {
                    const f = n.content?.dataset.side
                      , g = f === "right"
                      , _ = g ? -5 : 5
                      , m = d[g ? "left" : "right"]
                      , p = d[g ? "right" : "left"];
                    s.onPointerGraceIntentChange({
                        area: [{
                            x: h.clientX + _,
                            y: h.clientY
                        }, {
                            x: m,
                            y: d.top
                        }, {
                            x: p,
                            y: d.top
                        }, {
                            x: p,
                            y: d.bottom
                        }, {
                            x: m,
                            y: d.bottom
                        }],
                        side: f
                    }),
                    window.clearTimeout(a.current),
                    a.current = window.setTimeout( () => s.onPointerGraceIntentChange(null), 300)
                } else {
                    if (s.onTriggerLeave(h),
                    h.defaultPrevented)
                        return;
                    s.onPointerGraceIntentChange(null)
                }
            }
            )),
            onKeyDown: Ee(t.onKeyDown, h => {
                const d = s.searchRef.current !== "";
                t.disabled || d && h.key === " " || Nce[r.dir].includes(h.key) && (n.onOpenChange(!0),
                n.content?.focus(),
                h.preventDefault())
            }
            )
        })
    })
}
);
gM.displayName = Dc;
var _M = "MenuSubContent"
  , bM = S.forwardRef( (t, e) => {
    const n = tM(Lr, t.__scopeMenu)
      , {forceMount: r=n.forceMount, ...i} = t
      , s = Ta(Lr, t.__scopeMenu)
      , o = ed(Lr, t.__scopeMenu)
      , a = mM(_M, t.__scopeMenu)
      , l = S.useRef(null)
      , c = rt(e, l);
    return v.jsx(Vu.Provider, {
        scope: t.__scopeMenu,
        children: v.jsx(Jh, {
            present: r || s.open,
            children: v.jsx(Vu.Slot, {
                scope: t.__scopeMenu,
                children: v.jsx(B1, {
                    id: a.contentId,
                    "aria-labelledby": a.triggerId,
                    ...i,
                    ref: c,
                    align: "start",
                    side: o.dir === "rtl" ? "left" : "right",
                    disableOutsidePointerEvents: !1,
                    disableOutsideScroll: !1,
                    trapFocus: !1,
                    onOpenAutoFocus: u => {
                        o.isUsingKeyboardRef.current && l.current?.focus(),
                        u.preventDefault()
                    }
                    ,
                    onCloseAutoFocus: u => u.preventDefault(),
                    onFocusOutside: Ee(t.onFocusOutside, u => {
                        u.target !== a.trigger && s.onOpenChange(!1)
                    }
                    ),
                    onEscapeKeyDown: Ee(t.onEscapeKeyDown, u => {
                        o.onClose(),
                        u.preventDefault()
                    }
                    ),
                    onKeyDown: Ee(t.onKeyDown, u => {
                        const h = u.currentTarget.contains(u.target)
                          , d = Mce[o.dir].includes(u.key);
                        h && d && (s.onOpenChange(!1),
                        a.trigger?.focus(),
                        u.preventDefault())
                    }
                    )
                })
            })
        })
    })
}
);
bM.displayName = _M;
function yM(t) {
    return t ? "open" : "closed"
}
function Dp(t) {
    return t === "indeterminate"
}
function H1(t) {
    return Dp(t) ? "indeterminate" : t ? "checked" : "unchecked"
}
function tue(t) {
    const e = document.activeElement;
    for (const n of t)
        if (n === e || (n.focus(),
        document.activeElement !== e))
            return
}
function nue(t, e) {
    return t.map( (n, r) => t[(e + r) % t.length])
}
function rue(t, e, n) {
    const i = e.length > 1 && Array.from(e).every(c => c === e[0]) ? e[0] : e
      , s = n ? t.indexOf(n) : -1;
    let o = nue(t, Math.max(s, 0));
    i.length === 1 && (o = o.filter(c => c !== n));
    const l = o.find(c => c.toLowerCase().startsWith(i.toLowerCase()));
    return l !== n ? l : void 0
}
function iue(t, e) {
    const {x: n, y: r} = t;
    let i = !1;
    for (let s = 0, o = e.length - 1; s < e.length; o = s++) {
        const a = e[s].x
          , l = e[s].y
          , c = e[o].x
          , u = e[o].y;
        l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (i = !i)
    }
    return i
}
function sue(t, e) {
    if (!e)
        return !1;
    const n = {
        x: t.clientX,
        y: t.clientY
    };
    return iue(n, e)
}
function $u(t) {
    return e => e.pointerType === "mouse" ? t(e) : void 0
}
var oue = eM
  , aue = O1
  , lue = nM
  , cue = rM
  , uue = F1
  , hue = iM
  , due = ag
  , fue = oM
  , pue = lM
  , mue = uM
  , gue = dM
  , _ue = fM
  , bue = pM
  , yue = gM
  , vue = bM
  , U1 = "ContextMenu"
  , [xue,hve] = UN(U1, [JN])
  , Gn = JN()
  , [Eue,vM] = xue(U1)
  , xM = t => {
    const {__scopeContextMenu: e, children: n, onOpenChange: r, dir: i, modal: s=!0} = t
      , [o,a] = S.useState(!1)
      , l = Gn(e)
      , c = vn(r)
      , u = S.useCallback(h => {
        a(h),
        c(h)
    }
    , [c]);
    return v.jsx(Eue, {
        scope: e,
        open: o,
        onOpenChange: u,
        modal: s,
        children: v.jsx(oue, {
            ...l,
            dir: i,
            open: o,
            onOpenChange: u,
            modal: s,
            children: n
        })
    })
}
;
xM.displayName = U1;
var EM = "ContextMenuTrigger"
  , SM = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, disabled: r=!1, ...i} = t
      , s = vM(EM, n)
      , o = Gn(n)
      , a = S.useRef({
        x: 0,
        y: 0
    })
      , l = S.useRef({
        getBoundingClientRect: () => DOMRect.fromRect({
            width: 0,
            height: 0,
            ...a.current
        })
    })
      , c = S.useRef(0)
      , u = S.useCallback( () => window.clearTimeout(c.current), [])
      , h = d => {
        a.current = {
            x: d.clientX,
            y: d.clientY
        },
        s.onOpenChange(!0)
    }
    ;
    return S.useEffect( () => u, [u]),
    S.useEffect( () => void (r && u()), [r, u]),
    v.jsxs(v.Fragment, {
        children: [v.jsx(aue, {
            ...o,
            virtualRef: l
        }), v.jsx(We.span, {
            "data-state": s.open ? "open" : "closed",
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: e,
            style: {
                WebkitTouchCallout: "none",
                ...t.style
            },
            onContextMenu: r ? t.onContextMenu : Ee(t.onContextMenu, d => {
                u(),
                h(d),
                d.preventDefault()
            }
            ),
            onPointerDown: r ? t.onPointerDown : Ee(t.onPointerDown, Md(d => {
                u(),
                c.current = window.setTimeout( () => h(d), 700)
            }
            )),
            onPointerMove: r ? t.onPointerMove : Ee(t.onPointerMove, Md(u)),
            onPointerCancel: r ? t.onPointerCancel : Ee(t.onPointerCancel, Md(u)),
            onPointerUp: r ? t.onPointerUp : Ee(t.onPointerUp, Md(u))
        })]
    })
}
);
SM.displayName = EM;
var Sue = "ContextMenuPortal"
  , wM = t => {
    const {__scopeContextMenu: e, ...n} = t
      , r = Gn(e);
    return v.jsx(lue, {
        ...r,
        ...n
    })
}
;
wM.displayName = Sue;
var CM = "ContextMenuContent"
  , TM = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = vM(CM, n)
      , s = Gn(n)
      , o = S.useRef(!1);
    return v.jsx(cue, {
        ...s,
        ...r,
        ref: e,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: a => {
            t.onCloseAutoFocus?.(a),
            !a.defaultPrevented && o.current && a.preventDefault(),
            o.current = !1
        }
        ,
        onInteractOutside: a => {
            t.onInteractOutside?.(a),
            !a.defaultPrevented && !i.modal && (o.current = !0)
        }
        ,
        style: {
            ...t.style,
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
TM.displayName = CM;
var wue = "ContextMenuGroup"
  , AM = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(uue, {
        ...i,
        ...r,
        ref: e
    })
}
);
AM.displayName = wue;
var Cue = "ContextMenuLabel"
  , Tue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(hue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Tue.displayName = Cue;
var Aue = "ContextMenuItem"
  , kM = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(due, {
        ...i,
        ...r,
        ref: e
    })
}
);
kM.displayName = Aue;
var kue = "ContextMenuCheckboxItem"
  , Rue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(fue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Rue.displayName = kue;
var Iue = "ContextMenuRadioGroup"
  , Pue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(pue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Pue.displayName = Iue;
var Due = "ContextMenuRadioItem"
  , Lue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(mue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Lue.displayName = Due;
var Oue = "ContextMenuItemIndicator"
  , Nue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(gue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Nue.displayName = Oue;
var Mue = "ContextMenuSeparator"
  , Bue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(_ue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Bue.displayName = Mue;
var Fue = "ContextMenuArrow"
  , jue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(bue, {
        ...i,
        ...r,
        ref: e
    })
}
);
jue.displayName = Fue;
var Hue = "ContextMenuSubTrigger"
  , Uue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(yue, {
        ...i,
        ...r,
        ref: e
    })
}
);
Uue.displayName = Hue;
var Vue = "ContextMenuSubContent"
  , $ue = S.forwardRef( (t, e) => {
    const {__scopeContextMenu: n, ...r} = t
      , i = Gn(n);
    return v.jsx(vue, {
        ...i,
        ...r,
        ref: e,
        style: {
            ...t.style,
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
$ue.displayName = Vue;
function Md(t) {
    return e => e.pointerType !== "mouse" ? t(e) : void 0
}
var zue = xM
  , Wue = SM
  , Gue = wM
  , que = TM
  , Kue = AM
  , Yue = kM;
const RM = S.memo( ({node: t, nodeIsSelected: e, nodeIsCollapsed: n, onFileChange: r, onExpandNode: i, onClipboard: s, clipboardSelection: o, position: a="before", triggerProps: l, children: c}) => {
    const u = Ie(me.currentView)
      , [h,d] = S.useState("idle")
      , f = S.useRef(null);
    if (!r)
        return c;
    const g = () => navigator.clipboard.writeText(t?.fullPath ?? jt)
      , _ = () => navigator.clipboard.writeText(t ? Hn.relative(jt, t.fullPath) : "")
      , m = () => d("rename")
      , p = () => (d("add_file"),
    i?.())
      , b = () => (d("add_folder"),
    i?.())
      , y = Q => s?.({
        type: "cut",
        name: Q.fullPath,
        kind: Q.kind
    })
      , x = Q => s?.({
        type: "copy",
        name: Q.fullPath,
        kind: Q.kind
    })
      , E = async Q => {
        await r(Q).catch(GC),
        d("idle")
    }
      , w = () => {
        t && E({
            method: "remove",
            path: t.fullPath,
            type: t.kind
        })
    }
      , A = async () => {
        if (!o || !s)
            return;
        const Q = t?.fullPath ?? jt
          , ee = t?.kind === "file" ? Q.slice(0, Q.lastIndexOf("/")) : Q
          , D = o.name.slice(1 + o.name.lastIndexOf("/"));
        await r({
            method: o.type,
            type: o.kind,
            oldPath: o.name,
            newPath: `${ee}/${D}`
        }).catch(GC),
        s(void 0),
        i?.()
    }
      , C = Q => {
        const ee = Q.currentTarget.value;
        if (ee.trim() === "") {
            d("idle");
            return
        }
        k(ee)
    }
      , k = Q => {
        if (h === "idle")
            return;
        if (d("idle"),
        !Q) {
            ct.error("File name cannot be empty");
            return
        }
        if (h === "rename") {
            if (!t || Q === t.name)
                return;
            const D = t.fullPath.slice(0, t.fullPath.lastIndexOf("/"));
            E({
                oldPath: t.fullPath,
                newPath: `${D}/${Q}`,
                type: t.kind,
                method: "rename"
            });
            return
        }
        const ee = t?.kind === "file" ? t.fullPath.slice(0, t.fullPath.lastIndexOf("/")) : t?.kind === "folder" ? t.fullPath : jt;
        E({
            path: `${ee}/${Q}`,
            type: h === "add_file" ? "file" : "folder",
            method: "add"
        })
    }
      , I = Q => {
        Q.key === "Enter" && k(Q.currentTarget.value),
        Q.key === "Escape" && (Q.stopPropagation(),
        d("idle"))
    }
      , N = Q => {
        h !== "idle" && f.current && (Q.preventDefault(),
        f.current.focus())
    }
      , O = v.jsx(Wue, {
        asChild: !0,
        children: v.jsx("div", {
            ...l,
            children: c
        })
    })
      , M = u === "code"
      , H = !!t;
    let $;
    h === "add_file" || h === "rename" && t?.kind === "file" ? $ = "i-ph:file-duotone" : h === "add_folder" || h === "rename" && n ? $ = "i-ph:caret-right" : $ = "i-ph:caret-down";
    let J = t?.depth ?? 0;
    return t && t.kind === "folder" && h !== "rename" && (J += 1),
    v.jsxs(zue, {
        children: [a === "before" && h !== "rename" && O, h !== "idle" && v.jsxs("div", {
            className: be("group flex items-center gap-1.5 border-2 border-solid border-transparent", {
                "bg-transparent text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive hover:bg-bolt-elements-item-backgroundActive": !e || h !== "rename",
                "bg-bolt-elements-item-backgroundAccent text-bolt-elements-item-contentAccent": e && h === "rename"
            }),
            style: PM(J),
            children: [v.jsx("div", {
                className: `scale-98 shrink-0 ${$}`
            }), v.jsx("input", {
                ref: f,
                defaultValue: h === "rename" ? t?.name : void 0,
                spellCheck: "false",
                autoComplete: "off",
                "data-1p-ignore": !0,
                type: "text",
                onBlur: C,
                onKeyUp: I,
                className: be("text-bolt-elements-text-primary border-none w-full py-0.5 outline outline-1", {
                    "outline-bolt-elements-item-outlineActive group-hover:bg-transparent bg-bolt-elements-item-backgroundActive": !e || h !== "rename",
                    "outline-bolt-elements-item-contentAccent bg-transparent": e && h === "rename"
                })
            })]
        }), a === "after" && h !== "rename" && O, v.jsx(Gue, {
            children: v.jsxs(que, {
                onCloseAutoFocus: N,
                className: be("border border-bolt-elements-borderColor rounded-md", "z-context-menu bg-bolt-elements-background-depth-1 dark:bg-bolt-elements-background-depth-2 w-72", "data-[state=open]:animate-in animate-duration-100", "data-[state=open]:fade-in-0", "data-[state=open]:zoom-in-98", {
                    "w-56": H,
                    "w-48": !t,
                    hidden: !M
                }),
                children: [v.jsxs(dc, {
                    children: [v.jsx($r, {
                        icon: H,
                        onClick: p,
                        children: "New file..."
                    }), v.jsx($r, {
                        icon: H,
                        onClick: b,
                        children: "New folder..."
                    })]
                }), t && v.jsxs(dc, {
                    children: [v.jsx(Xue, {
                        node: t
                    }), v.jsx(Que, {
                        node: t
                    })]
                }), (t || o) && v.jsxs(dc, {
                    children: [t && v.jsx($r, {
                        icon: H,
                        onClick: () => y(t),
                        children: "Cut"
                    }), t && v.jsx($r, {
                        icon: H,
                        onClick: () => x(t),
                        children: "Copy"
                    }), o && v.jsx($r, {
                        icon: H,
                        onClick: A,
                        children: "Paste"
                    })]
                }), v.jsxs(dc, {
                    last: !t,
                    children: [v.jsx($r, {
                        icon: H,
                        onClick: g,
                        children: "Copy path"
                    }), v.jsx($r, {
                        icon: H,
                        onClick: _,
                        children: "Copy relative path"
                    })]
                }), t && v.jsxs(dc, {
                    last: !0,
                    children: [v.jsx($r, {
                        icon: H,
                        onClick: m,
                        children: "Rename..."
                    }), v.jsx($r, {
                        icon: H,
                        onClick: w,
                        children: "Delete"
                    })]
                })]
            })
        })]
    })
}
);
function GC(t) {
    const e = t instanceof Error ? t.message : String(t);
    t instanceof Er ? ct.error(e) : (pa.error(e),
    ct.error("Unknown error"))
}
function dc({children: t, last: e}) {
    return v.jsx(Kue, {
        className: be("p-1", {
            "border-b-px border-solid border-bolt-elements-borderColor": !e
        }),
        children: t
    })
}
function $r({icon: t, children: e, ...n}) {
    return v.jsxs(Yue, {
        ...n,
        className: "flex items-center gap-2 px-2 py-1.5 outline-0 text-sm text-bolt-elements-textPrimary cursor-pointer ws-nowrap text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive hover:bg-bolt-elements-item-backgroundActive rounded-md",
        children: [t && v.jsx("span", {
            className: `size-4 ${t || ""} shrink-0`
        }), v.jsx("span", {
            children: e
        })]
    })
}
const Xue = S.memo( ({node: t}) => {
    const e = Ie(me.files)
      , n = Ie(me.targetedFiles)
      , r = IM(e, t)
      , i = r.length > 0 && r.every(a => a in n)
      , s = () => {
        const a = t.kind === "folder" ? !i : !t.dirent.isTargeted;
        me.setFileOrFolderTarget(t.fullPath, a)
    }
    ;
    let o;
    return t.kind === "folder" ? o = i ? "Untarget all" : "Target all" : t.dirent.isTargeted ? o = "Untarget file" : o = "Target file",
    v.jsx($r, {
        onClick: s,
        icon: "i-ph:crosshair",
        children: o
    })
}
)
  , Que = S.memo( ({node: t}) => {
    const e = Ie(me.files)
      , n = Ie(me.lockedFiles)
      , r = IM(e, t)
      , i = r.length > 0 && r.every(a => a in n)
      , s = () => {
        const a = t.kind === "folder" ? !i : !t.dirent.isLocked;
        me.setFileOrFolderLocked(t.fullPath, a)
    }
    ;
    let o;
    return t.kind === "folder" ? o = i ? "Unlock all" : "Lock all" : t.dirent.isLocked ? o = "Unlock file" : o = "Lock file",
    v.jsx($r, {
        onClick: s,
        icon: "i-ph:lock-simple-open",
        children: o
    })
}
);
function IM(t, e) {
    return e.kind === "file" ? [] : Object.keys(t).filter(n => t[n] && t[n].type === "file" && n.startsWith(`${e.fullPath}/`))
}
function PM(t) {
    return {
        paddingLeft: `${6 + t * 8}px`
    }
}
function DM({node: t, selected: e, collapsed: n, isSelectedAsCut: r, onClick: i, provideQuickActions: s, renderContent: o}) {
    return v.jsxs("button", {
        className: be("group flex items-center gap-1.5 w-full pr-2 border-2 border-transparent text-faded py-0.5", {
            "bg-transparent text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive hover:bg-bolt-elements-item-backgroundActive": !e,
            "bg-bolt-elements-item-backgroundAccent text-bolt-elements-item-contentAccent": e,
            "hover:text-bolt-elements-item-contentDefault": r && !e
        }),
        onClick: i,
        style: PM(t.depth),
        children: [v.jsx("div", {
            className: be("shrink-0 scale-98", {
                "i-ph:file-duotone": t.kind === "file",
                "group-hover:text-bolt-elements-item-contentActive": t.kind === "file" && !e && !r,
                "i-ph:caret-right": t.kind === "folder" && n,
                "i-ph:caret-down": t.kind === "folder" && !n,
                "opacity-50 ": r
            })
        }), v.jsx("div", {
            className: "truncate w-full text-left",
            children: v.jsx("div", {
                className: be("flex items-center", {
                    "group-hover:text-bolt-elements-item-contentActive": !e && !r
                }),
                children: o ? o(t) : v.jsxs(v.Fragment, {
                    children: [v.jsx("div", {
                        className: be("flex-1 truncate pr-2", {
                            "opacity-50 ": r
                        }),
                        children: t.name
                    }), s?.(t)]
                })
            })
        })]
    })
}
function Jue(t, e) {
    const n = t.fullPath.split("/")
      , r = e.fullPath.split("/")
      , i = Math.min(n.length, r.length);
    for (let s = 0; s < i; s++) {
        const o = qC(t, n, s)
          , a = qC(e, r, s);
        if (o.type !== a.type)
            return o.type === "folder" ? -1 : 1;
        const l = o.segment.localeCompare(a.segment);
        if (l !== 0)
            return l
    }
    return t.fullPath.localeCompare(e.fullPath)
}
function qC(t, e, n) {
    const r = n === e.length - 1;
    return {
        segment: e[n],
        type: r ? t.kind : "folder"
    }
}
function LM(t, e, n, r) {
    const i = S.useRef()
      , [s,o] = S.useState( () => e ? new Set(t.filter(c => c.kind === "folder").map(c => c.fullPath)) : new Set);
    S.useEffect( () => {
        if (e && !r) {
            o(new Set(t.filter(c => c.kind === "folder").map(c => c.fullPath)));
            return
        }
        o(c => {
            const u = new Set
              , h = new Set(i.current?.filter(d => d.kind === "folder").map(d => d.fullPath));
            for (const d of t)
                if (d.kind === "folder") {
                    if (n?.startsWith(d.fullPath + "/"))
                        continue;
                    (c.has(d.fullPath) || e && !h.has(d.fullPath)) && u.add(d.fullPath)
                }
            return u
        }
        )
    }
    , [t, e, n, r]);
    const a = S.useMemo( () => {
        const c = [];
        let u = Number.MAX_SAFE_INTEGER;
        for (const h of t) {
            const d = h.depth;
            u === d && (u = Number.MAX_SAFE_INTEGER),
            s.has(h.fullPath) && (u = Math.min(u, d)),
            !(u < d) && c.push(h)
        }
        return c
    }
    , [t, s]);
    return S.useEffect( () => {
        i.current = t
    }
    , [t]),
    {
        collapsedFolders: s,
        filteredFileList: a,
        toggleCollapseState: c => {
            o(u => {
                const h = new Set(u);
                return h.has(c) ? h.delete(c) : h.add(c),
                h
            }
            )
        }
    }
}
const Zue = [/\/node_modules\//, /\/\.next/, /\/\.nuxt/, /\/\.astro/, /\/\.contentlayer/, /\/\.svelte-kit/, /\/\.vitepress/, /\/\.vscode/, /\/\.stackblitz/, /\/\.bolt/, /\/\.codesandbox/]
  , OM = S.memo( ({files: t={}, onFileSelect: e, onFileChange: n, selectedFile: r, rootFolder: i, hideRoot: s=!1, collapsed: o=!1, preserveCollapsedState: a=!1, allowFolderSelection: l=!1, hiddenFiles: c, className: u, provideQuickActions: h}) => {
    _r.trace("FileTree");
    const [d,f] = S.useState()
      , g = S.useMemo( () => [...Zue, ...c ?? []], [c])
      , _ = S.useMemo( () => the(t, i, s, g), [t, i, s, g])
      , {collapsedFolders: m, toggleCollapseState: p, filteredFileList: b} = LM(_, o, r, a);
    function y(x) {
        x.key === "Escape" && f(void 0)
    }
    return v.jsxs("div", {
        className: be("text-sm flex flex-col", u),
        onKeyUp: y,
        children: [b.map(x => v.jsx(ehe, {
            node: x,
            isSelected: x.kind === "folder" ? l && r === x.fullPath : r === x.fullPath,
            isCollapsed: x.kind === "folder" && m.has(x.fullPath),
            onClick: () => x.kind === "file" ? e?.(x.fullPath) : p(x.fullPath),
            onFileChange: n,
            onExpand: () => p(x.fullPath),
            setClipboard: f,
            clipboardSelection: d,
            provideQuickActions: h
        }, x.id)), v.jsx(RM, {
            position: "after",
            onFileChange: n,
            onClipboard: f,
            clipboardSelection: d,
            triggerProps: {
                className: "grow-1 outline-0",
                onKeyUp: y,
                tabIndex: 0
            }
        })]
    })
}
);
function ehe({node: t, isSelected: e, isCollapsed: n, onClick: r, onFileChange: i, onExpand: s, setClipboard: o, clipboardSelection: a, provideQuickActions: l}) {
    return v.jsx(RM, {
        node: t,
        nodeIsSelected: e,
        onFileChange: i,
        clipboardSelection: a,
        onClipboard: o,
        nodeIsCollapsed: n,
        onExpandNode: () => n && s(),
        children: v.jsx(DM, {
            node: t,
            selected: e,
            provideQuickActions: l,
            isSelectedAsCut: a?.type === "cut" && a?.name === t.fullPath,
            collapsed: n,
            onClick: r
        })
    })
}
function the(t, e="/", n, r) {
    const i = [];
    let s = 0;
    e === "/" && !n && (s = 1,
    i.push({
        kind: "folder",
        name: "/",
        depth: 0,
        id: 0,
        fullPath: "/"
    })),
    e.endsWith("/") || (e += "/");
    for (const [o,a] of Object.entries(t)) {
        const l = o.slice(e.length).split("/")
          , c = l.at(-1)
          , u = l.length - 1;
        !c || !a || nhe(o, c, r) || !o.startsWith(e) || n && o === e || i.push({
            ...a.type === "file" ? {
                kind: a.type,
                dirent: a
            } : {
                kind: a.type,
                dirent: a
            },
            id: i.length,
            name: c,
            fullPath: o,
            depth: u + s
        })
    }
    return i.sort(Jue)
}
function nhe(t, e, n) {
    return n.some(r => typeof r == "string" ? e === r : r.test(t))
}
const rhe = new RegExp(`^${jt.split("/").slice(0, -1).join("/").replaceAll("/", "\\/")}/`)
  , ihe = {
    open: {
        y: 0,
        opacity: 1,
        transition: {
            duration: .15,
            ease: Ft
        }
    },
    close: {
        y: 6,
        opacity: 0,
        transition: {
            duration: .15,
            ease: Ft
        }
    }
}
  , she = S.memo( ({files: t, pathSegments: e=[], onFileSelect: n}) => {
    _r.trace("FileBreadcrumb");
    const [r,i] = S.useState(null)
      , s = S.useRef(null)
      , o = S.useRef([])
      , a = l => {
        i(c => c === l ? null : l)
    }
    ;
    return S.useEffect( () => {
        const l = c => {
            r !== null && !s.current?.contains(c.target) && !o.current.some(u => u?.contains(c.target)) && i(null)
        }
        ;
        return document.addEventListener("mousedown", l),
        () => {
            document.removeEventListener("mousedown", l)
        }
    }
    , [r]),
    t === void 0 || e.length === 0 ? null : v.jsx("div", {
        className: "flex",
        children: e.map( (l, c) => {
            const u = c === e.length - 1
              , h = e.slice(0, c).join("/");
            if (!rhe.test(h))
                return null;
            const d = r === c;
            return v.jsx("div", {
                className: "relative flex items-center",
                children: v.jsxs(MN, {
                    open: d,
                    modal: !1,
                    children: [v.jsx(BN, {
                        asChild: !0,
                        children: v.jsxs("span", {
                            ref: f => o.current[c] = f,
                            className: be("flex items-center gap-1.5 cursor-pointer shrink-0", {
                                "text-bolt-elements-textTertiary hover:text-bolt-elements-textPrimary": !d,
                                "text-bolt-elements-textPrimary underline": d,
                                "pr-4": u
                            }),
                            onClick: () => a(c),
                            children: [u && v.jsx("div", {
                                className: "i-ph:file-duotone"
                            }), l]
                        })
                    }), c > 0 && !u && v.jsx("span", {
                        className: "i-ph:caret-right inline-block mx-1"
                    }), v.jsx(hs, {
                        children: d && v.jsx(FN, {
                            children: v.jsx(jN, {
                                className: "z-file-tree-breadcrumb",
                                asChild: !0,
                                align: "start",
                                side: "bottom",
                                avoidCollisions: !1,
                                children: v.jsxs(It.div, {
                                    ref: s,
                                    initial: "close",
                                    animate: "open",
                                    exit: "close",
                                    variants: ihe,
                                    children: [v.jsx("div", {
                                        className: "rounded-lg overflow-hidden",
                                        children: v.jsx("div", {
                                            className: "max-h-[50vh] min-w-[300px] overflow-auto bg-bolt-elements-background-depth-1 border border-bolt-elements-borderColor shadow-sm rounded-lg",
                                            children: v.jsx(OM, {
                                                files: t,
                                                hideRoot: !0,
                                                rootFolder: h,
                                                collapsed: !0,
                                                allowFolderSelection: !0,
                                                selectedFile: `${h}/${l}`,
                                                onFileSelect: f => {
                                                    i(null),
                                                    n?.(f)
                                                }
                                            })
                                        })
                                    }), v.jsx(HN, {
                                        className: "fill-bolt-elements-borderColor"
                                    })]
                                })
                            })
                        })
                    })]
                })
            }, c)
        }
        )
    })
}
)
  , V1 = S.memo( ({className: t, children: e}) => v.jsx("div", {
    className: be("flex items-center gap-2 bg-bolt-elements-background-depth-2 text-bolt-elements-textSecondary border-b border-bolt-elements-borderColor px-4 py-1 min-h-[34px] text-sm", t),
    children: e
}))
  , KC = {
    ease: Ft
}
  , ohe = S.memo( ({unsavedFiles: t, selectedFile: e, onFileSelect: n, ...r}) => {
    const i = Ie(me.currentFileTreeView)
      , s = Ie(me.lockedFiles)
      , o = Ie(me.targetedFiles)
      , a = Object.values(s).filter(_ => _?.isLocked).length
      , l = Object.values(o).filter(_ => _?.isTargeted).length
      , c = S.useMemo( () => {
        const _ = new Set;
        for (const m of Object.keys(s).concat(Object.keys(o))) {
            let p = Hn.dirname(m);
            for (; p !== jt; )
                _.add(p),
                p = Hn.dirname(p)
        }
        return _
    }
    , [s, o])
      , u = l > 0 ? "targeted" : a > 0 ? "locked" : "none"
      , h = S.useCallback( () => me.currentFileTreeView.set("files"), [])
      , d = S.useCallback( () => me.currentFileTreeView.set("focused"), [])
      , f = S.useCallback(_ => {
        me.removeFromTargetOrLockedFiles(_.fullPath),
        a + l === 1 && h()
    }
    , [h, a, l]);
    function g(_) {
        const m = o[_.fullPath]?.isTargeted
          , p = s[_.fullPath]?.isLocked
          , b = c.has(_.fullPath)
          , y = m || p || b
          , x = _.fullPath === e
          , E = t?.has(_.fullPath);
        return v.jsxs(v.Fragment, {
            children: [E && v.jsx("span", {
                className: "i-ph:circle-fill scale-68 shrink-0 text-orange-500"
            }), y && v.jsx(uhe, {
                isFileSelected: x,
                isFocused: m || p || b,
                isClickable: m || p,
                className: be({
                    "i-ph:crosshair": m,
                    "i-ph:dot-outline-fill": b,
                    "i-ph:lock-simple": p
                }),
                onClick: w => {
                    w.stopPropagation(),
                    (m || p) && me.setFileOrFolderTarget(_.fullPath, !1)
                }
            })]
        })
    }
    return v.jsx("div", {
        className: "flex flex-col border-r border-bolt-elements-borderColor overflow-hidden h-full",
        children: v.jsxs("div", {
            className: "relative h-full",
            children: [v.jsxs(It.div, {
                className: "absolute inset-0 flex flex-col",
                transition: KC,
                initial: {
                    x: i === "files" ? 0 : "-100%"
                },
                animate: {
                    x: i === "files" ? 0 : "-100%"
                },
                children: [v.jsx(ahe, {
                    targetedFileCount: l,
                    lockedFileCount: a,
                    onIconClick: d
                }), v.jsx(OM, {
                    className: "flex-grow overflow-y-auto",
                    hideRoot: !0,
                    collapsed: !0,
                    preserveCollapsedState: !0,
                    provideQuickActions: g,
                    selectedFile: e,
                    onFileSelect: n,
                    ...r
                })]
            }), v.jsxs(It.div, {
                className: "absolute inset-0 flex flex-col",
                transition: KC,
                initial: {
                    x: i === "focused" ? 0 : "100%"
                },
                animate: {
                    x: i === "focused" ? 0 : "100%"
                },
                children: [v.jsx(lhe, {
                    type: u,
                    onClick: h
                }), v.jsx(che, {
                    type: u,
                    files: l > 0 ? o : s,
                    selectedFile: e,
                    onFileSelect: n,
                    clearFocused: f
                })]
            })]
        })
    })
}
)
  , ahe = S.memo( ({lockedFileCount: t, targetedFileCount: e, onIconClick: n}) => v.jsxs(V1, {
    className: "px-2 gap-0.5",
    children: [v.jsx("div", {
        className: "i-ph:tree-structure-duotone shrink-0 mr-1.5"
    }), "Files", v.jsx("div", {
        className: "flex-grow-1"
    }), t > 0 && e > 0 ? v.jsxs(tn, {
        className: "text-xs flex items-center relative -right-1 px-1.5 py-0.5",
        onClick: n,
        children: [e, v.jsx("span", {
            className: "size-4 mx-1 i-ph:crosshair"
        }), t, v.jsx("span", {
            className: "size-4 ml-1 i-ph:lock-simple"
        })]
    }) : e > 0 ? v.jsxs(tn, {
        className: "text-xs flex items-center relative -right-1 px-1.5 py-0.5",
        onClick: n,
        children: [e, v.jsx("span", {
            className: "size-4 ml-1 i-ph:crosshair"
        })]
    }) : t > 0 ? v.jsxs(tn, {
        className: "text-xs flex items-center relative -right-1 px-1.5 py-0.5",
        onClick: n,
        children: [t, v.jsx("span", {
            className: "size-4 ml-1 i-ph:lock-simple"
        })]
    }) : null]
}))
  , lhe = S.memo( ({type: t, onClick: e}) => {
    function n() {
        me.resetAllLockedTargetedFiles(),
        e()
    }
    return v.jsxs(V1, {
        className: "px-2 gap-0.5",
        children: [v.jsx(tn, {
            className: "flex items-center -ml-0.5 mr-0.5 -my-0.5 px-1",
            onClick: e,
            children: v.jsx("div", {
                className: "i-ph:arrow-left-bold"
            })
        }), v.jsxs("div", {
            className: "shrink-0",
            children: [t === "locked" ? "Locked" : "Targeted", " files"]
        }), v.jsx("div", {
            className: "flex-grow-1"
        }), v.jsx(tn, {
            className: "text-xs flex items-center shrink-0 relative -my-0.5 px-1.5",
            onClick: n,
            children: "Reset All"
        })]
    })
}
)
  , che = S.memo( ({type: t, files: e, selectedFile: n, onFileSelect: r, clearFocused: i}) => {
    const s = S.useMemo( () => {
        const u = [];
        for (const [h,d] of Object.entries(e)) {
            if (!d)
                continue;
            const f = t === "locked" && d.isLocked || t === "targeted" && d.isTargeted ? 0 : 1
              , g = h.slice(h.lastIndexOf("/") + 1);
            (f !== 1 || d.type !== "folder") && u.push({
                ...d.type === "file" ? {
                    kind: d.type,
                    dirent: d
                } : {
                    kind: d.type,
                    dirent: d
                },
                id: u.length,
                depth: f,
                fullPath: h,
                name: g
            })
        }
        return u
    }
    , [e, t])
      , {toggleCollapseState: o, collapsedFolders: a, filteredFileList: l} = LM(s, !0, n, !0);
    function c(u) {
        const h = u.fullPath.slice(jt.length + 1, u.fullPath.lastIndexOf("/"))
          , d = n === u.fullPath;
        return v.jsxs(Vs, {
            children: [v.jsx(qo, {
                asChild: !0,
                children: v.jsx("div", {
                    className: "truncate pr-2",
                    children: u.name
                })
            }), h && v.jsx("div", {
                className: "text-xs truncate flex-1 mr-2 opacity-50",
                children: h
            }), !h && v.jsx("div", {
                className: "flex-grow"
            }), u.depth === 0 && v.jsx("span", {
                onClick: () => i(u),
                className: be("hidden group-hover:block i-ph:x-bold size-3.5", {
                    "text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive": !d,
                    "group-hover:opacity-70 hover:opacity-100!": d
                })
            }), v.jsx(Ko, {
                children: v.jsx(na, {
                    hideArrow: !0,
                    side: "bottom",
                    align: "start",
                    children: u.fullPath
                })
            })]
        })
    }
    return v.jsxs("div", {
        className: "text-sm overflow-y-auto",
        children: [v.jsx("div", {
            className: "p-3 pb-1.5 text-sm text-bolt-elements-textTertiary",
            children: t === "locked" ? "Bolt will not make any changes to the following files:" : "Bolt will only make changes to the following files:"
        }), v.jsx(ga, {
            children: v.jsx("div", {
                children: l.map(u => v.jsx(DM, {
                    node: u,
                    onClick: () => u.kind === "file" ? r?.(u.fullPath) : o(u.fullPath),
                    selected: n === u.fullPath,
                    collapsed: a.has(u.fullPath),
                    renderContent: c
                }, u.fullPath))
            })
        })]
    })
}
)
  , uhe = ({isFileSelected: t, isFocused: e, isClickable: n, className: r, onClick: i, ...s}) => v.jsx("span", {
    className: be("size-4 shrink-0 opacity-0", {
        "text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive": !t && n,
        "group-hover:opacity-70 hover:opacity-100!": t,
        "group-hover:opacity-100": !t,
        "not-hover-opacity-100": !t && e,
        "not-hover-opacity-70": t && e
    }, r),
    onClick: n ? i : void 0,
    ...s
});
function NM(t, e, {signal: n, shouldClose: r, env: i}) {
    const s = dhe(n, "abort").then( () => !0);
    let o, a = Qi(), l;
    const c = new Set
      , u = new Set;
    let h, d = !0;
    return (async () => {
        let f = !1;
        for (; !f; ) {
            if (d = !0,
            h = await t.spawn("/bin/jsh", ["--osc"], {
                terminal: {
                    cols: e.cols,
                    rows: e.rows
                },
                env: i
            }),
            l?.resolve(),
            o = h.input.getWriter(),
            n.aborted) {
                h.kill();
                return
            }
            const g = hhe(h, o, e, {
                onOSC(m) {
                    m === "interactive" && a.resolve();
                    for (const p of c)
                        p(m)
                },
                onOutput: m => {
                    for (const p of u)
                        p(m)
                }
            });
            if (await Promise.race([g, s])) {
                h.kill();
                return
            }
            if (d && e.clear(),
            f = r?.() ?? !1,
            !f) {
                const m = a;
                a = Qi(),
                m.reject()
            }
        }
    }
    )(),
    {
        async ready() {
            async function f() {
                try {
                    return await a.promise
                } catch {
                    return f()
                }
            }
            return f()
        },
        async restart(f=!0) {
            l = Qi(),
            d = f,
            e.write(`

`),
            h.kill(),
            await l.promise
        },
        write(f) {
            o.write(f)
        },
        registerOscHandler(f) {
            return c.add(f),
            () => {
                c.delete(f)
            }
        },
        registerOutputHandler(f) {
            return u.add(f),
            () => {
                u.delete(f)
            }
        }
    }
}
async function hhe(t, e, n, r) {
    const i = t.output
      , s = t.exit;
    let o = !1;
    i.pipeTo(new WritableStream({
        write(c) {
            if (!o || r?.onOSC) {
                const [,u] = c.match(/\x1b\]654;([^\x07]+)\x07/) || [];
                u === "interactive" && (o = !0),
                u && r?.onOSC?.(u)
            }
            n.write(c),
            r?.onOutput?.(c)
        }
    }));
    const a = n.onResize(c => {
        t.resize(c)
    }
    )
      , l = n.onData(c => {
        o && e.write(c)
    }
    );
    await s,
    a.dispose(),
    l.dispose()
}
function dhe(t, e) {
    const n = Qi();
    return t.addEventListener(e, n.resolve, {
        once: !0
    }),
    n.promise
}
function fhe({driver: t, ...e}) {
    const n = S.useRef(null)
      , r = S.useRef(null);
    return r.current == null && (r.current = new AbortController),
    S.useEffect( () => {
        let i = !1;
        return Nr.then(async s => {
            const o = NM(s, n.current.instance, {
                signal: r.current.signal,
                env: {
                    npm_config_yes: !0
                }
            });
            await o.ready(),
            i || t.start(o)
        }
        ),
        () => {
            i = !0
        }
    }
    , []),
    v.jsx(d1, {
        ...e,
        ref: n
    })
}
function phe({onTryExit: t, ...e}) {
    const n = S.useRef(null)
      , r = S.useRef(null)
      , i = S.useRef(t);
    return r.current == null && (r.current = new AbortController),
    S.useEffect( () => {
        i.current = t
    }
    ),
    S.useEffect( () => (Nr.then(s => {
        NM(s, n.current.instance, {
            signal: r.current.signal,
            shouldClose() {
                return i.current()
            }
        })
    }
    ),
    () => r.current.abort()), []),
    v.jsx(d1, {
        ...e,
        ref: n
    })
}
let gt = class MM {
    lineAt(e) {
        if (e < 0 || e > this.length)
            throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
        return this.lineInner(e, !1, 1, 0)
    }
    line(e) {
        if (e < 1 || e > this.lines)
            throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
        return this.lineInner(e, !0, 1, 0)
    }
    replace(e, n, r) {
        [e,n] = Ll(this, e, n);
        let i = [];
        return this.decompose(0, e, i, 2),
        r.length && r.decompose(0, r.length, i, 3),
        this.decompose(n, this.length, i, 1),
        _i.from(i, this.length - (n - e) + r.length)
    }
    append(e) {
        return this.replace(this.length, this.length, e)
    }
    slice(e, n=this.length) {
        [e,n] = Ll(this, e, n);
        let r = [];
        return this.decompose(e, n, r, 0),
        _i.from(r, n - e)
    }
    eq(e) {
        if (e == this)
            return !0;
        if (e.length != this.length || e.lines != this.lines)
            return !1;
        let n = this.scanIdentical(e, 1)
          , r = this.length - this.scanIdentical(e, -1)
          , i = new tu(this)
          , s = new tu(e);
        for (let o = n, a = n; ; ) {
            if (i.next(o),
            s.next(o),
            o = 0,
            i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
                return !1;
            if (a += i.value.length,
            i.done || a >= r)
                return !0
        }
    }
    iter(e=1) {
        return new tu(this,e)
    }
    iterRange(e, n=this.length) {
        return new BM(this,e,n)
    }
    iterLines(e, n) {
        let r;
        if (e == null)
            r = this.iter();
        else {
            n == null && (n = this.lines + 1);
            let i = this.line(e).from;
            r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to))
        }
        return new FM(r)
    }
    toString() {
        return this.sliceString(0)
    }
    toJSON() {
        let e = [];
        return this.flatten(e),
        e
    }
    constructor() {}
    static of(e) {
        if (e.length == 0)
            throw new RangeError("A document must have at least one line");
        return e.length == 1 && !e[0] ? MM.empty : e.length <= 32 ? new Ut(e) : _i.from(Ut.split(e, []))
    }
}
;
class Ut extends gt {
    constructor(e, n=mhe(e)) {
        super(),
        this.text = e,
        this.length = n
    }
    get lines() {
        return this.text.length
    }
    get children() {
        return null
    }
    lineInner(e, n, r, i) {
        for (let s = 0; ; s++) {
            let o = this.text[s]
              , a = i + o.length;
            if ((n ? r : a) >= e)
                return new ghe(i,a,r,o);
            i = a + 1,
            r++
        }
    }
    decompose(e, n, r, i) {
        let s = e <= 0 && n >= this.length ? this : new Ut(YC(this.text, e, n),Math.min(n, this.length) - Math.max(0, e));
        if (i & 1) {
            let o = r.pop()
              , a = Sf(s.text, o.text.slice(), 0, s.length);
            if (a.length <= 32)
                r.push(new Ut(a,o.length + s.length));
            else {
                let l = a.length >> 1;
                r.push(new Ut(a.slice(0, l)), new Ut(a.slice(l)))
            }
        } else
            r.push(s)
    }
    replace(e, n, r) {
        if (!(r instanceof Ut))
            return super.replace(e, n, r);
        [e,n] = Ll(this, e, n);
        let i = Sf(this.text, Sf(r.text, YC(this.text, 0, e)), n)
          , s = this.length + r.length - (n - e);
        return i.length <= 32 ? new Ut(i,s) : _i.from(Ut.split(i, []), s)
    }
    sliceString(e, n=this.length, r=`
`) {
        [e,n] = Ll(this, e, n);
        let i = "";
        for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {
            let a = this.text[o]
              , l = s + a.length;
            s > e && o && (i += r),
            e < l && n > s && (i += a.slice(Math.max(0, e - s), n - s)),
            s = l + 1
        }
        return i
    }
    flatten(e) {
        for (let n of this.text)
            e.push(n)
    }
    scanIdentical() {
        return 0
    }
    static split(e, n) {
        let r = []
          , i = -1;
        for (let s of e)
            r.push(s),
            i += s.length + 1,
            r.length == 32 && (n.push(new Ut(r,i)),
            r = [],
            i = -1);
        return i > -1 && n.push(new Ut(r,i)),
        n
    }
}
class _i extends gt {
    constructor(e, n) {
        super(),
        this.children = e,
        this.length = n,
        this.lines = 0;
        for (let r of e)
            this.lines += r.lines
    }
    lineInner(e, n, r, i) {
        for (let s = 0; ; s++) {
            let o = this.children[s]
              , a = i + o.length
              , l = r + o.lines - 1;
            if ((n ? l : a) >= e)
                return o.lineInner(e, n, r, i);
            i = a + 1,
            r = l + 1
        }
    }
    decompose(e, n, r, i) {
        for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {
            let a = this.children[s]
              , l = o + a.length;
            if (e <= l && n >= o) {
                let c = i & ((o <= e ? 1 : 0) | (l >= n ? 2 : 0));
                o >= e && l <= n && !c ? r.push(a) : a.decompose(e - o, n - o, r, c)
            }
            o = l + 1
        }
    }
    replace(e, n, r) {
        if ([e,n] = Ll(this, e, n),
        r.lines < this.lines)
            for (let i = 0, s = 0; i < this.children.length; i++) {
                let o = this.children[i]
                  , a = s + o.length;
                if (e >= s && n <= a) {
                    let l = o.replace(e - s, n - s, r)
                      , c = this.lines - o.lines + l.lines;
                    if (l.lines < c >> 4 && l.lines > c >> 6) {
                        let u = this.children.slice();
                        return u[i] = l,
                        new _i(u,this.length - (n - e) + r.length)
                    }
                    return super.replace(s, a, l)
                }
                s = a + 1
            }
        return super.replace(e, n, r)
    }
    sliceString(e, n=this.length, r=`
`) {
        [e,n] = Ll(this, e, n);
        let i = "";
        for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {
            let a = this.children[s]
              , l = o + a.length;
            o > e && s && (i += r),
            e < l && n > o && (i += a.sliceString(e - o, n - o, r)),
            o = l + 1
        }
        return i
    }
    flatten(e) {
        for (let n of this.children)
            n.flatten(e)
    }
    scanIdentical(e, n) {
        if (!(e instanceof _i))
            return 0;
        let r = 0
          , [i,s,o,a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
        for (; ; i += n,
        s += n) {
            if (i == o || s == a)
                return r;
            let l = this.children[i]
              , c = e.children[s];
            if (l != c)
                return r + l.scanIdentical(c, n);
            r += l.length + 1
        }
    }
    static from(e, n=e.reduce( (r, i) => r + i.length + 1, -1)) {
        let r = 0;
        for (let f of e)
            r += f.lines;
        if (r < 32) {
            let f = [];
            for (let g of e)
                g.flatten(f);
            return new Ut(f,n)
        }
        let i = Math.max(32, r >> 5)
          , s = i << 1
          , o = i >> 1
          , a = []
          , l = 0
          , c = -1
          , u = [];
        function h(f) {
            let g;
            if (f.lines > s && f instanceof _i)
                for (let _ of f.children)
                    h(_);
            else
                f.lines > o && (l > o || !l) ? (d(),
                a.push(f)) : f instanceof Ut && l && (g = u[u.length - 1])instanceof Ut && f.lines + g.lines <= 32 ? (l += f.lines,
                c += f.length + 1,
                u[u.length - 1] = new Ut(g.text.concat(f.text),g.length + 1 + f.length)) : (l + f.lines > i && d(),
                l += f.lines,
                c += f.length + 1,
                u.push(f))
        }
        function d() {
            l != 0 && (a.push(u.length == 1 ? u[0] : _i.from(u, c)),
            c = -1,
            l = u.length = 0)
        }
        for (let f of e)
            h(f);
        return d(),
        a.length == 1 ? a[0] : new _i(a,n)
    }
}
gt.empty = new Ut([""],0);
function mhe(t) {
    let e = -1;
    for (let n of t)
        e += n.length + 1;
    return e
}
function Sf(t, e, n=0, r=1e9) {
    for (let i = 0, s = 0, o = !0; s < t.length && i <= r; s++) {
        let a = t[s]
          , l = i + a.length;
        l >= n && (l > r && (a = a.slice(0, r - i)),
        i < n && (a = a.slice(n - i)),
        o ? (e[e.length - 1] += a,
        o = !1) : e.push(a)),
        i = l + 1
    }
    return e
}
function YC(t, e, n) {
    return Sf(t, [""], e, n)
}
class tu {
    constructor(e, n=1) {
        this.dir = n,
        this.done = !1,
        this.lineBreak = !1,
        this.value = "",
        this.nodes = [e],
        this.offsets = [n > 0 ? 1 : (e instanceof Ut ? e.text.length : e.children.length) << 1]
    }
    nextInner(e, n) {
        for (this.done = this.lineBreak = !1; ; ) {
            let r = this.nodes.length - 1
              , i = this.nodes[r]
              , s = this.offsets[r]
              , o = s >> 1
              , a = i instanceof Ut ? i.text.length : i.children.length;
            if (o == (n > 0 ? a : 0)) {
                if (r == 0)
                    return this.done = !0,
                    this.value = "",
                    this;
                n > 0 && this.offsets[r - 1]++,
                this.nodes.pop(),
                this.offsets.pop()
            } else if ((s & 1) == (n > 0 ? 0 : 1)) {
                if (this.offsets[r] += n,
                e == 0)
                    return this.lineBreak = !0,
                    this.value = `
`,
                    this;
                e--
            } else if (i instanceof Ut) {
                let l = i.text[o + (n < 0 ? -1 : 0)];
                if (this.offsets[r] += n,
                l.length > Math.max(0, e))
                    return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e),
                    this;
                e -= l.length
            } else {
                let l = i.children[o + (n < 0 ? -1 : 0)];
                e > l.length ? (e -= l.length,
                this.offsets[r] += n) : (n < 0 && this.offsets[r]--,
                this.nodes.push(l),
                this.offsets.push(n > 0 ? 1 : (l instanceof Ut ? l.text.length : l.children.length) << 1))
            }
        }
    }
    next(e=0) {
        return e < 0 && (this.nextInner(-e, -this.dir),
        e = this.value.length),
        this.nextInner(e, this.dir)
    }
}
class BM {
    constructor(e, n, r) {
        this.value = "",
        this.done = !1,
        this.cursor = new tu(e,n > r ? -1 : 1),
        this.pos = n > r ? e.length : 0,
        this.from = Math.min(n, r),
        this.to = Math.max(n, r)
    }
    nextInner(e, n) {
        if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
            return this.value = "",
            this.done = !0,
            this;
        e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
        let r = n < 0 ? this.pos - this.from : this.to - this.pos;
        e > r && (e = r),
        r -= e;
        let {value: i} = this.cursor.next(e);
        return this.pos += (i.length + e) * n,
        this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r),
        this.done = !this.value,
        this
    }
    next(e=0) {
        return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)),
        this.nextInner(e, this.cursor.dir)
    }
    get lineBreak() {
        return this.cursor.lineBreak && this.value != ""
    }
}
class FM {
    constructor(e) {
        this.inner = e,
        this.afterBreak = !0,
        this.value = "",
        this.done = !1
    }
    next(e=0) {
        let {done: n, lineBreak: r, value: i} = this.inner.next(e);
        return n && this.afterBreak ? (this.value = "",
        this.afterBreak = !1) : n ? (this.done = !0,
        this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0,
        this.next()) : (this.value = i,
        this.afterBreak = !1),
        this
    }
    get lineBreak() {
        return !1
    }
}
typeof Symbol < "u" && (gt.prototype[Symbol.iterator] = function() {
    return this.iter()
}
,
tu.prototype[Symbol.iterator] = BM.prototype[Symbol.iterator] = FM.prototype[Symbol.iterator] = function() {
    return this
}
);
class ghe {
    constructor(e, n, r, i) {
        this.from = e,
        this.to = n,
        this.number = r,
        this.text = i
    }
    get length() {
        return this.to - this.from
    }
}
function Ll(t, e, n) {
    return e = Math.max(0, Math.min(t.length, e)),
    [e, Math.max(e, Math.min(t.length, n))]
}
let pl = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(t => t ? parseInt(t, 36) : 1);
for (let t = 1; t < pl.length; t++)
    pl[t] += pl[t - 1];
function _he(t) {
    for (let e = 1; e < pl.length; e += 2)
        if (pl[e] > t)
            return pl[e - 1] <= t;
    return !1
}
function XC(t) {
    return t >= 127462 && t <= 127487
}
const QC = 8205;
function yn(t, e, n=!0, r=!0) {
    return (n ? jM : bhe)(t, e, r)
}
function jM(t, e, n) {
    if (e == t.length)
        return e;
    e && HM(t.charCodeAt(e)) && UM(t.charCodeAt(e - 1)) && e--;
    let r = Xn(t, e);
    for (e += Wr(r); e < t.length; ) {
        let i = Xn(t, e);
        if (r == QC || i == QC || n && _he(i))
            e += Wr(i),
            r = i;
        else if (XC(i)) {
            let s = 0
              , o = e - 2;
            for (; o >= 0 && XC(Xn(t, o)); )
                s++,
                o -= 2;
            if (s % 2 == 0)
                break;
            e += 2
        } else
            break
    }
    return e
}
function bhe(t, e, n) {
    for (; e > 0; ) {
        let r = jM(t, e - 2, n);
        if (r < e)
            return r;
        e--
    }
    return 0
}
function HM(t) {
    return t >= 56320 && t < 57344
}
function UM(t) {
    return t >= 55296 && t < 56320
}
function Xn(t, e) {
    let n = t.charCodeAt(e);
    if (!UM(n) || e + 1 == t.length)
        return n;
    let r = t.charCodeAt(e + 1);
    return HM(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n
}
function $1(t) {
    return t <= 65535 ? String.fromCharCode(t) : (t -= 65536,
    String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320))
}
function Wr(t) {
    return t < 65536 ? 1 : 2
}
const wb = /\r\n?|\n/;
var kn = function(t) {
    return t[t.Simple = 0] = "Simple",
    t[t.TrackDel = 1] = "TrackDel",
    t[t.TrackBefore = 2] = "TrackBefore",
    t[t.TrackAfter = 3] = "TrackAfter",
    t
}(kn || (kn = {}));
class Ri {
    constructor(e) {
        this.sections = e
    }
    get length() {
        let e = 0;
        for (let n = 0; n < this.sections.length; n += 2)
            e += this.sections[n];
        return e
    }
    get newLength() {
        let e = 0;
        for (let n = 0; n < this.sections.length; n += 2) {
            let r = this.sections[n + 1];
            e += r < 0 ? this.sections[n] : r
        }
        return e
    }
    get empty() {
        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0
    }
    iterGaps(e) {
        for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
            let s = this.sections[n++]
              , o = this.sections[n++];
            o < 0 ? (e(r, i, s),
            i += s) : i += o,
            r += s
        }
    }
    iterChangedRanges(e, n=!1) {
        Cb(this, e, n)
    }
    get invertedDesc() {
        let e = [];
        for (let n = 0; n < this.sections.length; ) {
            let r = this.sections[n++]
              , i = this.sections[n++];
            i < 0 ? e.push(r, i) : e.push(i, r)
        }
        return new Ri(e)
    }
    composeDesc(e) {
        return this.empty ? e : e.empty ? this : VM(this, e)
    }
    mapDesc(e, n=!1) {
        return e.empty ? this : Tb(this, e, n)
    }
    mapPos(e, n=-1, r=kn.Simple) {
        let i = 0
          , s = 0;
        for (let o = 0; o < this.sections.length; ) {
            let a = this.sections[o++]
              , l = this.sections[o++]
              , c = i + a;
            if (l < 0) {
                if (c > e)
                    return s + (e - i);
                s += a
            } else {
                if (r != kn.Simple && c >= e && (r == kn.TrackDel && i < e && c > e || r == kn.TrackBefore && i < e || r == kn.TrackAfter && c > e))
                    return null;
                if (c > e || c == e && n < 0 && !a)
                    return e == i || n < 0 ? s : s + l;
                s += l
            }
            i = c
        }
        if (e > i)
            throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
        return s
    }
    touchesRange(e, n=e) {
        for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
            let s = this.sections[r++]
              , o = this.sections[r++]
              , a = i + s;
            if (o >= 0 && i <= n && a >= e)
                return i < e && a > n ? "cover" : !0;
            i = a
        }
        return !1
    }
    toString() {
        let e = "";
        for (let n = 0; n < this.sections.length; ) {
            let r = this.sections[n++]
              , i = this.sections[n++];
            e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "")
        }
        return e
    }
    toJSON() {
        return this.sections
    }
    static fromJSON(e) {
        if (!Array.isArray(e) || e.length % 2 || e.some(n => typeof n != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new Ri(e)
    }
    static create(e) {
        return new Ri(e)
    }
}
class Zt extends Ri {
    constructor(e, n) {
        super(e),
        this.inserted = n
    }
    apply(e) {
        if (this.length != e.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        return Cb(this, (n, r, i, s, o) => e = e.replace(i, i + (r - n), o), !1),
        e
    }
    mapDesc(e, n=!1) {
        return Tb(this, e, n, !0)
    }
    invert(e) {
        let n = this.sections.slice()
          , r = [];
        for (let i = 0, s = 0; i < n.length; i += 2) {
            let o = n[i]
              , a = n[i + 1];
            if (a >= 0) {
                n[i] = a,
                n[i + 1] = o;
                let l = i >> 1;
                for (; r.length < l; )
                    r.push(gt.empty);
                r.push(o ? e.slice(s, s + o) : gt.empty)
            }
            s += o
        }
        return new Zt(n,r)
    }
    compose(e) {
        return this.empty ? e : e.empty ? this : VM(this, e, !0)
    }
    map(e, n=!1) {
        return e.empty ? this : Tb(this, e, n, !0)
    }
    iterChanges(e, n=!1) {
        Cb(this, e, n)
    }
    get desc() {
        return Ri.create(this.sections)
    }
    filter(e) {
        let n = []
          , r = []
          , i = []
          , s = new zu(this);
        e: for (let o = 0, a = 0; ; ) {
            let l = o == e.length ? 1e9 : e[o++];
            for (; a < l || a == l && s.len == 0; ) {
                if (s.done)
                    break e;
                let u = Math.min(s.len, l - a);
                Tn(i, u, -1);
                let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
                Tn(n, u, h),
                h > 0 && Rs(r, n, s.text),
                s.forward(u),
                a += u
            }
            let c = e[o++];
            for (; a < c; ) {
                if (s.done)
                    break e;
                let u = Math.min(s.len, c - a);
                Tn(n, u, -1),
                Tn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0),
                s.forward(u),
                a += u
            }
        }
        return {
            changes: new Zt(n,r),
            filtered: Ri.create(i)
        }
    }
    toJSON() {
        let e = [];
        for (let n = 0; n < this.sections.length; n += 2) {
            let r = this.sections[n]
              , i = this.sections[n + 1];
            i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()))
        }
        return e
    }
    static of(e, n, r) {
        let i = []
          , s = []
          , o = 0
          , a = null;
        function l(u=!1) {
            if (!u && !i.length)
                return;
            o < n && Tn(i, n - o, -1);
            let h = new Zt(i,s);
            a = a ? a.compose(h.map(a)) : h,
            i = [],
            s = [],
            o = 0
        }
        function c(u) {
            if (Array.isArray(u))
                for (let h of u)
                    c(h);
            else if (u instanceof Zt) {
                if (u.length != n)
                    throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
                l(),
                a = a ? a.compose(u.map(a)) : u
            } else {
                let {from: h, to: d=h, insert: f} = u;
                if (h > d || h < 0 || d > n)
                    throw new RangeError(`Invalid change range ${h} to ${d} (in doc of length ${n})`);
                let g = f ? typeof f == "string" ? gt.of(f.split(r || wb)) : f : gt.empty
                  , _ = g.length;
                if (h == d && _ == 0)
                    return;
                h < o && l(),
                h > o && Tn(i, h - o, -1),
                Tn(i, d - h, _),
                Rs(s, i, g),
                o = d
            }
        }
        return c(e),
        l(!a),
        a
    }
    static empty(e) {
        return new Zt(e ? [e, -1] : [],[])
    }
    static fromJSON(e) {
        if (!Array.isArray(e))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let n = []
          , r = [];
        for (let i = 0; i < e.length; i++) {
            let s = e[i];
            if (typeof s == "number")
                n.push(s, -1);
            else {
                if (!Array.isArray(s) || typeof s[0] != "number" || s.some( (o, a) => a && typeof o != "string"))
                    throw new RangeError("Invalid JSON representation of ChangeSet");
                if (s.length == 1)
                    n.push(s[0], 0);
                else {
                    for (; r.length < i; )
                        r.push(gt.empty);
                    r[i] = gt.of(s.slice(1)),
                    n.push(s[0], r[i].length)
                }
            }
        }
        return new Zt(n,r)
    }
    static createSet(e, n) {
        return new Zt(e,n)
    }
}
function Tn(t, e, n, r=!1) {
    if (e == 0 && n <= 0)
        return;
    let i = t.length - 2;
    i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e,
    t[i + 1] += n) : t.push(e, n)
}
function Rs(t, e, n) {
    if (n.length == 0)
        return;
    let r = e.length - 2 >> 1;
    if (r < t.length)
        t[t.length - 1] = t[t.length - 1].append(n);
    else {
        for (; t.length < r; )
            t.push(gt.empty);
        t.push(n)
    }
}
function Cb(t, e, n) {
    let r = t.inserted;
    for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
        let a = t.sections[o++]
          , l = t.sections[o++];
        if (l < 0)
            i += a,
            s += a;
        else {
            let c = i
              , u = s
              , h = gt.empty;
            for (; c += a,
            u += l,
            l && r && (h = h.append(r[o - 2 >> 1])),
            !(n || o == t.sections.length || t.sections[o + 1] < 0); )
                a = t.sections[o++],
                l = t.sections[o++];
            e(i, c, s, u, h),
            i = c,
            s = u
        }
    }
}
function Tb(t, e, n, r=!1) {
    let i = []
      , s = r ? [] : null
      , o = new zu(t)
      , a = new zu(e);
    for (let l = -1; ; )
        if (o.ins == -1 && a.ins == -1) {
            let c = Math.min(o.len, a.len);
            Tn(i, c, -1),
            o.forward(c),
            a.forward(c)
        } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !n))) {
            let c = a.len;
            for (Tn(i, a.ins, -1); c; ) {
                let u = Math.min(o.len, c);
                o.ins >= 0 && l < o.i && o.len <= u && (Tn(i, 0, o.ins),
                s && Rs(s, i, o.text),
                l = o.i),
                o.forward(u),
                c -= u
            }
            a.next()
        } else if (o.ins >= 0) {
            let c = 0
              , u = o.len;
            for (; u; )
                if (a.ins == -1) {
                    let h = Math.min(u, a.len);
                    c += h,
                    u -= h,
                    a.forward(h)
                } else if (a.ins == 0 && a.len < u)
                    u -= a.len,
                    a.next();
                else
                    break;
            Tn(i, c, l < o.i ? o.ins : 0),
            s && l < o.i && Rs(s, i, o.text),
            l = o.i,
            o.forward(o.len - u)
        } else {
            if (o.done && a.done)
                return s ? Zt.createSet(i, s) : Ri.create(i);
            throw new Error("Mismatched change set lengths")
        }
}
function VM(t, e, n=!1) {
    let r = []
      , i = n ? [] : null
      , s = new zu(t)
      , o = new zu(e);
    for (let a = !1; ; ) {
        if (s.done && o.done)
            return i ? Zt.createSet(r, i) : Ri.create(r);
        if (s.ins == 0)
            Tn(r, s.len, 0, a),
            s.next();
        else if (o.len == 0 && !o.done)
            Tn(r, 0, o.ins, a),
            i && Rs(i, r, o.text),
            o.next();
        else {
            if (s.done || o.done)
                throw new Error("Mismatched change set lengths");
            {
                let l = Math.min(s.len2, o.len)
                  , c = r.length;
                if (s.ins == -1) {
                    let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
                    Tn(r, l, u, a),
                    i && u && Rs(i, r, o.text)
                } else
                    o.ins == -1 ? (Tn(r, s.off ? 0 : s.len, l, a),
                    i && Rs(i, r, s.textBit(l))) : (Tn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, a),
                    i && !o.off && Rs(i, r, o.text));
                a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > c),
                s.forward2(l),
                o.forward(l)
            }
        }
    }
}
class zu {
    constructor(e) {
        this.set = e,
        this.i = 0,
        this.next()
    }
    next() {
        let {sections: e} = this.set;
        this.i < e.length ? (this.len = e[this.i++],
        this.ins = e[this.i++]) : (this.len = 0,
        this.ins = -2),
        this.off = 0
    }
    get done() {
        return this.ins == -2
    }
    get len2() {
        return this.ins < 0 ? this.len : this.ins
    }
    get text() {
        let {inserted: e} = this.set
          , n = this.i - 2 >> 1;
        return n >= e.length ? gt.empty : e[n]
    }
    textBit(e) {
        let {inserted: n} = this.set
          , r = this.i - 2 >> 1;
        return r >= n.length && !e ? gt.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e)
    }
    forward(e) {
        e == this.len ? this.next() : (this.len -= e,
        this.off += e)
    }
    forward2(e) {
        this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e,
        this.off += e)
    }
}
class Do {
    constructor(e, n, r) {
        this.from = e,
        this.to = n,
        this.flags = r
    }
    get anchor() {
        return this.flags & 32 ? this.to : this.from
    }
    get head() {
        return this.flags & 32 ? this.from : this.to
    }
    get empty() {
        return this.from == this.to
    }
    get assoc() {
        return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0
    }
    get bidiLevel() {
        let e = this.flags & 7;
        return e == 7 ? null : e
    }
    get goalColumn() {
        let e = this.flags >> 6;
        return e == 16777215 ? void 0 : e
    }
    map(e, n=-1) {
        let r, i;
        return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1),
        i = e.mapPos(this.to, -1)),
        r == this.from && i == this.to ? this : new Do(r,i,this.flags)
    }
    extend(e, n=e) {
        if (e <= this.anchor && n >= this.anchor)
            return ge.range(e, n);
        let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
        return ge.range(this.anchor, r)
    }
    eq(e, n=!1) {
        return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc)
    }
    toJSON() {
        return {
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(e) {
        if (!e || typeof e.anchor != "number" || typeof e.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return ge.range(e.anchor, e.head)
    }
    static create(e, n, r) {
        return new Do(e,n,r)
    }
}
class ge {
    constructor(e, n) {
        this.ranges = e,
        this.mainIndex = n
    }
    map(e, n=-1) {
        return e.empty ? this : ge.create(this.ranges.map(r => r.map(e, n)), this.mainIndex)
    }
    eq(e, n=!1) {
        if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
            return !1;
        for (let r = 0; r < this.ranges.length; r++)
            if (!this.ranges[r].eq(e.ranges[r], n))
                return !1;
        return !0
    }
    get main() {
        return this.ranges[this.mainIndex]
    }
    asSingle() {
        return this.ranges.length == 1 ? this : new ge([this.main],0)
    }
    addRange(e, n=!0) {
        return ge.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1)
    }
    replaceRange(e, n=this.mainIndex) {
        let r = this.ranges.slice();
        return r[n] = e,
        ge.create(r, this.mainIndex)
    }
    toJSON() {
        return {
            ranges: this.ranges.map(e => e.toJSON()),
            main: this.mainIndex
        }
    }
    static fromJSON(e) {
        if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new ge(e.ranges.map(n => Do.fromJSON(n)),e.main)
    }
    static single(e, n=e) {
        return new ge([ge.range(e, n)],0)
    }
    static create(e, n=0) {
        if (e.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let r = 0, i = 0; i < e.length; i++) {
            let s = e[i];
            if (s.empty ? s.from <= r : s.from < r)
                return ge.normalized(e.slice(), n);
            r = s.to
        }
        return new ge(e,n)
    }
    static cursor(e, n=0, r, i) {
        return Do.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6)
    }
    static range(e, n, r, i) {
        let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
        return n < e ? Do.create(n, e, 48 | s) : Do.create(e, n, (n > e ? 8 : 0) | s)
    }
    static normalized(e, n=0) {
        let r = e[n];
        e.sort( (i, s) => i.from - s.from),
        n = e.indexOf(r);
        for (let i = 1; i < e.length; i++) {
            let s = e[i]
              , o = e[i - 1];
            if (s.empty ? s.from <= o.to : s.from < o.to) {
                let a = o.from
                  , l = Math.max(s.to, o.to);
                i <= n && n--,
                e.splice(--i, 2, s.anchor > s.head ? ge.range(l, a) : ge.range(a, l))
            }
        }
        return new ge(e,n)
    }
}
function $M(t, e) {
    for (let n of t.ranges)
        if (n.to > e)
            throw new RangeError("Selection points outside of document")
}
let z1 = 0;
class Me {
    constructor(e, n, r, i, s) {
        this.combine = e,
        this.compareInput = n,
        this.compare = r,
        this.isStatic = i,
        this.id = z1++,
        this.default = e([]),
        this.extensions = typeof s == "function" ? s(this) : s
    }
    get reader() {
        return this
    }
    static define(e={}) {
        return new Me(e.combine || (n => n),e.compareInput || ( (n, r) => n === r),e.compare || (e.combine ? (n, r) => n === r : W1),!!e.static,e.enables)
    }
    of(e) {
        return new wf([],this,0,e)
    }
    compute(e, n) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new wf(e,this,1,n)
    }
    computeN(e, n) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new wf(e,this,2,n)
    }
    from(e, n) {
        return n || (n = r => r),
        this.compute([e], r => n(r.field(e)))
    }
}
function W1(t, e) {
    return t == e || t.length == e.length && t.every( (n, r) => n === e[r])
}
class wf {
    constructor(e, n, r, i) {
        this.dependencies = e,
        this.facet = n,
        this.type = r,
        this.value = i,
        this.id = z1++
    }
    dynamicSlot(e) {
        var n;
        let r = this.value
          , i = this.facet.compareInput
          , s = this.id
          , o = e[s] >> 1
          , a = this.type == 2
          , l = !1
          , c = !1
          , u = [];
        for (let h of this.dependencies)
            h == "doc" ? l = !0 : h == "selection" ? c = !0 : ((n = e[h.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[h.id]);
        return {
            create(h) {
                return h.values[o] = r(h),
                1
            },
            update(h, d) {
                if (l && d.docChanged || c && (d.docChanged || d.selection) || Ab(h, u)) {
                    let f = r(h);
                    if (a ? !JC(f, h.values[o], i) : !i(f, h.values[o]))
                        return h.values[o] = f,
                        1
                }
                return 0
            },
            reconfigure: (h, d) => {
                let f, g = d.config.address[s];
                if (g != null) {
                    let _ = Op(d, g);
                    if (this.dependencies.every(m => m instanceof Me ? d.facet(m) === h.facet(m) : m instanceof Qt ? d.field(m, !1) == h.field(m, !1) : !0) || (a ? JC(f = r(h), _, i) : i(f = r(h), _)))
                        return h.values[o] = _,
                        0
                } else
                    f = r(h);
                return h.values[o] = f,
                1
            }
        }
    }
}
function JC(t, e, n) {
    if (t.length != e.length)
        return !1;
    for (let r = 0; r < t.length; r++)
        if (!n(t[r], e[r]))
            return !1;
    return !0
}
function Ab(t, e) {
    let n = !1;
    for (let r of e)
        nu(t, r) & 1 && (n = !0);
    return n
}
function yhe(t, e, n) {
    let r = n.map(l => t[l.id])
      , i = n.map(l => l.type)
      , s = r.filter(l => !(l & 1))
      , o = t[e.id] >> 1;
    function a(l) {
        let c = [];
        for (let u = 0; u < r.length; u++) {
            let h = Op(l, r[u]);
            if (i[u] == 2)
                for (let d of h)
                    c.push(d);
            else
                c.push(h)
        }
        return e.combine(c)
    }
    return {
        create(l) {
            for (let c of r)
                nu(l, c);
            return l.values[o] = a(l),
            1
        },
        update(l, c) {
            if (!Ab(l, s))
                return 0;
            let u = a(l);
            return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u,
            1)
        },
        reconfigure(l, c) {
            let u = Ab(l, r)
              , h = c.config.facets[e.id]
              , d = c.facet(e);
            if (h && !u && W1(n, h))
                return l.values[o] = d,
                0;
            let f = a(l);
            return e.compare(f, d) ? (l.values[o] = d,
            0) : (l.values[o] = f,
            1)
        }
    }
}
const ZC = Me.define({
    static: !0
});
class Qt {
    constructor(e, n, r, i, s) {
        this.id = e,
        this.createF = n,
        this.updateF = r,
        this.compareF = i,
        this.spec = s,
        this.provides = void 0
    }
    static define(e) {
        let n = new Qt(z1++,e.create,e.update,e.compare || ( (r, i) => r === i),e);
        return e.provide && (n.provides = e.provide(n)),
        n
    }
    create(e) {
        let n = e.facet(ZC).find(r => r.field == this);
        return (n?.create || this.createF)(e)
    }
    slot(e) {
        let n = e[this.id] >> 1;
        return {
            create: r => (r.values[n] = this.create(r),
            1),
            update: (r, i) => {
                let s = r.values[n]
                  , o = this.updateF(s, i);
                return this.compareF(s, o) ? 0 : (r.values[n] = o,
                1)
            }
            ,
            reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[n] = i.field(this),
            0) : (r.values[n] = this.create(r),
            1)
        }
    }
    init(e) {
        return [this, ZC.of({
            field: this,
            create: e
        })]
    }
    get extension() {
        return this
    }
}
const Co = {
    lowest: 4,
    low: 3,
    default: 2,
    high: 1,
    highest: 0
};
function fc(t) {
    return e => new zM(e,t)
}
const co = {
    highest: fc(Co.highest),
    high: fc(Co.high),
    default: fc(Co.default),
    low: fc(Co.low),
    lowest: fc(Co.lowest)
};
class zM {
    constructor(e, n) {
        this.inner = e,
        this.prec = n
    }
}
class oa {
    of(e) {
        return new kb(this,e)
    }
    reconfigure(e) {
        return oa.reconfigure.of({
            compartment: this,
            extension: e
        })
    }
    get(e) {
        return e.config.compartments.get(this)
    }
}
class kb {
    constructor(e, n) {
        this.compartment = e,
        this.inner = n
    }
}
class Lp {
    constructor(e, n, r, i, s, o) {
        for (this.base = e,
        this.compartments = n,
        this.dynamicSlots = r,
        this.address = i,
        this.staticValues = s,
        this.facets = o,
        this.statusTemplate = []; this.statusTemplate.length < r.length; )
            this.statusTemplate.push(0)
    }
    staticFacet(e) {
        let n = this.address[e.id];
        return n == null ? e.default : this.staticValues[n >> 1]
    }
    static resolve(e, n, r) {
        let i = []
          , s = Object.create(null)
          , o = new Map;
        for (let d of vhe(e, n, o))
            d instanceof Qt ? i.push(d) : (s[d.facet.id] || (s[d.facet.id] = [])).push(d);
        let a = Object.create(null)
          , l = []
          , c = [];
        for (let d of i)
            a[d.id] = c.length << 1,
            c.push(f => d.slot(f));
        let u = r?.config.facets;
        for (let d in s) {
            let f = s[d]
              , g = f[0].facet
              , _ = u && u[d] || [];
            if (f.every(m => m.type == 0))
                if (a[g.id] = l.length << 1 | 1,
                W1(_, f))
                    l.push(r.facet(g));
                else {
                    let m = g.combine(f.map(p => p.value));
                    l.push(r && g.compare(m, r.facet(g)) ? r.facet(g) : m)
                }
            else {
                for (let m of f)
                    m.type == 0 ? (a[m.id] = l.length << 1 | 1,
                    l.push(m.value)) : (a[m.id] = c.length << 1,
                    c.push(p => m.dynamicSlot(p)));
                a[g.id] = c.length << 1,
                c.push(m => yhe(m, g, f))
            }
        }
        let h = c.map(d => d(a));
        return new Lp(e,o,h,a,l,s)
    }
}
function vhe(t, e, n) {
    let r = [[], [], [], [], []]
      , i = new Map;
    function s(o, a) {
        let l = i.get(o);
        if (l != null) {
            if (l <= a)
                return;
            let c = r[l].indexOf(o);
            c > -1 && r[l].splice(c, 1),
            o instanceof kb && n.delete(o.compartment)
        }
        if (i.set(o, a),
        Array.isArray(o))
            for (let c of o)
                s(c, a);
        else if (o instanceof kb) {
            if (n.has(o.compartment))
                throw new RangeError("Duplicate use of compartment in extensions");
            let c = e.get(o.compartment) || o.inner;
            n.set(o.compartment, c),
            s(c, a)
        } else if (o instanceof zM)
            s(o.inner, o.prec);
        else if (o instanceof Qt)
            r[a].push(o),
            o.provides && s(o.provides, a);
        else if (o instanceof wf)
            r[a].push(o),
            o.facet.extensions && s(o.facet.extensions, Co.default);
        else {
            let c = o.extension;
            if (!c)
                throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            s(c, a)
        }
    }
    return s(t, Co.default),
    r.reduce( (o, a) => o.concat(a))
}
function nu(t, e) {
    if (e & 1)
        return 2;
    let n = e >> 1
      , r = t.status[n];
    if (r == 4)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (r & 2)
        return r;
    t.status[n] = 4;
    let i = t.computeSlot(t, t.config.dynamicSlots[n]);
    return t.status[n] = 2 | i
}
function Op(t, e) {
    return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1]
}
const WM = Me.define()
  , Rb = Me.define({
    combine: t => t.some(e => e),
    static: !0
})
  , GM = Me.define({
    combine: t => t.length ? t[0] : void 0,
    static: !0
})
  , qM = Me.define()
  , KM = Me.define()
  , YM = Me.define()
  , XM = Me.define({
    combine: t => t.length ? t[0] : !1
});
class fs {
    constructor(e, n) {
        this.type = e,
        this.value = n
    }
    static define() {
        return new xhe
    }
}
class xhe {
    of(e) {
        return new fs(this,e)
    }
}
class Ehe {
    constructor(e) {
        this.map = e
    }
    of(e) {
        return new Je(this,e)
    }
}
class Je {
    constructor(e, n) {
        this.type = e,
        this.value = n
    }
    map(e) {
        let n = this.type.map(this.value, e);
        return n === void 0 ? void 0 : n == this.value ? this : new Je(this.type,n)
    }
    is(e) {
        return this.type == e
    }
    static define(e={}) {
        return new Ehe(e.map || (n => n))
    }
    static mapEffects(e, n) {
        if (!e.length)
            return e;
        let r = [];
        for (let i of e) {
            let s = i.map(n);
            s && r.push(s)
        }
        return r
    }
}
Je.reconfigure = Je.define();
Je.appendConfig = Je.define();
class Yt {
    constructor(e, n, r, i, s, o) {
        this.startState = e,
        this.changes = n,
        this.selection = r,
        this.effects = i,
        this.annotations = s,
        this.scrollIntoView = o,
        this._doc = null,
        this._state = null,
        r && $M(r, n.newLength),
        s.some(a => a.type == Yt.time) || (this.annotations = s.concat(Yt.time.of(Date.now())))
    }
    static create(e, n, r, i, s, o) {
        return new Yt(e,n,r,i,s,o)
    }
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc))
    }
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes)
    }
    get state() {
        return this._state || this.startState.applyTransaction(this),
        this._state
    }
    annotation(e) {
        for (let n of this.annotations)
            if (n.type == e)
                return n.value
    }
    get docChanged() {
        return !this.changes.empty
    }
    get reconfigured() {
        return this.startState.config != this.state.config
    }
    isUserEvent(e) {
        let n = this.annotation(Yt.userEvent);
        return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."))
    }
}
Yt.time = fs.define();
Yt.userEvent = fs.define();
Yt.addToHistory = fs.define();
Yt.remote = fs.define();
function She(t, e) {
    let n = [];
    for (let r = 0, i = 0; ; ) {
        let s, o;
        if (r < t.length && (i == e.length || e[i] >= t[r]))
            s = t[r++],
            o = t[r++];
        else if (i < e.length)
            s = e[i++],
            o = e[i++];
        else
            return n;
        !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o)
    }
}
function QM(t, e, n) {
    var r;
    let i, s, o;
    return n ? (i = e.changes,
    s = Zt.empty(e.changes.length),
    o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes),
    s = t.changes.mapDesc(e.changes, !0),
    o = t.changes.compose(i)),
    {
        changes: o,
        selection: e.selection ? e.selection.map(s) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
        effects: Je.mapEffects(t.effects, i).concat(Je.mapEffects(e.effects, s)),
        annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
        scrollIntoView: t.scrollIntoView || e.scrollIntoView
    }
}
function Ib(t, e, n) {
    let r = e.selection
      , i = ml(e.annotations);
    return e.userEvent && (i = i.concat(Yt.userEvent.of(e.userEvent))),
    {
        changes: e.changes instanceof Zt ? e.changes : Zt.of(e.changes || [], n, t.facet(GM)),
        selection: r && (r instanceof ge ? r : ge.single(r.anchor, r.head)),
        effects: ml(e.effects),
        annotations: i,
        scrollIntoView: !!e.scrollIntoView
    }
}
function JM(t, e, n) {
    let r = Ib(t, e.length ? e[0] : {}, t.doc.length);
    e.length && e[0].filter === !1 && (n = !1);
    for (let s = 1; s < e.length; s++) {
        e[s].filter === !1 && (n = !1);
        let o = !!e[s].sequential;
        r = QM(r, Ib(t, e[s], o ? r.changes.newLength : t.doc.length), o)
    }
    let i = Yt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
    return Che(n ? whe(i) : i)
}
function whe(t) {
    let e = t.startState
      , n = !0;
    for (let i of e.facet(qM)) {
        let s = i(t);
        if (s === !1) {
            n = !1;
            break
        }
        Array.isArray(s) && (n = n === !0 ? s : She(n, s))
    }
    if (n !== !0) {
        let i, s;
        if (n === !1)
            s = t.changes.invertedDesc,
            i = Zt.empty(e.doc.length);
        else {
            let o = t.changes.filter(n);
            i = o.changes,
            s = o.filtered.mapDesc(o.changes).invertedDesc
        }
        t = Yt.create(e, i, t.selection && t.selection.map(s), Je.mapEffects(t.effects, s), t.annotations, t.scrollIntoView)
    }
    let r = e.facet(KM);
    for (let i = r.length - 1; i >= 0; i--) {
        let s = r[i](t);
        s instanceof Yt ? t = s : Array.isArray(s) && s.length == 1 && s[0]instanceof Yt ? t = s[0] : t = JM(e, ml(s), !1)
    }
    return t
}
function Che(t) {
    let e = t.startState
      , n = e.facet(YM)
      , r = t;
    for (let i = n.length - 1; i >= 0; i--) {
        let s = n[i](t);
        s && Object.keys(s).length && (r = QM(r, Ib(e, s, t.changes.newLength), !0))
    }
    return r == t ? t : Yt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView)
}
const The = [];
function ml(t) {
    return t == null ? The : Array.isArray(t) ? t : [t]
}
var Xt = function(t) {
    return t[t.Word = 0] = "Word",
    t[t.Space = 1] = "Space",
    t[t.Other = 2] = "Other",
    t
}(Xt || (Xt = {}));
const Ahe = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Pb;
try {
    Pb = new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")
} catch {}
function khe(t) {
    if (Pb)
        return Pb.test(t);
    for (let e = 0; e < t.length; e++) {
        let n = t[e];
        if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || Ahe.test(n)))
            return !0
    }
    return !1
}
function Rhe(t) {
    return e => {
        if (!/\S/.test(e))
            return Xt.Space;
        if (khe(e))
            return Xt.Word;
        for (let n = 0; n < t.length; n++)
            if (e.indexOf(t[n]) > -1)
                return Xt.Word;
        return Xt.Other
    }
}
class lt {
    constructor(e, n, r, i, s, o) {
        this.config = e,
        this.doc = n,
        this.selection = r,
        this.values = i,
        this.status = e.statusTemplate.slice(),
        this.computeSlot = s,
        o && (o._state = this);
        for (let a = 0; a < this.config.dynamicSlots.length; a++)
            nu(this, a << 1);
        this.computeSlot = null
    }
    field(e, n=!0) {
        let r = this.config.address[e.id];
        if (r == null) {
            if (n)
                throw new RangeError("Field is not present in this state");
            return
        }
        return nu(this, r),
        Op(this, r)
    }
    update(...e) {
        return JM(this, e, !0)
    }
    applyTransaction(e) {
        let n = this.config
          , {base: r, compartments: i} = n;
        for (let a of e.effects)
            a.is(oa.reconfigure) ? (n && (i = new Map,
            n.compartments.forEach( (l, c) => i.set(c, l)),
            n = null),
            i.set(a.value.compartment, a.value.extension)) : a.is(Je.reconfigure) ? (n = null,
            r = a.value) : a.is(Je.appendConfig) && (n = null,
            r = ml(r).concat(a.value));
        let s;
        n ? s = e.startState.values.slice() : (n = Lp.resolve(r, i, this),
        s = new lt(n,this.doc,this.selection,n.dynamicSlots.map( () => null), (l, c) => c.reconfigure(l, this),null).values);
        let o = e.startState.facet(Rb) ? e.newSelection : e.newSelection.asSingle();
        new lt(n,e.newDoc,o,s, (a, l) => l.update(a, e),e)
    }
    replaceSelection(e) {
        return typeof e == "string" && (e = this.toText(e)),
        this.changeByRange(n => ({
            changes: {
                from: n.from,
                to: n.to,
                insert: e
            },
            range: ge.cursor(n.from + e.length)
        }))
    }
    changeByRange(e) {
        let n = this.selection
          , r = e(n.ranges[0])
          , i = this.changes(r.changes)
          , s = [r.range]
          , o = ml(r.effects);
        for (let a = 1; a < n.ranges.length; a++) {
            let l = e(n.ranges[a])
              , c = this.changes(l.changes)
              , u = c.map(i);
            for (let d = 0; d < a; d++)
                s[d] = s[d].map(u);
            let h = i.mapDesc(c, !0);
            s.push(l.range.map(h)),
            i = i.compose(u),
            o = Je.mapEffects(o, u).concat(Je.mapEffects(ml(l.effects), h))
        }
        return {
            changes: i,
            selection: ge.create(s, n.mainIndex),
            effects: o
        }
    }
    changes(e=[]) {
        return e instanceof Zt ? e : Zt.of(e, this.doc.length, this.facet(lt.lineSeparator))
    }
    toText(e) {
        return gt.of(e.split(this.facet(lt.lineSeparator) || wb))
    }
    sliceDoc(e=0, n=this.doc.length) {
        return this.doc.sliceString(e, n, this.lineBreak)
    }
    facet(e) {
        let n = this.config.address[e.id];
        return n == null ? e.default : (nu(this, n),
        Op(this, n))
    }
    toJSON(e) {
        let n = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (e)
            for (let r in e) {
                let i = e[r];
                i instanceof Qt && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this))
            }
        return n
    }
    static fromJSON(e, n={}, r) {
        if (!e || typeof e.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let i = [];
        if (r) {
            for (let s in r)
                if (Object.prototype.hasOwnProperty.call(e, s)) {
                    let o = r[s]
                      , a = e[s];
                    i.push(o.init(l => o.spec.fromJSON(a, l)))
                }
        }
        return lt.create({
            doc: e.doc,
            selection: ge.fromJSON(e.selection),
            extensions: n.extensions ? i.concat([n.extensions]) : i
        })
    }
    static create(e={}) {
        let n = Lp.resolve(e.extensions || [], new Map)
          , r = e.doc instanceof gt ? e.doc : gt.of((e.doc || "").split(n.staticFacet(lt.lineSeparator) || wb))
          , i = e.selection ? e.selection instanceof ge ? e.selection : ge.single(e.selection.anchor, e.selection.head) : ge.single(0);
        return $M(i, r.length),
        n.staticFacet(Rb) || (i = i.asSingle()),
        new lt(n,r,i,n.dynamicSlots.map( () => null), (s, o) => o.create(s),null)
    }
    get tabSize() {
        return this.facet(lt.tabSize)
    }
    get lineBreak() {
        return this.facet(lt.lineSeparator) || `
`
    }
    get readOnly() {
        return this.facet(XM)
    }
    phrase(e, ...n) {
        for (let r of this.facet(lt.phrases))
            if (Object.prototype.hasOwnProperty.call(r, e)) {
                e = r[e];
                break
            }
        return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
            if (i == "$")
                return "$";
            let s = +(i || 1);
            return !s || s > n.length ? r : n[s - 1]
        }
        )),
        e
    }
    languageDataAt(e, n, r=-1) {
        let i = [];
        for (let s of this.facet(WM))
            for (let o of s(this, n, r))
                Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
        return i
    }
    charCategorizer(e) {
        return Rhe(this.languageDataAt("wordChars", e).join(""))
    }
    wordAt(e) {
        let {text: n, from: r, length: i} = this.doc.lineAt(e)
          , s = this.charCategorizer(e)
          , o = e - r
          , a = e - r;
        for (; o > 0; ) {
            let l = yn(n, o, !1);
            if (s(n.slice(l, o)) != Xt.Word)
                break;
            o = l
        }
        for (; a < i; ) {
            let l = yn(n, a);
            if (s(n.slice(a, l)) != Xt.Word)
                break;
            a = l
        }
        return o == a ? null : ge.range(o + r, a + r)
    }
}
lt.allowMultipleSelections = Rb;
lt.tabSize = Me.define({
    combine: t => t.length ? t[0] : 4
});
lt.lineSeparator = GM;
lt.readOnly = XM;
lt.phrases = Me.define({
    compare(t, e) {
        let n = Object.keys(t)
          , r = Object.keys(e);
        return n.length == r.length && n.every(i => t[i] == e[i])
    }
});
lt.languageData = WM;
lt.changeFilter = qM;
lt.transactionFilter = KM;
lt.transactionExtender = YM;
oa.reconfigure = Je.define();
function Aa(t, e, n={}) {
    let r = {};
    for (let i of t)
        for (let s of Object.keys(i)) {
            let o = i[s]
              , a = r[s];
            if (a === void 0)
                r[s] = o;
            else if (!(a === o || o === void 0))
                if (Object.hasOwnProperty.call(n, s))
                    r[s] = n[s](a, o);
                else
                    throw new Error("Config merge conflict for field " + s)
        }
    for (let i in e)
        r[i] === void 0 && (r[i] = e[i]);
    return r
}
class aa {
    eq(e) {
        return this == e
    }
    range(e, n=e) {
        return Db.create(e, n, this)
    }
}
aa.prototype.startSide = aa.prototype.endSide = 0;
aa.prototype.point = !1;
aa.prototype.mapMode = kn.TrackDel;
let Db = class ZM {
    constructor(e, n, r) {
        this.from = e,
        this.to = n,
        this.value = r
    }
    static create(e, n, r) {
        return new ZM(e,n,r)
    }
}
;
function Lb(t, e) {
    return t.from - e.from || t.value.startSide - e.value.startSide
}
class G1 {
    constructor(e, n, r, i) {
        this.from = e,
        this.to = n,
        this.value = r,
        this.maxPoint = i
    }
    get length() {
        return this.to[this.to.length - 1]
    }
    findIndex(e, n, r, i=0) {
        let s = r ? this.to : this.from;
        for (let o = i, a = s.length; ; ) {
            if (o == a)
                return o;
            let l = o + a >> 1
              , c = s[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
            if (l == o)
                return c >= 0 ? o : a;
            c >= 0 ? a = l : o = l + 1
        }
    }
    between(e, n, r, i) {
        for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
            if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
                return !1
    }
    map(e, n) {
        let r = []
          , i = []
          , s = []
          , o = -1
          , a = -1;
        for (let l = 0; l < this.value.length; l++) {
            let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, d, f;
            if (u == h) {
                let g = n.mapPos(u, c.startSide, c.mapMode);
                if (g == null || (d = f = g,
                c.startSide != c.endSide && (f = n.mapPos(u, c.endSide),
                f < d)))
                    continue
            } else if (d = n.mapPos(u, c.startSide),
            f = n.mapPos(h, c.endSide),
            d > f || d == f && c.startSide > 0 && c.endSide <= 0)
                continue;
            (f - d || c.endSide - c.startSide) < 0 || (o < 0 && (o = d),
            c.point && (a = Math.max(a, f - d)),
            r.push(c),
            i.push(d - o),
            s.push(f - o))
        }
        return {
            mapped: r.length ? new G1(i,s,r,a) : null,
            pos: o
        }
    }
}
class dt {
    constructor(e, n, r, i) {
        this.chunkPos = e,
        this.chunk = n,
        this.nextLayer = r,
        this.maxPoint = i
    }
    static create(e, n, r, i) {
        return new dt(e,n,r,i)
    }
    get length() {
        let e = this.chunk.length - 1;
        return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length)
    }
    get size() {
        if (this.isEmpty)
            return 0;
        let e = this.nextLayer.size;
        for (let n of this.chunk)
            e += n.value.length;
        return e
    }
    chunkEnd(e) {
        return this.chunkPos[e] + this.chunk[e].length
    }
    update(e) {
        let {add: n=[], sort: r=!1, filterFrom: i=0, filterTo: s=this.length} = e
          , o = e.filter;
        if (n.length == 0 && !o)
            return this;
        if (r && (n = n.slice().sort(Lb)),
        this.isEmpty)
            return n.length ? dt.of(n) : this;
        let a = new e3(this,null,-1).goto(0)
          , l = 0
          , c = []
          , u = new la;
        for (; a.value || l < n.length; )
            if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
                let h = n[l++];
                u.addInner(h.from, h.to, h.value) || c.push(h)
            } else
                a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(Db.create(a.from, a.to, a.value))),
                a.next());
        return u.finishInner(this.nextLayer.isEmpty && !c.length ? dt.empty : this.nextLayer.update({
            add: c,
            filter: o,
            filterFrom: i,
            filterTo: s
        }))
    }
    map(e) {
        if (e.empty || this.isEmpty)
            return this;
        let n = []
          , r = []
          , i = -1;
        for (let o = 0; o < this.chunk.length; o++) {
            let a = this.chunkPos[o]
              , l = this.chunk[o]
              , c = e.touchesRange(a, a + l.length);
            if (c === !1)
                i = Math.max(i, l.maxPoint),
                n.push(l),
                r.push(e.mapPos(a));
            else if (c === !0) {
                let {mapped: u, pos: h} = l.map(a, e);
                u && (i = Math.max(i, u.maxPoint),
                n.push(u),
                r.push(h))
            }
        }
        let s = this.nextLayer.map(e);
        return n.length == 0 ? s : new dt(r,n,s || dt.empty,i)
    }
    between(e, n, r) {
        if (!this.isEmpty) {
            for (let i = 0; i < this.chunk.length; i++) {
                let s = this.chunkPos[i]
                  , o = this.chunk[i];
                if (n >= s && e <= s + o.length && o.between(s, e - s, n - s, r) === !1)
                    return
            }
            this.nextLayer.between(e, n, r)
        }
    }
    iter(e=0) {
        return Wu.from([this]).goto(e)
    }
    get isEmpty() {
        return this.nextLayer == this
    }
    static iter(e, n=0) {
        return Wu.from(e).goto(n)
    }
    static compare(e, n, r, i, s=-1) {
        let o = e.filter(h => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s)
          , a = n.filter(h => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s)
          , l = eT(o, a, r)
          , c = new pc(o,l,s)
          , u = new pc(a,l,s);
        r.iterGaps( (h, d, f) => tT(c, h, u, d, f, i)),
        r.empty && r.length == 0 && tT(c, 0, u, 0, 0, i)
    }
    static eq(e, n, r=0, i) {
        i == null && (i = 999999999);
        let s = e.filter(u => !u.isEmpty && n.indexOf(u) < 0)
          , o = n.filter(u => !u.isEmpty && e.indexOf(u) < 0);
        if (s.length != o.length)
            return !1;
        if (!s.length)
            return !0;
        let a = eT(s, o)
          , l = new pc(s,a,0).goto(r)
          , c = new pc(o,a,0).goto(r);
        for (; ; ) {
            if (l.to != c.to || !Ob(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
                return !1;
            if (l.to > i)
                return !0;
            l.next(),
            c.next()
        }
    }
    static spans(e, n, r, i, s=-1) {
        let o = new pc(e,null,s).goto(n)
          , a = n
          , l = o.openStart;
        for (; ; ) {
            let c = Math.min(o.to, r);
            if (o.point) {
                let u = o.activeForPoint(o.to)
                  , h = o.pointFrom < n ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
                i.point(a, c, o.point, u, h, o.pointRank),
                l = Math.min(o.openEnd(c), u.length)
            } else
                c > a && (i.span(a, c, o.active, l),
                l = o.openEnd(c));
            if (o.to > r)
                return l + (o.point && o.to > r ? 1 : 0);
            a = o.to,
            o.next()
        }
    }
    static of(e, n=!1) {
        let r = new la;
        for (let i of e instanceof Db ? [e] : n ? Ihe(e) : e)
            r.add(i.from, i.to, i.value);
        return r.finish()
    }
    static join(e) {
        if (!e.length)
            return dt.empty;
        let n = e[e.length - 1];
        for (let r = e.length - 2; r >= 0; r--)
            for (let i = e[r]; i != dt.empty; i = i.nextLayer)
                n = new dt(i.chunkPos,i.chunk,n,Math.max(i.maxPoint, n.maxPoint));
        return n
    }
}
dt.empty = new dt([],[],null,-1);
function Ihe(t) {
    if (t.length > 1)
        for (let e = t[0], n = 1; n < t.length; n++) {
            let r = t[n];
            if (Lb(e, r) > 0)
                return t.slice().sort(Lb);
            e = r
        }
    return t
}
dt.empty.nextLayer = dt.empty;
class la {
    finishChunk(e) {
        this.chunks.push(new G1(this.from,this.to,this.value,this.maxPoint)),
        this.chunkPos.push(this.chunkStart),
        this.chunkStart = -1,
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint),
        this.maxPoint = -1,
        e && (this.from = [],
        this.to = [],
        this.value = [])
    }
    constructor() {
        this.chunks = [],
        this.chunkPos = [],
        this.chunkStart = -1,
        this.last = null,
        this.lastFrom = -1e9,
        this.lastTo = -1e9,
        this.from = [],
        this.to = [],
        this.value = [],
        this.maxPoint = -1,
        this.setMaxPoint = -1,
        this.nextLayer = null
    }
    add(e, n, r) {
        this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new la)).add(e, n, r)
    }
    addInner(e, n, r) {
        let i = e - this.lastTo || r.startSide - this.last.endSide;
        if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0),
        this.chunkStart < 0 && (this.chunkStart = e),
        this.from.push(e - this.chunkStart),
        this.to.push(n - this.chunkStart),
        this.last = r,
        this.lastFrom = e,
        this.lastTo = n,
        this.value.push(r),
        r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)),
        !0)
    }
    addChunk(e, n) {
        if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
            return !1;
        this.from.length && this.finishChunk(!0),
        this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint),
        this.chunks.push(n),
        this.chunkPos.push(e);
        let r = n.value.length - 1;
        return this.last = n.value[r],
        this.lastFrom = n.from[r] + e,
        this.lastTo = n.to[r] + e,
        !0
    }
    finish() {
        return this.finishInner(dt.empty)
    }
    finishInner(e) {
        if (this.from.length && this.finishChunk(!1),
        this.chunks.length == 0)
            return e;
        let n = dt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
        return this.from = null,
        n
    }
}
function eT(t, e, n) {
    let r = new Map;
    for (let s of t)
        for (let o = 0; o < s.chunk.length; o++)
            s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
    let i = new Set;
    for (let s of e)
        for (let o = 0; o < s.chunk.length; o++) {
            let a = r.get(s.chunk[o]);
            a != null && (n ? n.mapPos(a) : a) == s.chunkPos[o] && !n?.touchesRange(a, a + s.chunk[o].length) && i.add(s.chunk[o])
        }
    return i
}
class e3 {
    constructor(e, n, r, i=0) {
        this.layer = e,
        this.skip = n,
        this.minPoint = r,
        this.rank = i
    }
    get startSide() {
        return this.value ? this.value.startSide : 0
    }
    get endSide() {
        return this.value ? this.value.endSide : 0
    }
    goto(e, n=-1e9) {
        return this.chunkIndex = this.rangeIndex = 0,
        this.gotoInner(e, n, !1),
        this
    }
    gotoInner(e, n, r) {
        for (; this.chunkIndex < this.layer.chunk.length; ) {
            let i = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
                break;
            this.chunkIndex++,
            r = !1
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
            (!r || this.rangeIndex < i) && this.setRangeIndex(i)
        }
        this.next()
    }
    forward(e, n) {
        (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0)
    }
    next() {
        for (; ; )
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1e9,
                this.value = null;
                break
            } else {
                let e = this.layer.chunkPos[this.chunkIndex]
                  , n = this.layer.chunk[this.chunkIndex]
                  , r = e + n.from[this.rangeIndex];
                if (this.from = r,
                this.to = e + n.to[this.rangeIndex],
                this.value = n.value[this.rangeIndex],
                this.setRangeIndex(this.rangeIndex + 1),
                this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break
            }
    }
    setRangeIndex(e) {
        if (e == this.layer.chunk[this.chunkIndex].value.length) {
            if (this.chunkIndex++,
            this.skip)
                for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
                    this.chunkIndex++;
            this.rangeIndex = 0
        } else
            this.rangeIndex = e
    }
    nextChunk() {
        this.chunkIndex++,
        this.rangeIndex = 0,
        this.next()
    }
    compare(e) {
        return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide
    }
}
class Wu {
    constructor(e) {
        this.heap = e
    }
    static from(e, n=null, r=-1) {
        let i = [];
        for (let s = 0; s < e.length; s++)
            for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
                o.maxPoint >= r && i.push(new e3(o,n,r,s));
        return i.length == 1 ? i[0] : new Wu(i)
    }
    get startSide() {
        return this.value ? this.value.startSide : 0
    }
    goto(e, n=-1e9) {
        for (let r of this.heap)
            r.goto(e, n);
        for (let r = this.heap.length >> 1; r >= 0; r--)
            P0(this.heap, r);
        return this.next(),
        this
    }
    forward(e, n) {
        for (let r of this.heap)
            r.forward(e, n);
        for (let r = this.heap.length >> 1; r >= 0; r--)
            P0(this.heap, r);
        (this.to - e || this.value.endSide - n) < 0 && this.next()
    }
    next() {
        if (this.heap.length == 0)
            this.from = this.to = 1e9,
            this.value = null,
            this.rank = -1;
        else {
            let e = this.heap[0];
            this.from = e.from,
            this.to = e.to,
            this.value = e.value,
            this.rank = e.rank,
            e.value && e.next(),
            P0(this.heap, 0)
        }
    }
}
function P0(t, e) {
    for (let n = t[e]; ; ) {
        let r = (e << 1) + 1;
        if (r >= t.length)
            break;
        let i = t[r];
        if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1],
        r++),
        n.compare(i) < 0)
            break;
        t[r] = n,
        t[e] = i,
        e = r
    }
}
class pc {
    constructor(e, n, r) {
        this.minPoint = r,
        this.active = [],
        this.activeTo = [],
        this.activeRank = [],
        this.minActive = -1,
        this.point = null,
        this.pointFrom = 0,
        this.pointRank = 0,
        this.to = -1e9,
        this.endSide = 0,
        this.openStart = -1,
        this.cursor = Wu.from(e, n, r)
    }
    goto(e, n=-1e9) {
        return this.cursor.goto(e, n),
        this.active.length = this.activeTo.length = this.activeRank.length = 0,
        this.minActive = -1,
        this.to = e,
        this.endSide = n,
        this.openStart = -1,
        this.next(),
        this
    }
    forward(e, n) {
        for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
            this.removeActive(this.minActive);
        this.cursor.forward(e, n)
    }
    removeActive(e) {
        Bd(this.active, e),
        Bd(this.activeTo, e),
        Bd(this.activeRank, e),
        this.minActive = nT(this.active, this.activeTo)
    }
    addActive(e) {
        let n = 0
          , {value: r, to: i, rank: s} = this.cursor;
        for (; n < this.activeRank.length && (s - this.activeRank[n] || i - this.activeTo[n]) > 0; )
            n++;
        Fd(this.active, n, r),
        Fd(this.activeTo, n, i),
        Fd(this.activeRank, n, s),
        e && Fd(e, n, this.cursor.from),
        this.minActive = nT(this.active, this.activeTo)
    }
    next() {
        let e = this.to
          , n = this.point;
        this.point = null;
        let r = this.openStart < 0 ? [] : null;
        for (; ; ) {
            let i = this.minActive;
            if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[i] > e) {
                    this.to = this.activeTo[i],
                    this.endSide = this.active[i].endSide;
                    break
                }
                this.removeActive(i),
                r && Bd(r, i)
            } else if (this.cursor.value)
                if (this.cursor.from > e) {
                    this.to = this.cursor.from,
                    this.endSide = this.cursor.startSide;
                    break
                } else {
                    let s = this.cursor.value;
                    if (!s.point)
                        this.addActive(r),
                        this.cursor.next();
                    else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
                        this.cursor.next();
                    else {
                        this.point = s,
                        this.pointFrom = this.cursor.from,
                        this.pointRank = this.cursor.rank,
                        this.to = this.cursor.to,
                        this.endSide = s.endSide,
                        this.cursor.next(),
                        this.forward(this.to, this.endSide);
                        break
                    }
                }
            else {
                this.to = this.endSide = 1e9;
                break
            }
        }
        if (r) {
            this.openStart = 0;
            for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
                this.openStart++
        }
    }
    activeForPoint(e) {
        if (!this.active.length)
            return this.active;
        let n = [];
        for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
            (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
        return n.reverse()
    }
    openEnd(e) {
        let n = 0;
        for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
            n++;
        return n
    }
}
function tT(t, e, n, r, i, s) {
    t.goto(e),
    n.goto(r);
    let o = r + i
      , a = r
      , l = r - e;
    for (; ; ) {
        let c = t.to + l - n.to || t.endSide - n.endSide
          , u = c < 0 ? t.to + l : n.to
          , h = Math.min(u, o);
        if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && Ob(t.activeForPoint(t.to), n.activeForPoint(n.to)) || s.comparePoint(a, h, t.point, n.point) : h > a && !Ob(t.active, n.active) && s.compareRange(a, h, t.active, n.active),
        u > o)
            break;
        a = u,
        c <= 0 && t.next(),
        c >= 0 && n.next()
    }
}
function Ob(t, e) {
    if (t.length != e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] != e[n] && !t[n].eq(e[n]))
            return !1;
    return !0
}
function Bd(t, e) {
    for (let n = e, r = t.length - 1; n < r; n++)
        t[n] = t[n + 1];
    t.pop()
}
function Fd(t, e, n) {
    for (let r = t.length - 1; r >= e; r--)
        t[r + 1] = t[r];
    t[e] = n
}
function nT(t, e) {
    let n = -1
      , r = 1e9;
    for (let i = 0; i < e.length; i++)
        (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i,
        r = e[i]);
    return n
}
function lg(t, e, n=t.length) {
    let r = 0;
    for (let i = 0; i < n; )
        t.charCodeAt(i) == 9 ? (r += e - r % e,
        i++) : (r++,
        i = yn(t, i));
    return r
}
function Phe(t, e, n, r) {
    for (let i = 0, s = 0; ; ) {
        if (s >= e)
            return i;
        if (i == t.length)
            break;
        s += t.charCodeAt(i) == 9 ? n - s % n : 1,
        i = yn(t, i)
    }
    return r === !0 ? -1 : t.length
}
const Nb = ""
  , rT = typeof Symbol > "u" ? "__" + Nb : Symbol.for(Nb)
  , Mb = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet")
  , iT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Qs {
    constructor(e, n) {
        this.rules = [];
        let {finish: r} = n || {};
        function i(o) {
            return /^@/.test(o) ? [o] : o.split(/,\s*/)
        }
        function s(o, a, l, c) {
            let u = []
              , h = /^@(\w+)\b/.exec(o[0])
              , d = h && h[1] == "keyframes";
            if (h && a == null)
                return l.push(o[0] + ";");
            for (let f in a) {
                let g = a[f];
                if (/&/.test(f))
                    s(f.split(/,\s*/).map(_ => o.map(m => _.replace(/&/, m))).reduce( (_, m) => _.concat(m)), g, l);
                else if (g && typeof g == "object") {
                    if (!h)
                        throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
                    s(i(f), g, u, d)
                } else
                    g != null && u.push(f.replace(/_.*/, "").replace(/[A-Z]/g, _ => "-" + _.toLowerCase()) + ": " + g + ";")
            }
            (u.length || d) && l.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}")
        }
        for (let o in e)
            s(i(o), e[o], this.rules)
    }
    getRules() {
        return this.rules.join(`
`)
    }
    static newName() {
        let e = iT[rT] || 1;
        return iT[rT] = e + 1,
        Nb + e.toString(36)
    }
    static mount(e, n, r) {
        let i = e[Mb]
          , s = r && r.nonce;
        i ? s && i.setNonce(s) : i = new Dhe(e,s),
        i.mount(Array.isArray(n) ? n : [n], e)
    }
}
let sT = new Map;
class Dhe {
    constructor(e, n) {
        let r = e.ownerDocument || e
          , i = r.defaultView;
        if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
            let s = sT.get(r);
            if (s)
                return e[Mb] = s;
            this.sheet = new i.CSSStyleSheet,
            sT.set(r, this)
        } else
            this.styleTag = r.createElement("style"),
            n && this.styleTag.setAttribute("nonce", n);
        this.modules = [],
        e[Mb] = this
    }
    mount(e, n) {
        let r = this.sheet
          , i = 0
          , s = 0;
        for (let o = 0; o < e.length; o++) {
            let a = e[o]
              , l = this.modules.indexOf(a);
            if (l < s && l > -1 && (this.modules.splice(l, 1),
            s--,
            l = -1),
            l == -1) {
                if (this.modules.splice(s++, 0, a),
                r)
                    for (let c = 0; c < a.rules.length; c++)
                        r.insertRule(a.rules[c], i++)
            } else {
                for (; s < l; )
                    i += this.modules[s++].rules.length;
                i += a.rules.length,
                s++
            }
        }
        if (r)
            n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
        else {
            let o = "";
            for (let l = 0; l < this.modules.length; l++)
                o += this.modules[l].getRules() + `
`;
            this.styleTag.textContent = o;
            let a = n.head || n;
            this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild)
        }
    }
    setNonce(e) {
        this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e)
    }
}
var Js = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
}
  , Gu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
}
  , Lhe = typeof navigator < "u" && /Mac/.test(navigator.platform)
  , Ohe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var gn = 0; gn < 10; gn++)
    Js[48 + gn] = Js[96 + gn] = String(gn);
for (var gn = 1; gn <= 24; gn++)
    Js[gn + 111] = "F" + gn;
for (var gn = 65; gn <= 90; gn++)
    Js[gn] = String.fromCharCode(gn + 32),
    Gu[gn] = String.fromCharCode(gn);
for (var D0 in Js)
    Gu.hasOwnProperty(D0) || (Gu[D0] = Js[D0]);
function Nhe(t) {
    var e = Lhe && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || Ohe && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified"
      , n = !e && t.key || (t.shiftKey ? Gu : Js)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
}
function qu(t) {
    let e;
    return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t,
    e.getSelection()
}
function Bb(t, e) {
    return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1
}
function Mhe(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot; )
        e = e.shadowRoot.activeElement;
    return e
}
function Cf(t, e) {
    if (!e.anchorNode)
        return !1;
    try {
        return Bb(t, e.anchorNode)
    } catch {
        return !1
    }
}
function Ku(t) {
    return t.nodeType == 3 ? ua(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : []
}
function ru(t, e, n, r) {
    return n ? oT(t, e, n, r, -1) || oT(t, e, n, r, 1) : !1
}
function ca(t) {
    for (var e = 0; ; e++)
        if (t = t.previousSibling,
        !t)
            return e
}
function Np(t) {
    return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName)
}
function oT(t, e, n, r, i) {
    for (; ; ) {
        if (t == n && e == r)
            return !0;
        if (e == (i < 0 ? 0 : os(t))) {
            if (t.nodeName == "DIV")
                return !1;
            let s = t.parentNode;
            if (!s || s.nodeType != 1)
                return !1;
            e = ca(t) + (i < 0 ? 0 : 1),
            t = s
        } else if (t.nodeType == 1) {
            if (t = t.childNodes[e + (i < 0 ? -1 : 0)],
            t.nodeType == 1 && t.contentEditable == "false")
                return !1;
            e = i < 0 ? os(t) : 0
        } else
            return !1
    }
}
function os(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function q1(t, e) {
    let n = e ? t.left : t.right;
    return {
        left: n,
        right: n,
        top: t.top,
        bottom: t.bottom
    }
}
function Bhe(t) {
    let e = t.visualViewport;
    return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
    } : {
        left: 0,
        right: t.innerWidth,
        top: 0,
        bottom: t.innerHeight
    }
}
function t3(t, e) {
    let n = e.width / t.offsetWidth
      , r = e.height / t.offsetHeight;
    return (n > .995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1),
    (r > .995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1),
    {
        scaleX: n,
        scaleY: r
    }
}
function Fhe(t, e, n, r, i, s, o, a) {
    let l = t.ownerDocument
      , c = l.defaultView || window;
    for (let u = t, h = !1; u && !h; )
        if (u.nodeType == 1) {
            let d, f = u == l.body, g = 1, _ = 1;
            if (f)
                d = Bhe(c);
            else {
                if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0),
                u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
                    u = u.assignedSlot || u.parentNode;
                    continue
                }
                let b = u.getBoundingClientRect();
                ({scaleX: g, scaleY: _} = t3(u, b)),
                d = {
                    left: b.left,
                    right: b.left + u.clientWidth * g,
                    top: b.top,
                    bottom: b.top + u.clientHeight * _
                }
            }
            let m = 0
              , p = 0;
            if (i == "nearest")
                e.top < d.top ? (p = -(d.top - e.top + o),
                n > 0 && e.bottom > d.bottom + p && (p = e.bottom - d.bottom + p + o)) : e.bottom > d.bottom && (p = e.bottom - d.bottom + o,
                n < 0 && e.top - p < d.top && (p = -(d.top + p - e.top + o)));
            else {
                let b = e.bottom - e.top
                  , y = d.bottom - d.top;
                p = (i == "center" && b <= y ? e.top + b / 2 - y / 2 : i == "start" || i == "center" && n < 0 ? e.top - o : e.bottom - y + o) - d.top
            }
            if (r == "nearest" ? e.left < d.left ? (m = -(d.left - e.left + s),
            n > 0 && e.right > d.right + m && (m = e.right - d.right + m + s)) : e.right > d.right && (m = e.right - d.right + s,
            n < 0 && e.left < d.left + m && (m = -(d.left + m - e.left + s))) : m = (r == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : r == "start" == a ? e.left - s : e.right - (d.right - d.left) + s) - d.left,
            m || p)
                if (f)
                    c.scrollBy(m, p);
                else {
                    let b = 0
                      , y = 0;
                    if (p) {
                        let x = u.scrollTop;
                        u.scrollTop += p / _,
                        y = (u.scrollTop - x) * _
                    }
                    if (m) {
                        let x = u.scrollLeft;
                        u.scrollLeft += m / g,
                        b = (u.scrollLeft - x) * g
                    }
                    e = {
                        left: e.left - b,
                        top: e.top - y,
                        right: e.right - b,
                        bottom: e.bottom - y
                    },
                    b && Math.abs(b - m) < 1 && (r = "nearest"),
                    y && Math.abs(y - p) < 1 && (i = "nearest")
                }
            if (f)
                break;
            u = u.assignedSlot || u.parentNode
        } else if (u.nodeType == 11)
            u = u.host;
        else
            break
}
function jhe(t) {
    let e = t.ownerDocument;
    for (let n = t.parentNode; n && n != e.body; )
        if (n.nodeType == 1) {
            if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)
                return n;
            n = n.assignedSlot || n.parentNode
        } else if (n.nodeType == 11)
            n = n.host;
        else
            break;
    return null
}
class Hhe {
    constructor() {
        this.anchorNode = null,
        this.anchorOffset = 0,
        this.focusNode = null,
        this.focusOffset = 0
    }
    eq(e) {
        return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset
    }
    setRange(e) {
        let {anchorNode: n, focusNode: r} = e;
        this.set(n, Math.min(e.anchorOffset, n ? os(n) : 0), r, Math.min(e.focusOffset, r ? os(r) : 0))
    }
    set(e, n, r, i) {
        this.anchorNode = e,
        this.anchorOffset = n,
        this.focusNode = r,
        this.focusOffset = i
    }
}
let Ha = null;
function n3(t) {
    if (t.setActive)
        return t.setActive();
    if (Ha)
        return t.focus(Ha);
    let e = [];
    for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft),
    n != n.ownerDocument); n = n.parentNode)
        ;
    if (t.focus(Ha == null ? {
        get preventScroll() {
            return Ha = {
                preventScroll: !0
            },
            !0
        }
    } : void 0),
    !Ha) {
        Ha = !1;
        for (let n = 0; n < e.length; ) {
            let r = e[n++]
              , i = e[n++]
              , s = e[n++];
            r.scrollTop != i && (r.scrollTop = i),
            r.scrollLeft != s && (r.scrollLeft = s)
        }
    }
}
let aT;
function ua(t, e, n=e) {
    let r = aT || (aT = document.createRange());
    return r.setEnd(t, n),
    r.setStart(t, e),
    r
}
function gl(t, e, n, r) {
    let i = {
        key: e,
        code: e,
        keyCode: n,
        which: n,
        cancelable: !0
    };
    r && ({altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey} = r);
    let s = new KeyboardEvent("keydown",i);
    s.synthetic = !0,
    t.dispatchEvent(s);
    let o = new KeyboardEvent("keyup",i);
    return o.synthetic = !0,
    t.dispatchEvent(o),
    s.defaultPrevented || o.defaultPrevented
}
function Uhe(t) {
    for (; t; ) {
        if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
            return t;
        t = t.assignedSlot || t.parentNode
    }
    return null
}
function r3(t) {
    for (; t.attributes.length; )
        t.removeAttributeNode(t.attributes[0])
}
function Vhe(t, e) {
    let n = e.focusNode
      , r = e.focusOffset;
    if (!n || e.anchorNode != n || e.anchorOffset != r)
        return !1;
    for (r = Math.min(r, os(n)); ; )
        if (r) {
            if (n.nodeType != 1)
                return !1;
            let i = n.childNodes[r - 1];
            i.contentEditable == "false" ? r-- : (n = i,
            r = os(n))
        } else {
            if (n == t)
                return !0;
            r = ca(n),
            n = n.parentNode
        }
}
function i3(t) {
    return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4)
}
function s3(t, e) {
    for (let n = t, r = e; ; ) {
        if (n.nodeType == 3 && r > 0)
            return {
                node: n,
                offset: r
            };
        if (n.nodeType == 1 && r > 0) {
            if (n.contentEditable == "false")
                return null;
            n = n.childNodes[r - 1],
            r = os(n)
        } else if (n.parentNode && !Np(n))
            r = ca(n),
            n = n.parentNode;
        else
            return null
    }
}
function o3(t, e) {
    for (let n = t, r = e; ; ) {
        if (n.nodeType == 3 && r < n.nodeValue.length)
            return {
                node: n,
                offset: r
            };
        if (n.nodeType == 1 && r < n.childNodes.length) {
            if (n.contentEditable == "false")
                return null;
            n = n.childNodes[r],
            r = 0
        } else if (n.parentNode && !Np(n))
            r = ca(n) + 1,
            n = n.parentNode;
        else
            return null
    }
}
class Rn {
    constructor(e, n, r=!0) {
        this.node = e,
        this.offset = n,
        this.precise = r
    }
    static before(e, n) {
        return new Rn(e.parentNode,ca(e),n)
    }
    static after(e, n) {
        return new Rn(e.parentNode,ca(e) + 1,n)
    }
}
const K1 = [];
class Tt {
    constructor() {
        this.parent = null,
        this.dom = null,
        this.flags = 2
    }
    get overrideDOMText() {
        return null
    }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0
    }
    get posAtEnd() {
        return this.posAtStart + this.length
    }
    posBefore(e) {
        let n = this.posAtStart;
        for (let r of this.children) {
            if (r == e)
                return n;
            n += r.length + r.breakAfter
        }
        throw new RangeError("Invalid child in posBefore")
    }
    posAfter(e) {
        return this.posBefore(e) + e.length
    }
    sync(e, n) {
        if (this.flags & 2) {
            let r = this.dom, i = null, s;
            for (let o of this.children) {
                if (o.flags & 7) {
                    if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
                        let a = Tt.get(s);
                        (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s)
                    }
                    o.sync(e, n),
                    o.flags &= -8
                }
                if (s = i ? i.nextSibling : r.firstChild,
                n && !n.written && n.node == r && s != o.dom && (n.written = !0),
                o.dom.parentNode == r)
                    for (; s && s != o.dom; )
                        s = lT(s);
                else
                    r.insertBefore(o.dom, s);
                i = o.dom
            }
            for (s = i ? i.nextSibling : r.firstChild,
            s && n && n.node == r && (n.written = !0); s; )
                s = lT(s)
        } else if (this.flags & 1)
            for (let r of this.children)
                r.flags & 7 && (r.sync(e, n),
                r.flags &= -8)
    }
    reuseDOM(e) {}
    localPosFromDOM(e, n) {
        let r;
        if (e == this.dom)
            r = this.dom.childNodes[n];
        else {
            let i = os(e) == 0 ? 0 : n == 0 ? -1 : 1;
            for (; ; ) {
                let s = e.parentNode;
                if (s == this.dom)
                    break;
                i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1),
                e = s
            }
            i < 0 ? r = e : r = e.nextSibling
        }
        if (r == this.dom.firstChild)
            return 0;
        for (; r && !Tt.get(r); )
            r = r.nextSibling;
        if (!r)
            return this.length;
        for (let i = 0, s = 0; ; i++) {
            let o = this.children[i];
            if (o.dom == r)
                return s;
            s += o.length + o.breakAfter
        }
    }
    domBoundsAround(e, n, r=0) {
        let i = -1
          , s = -1
          , o = -1
          , a = -1;
        for (let l = 0, c = r, u = r; l < this.children.length; l++) {
            let h = this.children[l]
              , d = c + h.length;
            if (c < e && d > n)
                return h.domBoundsAround(e, n, c);
            if (d >= e && i == -1 && (i = l,
            s = c),
            c > n && h.dom.parentNode == this.dom) {
                o = l,
                a = u;
                break
            }
            u = d,
            c = d + h.breakAfter
        }
        return {
            from: s,
            to: a < 0 ? r + this.length : a,
            startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
        }
    }
    markDirty(e=!1) {
        this.flags |= 2,
        this.markParentsDirty(e)
    }
    markParentsDirty(e) {
        for (let n = this.parent; n; n = n.parent) {
            if (e && (n.flags |= 2),
            n.flags & 1)
                return;
            n.flags |= 1,
            e = !1
        }
    }
    setParent(e) {
        this.parent != e && (this.parent = e,
        this.flags & 7 && this.markParentsDirty(!0))
    }
    setDOM(e) {
        this.dom != e && (this.dom && (this.dom.cmView = null),
        this.dom = e,
        e.cmView = this)
    }
    get rootView() {
        for (let e = this; ; ) {
            let n = e.parent;
            if (!n)
                return e;
            e = n
        }
    }
    replaceChildren(e, n, r=K1) {
        this.markDirty();
        for (let i = e; i < n; i++) {
            let s = this.children[i];
            s.parent == this && r.indexOf(s) < 0 && s.destroy()
        }
        this.children.splice(e, n - e, ...r);
        for (let i = 0; i < r.length; i++)
            r[i].setParent(this)
    }
    ignoreMutation(e) {
        return !1
    }
    ignoreEvent(e) {
        return !1
    }
    childCursor(e=this.length) {
        return new a3(this.children,e,this.children.length)
    }
    childPos(e, n=1) {
        return this.childCursor().findPos(e, n)
    }
    toString() {
        let e = this.constructor.name.replace("View", "");
        return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "")
    }
    static get(e) {
        return e.cmView
    }
    get isEditable() {
        return !0
    }
    get isWidget() {
        return !1
    }
    get isHidden() {
        return !1
    }
    merge(e, n, r, i, s, o) {
        return !1
    }
    become(e) {
        return !1
    }
    canReuseDOM(e) {
        return e.constructor == this.constructor && !((this.flags | e.flags) & 8)
    }
    getSide() {
        return 0
    }
    destroy() {
        for (let e of this.children)
            e.parent == this && e.destroy();
        this.parent = null
    }
}
Tt.prototype.breakAfter = 0;
function lT(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t),
    e
}
class a3 {
    constructor(e, n, r) {
        this.children = e,
        this.pos = n,
        this.i = r,
        this.off = 0
    }
    findPos(e, n=1) {
        for (; ; ) {
            if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
                return this.off = e - this.pos,
                this;
            let r = this.children[--this.i];
            this.pos -= r.length + r.breakAfter
        }
    }
}
function l3(t, e, n, r, i, s, o, a, l) {
    let {children: c} = t
      , u = c.length ? c[e] : null
      , h = s.length ? s[s.length - 1] : null
      , d = h ? h.breakAfter : o;
    if (!(e == r && u && !o && !d && s.length < 2 && u.merge(n, i, s.length ? h : null, n == 0, a, l))) {
        if (r < c.length) {
            let f = c[r];
            f && (i < f.length || f.breakAfter && h?.breakAfter) ? (e == r && (f = f.split(i),
            i = 0),
            !d && h && f.merge(0, i, h, !0, 0, l) ? s[s.length - 1] = f : ((i || f.children.length && !f.children[0].length) && f.merge(0, i, null, !1, 0, l),
            s.push(f))) : f?.breakAfter && (h ? h.breakAfter = 1 : o = 1),
            r++
        }
        for (u && (u.breakAfter = o,
        n > 0 && (!o && s.length && u.merge(n, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, !1, a, 0),
        e++)); e < r && s.length; )
            if (c[r - 1].become(s[s.length - 1]))
                r--,
                s.pop(),
                l = s.length ? 0 : a;
            else if (c[e].become(s[0]))
                e++,
                s.shift(),
                a = s.length ? 0 : l;
            else
                break;
        !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--,
        (e < r || s.length) && t.replaceChildren(e, r, s)
    }
}
function c3(t, e, n, r, i, s) {
    let o = t.childCursor()
      , {i: a, off: l} = o.findPos(n, 1)
      , {i: c, off: u} = o.findPos(e, -1)
      , h = e - n;
    for (let d of r)
        h += d.length;
    t.length += h,
    l3(t, c, u, a, l, r, 0, i, s)
}
let Qn = typeof navigator < "u" ? navigator : {
    userAgent: "",
    vendor: "",
    platform: ""
}
  , Fb = typeof document < "u" ? document : {
    documentElement: {
        style: {}
    }
};
const jb = /Edge\/(\d+)/.exec(Qn.userAgent)
  , u3 = /MSIE \d/.test(Qn.userAgent)
  , Hb = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Qn.userAgent)
  , cg = !!(u3 || Hb || jb)
  , cT = !cg && /gecko\/(\d+)/i.test(Qn.userAgent)
  , L0 = !cg && /Chrome\/(\d+)/.exec(Qn.userAgent)
  , uT = "webkitFontSmoothing"in Fb.documentElement.style
  , h3 = !cg && /Apple Computer/.test(Qn.vendor)
  , hT = h3 && (/Mobile\/\w+/.test(Qn.userAgent) || Qn.maxTouchPoints > 2);
var Le = {
    mac: hT || /Mac/.test(Qn.platform),
    windows: /Win/.test(Qn.platform),
    linux: /Linux|X11/.test(Qn.platform),
    ie: cg,
    ie_version: u3 ? Fb.documentMode || 6 : Hb ? +Hb[1] : jb ? +jb[1] : 0,
    gecko: cT,
    gecko_version: cT ? +(/Firefox\/(\d+)/.exec(Qn.userAgent) || [0, 0])[1] : 0,
    chrome: !!L0,
    chrome_version: L0 ? +L0[1] : 0,
    ios: hT,
    android: /Android\b/.test(Qn.userAgent),
    webkit: uT,
    safari: h3,
    webkit_version: uT ? +(/\bAppleWebKit\/(\d+)/.exec(Qn.userAgent) || [0, 0])[1] : 0,
    tabSize: Fb.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const $he = 256;
class ni extends Tt {
    constructor(e) {
        super(),
        this.text = e
    }
    get length() {
        return this.text.length
    }
    createDOM(e) {
        this.setDOM(e || document.createTextNode(this.text))
    }
    sync(e, n) {
        this.dom || this.createDOM(),
        this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0),
        this.dom.nodeValue = this.text)
    }
    reuseDOM(e) {
        e.nodeType == 3 && this.createDOM(e)
    }
    merge(e, n, r) {
        return this.flags & 8 || r && (!(r instanceof ni) || this.length - (n - e) + r.length > $he || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n),
        this.markDirty(),
        !0)
    }
    split(e) {
        let n = new ni(this.text.slice(e));
        return this.text = this.text.slice(0, e),
        this.markDirty(),
        n.flags |= this.flags & 8,
        n
    }
    localPosFromDOM(e, n) {
        return e == this.dom ? n : n ? this.text.length : 0
    }
    domAtPos(e) {
        return new Rn(this.dom,e)
    }
    domBoundsAround(e, n, r) {
        return {
            from: r,
            to: r + this.length,
            startDOM: this.dom,
            endDOM: this.dom.nextSibling
        }
    }
    coordsAt(e, n) {
        return zhe(this.dom, e, n)
    }
}
class as extends Tt {
    constructor(e, n=[], r=0) {
        super(),
        this.mark = e,
        this.children = n,
        this.length = r;
        for (let i of n)
            i.setParent(this)
    }
    setAttrs(e) {
        if (r3(e),
        this.mark.class && (e.className = this.mark.class),
        this.mark.attrs)
            for (let n in this.mark.attrs)
                e.setAttribute(n, this.mark.attrs[n]);
        return e
    }
    canReuseDOM(e) {
        return super.canReuseDOM(e) && !((this.flags | e.flags) & 8)
    }
    reuseDOM(e) {
        e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e),
        this.flags |= 6)
    }
    sync(e, n) {
        this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
        super.sync(e, n)
    }
    merge(e, n, r, i, s, o) {
        return r && (!(r instanceof as && r.mark.eq(this.mark)) || e && s <= 0 || n < this.length && o <= 0) ? !1 : (c3(this, e, n, r ? r.children.slice() : [], s - 1, o - 1),
        this.markDirty(),
        !0)
    }
    split(e) {
        let n = []
          , r = 0
          , i = -1
          , s = 0;
        for (let a of this.children) {
            let l = r + a.length;
            l > e && n.push(r < e ? a.split(e - r) : a),
            i < 0 && r >= e && (i = s),
            r = l,
            s++
        }
        let o = this.length - e;
        return this.length = e,
        i > -1 && (this.children.length = i,
        this.markDirty()),
        new as(this.mark,n,o)
    }
    domAtPos(e) {
        return d3(this, e)
    }
    coordsAt(e, n) {
        return p3(this, e, n)
    }
}
function zhe(t, e, n) {
    let r = t.nodeValue.length;
    e > r && (e = r);
    let i = e
      , s = e
      , o = 0;
    e == 0 && n < 0 || e == r && n >= 0 ? Le.chrome || Le.gecko || (e ? (i--,
    o = 1) : s < r && (s++,
    o = -1)) : n < 0 ? i-- : s < r && s++;
    let a = ua(t, i, s).getClientRects();
    if (!a.length)
        return null;
    let l = a[(o ? o < 0 : n >= 0) ? 0 : a.length - 1];
    return Le.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, c => c.width) || l),
    o ? q1(l, o < 0) : l || null
}
class Lo extends Tt {
    static create(e, n, r) {
        return new Lo(e,n,r)
    }
    constructor(e, n, r) {
        super(),
        this.widget = e,
        this.length = n,
        this.side = r,
        this.prevWidget = null
    }
    split(e) {
        let n = Lo.create(this.widget, this.length - e, this.side);
        return this.length -= e,
        n
    }
    sync(e) {
        (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
        this.prevWidget = null,
        this.setDOM(this.widget.toDOM(e)),
        this.widget.editable || (this.dom.contentEditable = "false"))
    }
    getSide() {
        return this.side
    }
    merge(e, n, r, i, s, o) {
        return r && (!(r instanceof Lo) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n),
        !0)
    }
    become(e) {
        return e instanceof Lo && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        this.widget = e.widget,
        this.length = e.length,
        !0) : !1
    }
    ignoreMutation() {
        return !0
    }
    ignoreEvent(e) {
        return this.widget.ignoreEvent(e)
    }
    get overrideDOMText() {
        if (this.length == 0)
            return gt.empty;
        let e = this;
        for (; e.parent; )
            e = e.parent;
        let {view: n} = e
          , r = n && n.state.doc
          , i = this.posAtStart;
        return r ? r.slice(i, i + this.length) : gt.empty
    }
    domAtPos(e) {
        return (this.length ? e == 0 : this.side > 0) ? Rn.before(this.dom) : Rn.after(this.dom, e == this.length)
    }
    domBoundsAround() {
        return null
    }
    coordsAt(e, n) {
        let r = this.widget.coordsAt(this.dom, e, n);
        if (r)
            return r;
        let i = this.dom.getClientRects()
          , s = null;
        if (!i.length)
            return null;
        let o = this.side ? this.side < 0 : e > 0;
        for (let a = o ? i.length - 1 : 0; s = i[a],
        !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
            ;
        return q1(s, !o)
    }
    get isEditable() {
        return !1
    }
    get isWidget() {
        return !0
    }
    get isHidden() {
        return this.widget.isHidden
    }
    destroy() {
        super.destroy(),
        this.dom && this.widget.destroy(this.dom)
    }
}
class Ol extends Tt {
    constructor(e) {
        super(),
        this.side = e
    }
    get length() {
        return 0
    }
    merge() {
        return !1
    }
    become(e) {
        return e instanceof Ol && e.side == this.side
    }
    split() {
        return new Ol(this.side)
    }
    sync() {
        if (!this.dom) {
            let e = document.createElement("img");
            e.className = "cm-widgetBuffer",
            e.setAttribute("aria-hidden", "true"),
            this.setDOM(e)
        }
    }
    getSide() {
        return this.side
    }
    domAtPos(e) {
        return this.side > 0 ? Rn.before(this.dom) : Rn.after(this.dom)
    }
    localPosFromDOM() {
        return 0
    }
    domBoundsAround() {
        return null
    }
    coordsAt(e) {
        return this.dom.getBoundingClientRect()
    }
    get overrideDOMText() {
        return gt.empty
    }
    get isHidden() {
        return !0
    }
}
ni.prototype.children = Lo.prototype.children = Ol.prototype.children = K1;
function d3(t, e) {
    let n = t.dom
      , {children: r} = t
      , i = 0;
    for (let s = 0; i < r.length; i++) {
        let o = r[i]
          , a = s + o.length;
        if (!(a == s && o.getSide() <= 0)) {
            if (e > s && e < a && o.dom.parentNode == n)
                return o.domAtPos(e - s);
            if (e <= s)
                break;
            s = a
        }
    }
    for (let s = i; s > 0; s--) {
        let o = r[s - 1];
        if (o.dom.parentNode == n)
            return o.domAtPos(o.length)
    }
    for (let s = i; s < r.length; s++) {
        let o = r[s];
        if (o.dom.parentNode == n)
            return o.domAtPos(0)
    }
    return new Rn(n,0)
}
function f3(t, e, n) {
    let r, {children: i} = t;
    n > 0 && e instanceof as && i.length && (r = i[i.length - 1])instanceof as && r.mark.eq(e.mark) ? f3(r, e.children[0], n - 1) : (i.push(e),
    e.setParent(t)),
    t.length += e.length
}
function p3(t, e, n) {
    let r = null
      , i = -1
      , s = null
      , o = -1;
    function a(c, u) {
        for (let h = 0, d = 0; h < c.children.length && d <= u; h++) {
            let f = c.children[h]
              , g = d + f.length;
            g >= u && (f.children.length ? a(f, u - d) : (!s || s.isHidden && n > 0) && (g > u || d == g && f.getSide() > 0) ? (s = f,
            o = u - d) : (d < u || d == g && f.getSide() < 0 && !f.isHidden) && (r = f,
            i = u - d)),
            d = g
        }
    }
    a(t, e);
    let l = (n < 0 ? r : s) || r || s;
    return l ? l.coordsAt(Math.max(0, l == r ? i : o), n) : Whe(t)
}
function Whe(t) {
    let e = t.dom.lastChild;
    if (!e)
        return t.dom.getBoundingClientRect();
    let n = Ku(e);
    return n[n.length - 1] || null
}
function Ub(t, e) {
    for (let n in t)
        n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
    return e
}
const dT = Object.create(null);
function Mp(t, e, n) {
    if (t == e)
        return !0;
    t || (t = dT),
    e || (e = dT);
    let r = Object.keys(t)
      , i = Object.keys(e);
    if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
        return !1;
    for (let s of r)
        if (s != n && (i.indexOf(s) == -1 || t[s] !== e[s]))
            return !1;
    return !0
}
function Vb(t, e, n) {
    let r = !1;
    if (e)
        for (let i in e)
            n && i in n || (r = !0,
            i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
    if (n)
        for (let i in n)
            e && e[i] == n[i] || (r = !0,
            i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
    return r
}
function Ghe(t) {
    let e = Object.create(null);
    for (let n = 0; n < t.attributes.length; n++) {
        let r = t.attributes[n];
        e[r.name] = r.value
    }
    return e
}
class qt extends Tt {
    constructor() {
        super(...arguments),
        this.children = [],
        this.length = 0,
        this.prevAttrs = void 0,
        this.attrs = null,
        this.breakAfter = 0
    }
    merge(e, n, r, i, s, o) {
        if (r) {
            if (!(r instanceof qt))
                return !1;
            this.dom || r.transferDOM(this)
        }
        return i && this.setDeco(r ? r.attrs : null),
        c3(this, e, n, r ? r.children.slice() : [], s, o),
        !0
    }
    split(e) {
        let n = new qt;
        if (n.breakAfter = this.breakAfter,
        this.length == 0)
            return n;
        let {i: r, off: i} = this.childPos(e);
        i && (n.append(this.children[r].split(i), 0),
        this.children[r].merge(i, this.children[r].length, null, !1, 0, 0),
        r++);
        for (let s = r; s < this.children.length; s++)
            n.append(this.children[s], 0);
        for (; r > 0 && this.children[r - 1].length == 0; )
            this.children[--r].destroy();
        return this.children.length = r,
        this.markDirty(),
        this.length = e,
        n
    }
    transferDOM(e) {
        this.dom && (this.markDirty(),
        e.setDOM(this.dom),
        e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs,
        this.prevAttrs = void 0,
        this.dom = null)
    }
    setDeco(e) {
        Mp(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs,
        this.markDirty()),
        this.attrs = e)
    }
    append(e, n) {
        f3(this, e, n)
    }
    addLineDeco(e) {
        let n = e.spec.attributes
          , r = e.spec.class;
        n && (this.attrs = Ub(n, this.attrs || {})),
        r && (this.attrs = Ub({
            class: r
        }, this.attrs || {}))
    }
    domAtPos(e) {
        return d3(this, e)
    }
    reuseDOM(e) {
        e.nodeName == "DIV" && (this.setDOM(e),
        this.flags |= 6)
    }
    sync(e, n) {
        var r;
        this.dom ? this.flags & 4 && (r3(this.dom),
        this.dom.className = "cm-line",
        this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")),
        this.dom.className = "cm-line",
        this.prevAttrs = this.attrs ? null : void 0),
        this.prevAttrs !== void 0 && (Vb(this.dom, this.prevAttrs, this.attrs),
        this.dom.classList.add("cm-line"),
        this.prevAttrs = void 0),
        super.sync(e, n);
        let i = this.dom.lastChild;
        for (; i && Tt.get(i)instanceof as; )
            i = i.lastChild;
        if (!i || !this.length || i.nodeName != "BR" && ((r = Tt.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!Le.ios || !this.children.some(s => s instanceof ni))) {
            let s = document.createElement("BR");
            s.cmIgnore = !0,
            this.dom.appendChild(s)
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let e = 0, n;
        for (let r of this.children) {
            if (!(r instanceof ni) || /[^ -~]/.test(r.text))
                return null;
            let i = Ku(r.dom);
            if (i.length != 1)
                return null;
            e += i[0].width,
            n = i[0].height
        }
        return e ? {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: e / this.length,
            textHeight: n
        } : null
    }
    coordsAt(e, n) {
        let r = p3(this, e, n);
        if (!this.children.length && r && this.parent) {
            let {heightOracle: i} = this.parent.view.viewState
              , s = r.bottom - r.top;
            if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
                let o = (s - i.textHeight) / 2;
                return {
                    top: r.top + o,
                    bottom: r.bottom - o,
                    left: r.left,
                    right: r.left
                }
            }
        }
        return r
    }
    become(e) {
        return e instanceof qt && this.children.length == 0 && e.children.length == 0 && Mp(this.attrs, e.attrs) && this.breakAfter == e.breakAfter
    }
    covers() {
        return !0
    }
    static find(e, n) {
        for (let r = 0, i = 0; r < e.children.length; r++) {
            let s = e.children[r]
              , o = i + s.length;
            if (o >= n) {
                if (s instanceof qt)
                    return s;
                if (o > n)
                    break
            }
            i = o + s.breakAfter
        }
        return null
    }
}
class Ji extends Tt {
    constructor(e, n, r) {
        super(),
        this.widget = e,
        this.length = n,
        this.deco = r,
        this.breakAfter = 0,
        this.prevWidget = null
    }
    merge(e, n, r, i, s, o) {
        return r && (!(r instanceof Ji) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n),
        !0)
    }
    domAtPos(e) {
        return e == 0 ? Rn.before(this.dom) : Rn.after(this.dom, e == this.length)
    }
    split(e) {
        let n = this.length - e;
        this.length = e;
        let r = new Ji(this.widget,n,this.deco);
        return r.breakAfter = this.breakAfter,
        r
    }
    get children() {
        return K1
    }
    sync(e) {
        (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
        this.prevWidget = null,
        this.setDOM(this.widget.toDOM(e)),
        this.widget.editable || (this.dom.contentEditable = "false"))
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : gt.empty
    }
    domBoundsAround() {
        return null
    }
    become(e) {
        return e instanceof Ji && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        this.widget = e.widget,
        this.length = e.length,
        this.deco = e.deco,
        this.breakAfter = e.breakAfter,
        !0) : !1
    }
    ignoreMutation() {
        return !0
    }
    ignoreEvent(e) {
        return this.widget.ignoreEvent(e)
    }
    get isEditable() {
        return !1
    }
    get isWidget() {
        return !0
    }
    coordsAt(e, n) {
        return this.widget.coordsAt(this.dom, e, n)
    }
    destroy() {
        super.destroy(),
        this.dom && this.widget.destroy(this.dom)
    }
    covers(e) {
        let {startSide: n, endSide: r} = this.deco;
        return n == r ? !1 : e < 0 ? n < 0 : r > 0
    }
}
class Xl {
    eq(e) {
        return !1
    }
    updateDOM(e, n) {
        return !1
    }
    compare(e) {
        return this == e || this.constructor == e.constructor && this.eq(e)
    }
    get estimatedHeight() {
        return -1
    }
    get lineBreaks() {
        return 0
    }
    ignoreEvent(e) {
        return !0
    }
    coordsAt(e, n, r) {
        return null
    }
    get isHidden() {
        return !1
    }
    get editable() {
        return !1
    }
    destroy(e) {}
}
var Vn = function(t) {
    return t[t.Text = 0] = "Text",
    t[t.WidgetBefore = 1] = "WidgetBefore",
    t[t.WidgetAfter = 2] = "WidgetAfter",
    t[t.WidgetRange = 3] = "WidgetRange",
    t
}(Vn || (Vn = {}));
class at extends aa {
    constructor(e, n, r, i) {
        super(),
        this.startSide = e,
        this.endSide = n,
        this.widget = r,
        this.spec = i
    }
    get heightRelevant() {
        return !1
    }
    static mark(e) {
        return new td(e)
    }
    static widget(e) {
        let n = Math.max(-1e4, Math.min(1e4, e.side || 0))
          , r = !!e.block;
        return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8,
        new Zs(e,n,n,r,e.widget || null,!1)
    }
    static replace(e) {
        let n = !!e.block, r, i;
        if (e.isBlockGap)
            r = -5e8,
            i = 4e8;
        else {
            let {start: s, end: o} = m3(e, n);
            r = (s ? n ? -3e8 : -1 : 5e8) - 1,
            i = (o ? n ? 2e8 : 1 : -6e8) + 1
        }
        return new Zs(e,r,i,n,e.widget || null,!0)
    }
    static line(e) {
        return new nd(e)
    }
    static set(e, n=!1) {
        return dt.of(e, n)
    }
    hasHeight() {
        return this.widget ? this.widget.estimatedHeight > -1 : !1
    }
}
at.none = dt.empty;
class td extends at {
    constructor(e) {
        let {start: n, end: r} = m3(e);
        super(n ? -1 : 5e8, r ? 1 : -6e8, null, e),
        this.tagName = e.tagName || "span",
        this.class = e.class || "",
        this.attrs = e.attributes || null
    }
    eq(e) {
        var n, r;
        return this == e || e instanceof td && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && Mp(this.attrs, e.attrs, "class")
    }
    range(e, n=e) {
        if (e >= n)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(e, n)
    }
}
td.prototype.point = !1;
class nd extends at {
    constructor(e) {
        super(-2e8, -2e8, null, e)
    }
    eq(e) {
        return e instanceof nd && this.spec.class == e.spec.class && Mp(this.spec.attributes, e.spec.attributes)
    }
    range(e, n=e) {
        if (n != e)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(e, n)
    }
}
nd.prototype.mapMode = kn.TrackBefore;
nd.prototype.point = !0;
class Zs extends at {
    constructor(e, n, r, i, s, o) {
        super(n, r, s, e),
        this.block = i,
        this.isReplace = o,
        this.mapMode = i ? n <= 0 ? kn.TrackBefore : kn.TrackAfter : kn.TrackDel
    }
    get type() {
        return this.startSide != this.endSide ? Vn.WidgetRange : this.startSide <= 0 ? Vn.WidgetBefore : Vn.WidgetAfter
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0)
    }
    eq(e) {
        return e instanceof Zs && qhe(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide
    }
    range(e, n=e) {
        if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && n != e)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(e, n)
    }
}
Zs.prototype.point = !0;
function m3(t, e=!1) {
    let {inclusiveStart: n, inclusiveEnd: r} = t;
    return n == null && (n = t.inclusive),
    r == null && (r = t.inclusive),
    {
        start: n ?? e,
        end: r ?? e
    }
}
function qhe(t, e) {
    return t == e || !!(t && e && t.compare(e))
}
function $b(t, e, n, r=0) {
    let i = n.length - 1;
    i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e)
}
class iu {
    constructor(e, n, r, i) {
        this.doc = e,
        this.pos = n,
        this.end = r,
        this.disallowBlockEffectsFor = i,
        this.content = [],
        this.curLine = null,
        this.breakAtStart = 0,
        this.pendingBuffer = 0,
        this.bufferMarks = [],
        this.atCursorPos = !0,
        this.openStart = -1,
        this.openEnd = -1,
        this.text = "",
        this.textOff = 0,
        this.cursor = e.iter(),
        this.skip = n
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let e = this.content[this.content.length - 1];
        return !(e.breakAfter || e instanceof Ji && e.deco.endSide < 0)
    }
    getLine() {
        return this.curLine || (this.content.push(this.curLine = new qt),
        this.atCursorPos = !0),
        this.curLine
    }
    flushBuffer(e=this.bufferMarks) {
        this.pendingBuffer && (this.curLine.append(jd(new Ol(-1), e), e.length),
        this.pendingBuffer = 0)
    }
    addBlockWidget(e) {
        this.flushBuffer(),
        this.curLine = null,
        this.content.push(e)
    }
    finish(e) {
        this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0,
        !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1]instanceof Ji) && this.getLine()
    }
    buildText(e, n, r) {
        for (; e > 0; ) {
            if (this.textOff == this.text.length) {
                let {value: s, lineBreak: o, done: a} = this.cursor.next(this.skip);
                if (this.skip = 0,
                a)
                    throw new Error("Ran out of text content when drawing inline views");
                if (o) {
                    this.posCovered() || this.getLine(),
                    this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1,
                    this.flushBuffer(),
                    this.curLine = null,
                    this.atCursorPos = !0,
                    e--;
                    continue
                } else
                    this.text = s,
                    this.textOff = 0
            }
            let i = Math.min(this.text.length - this.textOff, e, 512);
            this.flushBuffer(n.slice(n.length - r)),
            this.getLine().append(jd(new ni(this.text.slice(this.textOff, this.textOff + i)), n), r),
            this.atCursorPos = !0,
            this.textOff += i,
            e -= i,
            r = 0
        }
    }
    span(e, n, r, i) {
        this.buildText(n - e, r, i),
        this.pos = n,
        this.openStart < 0 && (this.openStart = i)
    }
    point(e, n, r, i, s, o) {
        if (this.disallowBlockEffectsFor[o] && r instanceof Zs) {
            if (r.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (n > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins")
        }
        let a = n - e;
        if (r instanceof Zs)
            if (r.block)
                r.startSide > 0 && !this.posCovered() && this.getLine(),
                this.addBlockWidget(new Ji(r.widget || Nl.block,a,r));
            else {
                let l = Lo.create(r.widget || Nl.inline, a, a ? 0 : r.startSide)
                  , c = this.atCursorPos && !l.isEditable && s <= i.length && (e < n || r.startSide > 0)
                  , u = !l.isEditable && (e < n || s > i.length || r.startSide <= 0)
                  , h = this.getLine();
                this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0),
                this.flushBuffer(i),
                c && (h.append(jd(new Ol(1), i), s),
                s = i.length + Math.max(0, s - i.length)),
                h.append(jd(l, i), s),
                this.atCursorPos = u,
                this.pendingBuffer = u ? e < n || s > i.length ? 1 : 2 : 0,
                this.pendingBuffer && (this.bufferMarks = i.slice())
            }
        else
            this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
        a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff),
        this.text = "",
        this.textOff = 0),
        this.pos = n),
        this.openStart < 0 && (this.openStart = s)
    }
    static build(e, n, r, i, s) {
        let o = new iu(e,n,r,s);
        return o.openEnd = dt.spans(i, n, r, o),
        o.openStart < 0 && (o.openStart = o.openEnd),
        o.finish(o.openEnd),
        o
    }
}
function jd(t, e) {
    for (let n of e)
        t = new as(n,[t],t.length);
    return t
}
class Nl extends Xl {
    constructor(e) {
        super(),
        this.tag = e
    }
    eq(e) {
        return e.tag == this.tag
    }
    toDOM() {
        return document.createElement(this.tag)
    }
    updateDOM(e) {
        return e.nodeName.toLowerCase() == this.tag
    }
    get isHidden() {
        return !0
    }
}
Nl.inline = new Nl("span");
Nl.block = new Nl("div");
var Nt = function(t) {
    return t[t.LTR = 0] = "LTR",
    t[t.RTL = 1] = "RTL",
    t
}(Nt || (Nt = {}));
const ha = Nt.LTR
  , Y1 = Nt.RTL;
function g3(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
        e.push(1 << +t[n]);
    return e
}
const Khe = g3("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008")
  , Yhe = g3("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333")
  , zb = Object.create(null)
  , li = [];
for (let t of ["()", "[]", "{}"]) {
    let e = t.charCodeAt(0)
      , n = t.charCodeAt(1);
    zb[e] = n,
    zb[n] = -e
}
function _3(t) {
    return t <= 247 ? Khe[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? Yhe[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1
}
const Xhe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Is {
    get dir() {
        return this.level % 2 ? Y1 : ha
    }
    constructor(e, n, r) {
        this.from = e,
        this.to = n,
        this.level = r
    }
    side(e, n) {
        return this.dir == n == e ? this.to : this.from
    }
    forward(e, n) {
        return e == (this.dir == n)
    }
    static find(e, n, r, i) {
        let s = -1;
        for (let o = 0; o < e.length; o++) {
            let a = e[o];
            if (a.from <= n && a.to >= n) {
                if (a.level == r)
                    return o;
                (s < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[s].level > a.level)) && (s = o)
            }
        }
        if (s < 0)
            throw new RangeError("Index out of range");
        return s
    }
}
function b3(t, e) {
    if (t.length != e.length)
        return !1;
    for (let n = 0; n < t.length; n++) {
        let r = t[n]
          , i = e[n];
        if (r.from != i.from || r.to != i.to || r.direction != i.direction || !b3(r.inner, i.inner))
            return !1
    }
    return !0
}
const Ct = [];
function Qhe(t, e, n, r, i) {
    for (let s = 0; s <= r.length; s++) {
        let o = s ? r[s - 1].to : e
          , a = s < r.length ? r[s].from : n
          , l = s ? 256 : i;
        for (let c = o, u = l, h = l; c < a; c++) {
            let d = _3(t.charCodeAt(c));
            d == 512 ? d = u : d == 8 && h == 4 && (d = 16),
            Ct[c] = d == 4 ? 2 : d,
            d & 7 && (h = d),
            u = d
        }
        for (let c = o, u = l, h = l; c < a; c++) {
            let d = Ct[c];
            if (d == 128)
                c < a - 1 && u == Ct[c + 1] && u & 24 ? d = Ct[c] = u : Ct[c] = 256;
            else if (d == 64) {
                let f = c + 1;
                for (; f < a && Ct[f] == 64; )
                    f++;
                let g = c && u == 8 || f < n && Ct[f] == 8 ? h == 1 ? 1 : 8 : 256;
                for (let _ = c; _ < f; _++)
                    Ct[_] = g;
                c = f - 1
            } else
                d == 8 && h == 1 && (Ct[c] = 1);
            u = d,
            d & 7 && (h = d)
        }
    }
}
function Jhe(t, e, n, r, i) {
    let s = i == 1 ? 2 : 1;
    for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
        let c = o ? r[o - 1].to : e
          , u = o < r.length ? r[o].from : n;
        for (let h = c, d, f, g; h < u; h++)
            if (f = zb[d = t.charCodeAt(h)])
                if (f < 0) {
                    for (let _ = a - 3; _ >= 0; _ -= 3)
                        if (li[_ + 1] == -f) {
                            let m = li[_ + 2]
                              , p = m & 2 ? i : m & 4 ? m & 1 ? s : i : 0;
                            p && (Ct[h] = Ct[li[_]] = p),
                            a = _;
                            break
                        }
                } else {
                    if (li.length == 189)
                        break;
                    li[a++] = h,
                    li[a++] = d,
                    li[a++] = l
                }
            else if ((g = Ct[h]) == 2 || g == 1) {
                let _ = g == i;
                l = _ ? 0 : 1;
                for (let m = a - 3; m >= 0; m -= 3) {
                    let p = li[m + 2];
                    if (p & 2)
                        break;
                    if (_)
                        li[m + 2] |= 2;
                    else {
                        if (p & 4)
                            break;
                        li[m + 2] |= 4
                    }
                }
            }
    }
}
function Zhe(t, e, n, r) {
    for (let i = 0, s = r; i <= n.length; i++) {
        let o = i ? n[i - 1].to : t
          , a = i < n.length ? n[i].from : e;
        for (let l = o; l < a; ) {
            let c = Ct[l];
            if (c == 256) {
                let u = l + 1;
                for (; ; )
                    if (u == a) {
                        if (i == n.length)
                            break;
                        u = n[i++].to,
                        a = i < n.length ? n[i].from : e
                    } else if (Ct[u] == 256)
                        u++;
                    else
                        break;
                let h = s == 1
                  , d = (u < e ? Ct[u] : r) == 1
                  , f = h == d ? h ? 1 : 2 : r;
                for (let g = u, _ = i, m = _ ? n[_ - 1].to : t; g > l; )
                    g == m && (g = n[--_].from,
                    m = _ ? n[_ - 1].to : t),
                    Ct[--g] = f;
                l = u
            } else
                s = c,
                l++
        }
    }
}
function Wb(t, e, n, r, i, s, o) {
    let a = r % 2 ? 2 : 1;
    if (r % 2 == i % 2)
        for (let l = e, c = 0; l < n; ) {
            let u = !0
              , h = !1;
            if (c == s.length || l < s[c].from) {
                let _ = Ct[l];
                _ != a && (u = !1,
                h = _ == 16)
            }
            let d = !u && a == 1 ? [] : null
              , f = u ? r : r + 1
              , g = l;
            e: for (; ; )
                if (c < s.length && g == s[c].from) {
                    if (h)
                        break e;
                    let _ = s[c];
                    if (!u)
                        for (let m = _.to, p = c + 1; ; ) {
                            if (m == n)
                                break e;
                            if (p < s.length && s[p].from == m)
                                m = s[p++].to;
                            else {
                                if (Ct[m] == a)
                                    break e;
                                break
                            }
                        }
                    if (c++,
                    d)
                        d.push(_);
                    else {
                        _.from > l && o.push(new Is(l,_.from,f));
                        let m = _.direction == ha != !(f % 2);
                        Gb(t, m ? r + 1 : r, i, _.inner, _.from, _.to, o),
                        l = _.to
                    }
                    g = _.to
                } else {
                    if (g == n || (u ? Ct[g] != a : Ct[g] == a))
                        break;
                    g++
                }
            d ? Wb(t, l, g, r + 1, i, d, o) : l < g && o.push(new Is(l,g,f)),
            l = g
        }
    else
        for (let l = n, c = s.length; l > e; ) {
            let u = !0
              , h = !1;
            if (!c || l > s[c - 1].to) {
                let _ = Ct[l - 1];
                _ != a && (u = !1,
                h = _ == 16)
            }
            let d = !u && a == 1 ? [] : null
              , f = u ? r : r + 1
              , g = l;
            e: for (; ; )
                if (c && g == s[c - 1].to) {
                    if (h)
                        break e;
                    let _ = s[--c];
                    if (!u)
                        for (let m = _.from, p = c; ; ) {
                            if (m == e)
                                break e;
                            if (p && s[p - 1].to == m)
                                m = s[--p].from;
                            else {
                                if (Ct[m - 1] == a)
                                    break e;
                                break
                            }
                        }
                    if (d)
                        d.push(_);
                    else {
                        _.to < l && o.push(new Is(_.to,l,f));
                        let m = _.direction == ha != !(f % 2);
                        Gb(t, m ? r + 1 : r, i, _.inner, _.from, _.to, o),
                        l = _.from
                    }
                    g = _.from
                } else {
                    if (g == e || (u ? Ct[g - 1] != a : Ct[g - 1] == a))
                        break;
                    g--
                }
            d ? Wb(t, g, l, r + 1, i, d, o) : g < l && o.push(new Is(g,l,f)),
            l = g
        }
}
function Gb(t, e, n, r, i, s, o) {
    let a = e % 2 ? 2 : 1;
    Qhe(t, i, s, r, a),
    Jhe(t, i, s, r, a),
    Zhe(i, s, r, a),
    Wb(t, i, s, e, n, r, o)
}
function ede(t, e, n) {
    if (!t)
        return [new Is(0,0,e == Y1 ? 1 : 0)];
    if (e == ha && !n.length && !Xhe.test(t))
        return y3(t.length);
    if (n.length)
        for (; t.length > Ct.length; )
            Ct[Ct.length] = 256;
    let r = []
      , i = e == ha ? 0 : 1;
    return Gb(t, i, i, n, 0, t.length, r),
    r
}
function y3(t) {
    return [new Is(0,t,0)]
}
let v3 = "";
function tde(t, e, n, r, i) {
    var s;
    let o = r.head - t.from
      , a = Is.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc)
      , l = e[a]
      , c = l.side(i, n);
    if (o == c) {
        let d = a += i ? 1 : -1;
        if (d < 0 || d >= e.length)
            return null;
        l = e[a = d],
        o = l.side(!i, n),
        c = l.side(i, n)
    }
    let u = yn(t.text, o, l.forward(i, n));
    (u < l.from || u > l.to) && (u = c),
    v3 = t.text.slice(Math.min(o, u), Math.max(o, u));
    let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
    return h && u == c && h.level + (i ? 0 : 1) < l.level ? ge.cursor(h.side(!i, n) + t.from, h.forward(i, n) ? 1 : -1, h.level) : ge.cursor(u + t.from, l.forward(i, n) ? -1 : 1, l.level)
}
function nde(t, e, n) {
    for (let r = e; r < n; r++) {
        let i = _3(t.charCodeAt(r));
        if (i == 1)
            return ha;
        if (i == 2 || i == 4)
            return Y1
    }
    return ha
}
const x3 = Me.define()
  , E3 = Me.define()
  , S3 = Me.define()
  , w3 = Me.define()
  , qb = Me.define()
  , C3 = Me.define()
  , T3 = Me.define()
  , A3 = Me.define({
    combine: t => t.some(e => e)
})
  , k3 = Me.define({
    combine: t => t.some(e => e)
})
  , R3 = Me.define();
class _l {
    constructor(e, n="nearest", r="nearest", i=5, s=5, o=!1) {
        this.range = e,
        this.y = n,
        this.x = r,
        this.yMargin = i,
        this.xMargin = s,
        this.isSnapshot = o
    }
    map(e) {
        return e.empty ? this : new _l(this.range.map(e),this.y,this.x,this.yMargin,this.xMargin,this.isSnapshot)
    }
    clip(e) {
        return this.range.to <= e.doc.length ? this : new _l(ge.cursor(e.doc.length),this.y,this.x,this.yMargin,this.xMargin,this.isSnapshot)
    }
}
const Hd = Je.define({
    map: (t, e) => t.map(e)
})
  , I3 = Je.define();
function fr(t, e, n) {
    let r = t.facet(w3);
    r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e)
}
const As = Me.define({
    combine: t => t.length ? t[0] : !0
});
let rde = 0;
const Lc = Me.define();
class xn {
    constructor(e, n, r, i, s) {
        this.id = e,
        this.create = n,
        this.domEventHandlers = r,
        this.domEventObservers = i,
        this.extension = s(this)
    }
    static define(e, n) {
        const {eventHandlers: r, eventObservers: i, provide: s, decorations: o} = n || {};
        return new xn(rde++,e,r,i,a => {
            let l = [Lc.of(a)];
            return o && l.push(Yu.of(c => {
                let u = c.plugin(a);
                return u ? o(u) : at.none
            }
            )),
            s && l.push(s(a)),
            l
        }
        )
    }
    static fromClass(e, n) {
        return xn.define(r => new e(r), n)
    }
}
class O0 {
    constructor(e) {
        this.spec = e,
        this.mustUpdate = null,
        this.value = null
    }
    update(e) {
        if (this.value) {
            if (this.mustUpdate) {
                let n = this.mustUpdate;
                if (this.mustUpdate = null,
                this.value.update)
                    try {
                        this.value.update(n)
                    } catch (r) {
                        if (fr(n.state, r, "CodeMirror plugin crashed"),
                        this.value.destroy)
                            try {
                                this.value.destroy()
                            } catch {}
                        this.deactivate()
                    }
            }
        } else if (this.spec)
            try {
                this.value = this.spec.create(e)
            } catch (n) {
                fr(e.state, n, "CodeMirror plugin crashed"),
                this.deactivate()
            }
        return this
    }
    destroy(e) {
        var n;
        if (!((n = this.value) === null || n === void 0) && n.destroy)
            try {
                this.value.destroy()
            } catch (r) {
                fr(e.state, r, "CodeMirror plugin crashed")
            }
    }
    deactivate() {
        this.spec = this.value = null
    }
}
const P3 = Me.define()
  , ug = Me.define()
  , Yu = Me.define()
  , D3 = Me.define()
  , X1 = Me.define()
  , L3 = Me.define();
function fT(t, e) {
    let n = t.state.facet(L3);
    if (!n.length)
        return n;
    let r = n.map(s => s instanceof Function ? s(t) : s)
      , i = [];
    return dt.spans(r, e.from, e.to, {
        point() {},
        span(s, o, a, l) {
            let c = s - e.from
              , u = o - e.from
              , h = i;
            for (let d = a.length - 1; d >= 0; d--,
            l--) {
                let f = a[d].spec.bidiIsolate, g;
                if (f == null && (f = nde(e.text, c, u)),
                l > 0 && h.length && (g = h[h.length - 1]).to == c && g.direction == f)
                    g.to = u,
                    h = g.inner;
                else {
                    let _ = {
                        from: c,
                        to: u,
                        direction: f,
                        inner: []
                    };
                    h.push(_),
                    h = _.inner
                }
            }
        }
    }),
    i
}
const O3 = Me.define();
function N3(t) {
    let e = 0
      , n = 0
      , r = 0
      , i = 0;
    for (let s of t.state.facet(O3)) {
        let o = s(t);
        o && (o.left != null && (e = Math.max(e, o.left)),
        o.right != null && (n = Math.max(n, o.right)),
        o.top != null && (r = Math.max(r, o.top)),
        o.bottom != null && (i = Math.max(i, o.bottom)))
    }
    return {
        left: e,
        right: n,
        top: r,
        bottom: i
    }
}
const Oc = Me.define();
class Or {
    constructor(e, n, r, i) {
        this.fromA = e,
        this.toA = n,
        this.fromB = r,
        this.toB = i
    }
    join(e) {
        return new Or(Math.min(this.fromA, e.fromA),Math.max(this.toA, e.toA),Math.min(this.fromB, e.fromB),Math.max(this.toB, e.toB))
    }
    addToSet(e) {
        let n = e.length
          , r = this;
        for (; n > 0; n--) {
            let i = e[n - 1];
            if (!(i.fromA > r.toA)) {
                if (i.toA < r.fromA)
                    break;
                r = r.join(i),
                e.splice(n - 1, 1)
            }
        }
        return e.splice(n, 0, r),
        e
    }
    static extendWithRanges(e, n) {
        if (n.length == 0)
            return e;
        let r = [];
        for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
            let l = i == e.length ? null : e[i]
              , c = o - a
              , u = l ? l.fromB : 1e9;
            for (; s < n.length && n[s] < u; ) {
                let h = n[s]
                  , d = n[s + 1]
                  , f = Math.max(a, h)
                  , g = Math.min(u, d);
                if (f <= g && new Or(f + c,g + c,f,g).addToSet(r),
                d > u)
                    break;
                s += 2
            }
            if (!l)
                return r;
            new Or(l.fromA,l.toA,l.fromB,l.toB).addToSet(r),
            o = l.toA,
            a = l.toB
        }
    }
}
class Bp {
    constructor(e, n, r) {
        this.view = e,
        this.state = n,
        this.transactions = r,
        this.flags = 0,
        this.startState = e.state,
        this.changes = Zt.empty(this.startState.doc.length);
        for (let s of r)
            this.changes = this.changes.compose(s.changes);
        let i = [];
        this.changes.iterChangedRanges( (s, o, a, l) => i.push(new Or(s,o,a,l))),
        this.changedRanges = i
    }
    static create(e, n, r) {
        return new Bp(e,n,r)
    }
    get viewportChanged() {
        return (this.flags & 4) > 0
    }
    get heightChanged() {
        return (this.flags & 2) > 0
    }
    get geometryChanged() {
        return this.docChanged || (this.flags & 10) > 0
    }
    get focusChanged() {
        return (this.flags & 1) > 0
    }
    get docChanged() {
        return !this.changes.empty
    }
    get selectionSet() {
        return this.transactions.some(e => e.selection)
    }
    get empty() {
        return this.flags == 0 && this.transactions.length == 0
    }
}
class pT extends Tt {
    get length() {
        return this.view.state.doc.length
    }
    constructor(e) {
        super(),
        this.view = e,
        this.decorations = [],
        this.dynamicDecorationMap = [!1],
        this.domChanged = null,
        this.hasComposition = null,
        this.markedForComposition = new Set,
        this.editContextFormatting = at.none,
        this.lastCompositionAfterCursor = !1,
        this.minWidth = 0,
        this.minWidthFrom = 0,
        this.minWidthTo = 0,
        this.impreciseAnchor = null,
        this.impreciseHead = null,
        this.forceSelection = !1,
        this.lastUpdate = Date.now(),
        this.setDOM(e.contentDOM),
        this.children = [new qt],
        this.children[0].setParent(this),
        this.updateDeco(),
        this.updateInner([new Or(0,0,0,e.state.doc.length)], 0, null)
    }
    update(e) {
        var n;
        let r = e.changedRanges;
        this.minWidth > 0 && r.length && (r.every( ({fromA: c, toA: u}) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1),
        this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0),
        this.updateEditContextFormatting(e);
        let i = -1;
        this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !ude(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
        let s = i > -1 ? sde(this.view, e.changes, i) : null;
        if (this.domChanged = null,
        this.hasComposition) {
            this.markedForComposition.clear();
            let {from: c, to: u} = this.hasComposition;
            r = new Or(c,u,e.changes.mapPos(c, -1),e.changes.mapPos(u, 1)).addToSet(r.slice())
        }
        this.hasComposition = s ? {
            from: s.range.fromB,
            to: s.range.toB
        } : null,
        (Le.ie || Le.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
        let o = this.decorations
          , a = this.updateDeco()
          , l = lde(o, a, e.changes);
        return r = Or.extendWithRanges(r, l),
        !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s),
        e.transactions.length && (this.lastUpdate = Date.now()),
        !0)
    }
    updateInner(e, n, r) {
        this.view.viewState.mustMeasureContent = !0,
        this.updateChildren(e, n, r);
        let {observer: i} = this.view;
        i.ignore( () => {
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px",
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            let o = Le.chrome || Le.ios ? {
                node: i.selectionRange.focusNode,
                written: !1
            } : void 0;
            this.sync(this.view, o),
            this.flags &= -8,
            o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0),
            this.dom.style.height = ""
        }
        ),
        this.markedForComposition.forEach(o => o.flags &= -9);
        let s = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let o of this.children)
                o instanceof Ji && o.widget instanceof mT && s.push(o.dom);
        i.updateGaps(s)
    }
    updateChildren(e, n, r) {
        let i = r ? r.range.addToSet(e.slice()) : e
          , s = this.childCursor(n);
        for (let o = i.length - 1; ; o--) {
            let a = o >= 0 ? i[o] : null;
            if (!a)
                break;
            let {fromA: l, toA: c, fromB: u, toB: h} = a, d, f, g, _;
            if (r && r.range.fromB < h && r.range.toB > u) {
                let x = iu.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap)
                  , E = iu.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
                f = x.breakAtStart,
                g = x.openStart,
                _ = E.openEnd;
                let w = this.compositionView(r);
                E.breakAtStart ? w.breakAfter = 1 : E.content.length && w.merge(w.length, w.length, E.content[0], !1, E.openStart, 0) && (w.breakAfter = E.content[0].breakAfter,
                E.content.shift()),
                x.content.length && w.merge(0, 0, x.content[x.content.length - 1], !0, 0, x.openEnd) && x.content.pop(),
                d = x.content.concat(w).concat(E.content)
            } else
                ({content: d, breakAtStart: f, openStart: g, openEnd: _} = iu.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
            let {i: m, off: p} = s.findPos(c, 1)
              , {i: b, off: y} = s.findPos(l, -1);
            l3(this, b, y, m, p, d, f, g, _)
        }
        r && this.fixCompositionDOM(r)
    }
    updateEditContextFormatting(e) {
        this.editContextFormatting = this.editContextFormatting.map(e.changes);
        for (let n of e.transactions)
            for (let r of n.effects)
                r.is(I3) && (this.editContextFormatting = r.value)
    }
    compositionView(e) {
        let n = new ni(e.text.nodeValue);
        n.flags |= 8;
        for (let {deco: i} of e.marks)
            n = new as(i,[n],n.length);
        let r = new qt;
        return r.append(n, 0),
        r
    }
    fixCompositionDOM(e) {
        let n = (s, o) => {
            o.flags |= 8 | (o.children.some(l => l.flags & 7) ? 1 : 0),
            this.markedForComposition.add(o);
            let a = Tt.get(s);
            a && a != o && (a.dom = null),
            o.setDOM(s)
        }
          , r = this.childPos(e.range.fromB, 1)
          , i = this.children[r.i];
        n(e.line, i);
        for (let s = e.marks.length - 1; s >= -1; s--)
            r = i.childPos(r.off, 1),
            i = i.children[r.i],
            n(s >= 0 ? e.marks[s].node : e.text, i)
    }
    updateSelection(e=!1, n=!1) {
        (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
        let r = this.view.root.activeElement
          , i = r == this.dom
          , s = !i && Cf(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
        if (!(i || n || s))
            return;
        let o = this.forceSelection;
        this.forceSelection = !1;
        let a = this.view.state.selection.main
          , l = this.moveToLine(this.domAtPos(a.anchor))
          , c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
        if (Le.gecko && a.empty && !this.hasComposition && ide(l)) {
            let h = document.createTextNode("");
            this.view.observer.ignore( () => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)),
            l = c = new Rn(h,0),
            o = !0
        }
        let u = this.view.observer.selectionRange;
        (o || !u.focusNode || (!ru(l.node, l.offset, u.anchorNode, u.anchorOffset) || !ru(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore( () => {
            Le.android && Le.chrome && this.dom.contains(u.focusNode) && cde(u.focusNode, this.dom) && (this.dom.blur(),
            this.dom.focus({
                preventScroll: !0
            }));
            let h = qu(this.view.root);
            if (h)
                if (a.empty) {
                    if (Le.gecko) {
                        let d = ode(l.node, l.offset);
                        if (d && d != 3) {
                            let f = (d == 1 ? s3 : o3)(l.node, l.offset);
                            f && (l = new Rn(f.node,f.offset))
                        }
                    }
                    h.collapse(l.node, l.offset),
                    a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel)
                } else if (h.extend) {
                    h.collapse(l.node, l.offset);
                    try {
                        h.extend(c.node, c.offset)
                    } catch {}
                } else {
                    let d = document.createRange();
                    a.anchor > a.head && ([l,c] = [c, l]),
                    d.setEnd(c.node, c.offset),
                    d.setStart(l.node, l.offset),
                    h.removeAllRanges(),
                    h.addRange(d)
                }
            s && this.view.root.activeElement == this.dom && (this.dom.blur(),
            r && r.focus())
        }
        ),
        this.view.observer.setSelectionRange(l, c)),
        this.impreciseAnchor = l.precise ? null : new Rn(u.anchorNode,u.anchorOffset),
        this.impreciseHead = c.precise ? null : new Rn(u.focusNode,u.focusOffset)
    }
    suppressWidgetCursorChange(e, n) {
        return this.hasComposition && n.empty && ru(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head
    }
    enforceCursorAssoc() {
        if (this.hasComposition)
            return;
        let {view: e} = this
          , n = e.state.selection.main
          , r = qu(e.root)
          , {anchorNode: i, anchorOffset: s} = e.observer.selectionRange;
        if (!r || !n.empty || !n.assoc || !r.modify)
            return;
        let o = qt.find(this, n.head);
        if (!o)
            return;
        let a = o.posAtStart;
        if (n.head == a || n.head == a + o.length)
            return;
        let l = this.coordsAt(n.head, -1)
          , c = this.coordsAt(n.head, 1);
        if (!l || !c || l.bottom > c.top)
            return;
        let u = this.domAtPos(n.head + n.assoc);
        r.collapse(u.node, u.offset),
        r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"),
        e.observer.readSelectionRange();
        let h = e.observer.selectionRange;
        e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != n.from && r.collapse(i, s)
    }
    moveToLine(e) {
        let n = this.dom, r;
        if (e.node != n)
            return e;
        for (let i = e.offset; !r && i < n.childNodes.length; i++) {
            let s = Tt.get(n.childNodes[i]);
            s instanceof qt && (r = s.domAtPos(0))
        }
        for (let i = e.offset - 1; !r && i >= 0; i--) {
            let s = Tt.get(n.childNodes[i]);
            s instanceof qt && (r = s.domAtPos(s.length))
        }
        return r ? new Rn(r.node,r.offset,!0) : e
    }
    nearest(e) {
        for (let n = e; n; ) {
            let r = Tt.get(n);
            if (r && r.rootView == this)
                return r;
            n = n.parentNode
        }
        return null
    }
    posFromDOM(e, n) {
        let r = this.nearest(e);
        if (!r)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return r.localPosFromDOM(e, n) + r.posAtStart
    }
    domAtPos(e) {
        let {i: n, off: r} = this.childCursor().findPos(e, -1);
        for (; n < this.children.length - 1; ) {
            let i = this.children[n];
            if (r < i.length || i instanceof qt)
                break;
            n++,
            r = 0
        }
        return this.children[n].domAtPos(r)
    }
    coordsAt(e, n) {
        let r = null
          , i = 0;
        for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
            let a = this.children[o]
              , l = s - a.breakAfter
              , c = l - a.length;
            if (l < e)
                break;
            if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof qt && !(r instanceof qt && n >= 0)))
                r = a,
                i = c;
            else if (r && c == e && l == e && a instanceof Ji && Math.abs(n) < 2) {
                if (a.deco.startSide < 0)
                    break;
                o && (r = null)
            }
            s = c
        }
        return r ? r.coordsAt(e - i, n) : null
    }
    coordsForChar(e) {
        let {i: n, off: r} = this.childPos(e, 1)
          , i = this.children[n];
        if (!(i instanceof qt))
            return null;
        for (; i.children.length; ) {
            let {i: a, off: l} = i.childPos(r, 1);
            for (; ; a++) {
                if (a == i.children.length)
                    return null;
                if ((i = i.children[a]).length)
                    break
            }
            r = l
        }
        if (!(i instanceof ni))
            return null;
        let s = yn(i.text, r);
        if (s == r)
            return null;
        let o = ua(i.dom, r, s).getClientRects();
        for (let a = 0; a < o.length; a++) {
            let l = o[a];
            if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
                return l
        }
        return null
    }
    measureVisibleLineHeights(e) {
        let n = []
          , {from: r, to: i} = e
          , s = this.view.contentDOM.clientWidth
          , o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1
          , a = -1
          , l = this.view.textDirection == Nt.LTR;
        for (let c = 0, u = 0; u < this.children.length; u++) {
            let h = this.children[u]
              , d = c + h.length;
            if (d > i)
                break;
            if (c >= r) {
                let f = h.dom.getBoundingClientRect();
                if (n.push(f.height),
                o) {
                    let g = h.dom.lastChild
                      , _ = g ? Ku(g) : [];
                    if (_.length) {
                        let m = _[_.length - 1]
                          , p = l ? m.right - f.left : f.right - m.left;
                        p > a && (a = p,
                        this.minWidth = s,
                        this.minWidthFrom = c,
                        this.minWidthTo = d)
                    }
                }
            }
            c = d + h.breakAfter
        }
        return n
    }
    textDirectionAt(e) {
        let {i: n} = this.childPos(e, 1);
        return getComputedStyle(this.children[n].dom).direction == "rtl" ? Nt.RTL : Nt.LTR
    }
    measureTextSize() {
        for (let s of this.children)
            if (s instanceof qt) {
                let o = s.measureTextSize();
                if (o)
                    return o
            }
        let e = document.createElement("div"), n, r, i;
        return e.className = "cm-line",
        e.style.width = "99999px",
        e.style.position = "absolute",
        e.textContent = "abc def ghi jkl mno pqr stu",
        this.view.observer.ignore( () => {
            this.dom.appendChild(e);
            let s = Ku(e.firstChild)[0];
            n = e.getBoundingClientRect().height,
            r = s ? s.width / 27 : 7,
            i = s ? s.height : n,
            e.remove()
        }
        ),
        {
            lineHeight: n,
            charWidth: r,
            textHeight: i
        }
    }
    childCursor(e=this.length) {
        let n = this.children.length;
        return n && (e -= this.children[--n].length),
        new a3(this.children,e,n)
    }
    computeBlockGapDeco() {
        let e = []
          , n = this.view.viewState;
        for (let r = 0, i = 0; ; i++) {
            let s = i == n.viewports.length ? null : n.viewports[i]
              , o = s ? s.from - 1 : this.length;
            if (o > r) {
                let a = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
                e.push(at.replace({
                    widget: new mT(a),
                    block: !0,
                    inclusive: !0,
                    isBlockGap: !0
                }).range(r, o))
            }
            if (!s)
                break;
            r = s.to + 1
        }
        return at.set(e)
    }
    updateDeco() {
        let e = 1
          , n = this.view.state.facet(Yu).map(s => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s)
          , r = !1
          , i = this.view.state.facet(D3).map( (s, o) => {
            let a = typeof s == "function";
            return a && (r = !0),
            a ? s(this.view) : s
        }
        );
        for (i.length && (this.dynamicDecorationMap[e++] = r,
        n.push(dt.join(i))),
        this.decorations = [this.editContextFormatting, ...n, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; e < this.decorations.length; )
            this.dynamicDecorationMap[e++] = !1;
        return this.decorations
    }
    scrollIntoView(e) {
        if (e.isSnapshot) {
            let c = this.view.viewState.lineBlockAt(e.range.head);
            this.view.scrollDOM.scrollTop = c.top - e.yMargin,
            this.view.scrollDOM.scrollLeft = e.xMargin;
            return
        }
        for (let c of this.view.state.facet(R3))
            try {
                if (c(this.view, e.range, e))
                    return !0
            } catch (u) {
                fr(this.view.state, u, "scroll handler")
            }
        let {range: n} = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
        if (!r)
            return;
        !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
            left: Math.min(r.left, i.left),
            top: Math.min(r.top, i.top),
            right: Math.max(r.right, i.right),
            bottom: Math.max(r.bottom, i.bottom)
        });
        let s = N3(this.view)
          , o = {
            left: r.left - s.left,
            top: r.top - s.top,
            right: r.right + s.right,
            bottom: r.bottom + s.bottom
        }
          , {offsetWidth: a, offsetHeight: l} = this.view.scrollDOM;
        Fhe(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Nt.LTR)
    }
}
function ide(t) {
    return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false")
}
class mT extends Xl {
    constructor(e) {
        super(),
        this.height = e
    }
    toDOM() {
        let e = document.createElement("div");
        return e.className = "cm-gap",
        this.updateDOM(e),
        e
    }
    eq(e) {
        return e.height == this.height
    }
    updateDOM(e) {
        return e.style.height = this.height + "px",
        !0
    }
    get editable() {
        return !0
    }
    get estimatedHeight() {
        return this.height
    }
    ignoreEvent() {
        return !1
    }
}
function M3(t, e) {
    let n = t.observer.selectionRange;
    if (!n.focusNode)
        return null;
    let r = s3(n.focusNode, n.focusOffset)
      , i = o3(n.focusNode, n.focusOffset)
      , s = r || i;
    if (i && r && i.node != r.node) {
        let a = Tt.get(i.node);
        if (!a || a instanceof ni && a.text != i.node.nodeValue)
            s = i;
        else if (t.docView.lastCompositionAfterCursor) {
            let l = Tt.get(r.node);
            !l || l instanceof ni && l.text != r.node.nodeValue || (s = i)
        }
    }
    if (t.docView.lastCompositionAfterCursor = s != r,
    !s)
        return null;
    let o = e - s.offset;
    return {
        from: o,
        to: o + s.node.nodeValue.length,
        node: s.node
    }
}
function sde(t, e, n) {
    let r = M3(t, n);
    if (!r)
        return null;
    let {node: i, from: s, to: o} = r
      , a = i.nodeValue;
    if (/[\n\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)
        return null;
    let l = e.invertedDesc
      , c = new Or(l.mapPos(s),l.mapPos(o),s,o)
      , u = [];
    for (let h = i.parentNode; ; h = h.parentNode) {
        let d = Tt.get(h);
        if (d instanceof as)
            u.push({
                node: h,
                deco: d.mark
            });
        else {
            if (d instanceof qt || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
                return {
                    range: c,
                    text: i,
                    marks: u,
                    line: h
                };
            if (h != t.contentDOM)
                u.push({
                    node: h,
                    deco: new td({
                        inclusive: !0,
                        attributes: Ghe(h),
                        tagName: h.tagName.toLowerCase()
                    })
                });
            else
                return null
        }
    }
}
function ode(t, e) {
    return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0)
}
let ade = class {
    constructor() {
        this.changes = []
    }
    compareRange(e, n) {
        $b(e, n, this.changes)
    }
    comparePoint(e, n) {
        $b(e, n, this.changes)
    }
}
;
function lde(t, e, n) {
    let r = new ade;
    return dt.compare(t, e, n, r),
    r.changes
}
function cde(t, e) {
    for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
        if (n.nodeType == 1 && n.contentEditable == "false")
            return !0;
    return !1
}
function ude(t, e) {
    let n = !1;
    return e && t.iterChangedRanges( (r, i) => {
        r < e.to && i > e.from && (n = !0)
    }
    ),
    n
}
function hde(t, e, n=1) {
    let r = t.charCategorizer(e)
      , i = t.doc.lineAt(e)
      , s = e - i.from;
    if (i.length == 0)
        return ge.cursor(e);
    s == 0 ? n = 1 : s == i.length && (n = -1);
    let o = s
      , a = s;
    n < 0 ? o = yn(i.text, s, !1) : a = yn(i.text, s);
    let l = r(i.text.slice(o, a));
    for (; o > 0; ) {
        let c = yn(i.text, o, !1);
        if (r(i.text.slice(c, o)) != l)
            break;
        o = c
    }
    for (; a < i.length; ) {
        let c = yn(i.text, a);
        if (r(i.text.slice(a, c)) != l)
            break;
        a = c
    }
    return ge.range(o + i.from, a + i.from)
}
function dde(t, e) {
    return e.left > t ? e.left - t : Math.max(0, t - e.right)
}
function fde(t, e) {
    return e.top > t ? e.top - t : Math.max(0, t - e.bottom)
}
function N0(t, e) {
    return t.top < e.bottom - 1 && t.bottom > e.top + 1
}
function gT(t, e) {
    return e < t.top ? {
        top: e,
        left: t.left,
        right: t.right,
        bottom: t.bottom
    } : t
}
function _T(t, e) {
    return e > t.bottom ? {
        top: t.top,
        left: t.left,
        right: t.right,
        bottom: e
    } : t
}
function Kb(t, e, n) {
    let r, i, s, o, a = !1, l, c, u, h;
    for (let g = t.firstChild; g; g = g.nextSibling) {
        let _ = Ku(g);
        for (let m = 0; m < _.length; m++) {
            let p = _[m];
            i && N0(i, p) && (p = gT(_T(p, i.bottom), i.top));
            let b = dde(e, p)
              , y = fde(n, p);
            if (b == 0 && y == 0)
                return g.nodeType == 3 ? bT(g, e, n) : Kb(g, e, n);
            if (!r || o > y || o == y && s > b) {
                r = g,
                i = p,
                s = b,
                o = y;
                let x = y ? n < p.top ? -1 : 1 : b ? e < p.left ? -1 : 1 : 0;
                a = !x || (x > 0 ? m < _.length - 1 : m > 0)
            }
            b == 0 ? n > p.bottom && (!u || u.bottom < p.bottom) ? (l = g,
            u = p) : n < p.top && (!h || h.top > p.top) && (c = g,
            h = p) : u && N0(u, p) ? u = _T(u, p.bottom) : h && N0(h, p) && (h = gT(h, p.top))
        }
    }
    if (u && u.bottom >= n ? (r = l,
    i = u) : h && h.top <= n && (r = c,
    i = h),
    !r)
        return {
            node: t,
            offset: 0
        };
    let d = Math.max(i.left, Math.min(i.right, e));
    if (r.nodeType == 3)
        return bT(r, d, n);
    if (a && r.contentEditable != "false")
        return Kb(r, d, n);
    let f = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
    return {
        node: t,
        offset: f
    }
}
function bT(t, e, n) {
    let r = t.nodeValue.length
      , i = -1
      , s = 1e9
      , o = 0;
    for (let a = 0; a < r; a++) {
        let l = ua(t, a, a + 1).getClientRects();
        for (let c = 0; c < l.length; c++) {
            let u = l[c];
            if (u.top == u.bottom)
                continue;
            o || (o = e - u.left);
            let h = (u.top > n ? u.top - n : n - u.bottom) - 1;
            if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
                let d = e >= (u.left + u.right) / 2
                  , f = d;
                if ((Le.chrome || Le.gecko) && ua(t, a).getBoundingClientRect().left == u.right && (f = !d),
                h <= 0)
                    return {
                        node: t,
                        offset: a + (f ? 1 : 0)
                    };
                i = a + (f ? 1 : 0),
                s = h
            }
        }
    }
    return {
        node: t,
        offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0
    }
}
function B3(t, e, n, r=-1) {
    var i, s;
    let o = t.contentDOM.getBoundingClientRect(), a = o.top + t.viewState.paddingTop, l, {docHeight: c} = t.viewState, {x: u, y: h} = e, d = h - a;
    if (d < 0)
        return 0;
    if (d > c)
        return t.state.doc.length;
    for (let x = t.viewState.heightOracle.textHeight / 2, E = !1; l = t.elementAtHeight(d),
    l.type != Vn.Text; )
        for (; d = r > 0 ? l.bottom + x : l.top - x,
        !(d >= 0 && d <= c); ) {
            if (E)
                return n ? null : 0;
            E = !0,
            r = -r
        }
    h = a + d;
    let f = l.from;
    if (f < t.viewport.from)
        return t.viewport.from == 0 ? 0 : n ? null : yT(t, o, l, u, h);
    if (f > t.viewport.to)
        return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : yT(t, o, l, u, h);
    let g = t.dom.ownerDocument
      , _ = t.root.elementFromPoint ? t.root : g
      , m = _.elementFromPoint(u, h);
    m && !t.contentDOM.contains(m) && (m = null),
    m || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)),
    m = _.elementFromPoint(u, h),
    m && !t.contentDOM.contains(m) && (m = null));
    let p, b = -1;
    if (m && ((i = t.docView.nearest(m)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
        if (g.caretPositionFromPoint) {
            let x = g.caretPositionFromPoint(u, h);
            x && ({offsetNode: p, offset: b} = x)
        } else if (g.caretRangeFromPoint) {
            let x = g.caretRangeFromPoint(u, h);
            x && ({startContainer: p, startOffset: b} = x,
            (!t.contentDOM.contains(p) || Le.safari && pde(p, b, u) || Le.chrome && mde(p, b, u)) && (p = void 0))
        }
    }
    if (!p || !t.docView.dom.contains(p)) {
        let x = qt.find(t.docView, f);
        if (!x)
            return d > l.top + l.height / 2 ? l.to : l.from;
        ({node: p, offset: b} = Kb(x.dom, u, h))
    }
    let y = t.docView.nearest(p);
    if (!y)
        return null;
    if (y.isWidget && ((s = y.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
        let x = y.dom.getBoundingClientRect();
        return e.y < x.top || e.y <= x.bottom && e.x <= (x.left + x.right) / 2 ? y.posAtStart : y.posAtEnd
    } else
        return y.localPosFromDOM(p, b) + y.posAtStart
}
function yT(t, e, n, r, i) {
    let s = Math.round((r - e.left) * t.defaultCharacterWidth);
    if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
        let a = t.viewState.heightOracle.textHeight
          , l = Math.floor((i - n.top - (t.defaultLineHeight - a) * .5) / a);
        s += l * t.viewState.heightOracle.lineLength
    }
    let o = t.state.sliceDoc(n.from, n.to);
    return n.from + Phe(o, s, t.state.tabSize)
}
function pde(t, e, n) {
    let r;
    if (t.nodeType != 3 || e != (r = t.nodeValue.length))
        return !1;
    for (let i = t.nextSibling; i; i = i.nextSibling)
        if (i.nodeType != 1 || i.nodeName != "BR")
            return !1;
    return ua(t, r - 1, r).getBoundingClientRect().left > n
}
function mde(t, e, n) {
    if (e != 0)
        return !1;
    for (let i = t; ; ) {
        let s = i.parentNode;
        if (!s || s.nodeType != 1 || s.firstChild != i)
            return !1;
        if (s.classList.contains("cm-line"))
            break;
        i = s
    }
    let r = t.nodeType == 1 ? t.getBoundingClientRect() : ua(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
    return n - r.left > 5
}
function Yb(t, e) {
    let n = t.lineBlockAt(e);
    if (Array.isArray(n.type)) {
        for (let r of n.type)
            if (r.to > e || r.to == e && (r.to == n.to || r.type == Vn.Text))
                return r
    }
    return n
}
function gde(t, e, n, r) {
    let i = Yb(t, e.head)
      , s = !r || i.type != Vn.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
    if (s) {
        let o = t.dom.getBoundingClientRect()
          , a = t.textDirectionAt(i.from)
          , l = t.posAtCoords({
            x: n == (a == Nt.LTR) ? o.right - 1 : o.left + 1,
            y: (s.top + s.bottom) / 2
        });
        if (l != null)
            return ge.cursor(l, n ? -1 : 1)
    }
    return ge.cursor(n ? i.to : i.from, n ? -1 : 1)
}
function vT(t, e, n, r) {
    let i = t.state.doc.lineAt(e.head)
      , s = t.bidiSpans(i)
      , o = t.textDirectionAt(i.from);
    for (let a = e, l = null; ; ) {
        let c = tde(i, s, o, a, n)
          , u = v3;
        if (!c) {
            if (i.number == (n ? t.state.doc.lines : 1))
                return a;
            u = `
`,
            i = t.state.doc.line(i.number + (n ? 1 : -1)),
            s = t.bidiSpans(i),
            c = t.visualLineSide(i, !n)
        }
        if (l) {
            if (!l(u))
                return a
        } else {
            if (!r)
                return c;
            l = r(u)
        }
        a = c
    }
}
function _de(t, e, n) {
    let r = t.state.charCategorizer(e)
      , i = r(n);
    return s => {
        let o = r(s);
        return i == Xt.Space && (i = o),
        i == o
    }
}
function bde(t, e, n, r) {
    let i = e.head
      , s = n ? 1 : -1;
    if (i == (n ? t.state.doc.length : 0))
        return ge.cursor(i, e.assoc);
    let o = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), u = t.documentTop;
    if (c)
        o == null && (o = c.left - l.left),
        a = s < 0 ? c.top : c.bottom;
    else {
        let f = t.viewState.lineBlockAt(i);
        o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - f.from))),
        a = (s < 0 ? f.top : f.bottom) + u
    }
    let h = l.left + o
      , d = r ?? t.viewState.heightOracle.textHeight >> 1;
    for (let f = 0; ; f += 10) {
        let g = a + (d + f) * s
          , _ = B3(t, {
            x: h,
            y: g
        }, !1, s);
        if (g < l.top || g > l.bottom || (s < 0 ? _ < i : _ > i)) {
            let m = t.docView.coordsForChar(_)
              , p = !m || g < m.top ? -1 : 1;
            return ge.cursor(_, p, void 0, o)
        }
    }
}
function Tf(t, e, n) {
    for (; ; ) {
        let r = 0;
        for (let i of t)
            i.between(e - 1, e + 1, (s, o, a) => {
                if (e > s && e < o) {
                    let l = r || n || (e - s < o - e ? -1 : 1);
                    e = l < 0 ? s : o,
                    r = l
                }
            }
            );
        if (!r)
            return e
    }
}
function M0(t, e, n) {
    let r = Tf(t.state.facet(X1).map(i => i(t)), n.from, e.head > n.from ? -1 : 1);
    return r == n.from ? n : ge.cursor(r, r < n.from ? 1 : -1)
}
class yde {
    setSelectionOrigin(e) {
        this.lastSelectionOrigin = e,
        this.lastSelectionTime = Date.now()
    }
    constructor(e) {
        this.view = e,
        this.lastKeyCode = 0,
        this.lastKeyTime = 0,
        this.lastTouchTime = 0,
        this.lastFocusTime = 0,
        this.lastScrollTop = 0,
        this.lastScrollLeft = 0,
        this.pendingIOSKey = void 0,
        this.tabFocusMode = -1,
        this.lastSelectionOrigin = null,
        this.lastSelectionTime = 0,
        this.lastContextMenu = 0,
        this.scrollHandlers = [],
        this.handlers = Object.create(null),
        this.composing = -1,
        this.compositionFirstChange = null,
        this.compositionEndedAt = 0,
        this.compositionPendingKey = !1,
        this.compositionPendingChange = !1,
        this.mouseSelection = null,
        this.draggedContent = null,
        this.handleEvent = this.handleEvent.bind(this),
        this.notifiedFocused = e.hasFocus,
        Le.safari && e.contentDOM.addEventListener("input", () => null),
        Le.gecko && Nde(e.contentDOM.ownerDocument)
    }
    handleEvent(e) {
        !Ade(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e)
    }
    runHandlers(e, n) {
        let r = this.handlers[e];
        if (r) {
            for (let i of r.observers)
                i(this.view, n);
            for (let i of r.handlers) {
                if (n.defaultPrevented)
                    break;
                if (i(this.view, n)) {
                    n.preventDefault();
                    break
                }
            }
        }
    }
    ensureHandlers(e) {
        let n = vde(e)
          , r = this.handlers
          , i = this.view.contentDOM;
        for (let s in n)
            if (s != "scroll") {
                let o = !n[s].handlers.length
                  , a = r[s];
                a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent),
                a = null),
                a || i.addEventListener(s, this.handleEvent, {
                    passive: o
                })
            }
        for (let s in r)
            s != "scroll" && !n[s] && i.removeEventListener(s, this.handleEvent);
        this.handlers = n
    }
    keydown(e) {
        if (this.lastKeyCode = e.keyCode,
        this.lastKeyTime = Date.now(),
        e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
            return !0;
        if (this.tabFocusMode > 0 && e.keyCode != 27 && j3.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1),
        Le.android && Le.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
            return this.view.observer.delayAndroidKey(e.key, e.keyCode),
            !0;
        let n;
        return Le.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = F3.find(r => r.keyCode == e.keyCode)) && !e.ctrlKey || xde.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e,
        setTimeout( () => this.flushIOSKey(), 250),
        !0) : (e.keyCode != 229 && this.view.observer.forceFlush(),
        !1)
    }
    flushIOSKey(e) {
        let n = this.pendingIOSKey;
        return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0,
        gl(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0))
    }
    ignoreDuringComposition(e) {
        return /^key/.test(e.type) ? this.composing > 0 ? !0 : Le.safari && !Le.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1,
        !0) : !1 : !1
    }
    startMouseSelection(e) {
        this.mouseSelection && this.mouseSelection.destroy(),
        this.mouseSelection = e
    }
    update(e) {
        this.view.observer.update(e),
        this.mouseSelection && this.mouseSelection.update(e),
        this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)),
        e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0)
    }
    destroy() {
        this.mouseSelection && this.mouseSelection.destroy()
    }
}
function xT(t, e) {
    return (n, r) => {
        try {
            return e.call(t, r, n)
        } catch (i) {
            fr(n.state, i)
        }
    }
}
function vde(t) {
    let e = Object.create(null);
    function n(r) {
        return e[r] || (e[r] = {
            observers: [],
            handlers: []
        })
    }
    for (let r of t) {
        let i = r.spec;
        if (i && i.domEventHandlers)
            for (let s in i.domEventHandlers) {
                let o = i.domEventHandlers[s];
                o && n(s).handlers.push(xT(r.value, o))
            }
        if (i && i.domEventObservers)
            for (let s in i.domEventObservers) {
                let o = i.domEventObservers[s];
                o && n(s).observers.push(xT(r.value, o))
            }
    }
    for (let r in ri)
        n(r).handlers.push(ri[r]);
    for (let r in Mr)
        n(r).observers.push(Mr[r]);
    return e
}
const F3 = [{
    key: "Backspace",
    keyCode: 8,
    inputType: "deleteContentBackward"
}, {
    key: "Enter",
    keyCode: 13,
    inputType: "insertParagraph"
}, {
    key: "Enter",
    keyCode: 13,
    inputType: "insertLineBreak"
}, {
    key: "Delete",
    keyCode: 46,
    inputType: "deleteContentForward"
}]
  , xde = "dthko"
  , j3 = [16, 17, 18, 20, 91, 92, 224, 225]
  , Ud = 6;
function Vd(t) {
    return Math.max(0, t) * .7 + 8
}
function Ede(t, e) {
    return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY))
}
class Sde {
    constructor(e, n, r, i) {
        this.view = e,
        this.startEvent = n,
        this.style = r,
        this.mustSelect = i,
        this.scrollSpeed = {
            x: 0,
            y: 0
        },
        this.scrolling = -1,
        this.lastEvent = n,
        this.scrollParent = jhe(e.contentDOM),
        this.atoms = e.state.facet(X1).map(o => o(e));
        let s = e.contentDOM.ownerDocument;
        s.addEventListener("mousemove", this.move = this.move.bind(this)),
        s.addEventListener("mouseup", this.up = this.up.bind(this)),
        this.extend = n.shiftKey,
        this.multiple = e.state.facet(lt.allowMultipleSelections) && wde(e, n),
        this.dragging = Tde(e, n) && $3(n) == 1 ? null : !1
    }
    start(e) {
        this.dragging === !1 && this.select(e)
    }
    move(e) {
        var n;
        if (e.buttons == 0)
            return this.destroy();
        if (this.dragging || this.dragging == null && Ede(this.startEvent, e) < 10)
            return;
        this.select(this.lastEvent = e);
        let r = 0
          , i = 0
          , s = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || {
            left: 0,
            top: 0,
            right: this.view.win.innerWidth,
            bottom: this.view.win.innerHeight
        }
          , o = N3(this.view);
        e.clientX - o.left <= s.left + Ud ? r = -Vd(s.left - e.clientX) : e.clientX + o.right >= s.right - Ud && (r = Vd(e.clientX - s.right)),
        e.clientY - o.top <= s.top + Ud ? i = -Vd(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - Ud && (i = Vd(e.clientY - s.bottom)),
        this.setScrollSpeed(r, i)
    }
    up(e) {
        this.dragging == null && this.select(this.lastEvent),
        this.dragging || e.preventDefault(),
        this.destroy()
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let e = this.view.contentDOM.ownerDocument;
        e.removeEventListener("mousemove", this.move),
        e.removeEventListener("mouseup", this.up),
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null
    }
    setScrollSpeed(e, n) {
        this.scrollSpeed = {
            x: e,
            y: n
        },
        e || n ? this.scrolling < 0 && (this.scrolling = setInterval( () => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling),
        this.scrolling = -1)
    }
    scroll() {
        this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x,
        this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
        this.dragging === !1 && this.select(this.lastEvent)
    }
    skipAtoms(e) {
        let n = null;
        for (let r = 0; r < e.ranges.length; r++) {
            let i = e.ranges[r]
              , s = null;
            if (i.empty) {
                let o = Tf(this.atoms, i.from, 0);
                o != i.from && (s = ge.cursor(o, -1))
            } else {
                let o = Tf(this.atoms, i.from, -1)
                  , a = Tf(this.atoms, i.to, 1);
                (o != i.from || a != i.to) && (s = ge.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a))
            }
            s && (n || (n = e.ranges.slice()),
            n[r] = s)
        }
        return n ? ge.create(n, e.mainIndex) : e
    }
    select(e) {
        let {view: n} = this
          , r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
        (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
            selection: r,
            userEvent: "select.pointer"
        }),
        this.mustSelect = !1
    }
    update(e) {
        e.transactions.some(n => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout( () => this.select(this.lastEvent), 20)
    }
}
function wde(t, e) {
    let n = t.state.facet(x3);
    return n.length ? n[0](e) : Le.mac ? e.metaKey : e.ctrlKey
}
function Cde(t, e) {
    let n = t.state.facet(E3);
    return n.length ? n[0](e) : Le.mac ? !e.altKey : !e.ctrlKey
}
function Tde(t, e) {
    let {main: n} = t.state.selection;
    if (n.empty)
        return !1;
    let r = qu(t.root);
    if (!r || r.rangeCount == 0)
        return !0;
    let i = r.getRangeAt(0).getClientRects();
    for (let s = 0; s < i.length; s++) {
        let o = i[s];
        if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
            return !0
    }
    return !1
}
function Ade(t, e) {
    if (!e.bubbles)
        return !0;
    if (e.defaultPrevented)
        return !1;
    for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
        if (!n || n.nodeType == 11 || (r = Tt.get(n)) && r.ignoreEvent(e))
            return !1;
    return !0
}
const ri = Object.create(null)
  , Mr = Object.create(null)
  , H3 = Le.ie && Le.ie_version < 15 || Le.ios && Le.webkit_version < 604;
function kde(t) {
    let e = t.dom.parentNode;
    if (!e)
        return;
    let n = e.appendChild(document.createElement("textarea"));
    n.style.cssText = "position: fixed; left: -10000px; top: 10px",
    n.focus(),
    setTimeout( () => {
        t.focus(),
        n.remove(),
        U3(t, n.value)
    }
    , 50)
}
function U3(t, e) {
    let {state: n} = t, r, i = 1, s = n.toText(e), o = s.lines == n.selection.ranges.length;
    if (Xb != null && n.selection.ranges.every(l => l.empty) && Xb == s.toString()) {
        let l = -1;
        r = n.changeByRange(c => {
            let u = n.doc.lineAt(c.from);
            if (u.from == l)
                return {
                    range: c
                };
            l = u.from;
            let h = n.toText((o ? s.line(i++).text : e) + n.lineBreak);
            return {
                changes: {
                    from: u.from,
                    insert: h
                },
                range: ge.cursor(c.from + h.length)
            }
        }
        )
    } else
        o ? r = n.changeByRange(l => {
            let c = s.line(i++);
            return {
                changes: {
                    from: l.from,
                    to: l.to,
                    insert: c.text
                },
                range: ge.cursor(l.from + c.length)
            }
        }
        ) : r = n.replaceSelection(s);
    t.dispatch(r, {
        userEvent: "input.paste",
        scrollIntoView: !0
    })
}
Mr.scroll = t => {
    t.inputState.lastScrollTop = t.scrollDOM.scrollTop,
    t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft
}
;
ri.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"),
e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3),
!1);
Mr.touchstart = (t, e) => {
    t.inputState.lastTouchTime = Date.now(),
    t.inputState.setSelectionOrigin("select.pointer")
}
;
Mr.touchmove = t => {
    t.inputState.setSelectionOrigin("select.pointer")
}
;
ri.mousedown = (t, e) => {
    if (t.observer.flush(),
    t.inputState.lastTouchTime > Date.now() - 2e3)
        return !1;
    let n = null;
    for (let r of t.state.facet(S3))
        if (n = r(t, e),
        n)
            break;
    if (!n && e.button == 0 && (n = Pde(t, e)),
    n) {
        let r = !t.hasFocus;
        t.inputState.startMouseSelection(new Sde(t,e,n,r)),
        r && t.observer.ignore( () => {
            n3(t.contentDOM);
            let s = t.root.activeElement;
            s && !s.contains(t.contentDOM) && s.blur()
        }
        );
        let i = t.inputState.mouseSelection;
        if (i)
            return i.start(e),
            i.dragging === !1
    }
    return !1
}
;
function ET(t, e, n, r) {
    if (r == 1)
        return ge.cursor(e, n);
    if (r == 2)
        return hde(t.state, e, n);
    {
        let i = qt.find(t.docView, e)
          , s = t.state.doc.lineAt(i ? i.posAtEnd : e)
          , o = i ? i.posAtStart : s.from
          , a = i ? i.posAtEnd : s.to;
        return a < t.state.doc.length && a == s.to && a++,
        ge.range(o, a)
    }
}
let V3 = (t, e) => t >= e.top && t <= e.bottom
  , ST = (t, e, n) => V3(e, n) && t >= n.left && t <= n.right;
function Rde(t, e, n, r) {
    let i = qt.find(t.docView, e);
    if (!i)
        return 1;
    let s = e - i.posAtStart;
    if (s == 0)
        return 1;
    if (s == i.length)
        return -1;
    let o = i.coordsAt(s, -1);
    if (o && ST(n, r, o))
        return -1;
    let a = i.coordsAt(s, 1);
    return a && ST(n, r, a) ? 1 : o && V3(r, o) ? -1 : 1
}
function wT(t, e) {
    let n = t.posAtCoords({
        x: e.clientX,
        y: e.clientY
    }, !1);
    return {
        pos: n,
        bias: Rde(t, n, e.clientX, e.clientY)
    }
}
const Ide = Le.ie && Le.ie_version <= 11;
let CT = null
  , TT = 0
  , AT = 0;
function $3(t) {
    if (!Ide)
        return t.detail;
    let e = CT
      , n = AT;
    return CT = t,
    AT = Date.now(),
    TT = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (TT + 1) % 3 : 1
}
function Pde(t, e) {
    let n = wT(t, e)
      , r = $3(e)
      , i = t.state.selection;
    return {
        update(s) {
            s.docChanged && (n.pos = s.changes.mapPos(n.pos),
            i = i.map(s.changes))
        },
        get(s, o, a) {
            let l = wT(t, s), c, u = ET(t, l.pos, l.bias, r);
            if (n.pos != l.pos && !o) {
                let h = ET(t, n.pos, n.bias, r)
                  , d = Math.min(h.from, u.from)
                  , f = Math.max(h.to, u.to);
                u = d < u.from ? ge.range(d, f) : ge.range(f, d)
            }
            return o ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = Dde(i, l.pos)) ? c : a ? i.addRange(u) : ge.create([u])
        }
    }
}
function Dde(t, e) {
    for (let n = 0; n < t.ranges.length; n++) {
        let {from: r, to: i} = t.ranges[n];
        if (r <= e && i >= e)
            return ge.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0))
    }
    return null
}
ri.dragstart = (t, e) => {
    let {selection: {main: n}} = t.state;
    if (e.target.draggable) {
        let i = t.docView.nearest(e.target);
        if (i && i.isWidget) {
            let s = i.posAtStart
              , o = s + i.length;
            (s >= n.to || o <= n.from) && (n = ge.range(s, o))
        }
    }
    let {inputState: r} = t;
    return r.mouseSelection && (r.mouseSelection.dragging = !0),
    r.draggedContent = n,
    e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(n.from, n.to)),
    e.dataTransfer.effectAllowed = "copyMove"),
    !1
}
;
ri.dragend = t => (t.inputState.draggedContent = null,
!1);
function kT(t, e, n, r) {
    if (!n)
        return;
    let i = t.posAtCoords({
        x: e.clientX,
        y: e.clientY
    }, !1)
      , {draggedContent: s} = t.inputState
      , o = r && s && Cde(t, e) ? {
        from: s.from,
        to: s.to
    } : null
      , a = {
        from: i,
        insert: n
    }
      , l = t.state.changes(o ? [o, a] : a);
    t.focus(),
    t.dispatch({
        changes: l,
        selection: {
            anchor: l.mapPos(i, -1),
            head: l.mapPos(i, 1)
        },
        userEvent: o ? "move.drop" : "input.drop"
    }),
    t.inputState.draggedContent = null
}
ri.drop = (t, e) => {
    if (!e.dataTransfer)
        return !1;
    if (t.state.readOnly)
        return !0;
    let n = e.dataTransfer.files;
    if (n && n.length) {
        let r = Array(n.length)
          , i = 0
          , s = () => {
            ++i == n.length && kT(t, e, r.filter(o => o != null).join(t.state.lineBreak), !1)
        }
        ;
        for (let o = 0; o < n.length; o++) {
            let a = new FileReader;
            a.onerror = s,
            a.onload = () => {
                /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result),
                s()
            }
            ,
            a.readAsText(n[o])
        }
        return !0
    } else {
        let r = e.dataTransfer.getData("Text");
        if (r)
            return kT(t, e, r, !0),
            !0
    }
    return !1
}
;
ri.paste = (t, e) => {
    if (t.state.readOnly)
        return !0;
    t.observer.flush();
    let n = H3 ? null : e.clipboardData;
    return n ? (U3(t, n.getData("text/plain") || n.getData("text/uri-list")),
    !0) : (kde(t),
    !1)
}
;
function Lde(t, e) {
    let n = t.dom.parentNode;
    if (!n)
        return;
    let r = n.appendChild(document.createElement("textarea"));
    r.style.cssText = "position: fixed; left: -10000px; top: 10px",
    r.value = e,
    r.focus(),
    r.selectionEnd = e.length,
    r.selectionStart = 0,
    setTimeout( () => {
        r.remove(),
        t.focus()
    }
    , 50)
}
function Ode(t) {
    let e = []
      , n = []
      , r = !1;
    for (let i of t.selection.ranges)
        i.empty || (e.push(t.sliceDoc(i.from, i.to)),
        n.push(i));
    if (!e.length) {
        let i = -1;
        for (let {from: s} of t.selection.ranges) {
            let o = t.doc.lineAt(s);
            o.number > i && (e.push(o.text),
            n.push({
                from: o.from,
                to: Math.min(t.doc.length, o.to + 1)
            })),
            i = o.number
        }
        r = !0
    }
    return {
        text: e.join(t.lineBreak),
        ranges: n,
        linewise: r
    }
}
let Xb = null;
ri.copy = ri.cut = (t, e) => {
    let {text: n, ranges: r, linewise: i} = Ode(t.state);
    if (!n && !i)
        return !1;
    Xb = i ? n : null,
    e.type == "cut" && !t.state.readOnly && t.dispatch({
        changes: r,
        scrollIntoView: !0,
        userEvent: "delete.cut"
    });
    let s = H3 ? null : e.clipboardData;
    return s ? (s.clearData(),
    s.setData("text/plain", n),
    !0) : (Lde(t, n),
    !1)
}
;
const z3 = fs.define();
function W3(t, e) {
    let n = [];
    for (let r of t.facet(T3)) {
        let i = r(t, e);
        i && n.push(i)
    }
    return n ? t.update({
        effects: n,
        annotations: z3.of(!0)
    }) : null
}
function G3(t) {
    setTimeout( () => {
        let e = t.hasFocus;
        if (e != t.inputState.notifiedFocused) {
            let n = W3(t.state, e);
            n ? t.dispatch(n) : t.update([])
        }
    }
    , 10)
}
Mr.focus = t => {
    t.inputState.lastFocusTime = Date.now(),
    !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop,
    t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft),
    G3(t)
}
;
Mr.blur = t => {
    t.observer.clearSelectionRange(),
    G3(t)
}
;
Mr.compositionstart = Mr.compositionupdate = t => {
    t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0),
    t.inputState.composing < 0 && (t.inputState.composing = 0))
}
;
Mr.compositionend = t => {
    t.observer.editContext || (t.inputState.composing = -1,
    t.inputState.compositionEndedAt = Date.now(),
    t.inputState.compositionPendingKey = !0,
    t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0,
    t.inputState.compositionFirstChange = null,
    Le.chrome && Le.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then( () => t.observer.flush()) : setTimeout( () => {
        t.inputState.composing < 0 && t.docView.hasComposition && t.update([])
    }
    , 50))
}
;
Mr.contextmenu = t => {
    t.inputState.lastContextMenu = Date.now()
}
;
ri.beforeinput = (t, e) => {
    var n;
    let r;
    if (Le.chrome && Le.android && (r = F3.find(i => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(r.key, r.keyCode),
    r.key == "Backspace" || r.key == "Delete")) {
        let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
        setTimeout( () => {
            var s;
            (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(),
            t.focus())
        }
        , 100)
    }
    return Le.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(),
    Le.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout( () => Mr.compositionend(t, e), 20),
    !1
}
;
const RT = new Set;
function Nde(t) {
    RT.has(t) || (RT.add(t),
    t.addEventListener("copy", () => {}
    ),
    t.addEventListener("cut", () => {}
    ))
}
const IT = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class Mde {
    constructor(e) {
        this.lineWrapping = e,
        this.doc = gt.empty,
        this.heightSamples = {},
        this.lineHeight = 14,
        this.charWidth = 7,
        this.textHeight = 14,
        this.lineLength = 30,
        this.heightChanged = !1
    }
    heightForGap(e, n) {
        let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
        return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * .5) / this.lineLength))),
        this.lineHeight * r
    }
    heightForLine(e) {
        return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight
    }
    setDoc(e) {
        return this.doc = e,
        this
    }
    mustRefreshForWrapping(e) {
        return IT.indexOf(e) > -1 != this.lineWrapping
    }
    mustRefreshForHeights(e) {
        let n = !1;
        for (let r = 0; r < e.length; r++) {
            let i = e[r];
            i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0,
            this.heightSamples[Math.floor(i * 10)] = !0)
        }
        return n
    }
    refresh(e, n, r, i, s, o) {
        let a = IT.indexOf(e) > -1
          , l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
        if (this.lineWrapping = a,
        this.lineHeight = n,
        this.charWidth = r,
        this.textHeight = i,
        this.lineLength = s,
        l) {
            this.heightSamples = {};
            for (let c = 0; c < o.length; c++) {
                let u = o[c];
                u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0
            }
        }
        return l
    }
}
class Bde {
    constructor(e, n) {
        this.from = e,
        this.heights = n,
        this.index = 0
    }
    get more() {
        return this.index < this.heights.length
    }
}
class bi {
    constructor(e, n, r, i, s) {
        this.from = e,
        this.length = n,
        this.top = r,
        this.height = i,
        this._content = s
    }
    get type() {
        return typeof this._content == "number" ? Vn.Text : Array.isArray(this._content) ? this._content : this._content.type
    }
    get to() {
        return this.from + this.length
    }
    get bottom() {
        return this.top + this.height
    }
    get widget() {
        return this._content instanceof Zs ? this._content.widget : null
    }
    get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0
    }
    join(e) {
        let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
        return new bi(this.from,this.length + e.length,this.top,this.height + e.height,n)
    }
}
var Dt = function(t) {
    return t[t.ByPos = 0] = "ByPos",
    t[t.ByHeight = 1] = "ByHeight",
    t[t.ByPosNoHeight = 2] = "ByPosNoHeight",
    t
}(Dt || (Dt = {}));
const Af = .001;
class $n {
    constructor(e, n, r=2) {
        this.length = e,
        this.height = n,
        this.flags = r
    }
    get outdated() {
        return (this.flags & 2) > 0
    }
    set outdated(e) {
        this.flags = (e ? 2 : 0) | this.flags & -3
    }
    setHeight(e, n) {
        this.height != n && (Math.abs(this.height - n) > Af && (e.heightChanged = !0),
        this.height = n)
    }
    replace(e, n, r) {
        return $n.of(r)
    }
    decomposeLeft(e, n) {
        n.push(this)
    }
    decomposeRight(e, n) {
        n.push(this)
    }
    applyChanges(e, n, r, i) {
        let s = this
          , o = r.doc;
        for (let a = i.length - 1; a >= 0; a--) {
            let {fromA: l, toA: c, fromB: u, toB: h} = i[a]
              , d = s.lineAt(l, Dt.ByPosNoHeight, r.setDoc(n), 0, 0)
              , f = d.to >= c ? d : s.lineAt(c, Dt.ByPosNoHeight, r, 0, 0);
            for (h += f.to - c,
            c = f.to; a > 0 && d.from <= i[a - 1].toA; )
                l = i[a - 1].fromA,
                u = i[a - 1].fromB,
                a--,
                l < d.from && (d = s.lineAt(l, Dt.ByPosNoHeight, r, 0, 0));
            u += d.from - l,
            l = d.from;
            let g = Q1.build(r.setDoc(o), e, u, h);
            s = s.replace(l, c, g)
        }
        return s.updateHeight(r, 0)
    }
    static empty() {
        return new lr(0,0)
    }
    static of(e) {
        if (e.length == 1)
            return e[0];
        let n = 0
          , r = e.length
          , i = 0
          , s = 0;
        for (; ; )
            if (n == r)
                if (i > s * 2) {
                    let a = e[n - 1];
                    a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right),
                    r += 1 + a.break,
                    i -= a.size
                } else if (s > i * 2) {
                    let a = e[r];
                    a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right),
                    r += 2 + a.break,
                    s -= a.size
                } else
                    break;
            else if (i < s) {
                let a = e[n++];
                a && (i += a.size)
            } else {
                let a = e[--r];
                a && (s += a.size)
            }
        let o = 0;
        return e[n - 1] == null ? (o = 1,
        n--) : e[n] == null && (o = 1,
        r++),
        new Fde($n.of(e.slice(0, n)),o,$n.of(e.slice(r)))
    }
}
$n.prototype.size = 1;
class q3 extends $n {
    constructor(e, n, r) {
        super(e, n),
        this.deco = r
    }
    blockAt(e, n, r, i) {
        return new bi(i,this.length,r,this.height,this.deco || 0)
    }
    lineAt(e, n, r, i, s) {
        return this.blockAt(0, r, i, s)
    }
    forEachLine(e, n, r, i, s, o) {
        e <= s + this.length && n >= s && o(this.blockAt(0, r, i, s))
    }
    updateHeight(e, n=0, r=!1, i) {
        return i && i.from <= n && i.more && this.setHeight(e, i.heights[i.index++]),
        this.outdated = !1,
        this
    }
    toString() {
        return `block(${this.length})`
    }
}
class lr extends q3 {
    constructor(e, n) {
        super(e, n, null),
        this.collapsed = 0,
        this.widgetHeight = 0,
        this.breaks = 0
    }
    blockAt(e, n, r, i) {
        return new bi(i,this.length,r,this.height,this.breaks)
    }
    replace(e, n, r) {
        let i = r[0];
        return r.length == 1 && (i instanceof lr || i instanceof pn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof pn ? i = new lr(i.length,this.height) : i.height = this.height,
        this.outdated || (i.outdated = !1),
        i) : $n.of(r)
    }
    updateHeight(e, n=0, r=!1, i) {
        return i && i.from <= n && i.more ? this.setHeight(e, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight),
        this.outdated = !1,
        this
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`
    }
}
class pn extends $n {
    constructor(e) {
        super(e, 0)
    }
    heightMetrics(e, n) {
        let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, s = i - r + 1, o, a = 0;
        if (e.lineWrapping) {
            let l = Math.min(this.height, e.lineHeight * s);
            o = l / s,
            this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1))
        } else
            o = this.height / s;
        return {
            firstLine: r,
            lastLine: i,
            perLine: o,
            perChar: a
        }
    }
    blockAt(e, n, r, i) {
        let {firstLine: s, lastLine: o, perLine: a, perChar: l} = this.heightMetrics(n, i);
        if (n.lineWrapping) {
            let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length))
              , u = n.doc.lineAt(c)
              , h = a + u.length * l
              , d = Math.max(r, e - h / 2);
            return new bi(u.from,u.length,d,h,0)
        } else {
            let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / a)))
              , {from: u, length: h} = n.doc.line(s + c);
            return new bi(u,h,r + a * c,a,0)
        }
    }
    lineAt(e, n, r, i, s) {
        if (n == Dt.ByHeight)
            return this.blockAt(e, r, i, s);
        if (n == Dt.ByPosNoHeight) {
            let {from: f, to: g} = r.doc.lineAt(e);
            return new bi(f,g - f,0,0,0)
        }
        let {firstLine: o, perLine: a, perChar: l} = this.heightMetrics(r, s)
          , c = r.doc.lineAt(e)
          , u = a + c.length * l
          , h = c.number - o
          , d = i + a * h + l * (c.from - s - h);
        return new bi(c.from,c.length,Math.max(i, Math.min(d, i + this.height - u)),u,0)
    }
    forEachLine(e, n, r, i, s, o) {
        e = Math.max(e, s),
        n = Math.min(n, s + this.length);
        let {firstLine: a, perLine: l, perChar: c} = this.heightMetrics(r, s);
        for (let u = e, h = i; u <= n; ) {
            let d = r.doc.lineAt(u);
            if (u == e) {
                let g = d.number - a;
                h += l * g + c * (e - s - g)
            }
            let f = l + c * d.length;
            o(new bi(d.from,d.length,h,f,0)),
            h += f,
            u = d.to + 1
        }
    }
    replace(e, n, r) {
        let i = this.length - n;
        if (i > 0) {
            let s = r[r.length - 1];
            s instanceof pn ? r[r.length - 1] = new pn(s.length + i) : r.push(null, new pn(i - 1))
        }
        if (e > 0) {
            let s = r[0];
            s instanceof pn ? r[0] = new pn(e + s.length) : r.unshift(new pn(e - 1), null)
        }
        return $n.of(r)
    }
    decomposeLeft(e, n) {
        n.push(new pn(e - 1), null)
    }
    decomposeRight(e, n) {
        n.push(null, new pn(this.length - e - 1))
    }
    updateHeight(e, n=0, r=!1, i) {
        let s = n + this.length;
        if (i && i.from <= n + this.length && i.more) {
            let o = []
              , a = Math.max(n, i.from)
              , l = -1;
            for (i.from > n && o.push(new pn(i.from - n - 1).updateHeight(e, n)); a <= s && i.more; ) {
                let u = e.doc.lineAt(a).length;
                o.length && o.push(null);
                let h = i.heights[i.index++];
                l == -1 ? l = h : Math.abs(h - l) >= Af && (l = -2);
                let d = new lr(u,h);
                d.outdated = !1,
                o.push(d),
                a += u + 1
            }
            a <= s && o.push(null, new pn(s - a).updateHeight(e, a));
            let c = $n.of(o);
            return (l < 0 || Math.abs(c.height - this.height) >= Af || Math.abs(l - this.heightMetrics(e, n).perLine) >= Af) && (e.heightChanged = !0),
            c
        } else
            (r || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)),
            this.outdated = !1);
        return this
    }
    toString() {
        return `gap(${this.length})`
    }
}
class Fde extends $n {
    constructor(e, n, r) {
        super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)),
        this.left = e,
        this.right = r,
        this.size = e.size + r.size
    }
    get break() {
        return this.flags & 1
    }
    blockAt(e, n, r, i) {
        let s = r + this.left.height;
        return e < s ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, s, i + this.left.length + this.break)
    }
    lineAt(e, n, r, i, s) {
        let o = i + this.left.height
          , a = s + this.left.length + this.break
          , l = n == Dt.ByHeight ? e < o : e < a
          , c = l ? this.left.lineAt(e, n, r, i, s) : this.right.lineAt(e, n, r, o, a);
        if (this.break || (l ? c.to < a : c.from > a))
            return c;
        let u = n == Dt.ByPosNoHeight ? Dt.ByPosNoHeight : Dt.ByPos;
        return l ? c.join(this.right.lineAt(a, u, r, o, a)) : this.left.lineAt(a, u, r, i, s).join(c)
    }
    forEachLine(e, n, r, i, s, o) {
        let a = i + this.left.height
          , l = s + this.left.length + this.break;
        if (this.break)
            e < l && this.left.forEachLine(e, n, r, i, s, o),
            n >= l && this.right.forEachLine(e, n, r, a, l, o);
        else {
            let c = this.lineAt(l, Dt.ByPos, r, i, s);
            e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o),
            c.to >= e && c.from <= n && o(c),
            n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, o)
        }
    }
    replace(e, n, r) {
        let i = this.left.length + this.break;
        if (n < i)
            return this.balanced(this.left.replace(e, n, r), this.right);
        if (e > this.left.length)
            return this.balanced(this.left, this.right.replace(e - i, n - i, r));
        let s = [];
        e > 0 && this.decomposeLeft(e, s);
        let o = s.length;
        for (let a of r)
            s.push(a);
        if (e > 0 && PT(s, o - 1),
        n < this.length) {
            let a = s.length;
            this.decomposeRight(n, s),
            PT(s, a)
        }
        return $n.of(s)
    }
    decomposeLeft(e, n) {
        let r = this.left.length;
        if (e <= r)
            return this.left.decomposeLeft(e, n);
        n.push(this.left),
        this.break && (r++,
        e >= r && n.push(null)),
        e > r && this.right.decomposeLeft(e - r, n)
    }
    decomposeRight(e, n) {
        let r = this.left.length
          , i = r + this.break;
        if (e >= i)
            return this.right.decomposeRight(e - i, n);
        e < r && this.left.decomposeRight(e, n),
        this.break && e < i && n.push(null),
        n.push(this.right)
    }
    balanced(e, n) {
        return e.size > 2 * n.size || n.size > 2 * e.size ? $n.of(this.break ? [e, null, n] : [e, n]) : (this.left = e,
        this.right = n,
        this.height = e.height + n.height,
        this.outdated = e.outdated || n.outdated,
        this.size = e.size + n.size,
        this.length = e.length + this.break + n.length,
        this)
    }
    updateHeight(e, n=0, r=!1, i) {
        let {left: s, right: o} = this
          , a = n + s.length + this.break
          , l = null;
        return i && i.from <= n + s.length && i.more ? l = s = s.updateHeight(e, n, r, i) : s.updateHeight(e, n, r),
        i && i.from <= a + o.length && i.more ? l = o = o.updateHeight(e, a, r, i) : o.updateHeight(e, a, r),
        l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height,
        this.outdated = !1,
        this)
    }
    toString() {
        return this.left + (this.break ? " " : "-") + this.right
    }
}
function PT(t, e) {
    let n, r;
    t[e] == null && (n = t[e - 1])instanceof pn && (r = t[e + 1])instanceof pn && t.splice(e - 1, 3, new pn(n.length + 1 + r.length))
}
const jde = 5;
class Q1 {
    constructor(e, n) {
        this.pos = e,
        this.oracle = n,
        this.nodes = [],
        this.lineStart = -1,
        this.lineEnd = -1,
        this.covering = null,
        this.writtenTo = e
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering
    }
    span(e, n) {
        if (this.lineStart > -1) {
            let r = Math.min(n, this.lineEnd)
              , i = this.nodes[this.nodes.length - 1];
            i instanceof lr ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new lr(r - this.pos,-1)),
            this.writtenTo = r,
            n > r && (this.nodes.push(null),
            this.writtenTo++,
            this.lineStart = -1)
        }
        this.pos = n
    }
    point(e, n, r) {
        if (e < n || r.heightRelevant) {
            let i = r.widget ? r.widget.estimatedHeight : 0
              , s = r.widget ? r.widget.lineBreaks : 0;
            i < 0 && (i = this.oracle.lineHeight);
            let o = n - e;
            r.block ? this.addBlock(new q3(o,i,r)) : (o || s || i >= jde) && this.addLineDeco(i, s, o)
        } else
            n > e && this.span(e, n);
        this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to)
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let {from: e, to: n} = this.oracle.doc.lineAt(this.pos);
        this.lineStart = e,
        this.lineEnd = n,
        this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
        this.nodes.push(null)),
        this.pos > e && this.nodes.push(new lr(this.pos - e,-1)),
        this.writtenTo = this.pos
    }
    blankContent(e, n) {
        let r = new pn(n - e);
        return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4),
        r
    }
    ensureLine() {
        this.enterLine();
        let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (e instanceof lr)
            return e;
        let n = new lr(0,-1);
        return this.nodes.push(n),
        n
    }
    addBlock(e) {
        this.enterLine();
        let n = e.deco;
        n && n.startSide > 0 && !this.isCovered && this.ensureLine(),
        this.nodes.push(e),
        this.writtenTo = this.pos = this.pos + e.length,
        n && n.endSide > 0 && (this.covering = e)
    }
    addLineDeco(e, n, r) {
        let i = this.ensureLine();
        i.length += r,
        i.collapsed += r,
        i.widgetHeight = Math.max(i.widgetHeight, e),
        i.breaks += n,
        this.writtenTo = this.pos = this.pos + r
    }
    finish(e) {
        let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        this.lineStart > -1 && !(n instanceof lr) && !this.isCovered ? this.nodes.push(new lr(0,-1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let r = e;
        for (let i of this.nodes)
            i instanceof lr && i.updateHeight(this.oracle, r),
            r += i ? i.length : 1;
        return this.nodes
    }
    static build(e, n, r, i) {
        let s = new Q1(r,e);
        return dt.spans(n, r, i, s, 0),
        s.finish(r)
    }
}
function Hde(t, e, n) {
    let r = new Ude;
    return dt.compare(t, e, n, r, 0),
    r.changes
}
class Ude {
    constructor() {
        this.changes = []
    }
    compareRange() {}
    comparePoint(e, n, r, i) {
        (e < n || r && r.heightRelevant || i && i.heightRelevant) && $b(e, n, this.changes, 5)
    }
}
function Vde(t, e) {
    let n = t.getBoundingClientRect()
      , r = t.ownerDocument
      , i = r.defaultView || window
      , s = Math.max(0, n.left)
      , o = Math.min(i.innerWidth, n.right)
      , a = Math.max(0, n.top)
      , l = Math.min(i.innerHeight, n.bottom);
    for (let c = t.parentNode; c && c != r.body; )
        if (c.nodeType == 1) {
            let u = c
              , h = window.getComputedStyle(u);
            if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
                let d = u.getBoundingClientRect();
                s = Math.max(s, d.left),
                o = Math.min(o, d.right),
                a = Math.max(a, d.top),
                l = c == t.parentNode ? d.bottom : Math.min(l, d.bottom)
            }
            c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode
        } else if (c.nodeType == 11)
            c = c.host;
        else
            break;
    return {
        left: s - n.left,
        right: Math.max(s, o) - n.left,
        top: a - (n.top + e),
        bottom: Math.max(a, l) - (n.top + e)
    }
}
function $de(t, e) {
    let n = t.getBoundingClientRect();
    return {
        left: 0,
        right: n.right - n.left,
        top: e,
        bottom: n.bottom - (n.top + e)
    }
}
class B0 {
    constructor(e, n, r) {
        this.from = e,
        this.to = n,
        this.size = r
    }
    static same(e, n) {
        if (e.length != n.length)
            return !1;
        for (let r = 0; r < e.length; r++) {
            let i = e[r]
              , s = n[r];
            if (i.from != s.from || i.to != s.to || i.size != s.size)
                return !1
        }
        return !0
    }
    draw(e, n) {
        return at.replace({
            widget: new zde(this.size * (n ? e.scaleY : e.scaleX),n)
        }).range(this.from, this.to)
    }
}
class zde extends Xl {
    constructor(e, n) {
        super(),
        this.size = e,
        this.vertical = n
    }
    eq(e) {
        return e.size == this.size && e.vertical == this.vertical
    }
    toDOM() {
        let e = document.createElement("div");
        return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px",
        e.style.height = "2px",
        e.style.display = "inline-block"),
        e
    }
    get estimatedHeight() {
        return this.vertical ? this.size : -1
    }
}
class DT {
    constructor(e) {
        this.state = e,
        this.pixelViewport = {
            left: 0,
            right: window.innerWidth,
            top: 0,
            bottom: 0
        },
        this.inView = !0,
        this.paddingTop = 0,
        this.paddingBottom = 0,
        this.contentDOMWidth = 0,
        this.contentDOMHeight = 0,
        this.editorHeight = 0,
        this.editorWidth = 0,
        this.scrollTop = 0,
        this.scrolledToBottom = !1,
        this.scaleX = 1,
        this.scaleY = 1,
        this.scrollAnchorPos = 0,
        this.scrollAnchorHeight = -1,
        this.scaler = LT,
        this.scrollTarget = null,
        this.printing = !1,
        this.mustMeasureContent = !0,
        this.defaultTextDirection = Nt.LTR,
        this.visibleRanges = [],
        this.mustEnforceCursorAssoc = !1;
        let n = e.facet(ug).some(r => typeof r != "function" && r.class == "cm-lineWrapping");
        this.heightOracle = new Mde(n),
        this.stateDeco = e.facet(Yu).filter(r => typeof r != "function"),
        this.heightMap = $n.empty().applyChanges(this.stateDeco, gt.empty, this.heightOracle.setDoc(e.doc), [new Or(0,0,0,e.doc.length)]);
        for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null),
        !!this.updateForViewport()); r++)
            ;
        this.updateViewportLines(),
        this.lineGaps = this.ensureLineGaps([]),
        this.lineGapDeco = at.set(this.lineGaps.map(r => r.draw(this, !1))),
        this.computeVisibleRanges()
    }
    updateForViewport() {
        let e = [this.viewport]
          , {main: n} = this.state.selection;
        for (let r = 0; r <= 1; r++) {
            let i = r ? n.head : n.anchor;
            if (!e.some( ({from: s, to: o}) => i >= s && i <= o)) {
                let {from: s, to: o} = this.lineBlockAt(i);
                e.push(new $d(s,o))
            }
        }
        return this.viewports = e.sort( (r, i) => r.from - i.from),
        this.updateScaler()
    }
    updateScaler() {
        let e = this.scaler;
        return this.scaler = this.heightMap.height <= 7e6 ? LT : new J1(this.heightOracle,this.heightMap,this.viewports),
        e.eq(this.scaler) ? 0 : 2
    }
    updateViewportLines() {
        this.viewportLines = [],
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, e => {
            this.viewportLines.push(Nc(e, this.scaler))
        }
        )
    }
    update(e, n=null) {
        this.state = e.state;
        let r = this.stateDeco;
        this.stateDeco = this.state.facet(Yu).filter(u => typeof u != "function");
        let i = e.changedRanges
          , s = Or.extendWithRanges(i, Hde(r, this.stateDeco, e ? e.changes : Zt.empty(this.state.doc.length)))
          , o = this.heightMap.height
          , a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s),
        this.heightMap.height != o && (e.flags |= 2),
        a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1),
        this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1,
        this.scrollAnchorHeight = this.heightMap.height);
        let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
        (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
        let c = l.from != this.viewport.from || l.to != this.viewport.to;
        this.viewport = l,
        e.flags |= this.updateForViewport(),
        (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(),
        (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
        e.flags |= this.computeVisibleRanges(),
        n && (this.scrollTarget = n),
        !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(k3) && (this.mustEnforceCursorAssoc = !0)
    }
    measure(e) {
        let n = e.contentDOM
          , r = window.getComputedStyle(n)
          , i = this.heightOracle
          , s = r.whiteSpace;
        this.defaultTextDirection = r.direction == "rtl" ? Nt.RTL : Nt.LTR;
        let o = this.heightOracle.mustRefreshForWrapping(s)
          , a = n.getBoundingClientRect()
          , l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
        this.contentDOMHeight = a.height,
        this.mustMeasureContent = !1;
        let c = 0
          , u = 0;
        if (a.width && a.height) {
            let {scaleX: x, scaleY: E} = t3(n, a);
            (x > .005 && Math.abs(this.scaleX - x) > .005 || E > .005 && Math.abs(this.scaleY - E) > .005) && (this.scaleX = x,
            this.scaleY = E,
            c |= 8,
            o = l = !0)
        }
        let h = (parseInt(r.paddingTop) || 0) * this.scaleY
          , d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
        (this.paddingTop != h || this.paddingBottom != d) && (this.paddingTop = h,
        this.paddingBottom = d,
        c |= 10),
        this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0),
        this.editorWidth = e.scrollDOM.clientWidth,
        c |= 8);
        let f = e.scrollDOM.scrollTop * this.scaleY;
        this.scrollTop != f && (this.scrollAnchorHeight = -1,
        this.scrollTop = f),
        this.scrolledToBottom = i3(e.scrollDOM);
        let g = (this.printing ? $de : Vde)(n, this.paddingTop)
          , _ = g.top - this.pixelViewport.top
          , m = g.bottom - this.pixelViewport.bottom;
        this.pixelViewport = g;
        let p = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (p != this.inView && (this.inView = p,
        p && (l = !0)),
        !this.inView && !this.scrollTarget)
            return 0;
        let b = a.width;
        if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width,
        this.editorHeight = e.scrollDOM.clientHeight,
        c |= 8),
        l) {
            let x = e.docView.measureVisibleLineHeights(this.viewport);
            if (i.mustRefreshForHeights(x) && (o = !0),
            o || i.lineWrapping && Math.abs(b - this.contentDOMWidth) > i.charWidth) {
                let {lineHeight: E, charWidth: w, textHeight: A} = e.docView.measureTextSize();
                o = E > 0 && i.refresh(s, E, w, A, b / w, x),
                o && (e.docView.minWidth = 0,
                c |= 8)
            }
            _ > 0 && m > 0 ? u = Math.max(_, m) : _ < 0 && m < 0 && (u = Math.min(_, m)),
            i.heightChanged = !1;
            for (let E of this.viewports) {
                let w = E.from == this.viewport.from ? x : e.docView.measureVisibleLineHeights(E);
                this.heightMap = (o ? $n.empty().applyChanges(this.stateDeco, gt.empty, this.heightOracle, [new Or(0,0,0,e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new Bde(E.from,w))
            }
            i.heightChanged && (c |= 2)
        }
        let y = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        return y && (c & 2 && (c |= this.updateScaler()),
        this.viewport = this.getViewport(u, this.scrollTarget),
        c |= this.updateForViewport()),
        (c & 2 || y) && this.updateViewportLines(),
        (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)),
        c |= this.computeVisibleRanges(),
        this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1,
        e.docView.enforceCursorAssoc()),
        c
    }
    get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top)
    }
    get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom)
    }
    getViewport(e, n) {
        let r = .5 - Math.max(-.5, Math.min(.5, e / 1e3 / 2))
          , i = this.heightMap
          , s = this.heightOracle
          , {visibleTop: o, visibleBottom: a} = this
          , l = new $d(i.lineAt(o - r * 1e3, Dt.ByHeight, s, 0, 0).from,i.lineAt(a + (1 - r) * 1e3, Dt.ByHeight, s, 0, 0).to);
        if (n) {
            let {head: c} = n.range;
            if (c < l.from || c > l.to) {
                let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, Dt.ByPos, s, 0, 0), d;
                n.y == "center" ? d = (h.top + h.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? d = h.top : d = h.bottom - u,
                l = new $d(i.lineAt(d - 1e3 / 2, Dt.ByHeight, s, 0, 0).from,i.lineAt(d + u + 1e3 / 2, Dt.ByHeight, s, 0, 0).to)
            }
        }
        return l
    }
    mapViewport(e, n) {
        let r = n.mapPos(e.from, -1)
          , i = n.mapPos(e.to, 1);
        return new $d(this.heightMap.lineAt(r, Dt.ByPos, this.heightOracle, 0, 0).from,this.heightMap.lineAt(i, Dt.ByPos, this.heightOracle, 0, 0).to)
    }
    viewportIsAppropriate({from: e, to: n}, r=0) {
        if (!this.inView)
            return !0;
        let {top: i} = this.heightMap.lineAt(e, Dt.ByPos, this.heightOracle, 0, 0)
          , {bottom: s} = this.heightMap.lineAt(n, Dt.ByPos, this.heightOracle, 0, 0)
          , {visibleTop: o, visibleBottom: a} = this;
        return (e == 0 || i <= o - Math.max(10, Math.min(-r, 250))) && (n == this.state.doc.length || s >= a + Math.max(10, Math.min(r, 250))) && i > o - 2 * 1e3 && s < a + 2 * 1e3
    }
    mapLineGaps(e, n) {
        if (!e.length || n.empty)
            return e;
        let r = [];
        for (let i of e)
            n.touchesRange(i.from, i.to) || r.push(new B0(n.mapPos(i.from),n.mapPos(i.to),i.size));
        return r
    }
    ensureLineGaps(e, n) {
        let r = this.heightOracle.lineWrapping
          , i = r ? 1e4 : 2e3
          , s = i >> 1
          , o = i << 1;
        if (this.defaultTextDirection != Nt.LTR && !r)
            return [];
        let a = []
          , l = (u, h, d, f) => {
            if (h - u < s)
                return;
            let g = this.state.selection.main
              , _ = [g.from];
            g.empty || _.push(g.to);
            for (let p of _)
                if (p > u && p < h) {
                    l(u, p - 10, d, f),
                    l(p + 10, h, d, f);
                    return
                }
            let m = Gde(e, p => p.from >= d.from && p.to <= d.to && Math.abs(p.from - u) < s && Math.abs(p.to - h) < s && !_.some(b => p.from < b && p.to > b));
            if (!m) {
                if (h < d.to && n && r && n.visibleRanges.some(p => p.from <= h && p.to >= h)) {
                    let p = n.moveToLineBoundary(ge.cursor(h), !1, !0).head;
                    p > u && (h = p)
                }
                m = new B0(u,h,this.gapSize(d, u, h, f))
            }
            a.push(m)
        }
          , c = u => {
            if (u.length < o || u.type != Vn.Text)
                return;
            let h = Wde(u.from, u.to, this.stateDeco);
            if (h.total < o)
                return;
            let d = this.scrollTarget ? this.scrollTarget.range.head : null, f, g;
            if (r) {
                let _ = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, p;
                if (d != null) {
                    let b = Wd(h, d)
                      , y = ((this.visibleBottom - this.visibleTop) / 2 + _) / u.height;
                    m = b - y,
                    p = b + y
                } else
                    m = (this.visibleTop - u.top - _) / u.height,
                    p = (this.visibleBottom - u.top + _) / u.height;
                f = zd(h, m),
                g = zd(h, p)
            } else {
                let _ = h.total * this.heightOracle.charWidth, m = i * this.heightOracle.charWidth, p, b;
                if (d != null) {
                    let y = Wd(h, d)
                      , x = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m) / _;
                    p = y - x,
                    b = y + x
                } else
                    p = (this.pixelViewport.left - m) / _,
                    b = (this.pixelViewport.right + m) / _;
                f = zd(h, p),
                g = zd(h, b)
            }
            f > u.from && l(u.from, f, u, h),
            g < u.to && l(g, u.to, u, h)
        }
        ;
        for (let u of this.viewportLines)
            Array.isArray(u.type) ? u.type.forEach(c) : c(u);
        return a
    }
    gapSize(e, n, r, i) {
        let s = Wd(i, r) - Wd(i, n);
        return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s
    }
    updateLineGaps(e) {
        B0.same(e, this.lineGaps) || (this.lineGaps = e,
        this.lineGapDeco = at.set(e.map(n => n.draw(this, this.heightOracle.lineWrapping))))
    }
    computeVisibleRanges() {
        let e = this.stateDeco;
        this.lineGaps.length && (e = e.concat(this.lineGapDeco));
        let n = [];
        dt.spans(e, this.viewport.from, this.viewport.to, {
            span(i, s) {
                n.push({
                    from: i,
                    to: s
                })
            },
            point() {}
        }, 20);
        let r = n.length != this.visibleRanges.length || this.visibleRanges.some( (i, s) => i.from != n[s].from || i.to != n[s].to);
        return this.visibleRanges = n,
        r ? 4 : 0
    }
    lineBlockAt(e) {
        return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find(n => n.from <= e && n.to >= e) || Nc(this.heightMap.lineAt(e, Dt.ByPos, this.heightOracle, 0, 0), this.scaler)
    }
    lineBlockAtHeight(e) {
        return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find(n => n.top <= e && n.bottom >= e) || Nc(this.heightMap.lineAt(this.scaler.fromDOM(e), Dt.ByHeight, this.heightOracle, 0, 0), this.scaler)
    }
    scrollAnchorAt(e) {
        let n = this.lineBlockAtHeight(e + 8);
        return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0]
    }
    elementAtHeight(e) {
        return Nc(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler)
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height)
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom
    }
}
class $d {
    constructor(e, n) {
        this.from = e,
        this.to = n
    }
}
function Wde(t, e, n) {
    let r = []
      , i = t
      , s = 0;
    return dt.spans(n, t, e, {
        span() {},
        point(o, a) {
            o > i && (r.push({
                from: i,
                to: o
            }),
            s += o - i),
            i = a
        }
    }, 20),
    i < e && (r.push({
        from: i,
        to: e
    }),
    s += e - i),
    {
        total: s,
        ranges: r
    }
}
function zd({total: t, ranges: e}, n) {
    if (n <= 0)
        return e[0].from;
    if (n >= 1)
        return e[e.length - 1].to;
    let r = Math.floor(t * n);
    for (let i = 0; ; i++) {
        let {from: s, to: o} = e[i]
          , a = o - s;
        if (r <= a)
            return s + r;
        r -= a
    }
}
function Wd(t, e) {
    let n = 0;
    for (let {from: r, to: i} of t.ranges) {
        if (e <= i) {
            n += e - r;
            break
        }
        n += i - r
    }
    return n / t.total
}
function Gde(t, e) {
    for (let n of t)
        if (e(n))
            return n
}
const LT = {
    toDOM(t) {
        return t
    },
    fromDOM(t) {
        return t
    },
    scale: 1,
    eq(t) {
        return t == this
    }
};
class J1 {
    constructor(e, n, r) {
        let i = 0
          , s = 0
          , o = 0;
        this.viewports = r.map( ({from: a, to: l}) => {
            let c = n.lineAt(a, Dt.ByPos, e, 0, 0).top
              , u = n.lineAt(l, Dt.ByPos, e, 0, 0).bottom;
            return i += u - c,
            {
                from: a,
                to: l,
                top: c,
                bottom: u,
                domTop: 0,
                domBottom: 0
            }
        }
        ),
        this.scale = (7e6 - i) / (n.height - i);
        for (let a of this.viewports)
            a.domTop = o + (a.top - s) * this.scale,
            o = a.domBottom = a.domTop + (a.bottom - a.top),
            s = a.bottom
    }
    toDOM(e) {
        for (let n = 0, r = 0, i = 0; ; n++) {
            let s = n < this.viewports.length ? this.viewports[n] : null;
            if (!s || e < s.top)
                return i + (e - r) * this.scale;
            if (e <= s.bottom)
                return s.domTop + (e - s.top);
            r = s.bottom,
            i = s.domBottom
        }
    }
    fromDOM(e) {
        for (let n = 0, r = 0, i = 0; ; n++) {
            let s = n < this.viewports.length ? this.viewports[n] : null;
            if (!s || e < s.domTop)
                return r + (e - i) / this.scale;
            if (e <= s.domBottom)
                return s.top + (e - s.domTop);
            r = s.bottom,
            i = s.domBottom
        }
    }
    eq(e) {
        return e instanceof J1 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every( (n, r) => n.from == e.viewports[r].from && n.to == e.viewports[r].to) : !1
    }
}
function Nc(t, e) {
    if (e.scale == 1)
        return t;
    let n = e.toDOM(t.top)
      , r = e.toDOM(t.bottom);
    return new bi(t.from,t.length,n,r - n,Array.isArray(t._content) ? t._content.map(i => Nc(i, e)) : t._content)
}
const Gd = Me.define({
    combine: t => t.join(" ")
})
  , Qb = Me.define({
    combine: t => t.indexOf(!0) > -1
})
  , Jb = Qs.newName()
  , K3 = Qs.newName()
  , Y3 = Qs.newName()
  , X3 = {
    "&light": "." + K3,
    "&dark": "." + Y3
};
function Zb(t, e, n) {
    return new Qs(e,{
        finish(r) {
            return /&/.test(r) ? r.replace(/&\w*/, i => {
                if (i == "&")
                    return t;
                if (!n || !n[i])
                    throw new RangeError(`Unsupported selector: ${i}`);
                return n[i]
            }
            ) : t + " " + r
        }
    })
}
const qde = Zb("." + Jb, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only"
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": {
        caretColor: "black"
    },
    "&dark .cm-content": {
        caretColor: "white"
    },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
    },
    ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
            position: "absolute"
        }
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {
        "0%": {},
        "50%": {
            opacity: 0
        },
        "100%": {}
    },
    "@keyframes cm-blink2": {
        "0%": {},
        "50%": {
            opacity: 0
        },
        "100%": {}
    },
    ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none"
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
        position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
    },
    ".cm-iso": {
        unicodeBidi: "isolate"
    },
    ".cm-announced": {
        position: "fixed",
        top: "-10000px"
    },
    "@media print": {
        ".cm-announced": {
            display: "none"
        }
    },
    "&light .cm-activeLine": {
        backgroundColor: "#cceeff44"
    },
    "&dark .cm-activeLine": {
        backgroundColor: "#99eeff33"
    },
    "&light .cm-specialChar": {
        color: "red"
    },
    "&dark .cm-specialChar": {
        color: "#f78"
    },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        insetInlineStart: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top"
    },
    ".cm-highlightSpace:before": {
        content: "attr(data-display)",
        position: "absolute",
        pointerEvents: "none",
        color: "#888"
    },
    ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, X3)
  , Mc = "";
class Kde {
    constructor(e, n) {
        this.points = e,
        this.text = "",
        this.lineSeparator = n.facet(lt.lineSeparator)
    }
    append(e) {
        this.text += e
    }
    lineBreak() {
        this.text += Mc
    }
    readRange(e, n) {
        if (!e)
            return this;
        let r = e.parentNode;
        for (let i = e; ; ) {
            this.findPointBefore(r, i);
            let s = this.text.length;
            this.readNode(i);
            let o = i.nextSibling;
            if (o == n)
                break;
            let a = Tt.get(i)
              , l = Tt.get(o);
            (a && l ? a.breakAfter : (a ? a.breakAfter : Np(i)) || Np(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(),
            i = o
        }
        return this.findPointBefore(r, n),
        this
    }
    readTextNode(e) {
        let n = e.nodeValue;
        for (let r of this.points)
            r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
        for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
            let s = -1, o = 1, a;
            if (this.lineSeparator ? (s = n.indexOf(this.lineSeparator, r),
            o = this.lineSeparator.length) : (a = i.exec(n)) && (s = a.index,
            o = a[0].length),
            this.append(n.slice(r, s < 0 ? n.length : s)),
            s < 0)
                break;
            if (this.lineBreak(),
            o > 1)
                for (let l of this.points)
                    l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
            r = s + o
        }
    }
    readNode(e) {
        if (e.cmIgnore)
            return;
        let n = Tt.get(e)
          , r = n && n.overrideDOMText;
        if (r != null) {
            this.findPointInside(e, r.length);
            for (let i = r.iter(); !i.next().done; )
                i.lineBreak ? this.lineBreak() : this.append(i.value)
        } else
            e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null)
    }
    findPointBefore(e, n) {
        for (let r of this.points)
            r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length)
    }
    findPointInside(e, n) {
        for (let r of this.points)
            (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (Yde(e, r.node, r.offset) ? n : 0))
    }
}
function Yde(t, e, n) {
    for (; ; ) {
        if (!e || n < os(e))
            return !1;
        if (e == t)
            return !0;
        n = ca(e) + 1,
        e = e.parentNode
    }
}
class OT {
    constructor(e, n) {
        this.node = e,
        this.offset = n,
        this.pos = -1
    }
}
class Xde {
    constructor(e, n, r, i) {
        this.typeOver = i,
        this.bounds = null,
        this.text = "",
        this.domChanged = n > -1;
        let {impreciseHead: s, impreciseAnchor: o} = e.docView;
        if (e.state.readOnly && n > -1)
            this.newSel = null;
        else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
            let a = s || o ? [] : Zde(e)
              , l = new Kde(a,e.state);
            l.readRange(this.bounds.startDOM, this.bounds.endDOM),
            this.text = l.text,
            this.newSel = efe(a, this.bounds.from)
        } else {
            let a = e.observer.selectionRange
              , l = s && s.node == a.focusNode && s.offset == a.focusOffset || !Bb(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset)
              , c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !Bb(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset)
              , u = e.viewport;
            if ((Le.ios || Le.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
                let h = Math.min(l, c)
                  , d = Math.max(l, c)
                  , f = u.from - h
                  , g = u.to - d;
                (f == 0 || f == 1 || h == 0) && (g == 0 || g == -1 || d == e.state.doc.length) && (l = 0,
                c = e.state.doc.length)
            }
            this.newSel = ge.single(c, l)
        }
    }
}
function Q3(t, e) {
    let n, {newSel: r} = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
    if (e.bounds) {
        let {from: o, to: a} = e.bounds
          , l = i.from
          , c = null;
        (s === 8 || Le.android && e.text.length < a - o) && (l = i.to,
        c = "end");
        let u = Jde(t.state.doc.sliceString(o, a, Mc), e.text, l - o, c);
        u && (Le.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Mc + Mc && u.toB--,
        n = {
            from: o + u.from,
            to: o + u.toA,
            insert: gt.of(e.text.slice(u.from, u.toB).split(Mc))
        })
    } else
        r && (!t.hasFocus && t.state.facet(As) || r.main.eq(i)) && (r = null);
    if (!n && !r)
        return !1;
    if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = {
        from: i.from,
        to: i.to,
        insert: t.state.doc.slice(i.from, i.to)
    } : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
        from: i.from,
        to: i.to,
        insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
    } : (Le.mac || Le.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = ge.single(r.main.anchor - 1, r.main.head - 1)),
    n = {
        from: i.from,
        to: i.to,
        insert: gt.of([" "])
    }) : Le.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = ge.single(r.main.anchor - 1, r.main.head - 1)),
    n = {
        from: i.from,
        to: i.to,
        insert: gt.of([" "])
    }),
    n)
        return J3(t, n, r, s);
    if (r && !r.main.eq(i)) {
        let o = !1
          , a = "select";
        return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0),
        a = t.inputState.lastSelectionOrigin),
        t.dispatch({
            selection: r,
            scrollIntoView: o,
            userEvent: a
        }),
        !0
    } else
        return !1
}
function J3(t, e, n, r=-1) {
    if (Le.ios && t.inputState.flushIOSKey(e))
        return !0;
    let i = t.state.selection.main;
    if (Le.android && (e.to == i.to && (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && gl(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && gl(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && gl(t.contentDOM, "Delete", 46)))
        return !0;
    let s = e.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let o, a = () => o || (o = Qde(t, e, n));
    return t.state.facet(C3).some(l => l(t, e.from, e.to, s, a)) || t.dispatch(a()),
    !0
}
function Qde(t, e, n) {
    let r, i = t.state, s = i.selection.main;
    if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
        let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : ""
          , l = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
        r = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l))
    } else {
        let a = i.changes(e)
          , l = n && n.main.to <= a.newLength ? n.main : void 0;
        if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
            let c = t.state.sliceDoc(e.from, e.to), u, h = n && M3(t, n.main.head);
            if (h) {
                let g = e.insert.length - (e.to - e.from);
                u = {
                    from: h.from,
                    to: h.to - g
                }
            } else
                u = t.state.doc.lineAt(s.head);
            let d = s.to - e.to
              , f = s.to - s.from;
            r = i.changeByRange(g => {
                if (g.from == s.from && g.to == s.to)
                    return {
                        changes: a,
                        range: l || g.map(a)
                    };
                let _ = g.to - d
                  , m = _ - c.length;
                if (g.to - g.from != f || t.state.sliceDoc(m, _) != c || g.to >= u.from && g.from <= u.to)
                    return {
                        range: g
                    };
                let p = i.changes({
                    from: m,
                    to: _,
                    insert: e.insert
                })
                  , b = g.to - s.to;
                return {
                    changes: p,
                    range: l ? ge.range(Math.max(0, l.anchor + b), Math.max(0, l.head + b)) : g.map(p)
                }
            }
            )
        } else
            r = {
                changes: a,
                selection: l && i.selection.replaceRange(l)
            }
    }
    let o = "input.type";
    return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1,
    o += ".compose",
    t.inputState.compositionFirstChange && (o += ".start",
    t.inputState.compositionFirstChange = !1)),
    i.update(r, {
        userEvent: o,
        scrollIntoView: !0
    })
}
function Jde(t, e, n, r) {
    let i = Math.min(t.length, e.length)
      , s = 0;
    for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
        s++;
    if (s == i && t.length == e.length)
        return null;
    let o = t.length
      , a = e.length;
    for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
        o--,
        a--;
    if (r == "end") {
        let l = Math.max(0, s - Math.min(o, a));
        n -= o + l - s
    }
    if (o < s && t.length < e.length) {
        let l = n <= s && n >= o ? s - n : 0;
        s -= l,
        a = s + (a - o),
        o = s
    } else if (a < s) {
        let l = n <= s && n >= a ? s - n : 0;
        s -= l,
        o = s + (o - a),
        a = s
    }
    return {
        from: s,
        toA: o,
        toB: a
    }
}
function Zde(t) {
    let e = [];
    if (t.root.activeElement != t.contentDOM)
        return e;
    let {anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s} = t.observer.selectionRange;
    return n && (e.push(new OT(n,r)),
    (i != n || s != r) && e.push(new OT(i,s))),
    e
}
function efe(t, e) {
    if (t.length == 0)
        return null;
    let n = t[0].pos
      , r = t.length == 2 ? t[1].pos : n;
    return n > -1 && r > -1 ? ge.single(n + e, r + e) : null
}
const tfe = {
    childList: !0,
    characterData: !0,
    subtree: !0,
    attributes: !0,
    characterDataOldValue: !0
}
  , F0 = Le.ie && Le.ie_version <= 11;
class nfe {
    constructor(e) {
        this.view = e,
        this.active = !1,
        this.editContext = null,
        this.selectionRange = new Hhe,
        this.selectionChanged = !1,
        this.delayedFlush = -1,
        this.resizeTimeout = -1,
        this.queue = [],
        this.delayedAndroidKey = null,
        this.flushingAndroidKey = -1,
        this.lastChange = 0,
        this.scrollTargets = [],
        this.intersection = null,
        this.resizeScroll = null,
        this.intersecting = !1,
        this.gapIntersection = null,
        this.gaps = [],
        this.printQuery = null,
        this.parentCheck = -1,
        this.dom = e.contentDOM,
        this.observer = new MutationObserver(n => {
            for (let r of n)
                this.queue.push(r);
            (Le.ie && Le.ie_version <= 11 || Le.ios && e.composing) && n.some(r => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush()
        }
        ),
        window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && !(Le.chrome && Le.chrome_version < 126) && (this.editContext = new ife(e),
        e.state.facet(As) && (e.contentDOM.editContext = this.editContext.editContext)),
        F0 && (this.onCharData = n => {
            this.queue.push({
                target: n.target,
                type: "characterData",
                oldValue: n.prevValue
            }),
            this.flushSoon()
        }
        ),
        this.onSelectionChange = this.onSelectionChange.bind(this),
        this.onResize = this.onResize.bind(this),
        this.onPrint = this.onPrint.bind(this),
        this.onScroll = this.onScroll.bind(this),
        window.matchMedia && (this.printQuery = window.matchMedia("print")),
        typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver( () => {
            var n;
            ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize()
        }
        ),
        this.resizeScroll.observe(e.scrollDOM)),
        this.addWindowListeners(this.win = e.win),
        this.start(),
        typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver(n => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
            n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting,
            this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")))
        }
        ,{
            threshold: [0, .001]
        }),
        this.intersection.observe(this.dom),
        this.gapIntersection = new IntersectionObserver(n => {
            n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"))
        }
        ,{})),
        this.listenForScroll(),
        this.readSelectionRange()
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e),
        this.intersecting && this.view.measure()
    }
    onScroll(e) {
        this.intersecting && this.flush(!1),
        this.editContext && this.view.requestMeasure(this.editContext.measureReq),
        this.onScrollChanged(e)
    }
    onResize() {
        this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout( () => {
            this.resizeTimeout = -1,
            this.view.requestMeasure()
        }
        , 50))
    }
    onPrint(e) {
        e.type == "change" && !e.matches || (this.view.viewState.printing = !0,
        this.view.measure(),
        setTimeout( () => {
            this.view.viewState.printing = !1,
            this.view.requestMeasure()
        }
        , 500))
    }
    updateGaps(e) {
        if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some( (n, r) => n != e[r]))) {
            this.gapIntersection.disconnect();
            for (let n of e)
                this.gapIntersection.observe(n);
            this.gaps = e
        }
    }
    onSelectionChange(e) {
        let n = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let {view: r} = this
          , i = this.selectionRange;
        if (r.state.facet(As) ? r.root.activeElement != this.dom : !Cf(r.dom, i))
            return;
        let s = i.anchorNode && r.docView.nearest(i.anchorNode);
        if (s && s.ignoreEvent(e)) {
            n || (this.selectionChanged = !1);
            return
        }
        (Le.ie && Le.ie_version <= 11 || Le.android && Le.chrome) && !r.state.selection.main.empty && i.focusNode && ru(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1)
    }
    readSelectionRange() {
        let {view: e} = this
          , n = qu(e.root);
        if (!n)
            return !1;
        let r = Le.safari && e.root.nodeType == 11 && Mhe(this.dom.ownerDocument) == this.dom && rfe(this.view, n) || n;
        if (!r || this.selectionRange.eq(r))
            return !1;
        let i = Cf(this.dom, r);
        return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Vhe(this.dom, r) ? (this.view.inputState.lastFocusTime = 0,
        e.docView.updateSelection(),
        !1) : (this.selectionRange.setRange(r),
        i && (this.selectionChanged = !0),
        !0)
    }
    setSelectionRange(e, n) {
        this.selectionRange.set(e.node, e.offset, n.node, n.offset),
        this.selectionChanged = !1
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0)
    }
    listenForScroll() {
        this.parentCheck = -1;
        let e = 0
          , n = null;
        for (let r = this.dom; r; )
            if (r.nodeType == 1)
                !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)),
                n && n.push(r),
                r = r.assignedSlot || r.parentNode;
            else if (r.nodeType == 11)
                r = r.host;
            else
                break;
        if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)),
        n) {
            for (let r of this.scrollTargets)
                r.removeEventListener("scroll", this.onScroll);
            for (let r of this.scrollTargets = n)
                r.addEventListener("scroll", this.onScroll)
        }
    }
    ignore(e) {
        if (!this.active)
            return e();
        try {
            return this.stop(),
            e()
        } finally {
            this.start(),
            this.clear()
        }
    }
    start() {
        this.active || (this.observer.observe(this.dom, tfe),
        F0 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
        this.active = !0)
    }
    stop() {
        this.active && (this.active = !1,
        this.observer.disconnect(),
        F0 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData))
    }
    clear() {
        this.processRecords(),
        this.queue.length = 0,
        this.selectionChanged = !1
    }
    delayAndroidKey(e, n) {
        var r;
        if (!this.delayedAndroidKey) {
            let i = () => {
                let s = this.delayedAndroidKey;
                s && (this.clearDelayedAndroidKey(),
                this.view.inputState.lastKeyCode = s.keyCode,
                this.view.inputState.lastKeyTime = Date.now(),
                !this.flush() && s.force && gl(this.dom, s.key, s.keyCode))
            }
            ;
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(i)
        }
        (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
            key: e,
            keyCode: n,
            force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
        })
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey),
        this.delayedAndroidKey = null,
        this.flushingAndroidKey = -1
    }
    flushSoon() {
        this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame( () => {
            this.delayedFlush = -1,
            this.flush()
        }
        ))
    }
    forceFlush() {
        this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush),
        this.delayedFlush = -1),
        this.flush()
    }
    pendingRecords() {
        for (let e of this.observer.takeRecords())
            this.queue.push(e);
        return this.queue
    }
    processRecords() {
        let e = this.pendingRecords();
        e.length && (this.queue = []);
        let n = -1
          , r = -1
          , i = !1;
        for (let s of e) {
            let o = this.readMutation(s);
            o && (o.typeOver && (i = !0),
            n == -1 ? {from: n, to: r} = o : (n = Math.min(o.from, n),
            r = Math.max(o.to, r)))
        }
        return {
            from: n,
            to: r,
            typeOver: i
        }
    }
    readChange() {
        let {from: e, to: n, typeOver: r} = this.processRecords()
          , i = this.selectionChanged && Cf(this.dom, this.selectionRange);
        if (e < 0 && !i)
            return null;
        e > -1 && (this.lastChange = Date.now()),
        this.view.inputState.lastFocusTime = 0,
        this.selectionChanged = !1;
        let s = new Xde(this.view,e,n,r);
        return this.view.docView.domChanged = {
            newSel: s.newSel ? s.newSel.main : null
        },
        s
    }
    flush(e=!0) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return !1;
        e && this.readSelectionRange();
        let n = this.readChange();
        if (!n)
            return this.view.requestMeasure(),
            !1;
        let r = this.view.state
          , i = Q3(this.view, n);
        return this.view.state == r && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]),
        i
    }
    readMutation(e) {
        let n = this.view.docView.nearest(e.target);
        if (!n || n.ignoreMutation(e))
            return null;
        if (n.markDirty(e.type == "attributes"),
        e.type == "attributes" && (n.flags |= 4),
        e.type == "childList") {
            let r = NT(n, e.previousSibling || e.target.previousSibling, -1)
              , i = NT(n, e.nextSibling || e.target.nextSibling, 1);
            return {
                from: r ? n.posAfter(r) : n.posAtStart,
                to: i ? n.posBefore(i) : n.posAtEnd,
                typeOver: !1
            }
        } else
            return e.type == "characterData" ? {
                from: n.posAtStart,
                to: n.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue
            } : null
    }
    setWindow(e) {
        e != this.win && (this.removeWindowListeners(this.win),
        this.win = e,
        this.addWindowListeners(this.win))
    }
    addWindowListeners(e) {
        e.addEventListener("resize", this.onResize),
        this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : e.addEventListener("beforeprint", this.onPrint),
        e.addEventListener("scroll", this.onScroll),
        e.document.addEventListener("selectionchange", this.onSelectionChange)
    }
    removeWindowListeners(e) {
        e.removeEventListener("scroll", this.onScroll),
        e.removeEventListener("resize", this.onResize),
        this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : e.removeEventListener("beforeprint", this.onPrint),
        e.document.removeEventListener("selectionchange", this.onSelectionChange)
    }
    update(e) {
        this.editContext && (this.editContext.update(e),
        e.startState.facet(As) != e.state.facet(As) && (e.view.contentDOM.editContext = e.state.facet(As) ? this.editContext.editContext : null))
    }
    destroy() {
        var e, n, r;
        this.stop(),
        (e = this.intersection) === null || e === void 0 || e.disconnect(),
        (n = this.gapIntersection) === null || n === void 0 || n.disconnect(),
        (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
        for (let i of this.scrollTargets)
            i.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win),
        clearTimeout(this.parentCheck),
        clearTimeout(this.resizeTimeout),
        this.win.cancelAnimationFrame(this.delayedFlush),
        this.win.cancelAnimationFrame(this.flushingAndroidKey)
    }
}
function NT(t, e, n) {
    for (; e; ) {
        let r = Tt.get(e);
        if (r && r.parent == t)
            return r;
        let i = e.parentNode;
        e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling
    }
    return null
}
function MT(t, e) {
    let n = e.startContainer
      , r = e.startOffset
      , i = e.endContainer
      , s = e.endOffset
      , o = t.docView.domAtPos(t.state.selection.main.anchor);
    return ru(o.node, o.offset, i, s) && ([n,r,i,s] = [i, s, n, r]),
    {
        anchorNode: n,
        anchorOffset: r,
        focusNode: i,
        focusOffset: s
    }
}
function rfe(t, e) {
    if (e.getComposedRanges) {
        let i = e.getComposedRanges(t.root)[0];
        if (i)
            return MT(t, i)
    }
    let n = null;
    function r(i) {
        i.preventDefault(),
        i.stopImmediatePropagation(),
        n = i.getTargetRanges()[0]
    }
    return t.contentDOM.addEventListener("beforeinput", r, !0),
    t.dom.ownerDocument.execCommand("indent"),
    t.contentDOM.removeEventListener("beforeinput", r, !0),
    n ? MT(t, n) : null
}
class ife {
    constructor(e) {
        this.from = 0,
        this.to = 0,
        this.pendingContextChange = null,
        this.resetRange(e.state);
        let n = this.editContext = new window.EditContext({
            text: e.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(e.state.selection.main.head)
        });
        n.addEventListener("textupdate", r => {
            let {anchor: i} = e.state.selection.main
              , s = {
                from: this.toEditorPos(r.updateRangeStart),
                to: this.toEditorPos(r.updateRangeEnd),
                insert: gt.of(r.text.split(`
`))
            };
            s.from == this.from && i < this.from ? s.from = i : s.to == this.to && i > this.to && (s.to = i),
            !(s.from == s.to && !s.insert.length) && (this.pendingContextChange = s,
            J3(e, s, ge.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd))),
            this.pendingContextChange && this.revertPending(e.state))
        }
        ),
        n.addEventListener("characterboundsupdate", r => {
            let i = []
              , s = null;
            for (let o = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); o < a; o++) {
                let l = e.coordsForChar(o);
                s = l && new DOMRect(l.left,l.top,l.right - l.left,l.bottom - l.top) || s || new DOMRect,
                i.push(s)
            }
            n.updateCharacterBounds(r.rangeStart, i)
        }
        ),
        n.addEventListener("textformatupdate", r => {
            let i = [];
            for (let s of r.getTextFormats()) {
                let o = s.underlineStyle
                  , a = s.underlineThickness;
                if (o != "None" && a != "None") {
                    let l = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
                    i.push(at.mark({
                        attributes: {
                            style: l
                        }
                    }).range(this.toEditorPos(s.rangeStart), this.toEditorPos(s.rangeEnd)))
                }
            }
            e.dispatch({
                effects: I3.of(at.set(i))
            })
        }
        ),
        n.addEventListener("compositionstart", () => {
            e.inputState.composing < 0 && (e.inputState.composing = 0,
            e.inputState.compositionFirstChange = !0)
        }
        ),
        n.addEventListener("compositionend", () => {
            e.inputState.composing = -1,
            e.inputState.compositionFirstChange = null
        }
        ),
        this.measureReq = {
            read: r => {
                this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
                let i = qu(r.root);
                i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect())
            }
        }
    }
    applyEdits(e) {
        let n = 0
          , r = !1
          , i = this.pendingContextChange;
        return e.changes.iterChanges( (s, o, a, l, c) => {
            if (r)
                return;
            let u = c.length - (o - s);
            if (i && o >= i.to)
                if (i.from == s && i.to == o && i.insert.eq(c)) {
                    i = this.pendingContextChange = null,
                    n += u,
                    this.to += u;
                    return
                } else
                    i = null,
                    this.revertPending(e.state);
            if (s += n,
            o += n,
            o <= this.from)
                this.from += u,
                this.to += u;
            else if (s < this.to) {
                if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
                    r = !0;
                    return
                }
                this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()),
                this.to += u
            }
            n += u
        }
        ),
        i && !r && this.revertPending(e.state),
        !r
    }
    update(e) {
        !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null,
        this.resetRange(e.state),
        this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)),
        this.setSelection(e.state)) : (e.docChanged || e.selectionSet) && this.setSelection(e.state),
        (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq)
    }
    resetRange(e) {
        let {head: n} = e.selection.main;
        this.from = Math.max(0, n - 1e4),
        this.to = Math.min(e.doc.length, n + 1e4)
    }
    revertPending(e) {
        let n = this.pendingContextChange;
        this.pendingContextChange = null,
        this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.to + n.insert.length), e.doc.sliceString(n.from, n.to))
    }
    setSelection(e) {
        let {main: n} = e.selection
          , r = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor)))
          , i = this.toContextPos(n.head);
        (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i)
    }
    rangeIsValid(e) {
        let {head: n} = e.selection.main;
        return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3)
    }
    toEditorPos(e) {
        return e + this.from
    }
    toContextPos(e) {
        return e - this.from
    }
}
class Oe {
    get state() {
        return this.viewState.state
    }
    get viewport() {
        return this.viewState.viewport
    }
    get visibleRanges() {
        return this.viewState.visibleRanges
    }
    get inView() {
        return this.viewState.inView
    }
    get composing() {
        return this.inputState.composing > 0
    }
    get compositionStarted() {
        return this.inputState.composing >= 0
    }
    get root() {
        return this._root
    }
    get win() {
        return this.dom.ownerDocument.defaultView || window
    }
    constructor(e={}) {
        this.plugins = [],
        this.pluginMap = new Map,
        this.editorAttrs = {},
        this.contentAttrs = {},
        this.bidiCache = [],
        this.destroyed = !1,
        this.updateState = 2,
        this.measureScheduled = -1,
        this.measureRequests = [],
        this.contentDOM = document.createElement("div"),
        this.scrollDOM = document.createElement("div"),
        this.scrollDOM.tabIndex = -1,
        this.scrollDOM.className = "cm-scroller",
        this.scrollDOM.appendChild(this.contentDOM),
        this.announceDOM = document.createElement("div"),
        this.announceDOM.className = "cm-announced",
        this.announceDOM.setAttribute("aria-live", "polite"),
        this.dom = document.createElement("div"),
        this.dom.appendChild(this.announceDOM),
        this.dom.appendChild(this.scrollDOM),
        e.parent && e.parent.appendChild(this.dom);
        let {dispatch: n} = e;
        this.dispatchTransactions = e.dispatchTransactions || n && (r => r.forEach(i => n(i, this))) || (r => this.update(r)),
        this.dispatch = this.dispatch.bind(this),
        this._root = e.root || Uhe(e.parent) || document,
        this.viewState = new DT(e.state || lt.create(e)),
        e.scrollTo && e.scrollTo.is(Hd) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)),
        this.plugins = this.state.facet(Lc).map(r => new O0(r));
        for (let r of this.plugins)
            r.update(this);
        this.observer = new nfe(this),
        this.inputState = new yde(this),
        this.inputState.ensureHandlers(this.plugins),
        this.docView = new pT(this),
        this.mountStyles(),
        this.updateAttrs(),
        this.updateState = 0,
        this.requestMeasure()
    }
    dispatch(...e) {
        let n = e.length == 1 && e[0]instanceof Yt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
        this.dispatchTransactions(n, this)
    }
    update(e) {
        if (this.updateState != 0)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let n = !1, r = !1, i, s = this.state;
        for (let d of e) {
            if (d.startState != s)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            s = d.state
        }
        if (this.destroyed) {
            this.viewState.state = s;
            return
        }
        let o = this.hasFocus
          , a = 0
          , l = null;
        e.some(d => d.annotation(z3)) ? (this.inputState.notifiedFocused = o,
        a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o,
        l = W3(s, o),
        l || (a = 1));
        let c = this.observer.delayedAndroidKey
          , u = null;
        if (c ? (this.observer.clearDelayedAndroidKey(),
        u = this.observer.readChange(),
        (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(),
        s.facet(lt.phrases) != this.state.facet(lt.phrases))
            return this.setState(s);
        i = Bp.create(this, s, e),
        i.flags |= a;
        let h = this.viewState.scrollTarget;
        try {
            this.updateState = 2;
            for (let d of e) {
                if (h && (h = h.map(d.changes)),
                d.scrollIntoView) {
                    let {main: f} = d.state.selection;
                    h = new _l(f.empty ? f : ge.cursor(f.head, f.head > f.anchor ? -1 : 1))
                }
                for (let f of d.effects)
                    f.is(Hd) && (h = f.value.clip(this.state))
            }
            this.viewState.update(i, h),
            this.bidiCache = Fp.update(this.bidiCache, i.changes),
            i.empty || (this.updatePlugins(i),
            this.inputState.update(i)),
            n = this.docView.update(i),
            this.state.facet(Oc) != this.styleModules && this.mountStyles(),
            r = this.updateAttrs(),
            this.showAnnouncements(e),
            this.docView.updateSelection(n, e.some(d => d.isUserEvent("select.pointer")))
        } finally {
            this.updateState = 0
        }
        if (i.startState.facet(Gd) != i.state.facet(Gd) && (this.viewState.mustMeasureContent = !0),
        (n || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(),
        n && this.docViewUpdate(),
        !i.empty)
            for (let d of this.state.facet(qb))
                try {
                    d(i)
                } catch (f) {
                    fr(this.state, f, "update listener")
                }
        (l || u) && Promise.resolve().then( () => {
            l && this.state == l.startState && this.dispatch(l),
            u && !Q3(this, u) && c.force && gl(this.contentDOM, c.key, c.keyCode)
        }
        )
    }
    setState(e) {
        if (this.updateState != 0)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = e;
            return
        }
        this.updateState = 2;
        let n = this.hasFocus;
        try {
            for (let r of this.plugins)
                r.destroy(this);
            this.viewState = new DT(e),
            this.plugins = e.facet(Lc).map(r => new O0(r)),
            this.pluginMap.clear();
            for (let r of this.plugins)
                r.update(this);
            this.docView.destroy(),
            this.docView = new pT(this),
            this.inputState.ensureHandlers(this.plugins),
            this.mountStyles(),
            this.updateAttrs(),
            this.bidiCache = []
        } finally {
            this.updateState = 0
        }
        n && this.focus(),
        this.requestMeasure()
    }
    updatePlugins(e) {
        let n = e.startState.facet(Lc)
          , r = e.state.facet(Lc);
        if (n != r) {
            let i = [];
            for (let s of r) {
                let o = n.indexOf(s);
                if (o < 0)
                    i.push(new O0(s));
                else {
                    let a = this.plugins[o];
                    a.mustUpdate = e,
                    i.push(a)
                }
            }
            for (let s of this.plugins)
                s.mustUpdate != e && s.destroy(this);
            this.plugins = i,
            this.pluginMap.clear()
        } else
            for (let i of this.plugins)
                i.mustUpdate = e;
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        n != r && this.inputState.ensureHandlers(this.plugins)
    }
    docViewUpdate() {
        for (let e of this.plugins) {
            let n = e.value;
            if (n && n.docViewUpdate)
                try {
                    n.docViewUpdate(this)
                } catch (r) {
                    fr(this.state, r, "doc view update listener")
                }
        }
    }
    measure(e=!0) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
        this.observer.delayedAndroidKey) {
            this.measureScheduled = -1,
            this.requestMeasure();
            return
        }
        this.measureScheduled = 0,
        e && this.observer.forceFlush();
        let n = null
          , r = this.scrollDOM
          , i = r.scrollTop * this.scaleY
          , {scrollAnchorPos: s, scrollAnchorHeight: o} = this.viewState;
        Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1),
        this.viewState.scrollAnchorHeight = -1;
        try {
            for (let a = 0; ; a++) {
                if (o < 0)
                    if (i3(r))
                        s = -1,
                        o = this.viewState.heightMap.height;
                    else {
                        let f = this.viewState.scrollAnchorAt(i);
                        s = f.from,
                        o = f.top
                    }
                this.updateState = 1;
                let l = this.viewState.measure(this);
                if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (a > 5) {
                    console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                    break
                }
                let c = [];
                l & 4 || ([this.measureRequests,c] = [c, this.measureRequests]);
                let u = c.map(f => {
                    try {
                        return f.read(this)
                    } catch (g) {
                        return fr(this.state, g),
                        BT
                    }
                }
                )
                  , h = Bp.create(this, this.state, [])
                  , d = !1;
                h.flags |= l,
                n ? n.flags |= l : n = h,
                this.updateState = 2,
                h.empty || (this.updatePlugins(h),
                this.inputState.update(h),
                this.updateAttrs(),
                d = this.docView.update(h),
                d && this.docViewUpdate());
                for (let f = 0; f < c.length; f++)
                    if (u[f] != BT)
                        try {
                            let g = c[f];
                            g.write && g.write(u[f], this)
                        } catch (g) {
                            fr(this.state, g)
                        }
                if (d && this.docView.updateSelection(!0),
                !h.viewportChanged && this.measureRequests.length == 0) {
                    if (this.viewState.editorHeight)
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget),
                            this.viewState.scrollTarget = null,
                            o = -1;
                            continue
                        } else {
                            let g = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
                            if (g > 1 || g < -1) {
                                i = i + g,
                                r.scrollTop = i / this.scaleY,
                                o = -1;
                                continue
                            }
                        }
                    break
                }
            }
        } finally {
            this.updateState = 0,
            this.measureScheduled = -1
        }
        if (n && !n.empty)
            for (let a of this.state.facet(qb))
                a(n)
    }
    get themeClasses() {
        return Jb + " " + (this.state.facet(Qb) ? Y3 : K3) + " " + this.state.facet(Gd)
    }
    updateAttrs() {
        let e = FT(this, P3, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        })
          , n = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: this.state.facet(As) ? "true" : "false",
            class: "cm-content",
            style: `${Le.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        this.state.readOnly && (n["aria-readonly"] = "true"),
        FT(this, ug, n);
        let r = this.observer.ignore( () => {
            let i = Vb(this.contentDOM, this.contentAttrs, n)
              , s = Vb(this.dom, this.editorAttrs, e);
            return i || s
        }
        );
        return this.editorAttrs = e,
        this.contentAttrs = n,
        r
    }
    showAnnouncements(e) {
        let n = !0;
        for (let r of e)
            for (let i of r.effects)
                if (i.is(Oe.announce)) {
                    n && (this.announceDOM.textContent = ""),
                    n = !1;
                    let s = this.announceDOM.appendChild(document.createElement("div"));
                    s.textContent = i.value
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(Oc);
        let e = this.state.facet(Oe.cspNonce);
        Qs.mount(this.root, this.styleModules.concat(qde).reverse(), e ? {
            nonce: e
        } : void 0)
    }
    readMeasured() {
        if (this.updateState == 2)
            throw new Error("Reading the editor layout isn't allowed during an update");
        this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1)
    }
    requestMeasure(e) {
        if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame( () => this.measure())),
        e) {
            if (this.measureRequests.indexOf(e) > -1)
                return;
            if (e.key != null) {
                for (let n = 0; n < this.measureRequests.length; n++)
                    if (this.measureRequests[n].key === e.key) {
                        this.measureRequests[n] = e;
                        return
                    }
            }
            this.measureRequests.push(e)
        }
    }
    plugin(e) {
        let n = this.pluginMap.get(e);
        return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find(r => r.spec == e) || null),
        n && n.update(this).value
    }
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop
    }
    get documentPadding() {
        return {
            top: this.viewState.paddingTop,
            bottom: this.viewState.paddingBottom
        }
    }
    get scaleX() {
        return this.viewState.scaleX
    }
    get scaleY() {
        return this.viewState.scaleY
    }
    elementAtHeight(e) {
        return this.readMeasured(),
        this.viewState.elementAtHeight(e)
    }
    lineBlockAtHeight(e) {
        return this.readMeasured(),
        this.viewState.lineBlockAtHeight(e)
    }
    get viewportLineBlocks() {
        return this.viewState.viewportLines
    }
    lineBlockAt(e) {
        return this.viewState.lineBlockAt(e)
    }
    get contentHeight() {
        return this.viewState.contentHeight
    }
    moveByChar(e, n, r) {
        return M0(this, e, vT(this, e, n, r))
    }
    moveByGroup(e, n) {
        return M0(this, e, vT(this, e, n, r => _de(this, e.head, r)))
    }
    visualLineSide(e, n) {
        let r = this.bidiSpans(e)
          , i = this.textDirectionAt(e.from)
          , s = r[n ? r.length - 1 : 0];
        return ge.cursor(s.side(n, i) + e.from, s.forward(!n, i) ? 1 : -1)
    }
    moveToLineBoundary(e, n, r=!0) {
        return gde(this, e, n, r)
    }
    moveVertically(e, n, r) {
        return M0(this, e, bde(this, e, n, r))
    }
    domAtPos(e) {
        return this.docView.domAtPos(e)
    }
    posAtDOM(e, n=0) {
        return this.docView.posFromDOM(e, n)
    }
    posAtCoords(e, n=!0) {
        return this.readMeasured(),
        B3(this, e, n)
    }
    coordsAtPos(e, n=1) {
        this.readMeasured();
        let r = this.docView.coordsAt(e, n);
        if (!r || r.left == r.right)
            return r;
        let i = this.state.doc.lineAt(e)
          , s = this.bidiSpans(i)
          , o = s[Is.find(s, e - i.from, -1, n)];
        return q1(r, o.dir == Nt.LTR == n > 0)
    }
    coordsForChar(e) {
        return this.readMeasured(),
        this.docView.coordsForChar(e)
    }
    get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth
    }
    get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight
    }
    get textDirection() {
        return this.viewState.defaultTextDirection
    }
    textDirectionAt(e) {
        return !this.state.facet(A3) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(),
        this.docView.textDirectionAt(e))
    }
    get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping
    }
    bidiSpans(e) {
        if (e.length > sfe)
            return y3(e.length);
        let n = this.textDirectionAt(e.from), r;
        for (let s of this.bidiCache)
            if (s.from == e.from && s.dir == n && (s.fresh || b3(s.isolates, r = fT(this, e))))
                return s.order;
        r || (r = fT(this, e));
        let i = ede(e.text, n, r);
        return this.bidiCache.push(new Fp(e.from,e.to,n,r,!0,i)),
        i
    }
    get hasFocus() {
        var e;
        return (this.dom.ownerDocument.hasFocus() || Le.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM
    }
    focus() {
        this.observer.ignore( () => {
            n3(this.contentDOM),
            this.docView.updateSelection()
        }
        )
    }
    setRoot(e) {
        this._root != e && (this._root = e,
        this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window),
        this.mountStyles())
    }
    destroy() {
        this.root.activeElement == this.contentDOM && this.contentDOM.blur();
        for (let e of this.plugins)
            e.destroy(this);
        this.plugins = [],
        this.inputState.destroy(),
        this.docView.destroy(),
        this.dom.remove(),
        this.observer.destroy(),
        this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
        this.destroyed = !0
    }
    static scrollIntoView(e, n={}) {
        return Hd.of(new _l(typeof e == "number" ? ge.cursor(e) : e,n.y,n.x,n.yMargin,n.xMargin))
    }
    scrollSnapshot() {
        let {scrollTop: e, scrollLeft: n} = this.scrollDOM
          , r = this.viewState.scrollAnchorAt(e);
        return Hd.of(new _l(ge.cursor(r.from),"start","start",r.top - e,n,!0))
    }
    setTabFocusMode(e) {
        e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e)
    }
    static domEventHandlers(e) {
        return xn.define( () => ({}), {
            eventHandlers: e
        })
    }
    static domEventObservers(e) {
        return xn.define( () => ({}), {
            eventObservers: e
        })
    }
    static theme(e, n) {
        let r = Qs.newName()
          , i = [Gd.of(r), Oc.of(Zb(`.${r}`, e))];
        return n && n.dark && i.push(Qb.of(!0)),
        i
    }
    static baseTheme(e) {
        return co.lowest(Oc.of(Zb("." + Jb, e, X3)))
    }
    static findFromDOM(e) {
        var n;
        let r = e.querySelector(".cm-content")
          , i = r && Tt.get(r) || Tt.get(e);
        return ((n = i?.rootView) === null || n === void 0 ? void 0 : n.view) || null
    }
}
Oe.styleModule = Oc;
Oe.inputHandler = C3;
Oe.scrollHandler = R3;
Oe.focusChangeEffect = T3;
Oe.perLineTextDirection = A3;
Oe.exceptionSink = w3;
Oe.updateListener = qb;
Oe.editable = As;
Oe.mouseSelectionStyle = S3;
Oe.dragMovesSelection = E3;
Oe.clickAddsSelectionRange = x3;
Oe.decorations = Yu;
Oe.outerDecorations = D3;
Oe.atomicRanges = X1;
Oe.bidiIsolatedRanges = L3;
Oe.scrollMargins = O3;
Oe.darkTheme = Qb;
Oe.cspNonce = Me.define({
    combine: t => t.length ? t[0] : ""
});
Oe.contentAttributes = ug;
Oe.editorAttributes = P3;
Oe.lineWrapping = Oe.contentAttributes.of({
    class: "cm-lineWrapping"
});
Oe.announce = Je.define();
const sfe = 4096
  , BT = {};
class Fp {
    constructor(e, n, r, i, s, o) {
        this.from = e,
        this.to = n,
        this.dir = r,
        this.isolates = i,
        this.fresh = s,
        this.order = o
    }
    static update(e, n) {
        if (n.empty && !e.some(s => s.fresh))
            return e;
        let r = []
          , i = e.length ? e[e.length - 1].dir : Nt.LTR;
        for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
            let o = e[s];
            o.dir == i && !n.touchesRange(o.from, o.to) && r.push(new Fp(n.mapPos(o.from, 1),n.mapPos(o.to, -1),o.dir,o.isolates,!1,o.order))
        }
        return r
    }
}
function FT(t, e, n) {
    for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
        let s = r[i]
          , o = typeof s == "function" ? s(t) : s;
        o && Ub(o, n)
    }
    return n
}
const ofe = Le.mac ? "mac" : Le.windows ? "win" : Le.linux ? "linux" : "key";
function afe(t, e) {
    const n = t.split(/-(?!$)/);
    let r = n[n.length - 1];
    r == "Space" && (r = " ");
    let i, s, o, a;
    for (let l = 0; l < n.length - 1; ++l) {
        const c = n[l];
        if (/^(cmd|meta|m)$/i.test(c))
            a = !0;
        else if (/^a(lt)?$/i.test(c))
            i = !0;
        else if (/^(c|ctrl|control)$/i.test(c))
            s = !0;
        else if (/^s(hift)?$/i.test(c))
            o = !0;
        else if (/^mod$/i.test(c))
            e == "mac" ? a = !0 : s = !0;
        else
            throw new Error("Unrecognized modifier name: " + c)
    }
    return i && (r = "Alt-" + r),
    s && (r = "Ctrl-" + r),
    a && (r = "Meta-" + r),
    o && (r = "Shift-" + r),
    r
}
function qd(t, e, n) {
    return e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n !== !1 && e.shiftKey && (t = "Shift-" + t),
    t
}
const lfe = co.default(Oe.domEventHandlers({
    keydown(t, e) {
        return eB(Z3(e.state), t, e, "editor")
    }
}))
  , hg = Me.define({
    enables: lfe
})
  , jT = new WeakMap;
function Z3(t) {
    let e = t.facet(hg)
      , n = jT.get(e);
    return n || jT.set(e, n = hfe(e.reduce( (r, i) => r.concat(i), []))),
    n
}
function cfe(t, e, n) {
    return eB(Z3(t.state), e, t, n)
}
let ks = null;
const ufe = 4e3;
function hfe(t, e=ofe) {
    let n = Object.create(null)
      , r = Object.create(null)
      , i = (o, a) => {
        let l = r[o];
        if (l == null)
            r[o] = a;
        else if (l != a)
            throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix")
    }
      , s = (o, a, l, c, u) => {
        var h, d;
        let f = n[o] || (n[o] = Object.create(null))
          , g = a.split(/ (?!$)/).map(p => afe(p, e));
        for (let p = 1; p < g.length; p++) {
            let b = g.slice(0, p).join(" ");
            i(b, !0),
            f[b] || (f[b] = {
                preventDefault: !0,
                stopPropagation: !1,
                run: [y => {
                    let x = ks = {
                        view: y,
                        prefix: b,
                        scope: o
                    };
                    return setTimeout( () => {
                        ks == x && (ks = null)
                    }
                    , ufe),
                    !0
                }
                ]
            })
        }
        let _ = g.join(" ");
        i(_, !1);
        let m = f[_] || (f[_] = {
            preventDefault: !1,
            stopPropagation: !1,
            run: ((d = (h = f._any) === null || h === void 0 ? void 0 : h.run) === null || d === void 0 ? void 0 : d.slice()) || []
        });
        l && m.run.push(l),
        c && (m.preventDefault = !0),
        u && (m.stopPropagation = !0)
    }
    ;
    for (let o of t) {
        let a = o.scope ? o.scope.split(" ") : ["editor"];
        if (o.any)
            for (let c of a) {
                let u = n[c] || (n[c] = Object.create(null));
                u._any || (u._any = {
                    preventDefault: !1,
                    stopPropagation: !1,
                    run: []
                });
                let {any: h} = o;
                for (let d in u)
                    u[d].run.push(f => h(f, ey))
            }
        let l = o[e] || o.key;
        if (l)
            for (let c of a)
                s(c, l, o.run, o.preventDefault, o.stopPropagation),
                o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation)
    }
    return n
}
let ey = null;
function eB(t, e, n, r) {
    ey = e;
    let i = Nhe(e)
      , s = Xn(i, 0)
      , o = Wr(s) == i.length && i != " "
      , a = ""
      , l = !1
      , c = !1
      , u = !1;
    ks && ks.view == n && ks.scope == r && (a = ks.prefix + " ",
    j3.indexOf(e.keyCode) < 0 && (c = !0,
    ks = null));
    let h = new Set, d = m => {
        if (m) {
            for (let p of m.run)
                if (!h.has(p) && (h.add(p),
                p(n)))
                    return m.stopPropagation && (u = !0),
                    !0;
            m.preventDefault && (m.stopPropagation && (u = !0),
            c = !0)
        }
        return !1
    }
    , f = t[r], g, _;
    return f && (d(f[a + qd(i, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && !(Le.windows && e.ctrlKey && e.altKey) && (g = Js[e.keyCode]) && g != i ? (d(f[a + qd(g, e, !0)]) || e.shiftKey && (_ = Gu[e.keyCode]) != i && _ != g && d(f[a + qd(_, e, !1)])) && (l = !0) : o && e.shiftKey && d(f[a + qd(i, e, !0)]) && (l = !0),
    !l && d(f._any) && (l = !0)),
    c && (l = !0),
    l && u && e.stopPropagation(),
    ey = null,
    l
}
class rd {
    constructor(e, n, r, i, s) {
        this.className = e,
        this.left = n,
        this.top = r,
        this.width = i,
        this.height = s
    }
    draw() {
        let e = document.createElement("div");
        return e.className = this.className,
        this.adjust(e),
        e
    }
    update(e, n) {
        return n.className != this.className ? !1 : (this.adjust(e),
        !0)
    }
    adjust(e) {
        e.style.left = this.left + "px",
        e.style.top = this.top + "px",
        this.width != null && (e.style.width = this.width + "px"),
        e.style.height = this.height + "px"
    }
    eq(e) {
        return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className
    }
    static forRange(e, n, r) {
        if (r.empty) {
            let i = e.coordsAtPos(r.head, r.assoc || 1);
            if (!i)
                return [];
            let s = tB(e);
            return [new rd(n,i.left - s.left,i.top - s.top,null,i.bottom - i.top)]
        } else
            return dfe(e, n, r)
    }
}
function tB(t) {
    let e = t.scrollDOM.getBoundingClientRect();
    return {
        left: (t.textDirection == Nt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX,
        top: e.top - t.scrollDOM.scrollTop * t.scaleY
    }
}
function HT(t, e, n, r) {
    let i = t.coordsAtPos(e, n * 2);
    if (!i)
        return r;
    let s = t.dom.getBoundingClientRect()
      , o = (i.top + i.bottom) / 2
      , a = t.posAtCoords({
        x: s.left + 1,
        y: o
    })
      , l = t.posAtCoords({
        x: s.right - 1,
        y: o
    });
    return a == null || l == null ? r : {
        from: Math.max(r.from, Math.min(a, l)),
        to: Math.min(r.to, Math.max(a, l))
    }
}
function dfe(t, e, n) {
    if (n.to <= t.viewport.from || n.from >= t.viewport.to)
        return [];
    let r = Math.max(n.from, t.viewport.from)
      , i = Math.min(n.to, t.viewport.to)
      , s = t.textDirection == Nt.LTR
      , o = t.contentDOM
      , a = o.getBoundingClientRect()
      , l = tB(t)
      , c = o.querySelector(".cm-line")
      , u = c && window.getComputedStyle(c)
      , h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0)
      , d = a.right - (u ? parseInt(u.paddingRight) : 0)
      , f = Yb(t, r)
      , g = Yb(t, i)
      , _ = f.type == Vn.Text ? f : null
      , m = g.type == Vn.Text ? g : null;
    if (_ && (t.lineWrapping || f.widgetLineBreaks) && (_ = HT(t, r, 1, _)),
    m && (t.lineWrapping || g.widgetLineBreaks) && (m = HT(t, i, -1, m)),
    _ && m && _.from == m.from && _.to == m.to)
        return b(y(n.from, n.to, _));
    {
        let E = _ ? y(n.from, null, _) : x(f, !1)
          , w = m ? y(null, n.to, m) : x(g, !0)
          , A = [];
        return (_ || f).to < (m || g).from - (_ && m ? 1 : 0) || f.widgetLineBreaks > 1 && E.bottom + t.defaultLineHeight / 2 < w.top ? A.push(p(h, E.bottom, d, w.top)) : E.bottom < w.top && t.elementAtHeight((E.bottom + w.top) / 2).type == Vn.Text && (E.bottom = w.top = (E.bottom + w.top) / 2),
        b(E).concat(A).concat(b(w))
    }
    function p(E, w, A, C) {
        return new rd(e,E - l.left,w - l.top - .01,A - E,C - w + .01)
    }
    function b({top: E, bottom: w, horizontal: A}) {
        let C = [];
        for (let k = 0; k < A.length; k += 2)
            C.push(p(A[k], E, A[k + 1], w));
        return C
    }
    function y(E, w, A) {
        let C = 1e9
          , k = -1e9
          , I = [];
        function N(H, $, J, Q, ee) {
            let D = t.coordsAtPos(H, H == A.to ? -2 : 2)
              , L = t.coordsAtPos(J, J == A.from ? 2 : -2);
            !D || !L || (C = Math.min(D.top, L.top, C),
            k = Math.max(D.bottom, L.bottom, k),
            ee == Nt.LTR ? I.push(s && $ ? h : D.left, s && Q ? d : L.right) : I.push(!s && Q ? h : L.left, !s && $ ? d : D.right))
        }
        let O = E ?? A.from
          , M = w ?? A.to;
        for (let H of t.visibleRanges)
            if (H.to > O && H.from < M)
                for (let $ = Math.max(H.from, O), J = Math.min(H.to, M); ; ) {
                    let Q = t.state.doc.lineAt($);
                    for (let ee of t.bidiSpans(Q)) {
                        let D = ee.from + Q.from
                          , L = ee.to + Q.from;
                        if (D >= J)
                            break;
                        L > $ && N(Math.max(D, $), E == null && D <= O, Math.min(L, J), w == null && L >= M, ee.dir)
                    }
                    if ($ = Q.to + 1,
                    $ >= J)
                        break
                }
        return I.length == 0 && N(O, E == null, M, w == null, t.textDirection),
        {
            top: C,
            bottom: k,
            horizontal: I
        }
    }
    function x(E, w) {
        let A = a.top + (w ? E.top : E.bottom);
        return {
            top: A,
            bottom: A,
            horizontal: []
        }
    }
}
function ffe(t, e) {
    return t.constructor == e.constructor && t.eq(e)
}
class pfe {
    constructor(e, n) {
        this.view = e,
        this.layer = n,
        this.drawn = [],
        this.scaleX = 1,
        this.scaleY = 1,
        this.measureReq = {
            read: this.measure.bind(this),
            write: this.draw.bind(this)
        },
        this.dom = e.scrollDOM.appendChild(document.createElement("div")),
        this.dom.classList.add("cm-layer"),
        n.above && this.dom.classList.add("cm-layer-above"),
        n.class && this.dom.classList.add(n.class),
        this.scale(),
        this.dom.setAttribute("aria-hidden", "true"),
        this.setOrder(e.state),
        e.requestMeasure(this.measureReq),
        n.mount && n.mount(this.dom, e)
    }
    update(e) {
        e.startState.facet(kf) != e.state.facet(kf) && this.setOrder(e.state),
        (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(),
        e.view.requestMeasure(this.measureReq))
    }
    docViewUpdate(e) {
        this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq)
    }
    setOrder(e) {
        let n = 0
          , r = e.facet(kf);
        for (; n < r.length && r[n] != this.layer; )
            n++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n)
    }
    measure() {
        return this.layer.markers(this.view)
    }
    scale() {
        let {scaleX: e, scaleY: n} = this.view;
        (e != this.scaleX || n != this.scaleY) && (this.scaleX = e,
        this.scaleY = n,
        this.dom.style.transform = `scale(${1 / e}, ${1 / n})`)
    }
    draw(e) {
        if (e.length != this.drawn.length || e.some( (n, r) => !ffe(n, this.drawn[r]))) {
            let n = this.dom.firstChild
              , r = 0;
            for (let i of e)
                i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling,
                r++) : this.dom.insertBefore(i.draw(), n);
            for (; n; ) {
                let i = n.nextSibling;
                n.remove(),
                n = i
            }
            this.drawn = e
        }
    }
    destroy() {
        this.layer.destroy && this.layer.destroy(this.dom, this.view),
        this.dom.remove()
    }
}
const kf = Me.define();
function nB(t) {
    return [xn.define(e => new pfe(e,t)), kf.of(t)]
}
const rB = !Le.ios
  , Xu = Me.define({
    combine(t) {
        return Aa(t, {
            cursorBlinkRate: 1200,
            drawRangeCursor: !0
        }, {
            cursorBlinkRate: (e, n) => Math.min(e, n),
            drawRangeCursor: (e, n) => e || n
        })
    }
});
function mfe(t={}) {
    return [Xu.of(t), gfe, _fe, bfe, k3.of(!0)]
}
function iB(t) {
    return t.startState.facet(Xu) != t.state.facet(Xu)
}
const gfe = nB({
    above: !0,
    markers(t) {
        let {state: e} = t
          , n = e.facet(Xu)
          , r = [];
        for (let i of e.selection.ranges) {
            let s = i == e.selection.main;
            if (i.empty ? !s || rB : n.drawRangeCursor) {
                let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary"
                  , a = i.empty ? i : ge.cursor(i.head, i.head > i.anchor ? -1 : 1);
                for (let l of rd.forRange(t, o, a))
                    r.push(l)
            }
        }
        return r
    },
    update(t, e) {
        t.transactions.some(r => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
        let n = iB(t);
        return n && UT(t.state, e),
        t.docChanged || t.selectionSet || n
    },
    mount(t, e) {
        UT(e.state, t)
    },
    class: "cm-cursorLayer"
});
function UT(t, e) {
    e.style.animationDuration = t.facet(Xu).cursorBlinkRate + "ms"
}
const _fe = nB({
    above: !1,
    markers(t) {
        return t.state.selection.ranges.map(e => e.empty ? [] : rd.forRange(t, "cm-selectionBackground", e)).reduce( (e, n) => e.concat(n))
    },
    update(t, e) {
        return t.docChanged || t.selectionSet || t.viewportChanged || iB(t)
    },
    class: "cm-selectionLayer"
})
  , ty = {
    ".cm-line": {
        "& ::selection, &::selection": {
            backgroundColor: "transparent !important"
        }
    },
    ".cm-content": {
        "& :focus": {
            caretColor: "initial !important",
            "&::selection, & ::selection": {
                backgroundColor: "Highlight !important"
            }
        }
    }
};
rB && (ty[".cm-line"].caretColor = ty[".cm-content"].caretColor = "transparent !important");
const bfe = co.highest(Oe.theme(ty))
  , sB = Je.define({
    map(t, e) {
        return t == null ? null : e.mapPos(t)
    }
})
  , Bc = Qt.define({
    create() {
        return null
    },
    update(t, e) {
        return t != null && (t = e.changes.mapPos(t)),
        e.effects.reduce( (n, r) => r.is(sB) ? r.value : n, t)
    }
})
  , yfe = xn.fromClass(class {
    constructor(t) {
        this.view = t,
        this.cursor = null,
        this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawCursor.bind(this)
        }
    }
    update(t) {
        var e;
        let n = t.state.field(Bc);
        n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(),
        this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")),
        this.cursor.className = "cm-dropCursor"),
        (t.startState.field(Bc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq))
    }
    readPos() {
        let {view: t} = this
          , e = t.state.field(Bc)
          , n = e != null && t.coordsAtPos(e);
        if (!n)
            return null;
        let r = t.scrollDOM.getBoundingClientRect();
        return {
            left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
            top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
            height: n.bottom - n.top
        }
    }
    drawCursor(t) {
        if (this.cursor) {
            let {scaleX: e, scaleY: n} = this.view;
            t ? (this.cursor.style.left = t.left / e + "px",
            this.cursor.style.top = t.top / n + "px",
            this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px"
        }
    }
    destroy() {
        this.cursor && this.cursor.remove()
    }
    setDropPos(t) {
        this.view.state.field(Bc) != t && this.view.dispatch({
            effects: sB.of(t)
        })
    }
}
, {
    eventObservers: {
        dragover(t) {
            this.setDropPos(this.view.posAtCoords({
                x: t.clientX,
                y: t.clientY
            }))
        },
        dragleave(t) {
            (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null)
        },
        dragend() {
            this.setDropPos(null)
        },
        drop() {
            this.setDropPos(null)
        }
    }
});
function vfe() {
    return [Bc, yfe]
}
const VT = xn.fromClass(class {
    constructor() {
        this.height = 1e3,
        this.attrs = {
            style: "padding-bottom: 1000px"
        }
    }
    update(t) {
        let {view: e} = t
          , n = e.viewState.editorHeight - e.defaultLineHeight - e.documentPadding.top - .5;
        n >= 0 && n != this.height && (this.height = n,
        this.attrs = {
            style: `padding-bottom: ${n}px`
        })
    }
}
);
function xfe() {
    return [VT, ug.of(t => {
        var e;
        return ((e = t.plugin(VT)) === null || e === void 0 ? void 0 : e.attrs) || null
    }
    )]
}
function Efe() {
    return wfe
}
const Sfe = at.line({
    class: "cm-activeLine"
})
  , wfe = xn.fromClass(class {
    constructor(t) {
        this.decorations = this.getDeco(t)
    }
    update(t) {
        (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view))
    }
    getDeco(t) {
        let e = -1
          , n = [];
        for (let r of t.state.selection.ranges) {
            let i = t.lineBlockAt(r.head);
            i.from > e && (n.push(Sfe.range(i.from)),
            e = i.from)
        }
        return at.set(n)
    }
}
, {
    decorations: t => t.decorations
})
  , mc = "-10000px";
class Cfe {
    constructor(e, n, r, i) {
        this.facet = n,
        this.createTooltipView = r,
        this.removeTooltipView = i,
        this.input = e.state.facet(n),
        this.tooltips = this.input.filter(o => o);
        let s = null;
        this.tooltipViews = this.tooltips.map(o => s = r(o, s))
    }
    update(e, n) {
        var r;
        let i = e.state.facet(this.facet)
          , s = i.filter(l => l);
        if (i === this.input) {
            for (let l of this.tooltipViews)
                l.update && l.update(e);
            return !1
        }
        let o = []
          , a = n ? [] : null;
        for (let l = 0; l < s.length; l++) {
            let c = s[l]
              , u = -1;
            if (c) {
                for (let h = 0; h < this.tooltips.length; h++) {
                    let d = this.tooltips[h];
                    d && d.create == c.create && (u = h)
                }
                if (u < 0)
                    o[l] = this.createTooltipView(c, l ? o[l - 1] : null),
                    a && (a[l] = !!c.above);
                else {
                    let h = o[l] = this.tooltipViews[u];
                    a && (a[l] = n[u]),
                    h.update && h.update(e)
                }
            }
        }
        for (let l of this.tooltipViews)
            o.indexOf(l) < 0 && (this.removeTooltipView(l),
            (r = l.destroy) === null || r === void 0 || r.call(l));
        return n && (a.forEach( (l, c) => n[c] = l),
        n.length = a.length),
        this.input = i,
        this.tooltips = s,
        this.tooltipViews = o,
        !0
    }
}
function Tfe(t={}) {
    return Rf.of(t)
}
function Afe(t) {
    let {win: e} = t;
    return {
        top: 0,
        left: 0,
        bottom: e.innerHeight,
        right: e.innerWidth
    }
}
const Rf = Me.define({
    combine: t => {
        var e, n, r;
        return {
            position: Le.ios ? "absolute" : ((e = t.find(i => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
            parent: ((n = t.find(i => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
            tooltipSpace: ((r = t.find(i => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || Afe
        }
    }
})
  , $T = new WeakMap
  , oB = xn.fromClass(class {
    constructor(t) {
        this.view = t,
        this.above = [],
        this.inView = !0,
        this.madeAbsolute = !1,
        this.lastTransaction = 0,
        this.measureTimeout = -1;
        let e = t.state.facet(Rf);
        this.position = e.position,
        this.parent = e.parent,
        this.classes = t.themeClasses,
        this.createContainer(),
        this.measureReq = {
            read: this.readMeasure.bind(this),
            write: this.writeMeasure.bind(this),
            key: this
        },
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver( () => this.measureSoon()) : null,
        this.manager = new Cfe(t,dg, (n, r) => this.createTooltip(n, r),n => {
            this.resizeObserver && this.resizeObserver.unobserve(n.dom),
            n.dom.remove()
        }
        ),
        this.above = this.manager.tooltips.map(n => !!n.above),
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(n => {
            Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon()
        }
        ,{
            threshold: [1]
        }) : null,
        this.observeIntersection(),
        t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)),
        this.maybeMeasure()
    }
    createContainer() {
        this.parent ? (this.container = document.createElement("div"),
        this.container.style.position = "relative",
        this.container.className = this.view.themeClasses,
        this.parent.appendChild(this.container)) : this.container = this.view.dom
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let t of this.manager.tooltipViews)
                this.intersectionObserver.observe(t.dom)
        }
    }
    measureSoon() {
        this.measureTimeout < 0 && (this.measureTimeout = setTimeout( () => {
            this.measureTimeout = -1,
            this.maybeMeasure()
        }
        , 50))
    }
    update(t) {
        t.transactions.length && (this.lastTransaction = Date.now());
        let e = this.manager.update(t, this.above);
        e && this.observeIntersection();
        let n = e || t.geometryChanged
          , r = t.state.facet(Rf);
        if (r.position != this.position && !this.madeAbsolute) {
            this.position = r.position;
            for (let i of this.manager.tooltipViews)
                i.dom.style.position = this.position;
            n = !0
        }
        if (r.parent != this.parent) {
            this.parent && this.container.remove(),
            this.parent = r.parent,
            this.createContainer();
            for (let i of this.manager.tooltipViews)
                this.container.appendChild(i.dom);
            n = !0
        } else
            this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
        n && this.maybeMeasure()
    }
    createTooltip(t, e) {
        let n = t.create(this.view)
          , r = e ? e.dom : null;
        if (n.dom.classList.add("cm-tooltip"),
        t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let i = document.createElement("div");
            i.className = "cm-tooltip-arrow",
            n.dom.appendChild(i)
        }
        return n.dom.style.position = this.position,
        n.dom.style.top = mc,
        n.dom.style.left = "0px",
        this.container.insertBefore(n.dom, r),
        n.mount && n.mount(this.view),
        this.resizeObserver && this.resizeObserver.observe(n.dom),
        n
    }
    destroy() {
        var t, e, n;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let r of this.manager.tooltipViews)
            r.dom.remove(),
            (t = r.destroy) === null || t === void 0 || t.call(r);
        this.parent && this.container.remove(),
        (e = this.resizeObserver) === null || e === void 0 || e.disconnect(),
        (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(),
        clearTimeout(this.measureTimeout)
    }
    readMeasure() {
        let t = this.view.dom.getBoundingClientRect()
          , e = 1
          , n = 1
          , r = !1;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let {dom: i} = this.manager.tooltipViews[0];
            if (Le.gecko)
                r = i.offsetParent != this.container.ownerDocument.body;
            else if (i.style.top == mc && i.style.left == "0px") {
                let s = i.getBoundingClientRect();
                r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1
            }
        }
        if (r || this.position == "absolute")
            if (this.parent) {
                let i = this.parent.getBoundingClientRect();
                i.width && i.height && (e = i.width / this.parent.offsetWidth,
                n = i.height / this.parent.offsetHeight)
            } else
                ({scaleX: e, scaleY: n} = this.view.viewState);
        return {
            editor: t,
            parent: this.parent ? this.container.getBoundingClientRect() : t,
            pos: this.manager.tooltips.map( (i, s) => {
                let o = this.manager.tooltipViews[s];
                return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos)
            }
            ),
            size: this.manager.tooltipViews.map( ({dom: i}) => i.getBoundingClientRect()),
            space: this.view.state.facet(Rf).tooltipSpace(this.view),
            scaleX: e,
            scaleY: n,
            makeAbsolute: r
        }
    }
    writeMeasure(t) {
        var e;
        if (t.makeAbsolute) {
            this.madeAbsolute = !0,
            this.position = "absolute";
            for (let a of this.manager.tooltipViews)
                a.dom.style.position = "absolute"
        }
        let {editor: n, space: r, scaleX: i, scaleY: s} = t
          , o = [];
        for (let a = 0; a < this.manager.tooltips.length; a++) {
            let l = this.manager.tooltips[a]
              , c = this.manager.tooltipViews[a]
              , {dom: u} = c
              , h = t.pos[a]
              , d = t.size[a];
            if (!h || h.bottom <= Math.max(n.top, r.top) || h.top >= Math.min(n.bottom, r.bottom) || h.right < Math.max(n.left, r.left) - .1 || h.left > Math.min(n.right, r.right) + .1) {
                u.style.top = mc;
                continue
            }
            let f = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null
              , g = f ? 7 : 0
              , _ = d.right - d.left
              , m = (e = $T.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top
              , p = c.offset || Rfe
              , b = this.view.textDirection == Nt.LTR
              , y = d.width > r.right - r.left ? b ? r.left : r.right - d.width : b ? Math.min(h.left - (f ? 14 : 0) + p.x, r.right - _) : Math.max(r.left, h.left - _ + (f ? 14 : 0) - p.x)
              , x = this.above[a];
            !l.strictSide && (x ? h.top - (d.bottom - d.top) - p.y < r.top : h.bottom + (d.bottom - d.top) + p.y > r.bottom) && x == r.bottom - h.bottom > h.top - r.top && (x = this.above[a] = !x);
            let E = (x ? h.top - r.top : r.bottom - h.bottom) - g;
            if (E < m && c.resize !== !1) {
                if (E < this.view.defaultLineHeight) {
                    u.style.top = mc;
                    continue
                }
                $T.set(c, m),
                u.style.height = (m = E) / s + "px"
            } else
                u.style.height && (u.style.height = "");
            let w = x ? h.top - m - g - p.y : h.bottom + g + p.y
              , A = y + _;
            if (c.overlap !== !0)
                for (let C of o)
                    C.left < A && C.right > y && C.top < w + m && C.bottom > w && (w = x ? C.top - m - 2 - g : C.bottom + g + 2);
            if (this.position == "absolute" ? (u.style.top = (w - t.parent.top) / s + "px",
            u.style.left = (y - t.parent.left) / i + "px") : (u.style.top = w / s + "px",
            u.style.left = y / i + "px"),
            f) {
                let C = h.left + (b ? p.x : -p.x) - (y + 14 - 7);
                f.style.left = C / i + "px"
            }
            c.overlap !== !0 && o.push({
                left: y,
                top: w,
                right: A,
                bottom: w + m
            }),
            u.classList.toggle("cm-tooltip-above", x),
            u.classList.toggle("cm-tooltip-below", !x),
            c.positioned && c.positioned(t.space)
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq),
        this.inView != this.view.inView && (this.inView = this.view.inView,
        !this.inView)))
            for (let t of this.manager.tooltipViews)
                t.dom.style.top = mc
    }
}
, {
    eventObservers: {
        scroll() {
            this.maybeMeasure()
        }
    }
})
  , kfe = Oe.baseTheme({
    ".cm-tooltip": {
        zIndex: 100,
        boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: "7px",
        width: `${7 * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: "7px solid transparent",
            borderRight: "7px solid transparent"
        },
        ".cm-tooltip-above &": {
            bottom: "-7px",
            "&:before": {
                borderTop: "7px solid #bbb"
            },
            "&:after": {
                borderTop: "7px solid #f5f5f5",
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: "-7px",
            "&:before": {
                borderBottom: "7px solid #bbb"
            },
            "&:after": {
                borderBottom: "7px solid #f5f5f5",
                top: "1px"
            }
        }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
})
  , Rfe = {
    x: 0,
    y: 0
}
  , dg = Me.define({
    enables: [oB, kfe]
});
function aB(t, e) {
    let n = t.plugin(oB);
    if (!n)
        return null;
    let r = n.manager.tooltips.indexOf(e);
    return r < 0 ? null : n.manager.tooltipViews[r]
}
const zT = Me.define({
    combine(t) {
        let e, n;
        for (let r of t)
            e = e || r.topContainer,
            n = n || r.bottomContainer;
        return {
            topContainer: e,
            bottomContainer: n
        }
    }
});
function jp(t, e) {
    let n = t.plugin(lB)
      , r = n ? n.specs.indexOf(e) : -1;
    return r > -1 ? n.panels[r] : null
}
const lB = xn.fromClass(class {
    constructor(t) {
        this.input = t.state.facet(Hp),
        this.specs = this.input.filter(n => n),
        this.panels = this.specs.map(n => n(t));
        let e = t.state.facet(zT);
        this.top = new Kd(t,!0,e.topContainer),
        this.bottom = new Kd(t,!1,e.bottomContainer),
        this.top.sync(this.panels.filter(n => n.top)),
        this.bottom.sync(this.panels.filter(n => !n.top));
        for (let n of this.panels)
            n.dom.classList.add("cm-panel"),
            n.mount && n.mount()
    }
    update(t) {
        let e = t.state.facet(zT);
        this.top.container != e.topContainer && (this.top.sync([]),
        this.top = new Kd(t.view,!0,e.topContainer)),
        this.bottom.container != e.bottomContainer && (this.bottom.sync([]),
        this.bottom = new Kd(t.view,!1,e.bottomContainer)),
        this.top.syncClasses(),
        this.bottom.syncClasses();
        let n = t.state.facet(Hp);
        if (n != this.input) {
            let r = n.filter(l => l)
              , i = []
              , s = []
              , o = []
              , a = [];
            for (let l of r) {
                let c = this.specs.indexOf(l), u;
                c < 0 ? (u = l(t.view),
                a.push(u)) : (u = this.panels[c],
                u.update && u.update(t)),
                i.push(u),
                (u.top ? s : o).push(u)
            }
            this.specs = r,
            this.panels = i,
            this.top.sync(s),
            this.bottom.sync(o);
            for (let l of a)
                l.dom.classList.add("cm-panel"),
                l.mount && l.mount()
        } else
            for (let r of this.panels)
                r.update && r.update(t)
    }
    destroy() {
        this.top.sync([]),
        this.bottom.sync([])
    }
}
, {
    provide: t => Oe.scrollMargins.of(e => {
        let n = e.plugin(t);
        return n && {
            top: n.top.scrollMargin(),
            bottom: n.bottom.scrollMargin()
        }
    }
    )
});
class Kd {
    constructor(e, n, r) {
        this.view = e,
        this.top = n,
        this.container = r,
        this.dom = void 0,
        this.classes = "",
        this.panels = [],
        this.syncClasses()
    }
    sync(e) {
        for (let n of this.panels)
            n.destroy && e.indexOf(n) < 0 && n.destroy();
        this.panels = e,
        this.syncDOM()
    }
    syncDOM() {
        if (this.panels.length == 0) {
            this.dom && (this.dom.remove(),
            this.dom = void 0);
            return
        }
        if (!this.dom) {
            this.dom = document.createElement("div"),
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom",
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let n = this.container || this.view.dom;
            n.insertBefore(this.dom, this.top ? n.firstChild : null)
        }
        let e = this.dom.firstChild;
        for (let n of this.panels)
            if (n.dom.parentNode == this.dom) {
                for (; e != n.dom; )
                    e = WT(e);
                e = e.nextSibling
            } else
                this.dom.insertBefore(n.dom, e);
        for (; e; )
            e = WT(e)
    }
    scrollMargin() {
        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top)
    }
    syncClasses() {
        if (!(!this.container || this.classes == this.view.themeClasses)) {
            for (let e of this.classes.split(" "))
                e && this.container.classList.remove(e);
            for (let e of (this.classes = this.view.themeClasses).split(" "))
                e && this.container.classList.add(e)
        }
    }
}
function WT(t) {
    let e = t.nextSibling;
    return t.remove(),
    e
}
const Hp = Me.define({
    enables: lB
});
class ls extends aa {
    compare(e) {
        return this == e || this.constructor == e.constructor && this.eq(e)
    }
    eq(e) {
        return !1
    }
    destroy(e) {}
}
ls.prototype.elementClass = "";
ls.prototype.toDOM = void 0;
ls.prototype.mapMode = kn.TrackBefore;
ls.prototype.startSide = ls.prototype.endSide = -1;
ls.prototype.point = !0;
const If = Me.define()
  , Ife = {
    class: "",
    renderEmptyElements: !1,
    elementStyle: "",
    markers: () => dt.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
}
  , su = Me.define();
function Pfe(t) {
    return [cB(), su.of(Object.assign(Object.assign({}, Ife), t))]
}
const GT = Me.define({
    combine: t => t.some(e => e)
});
function cB(t) {
    return [Dfe]
}
const Dfe = xn.fromClass(class {
    constructor(t) {
        this.view = t,
        this.prevViewport = t.viewport,
        this.dom = document.createElement("div"),
        this.dom.className = "cm-gutters",
        this.dom.setAttribute("aria-hidden", "true"),
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px",
        this.gutters = t.state.facet(su).map(e => new KT(t,e));
        for (let e of this.gutters)
            this.dom.appendChild(e.dom);
        this.fixed = !t.state.facet(GT),
        this.fixed && (this.dom.style.position = "sticky"),
        this.syncGutters(!1),
        t.scrollDOM.insertBefore(this.dom, t.contentDOM)
    }
    update(t) {
        if (this.updateGutters(t)) {
            let e = this.prevViewport
              , n = t.view.viewport
              , r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
            this.syncGutters(r < (n.to - n.from) * .8)
        }
        t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
        this.view.state.facet(GT) != !this.fixed && (this.fixed = !this.fixed,
        this.dom.style.position = this.fixed ? "sticky" : ""),
        this.prevViewport = t.view.viewport
    }
    syncGutters(t) {
        let e = this.dom.nextSibling;
        t && this.dom.remove();
        let n = dt.iter(this.view.state.facet(If), this.view.viewport.from)
          , r = []
          , i = this.gutters.map(s => new Lfe(s,this.view.viewport,-this.view.documentPadding.top));
        for (let s of this.view.viewportLineBlocks)
            if (r.length && (r = []),
            Array.isArray(s.type)) {
                let o = !0;
                for (let a of s.type)
                    if (a.type == Vn.Text && o) {
                        ny(n, r, a.from);
                        for (let l of i)
                            l.line(this.view, a, r);
                        o = !1
                    } else if (a.widget)
                        for (let l of i)
                            l.widget(this.view, a)
            } else if (s.type == Vn.Text) {
                ny(n, r, s.from);
                for (let o of i)
                    o.line(this.view, s, r)
            } else if (s.widget)
                for (let o of i)
                    o.widget(this.view, s);
        for (let s of i)
            s.finish();
        t && this.view.scrollDOM.insertBefore(this.dom, e)
    }
    updateGutters(t) {
        let e = t.startState.facet(su)
          , n = t.state.facet(su)
          , r = t.docChanged || t.heightChanged || t.viewportChanged || !dt.eq(t.startState.facet(If), t.state.facet(If), t.view.viewport.from, t.view.viewport.to);
        if (e == n)
            for (let i of this.gutters)
                i.update(t) && (r = !0);
        else {
            r = !0;
            let i = [];
            for (let s of n) {
                let o = e.indexOf(s);
                o < 0 ? i.push(new KT(this.view,s)) : (this.gutters[o].update(t),
                i.push(this.gutters[o]))
            }
            for (let s of this.gutters)
                s.dom.remove(),
                i.indexOf(s) < 0 && s.destroy();
            for (let s of i)
                this.dom.appendChild(s.dom);
            this.gutters = i
        }
        return r
    }
    destroy() {
        for (let t of this.gutters)
            t.destroy();
        this.dom.remove()
    }
}
, {
    provide: t => Oe.scrollMargins.of(e => {
        let n = e.plugin(t);
        return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == Nt.LTR ? {
            left: n.dom.offsetWidth * e.scaleX
        } : {
            right: n.dom.offsetWidth * e.scaleX
        }
    }
    )
});
function qT(t) {
    return Array.isArray(t) ? t : [t]
}
function ny(t, e, n) {
    for (; t.value && t.from <= n; )
        t.from == n && e.push(t.value),
        t.next()
}
class Lfe {
    constructor(e, n, r) {
        this.gutter = e,
        this.height = r,
        this.i = 0,
        this.cursor = dt.iter(e.markers, n.from)
    }
    addElement(e, n, r) {
        let {gutter: i} = this
          , s = (n.top - this.height) / e.scaleY
          , o = n.height / e.scaleY;
        if (this.i == i.elements.length) {
            let a = new uB(e,o,s,r);
            i.elements.push(a),
            i.dom.appendChild(a.dom)
        } else
            i.elements[this.i].update(e, o, s, r);
        this.height = n.bottom,
        this.i++
    }
    line(e, n, r) {
        let i = [];
        ny(this.cursor, i, n.from),
        r.length && (i = i.concat(r));
        let s = this.gutter.config.lineMarker(e, n, i);
        s && i.unshift(s);
        let o = this.gutter;
        i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, n, i)
    }
    widget(e, n) {
        let r = this.gutter.config.widgetMarker(e, n.widget, n);
        r && this.addElement(e, n, [r])
    }
    finish() {
        let e = this.gutter;
        for (; e.elements.length > this.i; ) {
            let n = e.elements.pop();
            e.dom.removeChild(n.dom),
            n.destroy()
        }
    }
}
class KT {
    constructor(e, n) {
        this.view = e,
        this.config = n,
        this.elements = [],
        this.spacer = null,
        this.dom = document.createElement("div"),
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let r in n.domEventHandlers)
            this.dom.addEventListener(r, i => {
                let s = i.target, o;
                if (s != this.dom && this.dom.contains(s)) {
                    for (; s.parentNode != this.dom; )
                        s = s.parentNode;
                    let l = s.getBoundingClientRect();
                    o = (l.top + l.bottom) / 2
                } else
                    o = i.clientY;
                let a = e.lineBlockAtHeight(o - e.documentTop);
                n.domEventHandlers[r](e, a, i) && i.preventDefault()
            }
            );
        this.markers = qT(n.markers(e)),
        n.initialSpacer && (this.spacer = new uB(e,0,0,[n.initialSpacer(e)]),
        this.dom.appendChild(this.spacer.dom),
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none")
    }
    update(e) {
        let n = this.markers;
        if (this.markers = qT(this.config.markers(e.view)),
        this.spacer && this.config.updateSpacer) {
            let i = this.config.updateSpacer(this.spacer.markers[0], e);
            i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i])
        }
        let r = e.view.viewport;
        return !dt.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1)
    }
    destroy() {
        for (let e of this.elements)
            e.destroy()
    }
}
class uB {
    constructor(e, n, r, i) {
        this.height = -1,
        this.above = 0,
        this.markers = [],
        this.dom = document.createElement("div"),
        this.dom.className = "cm-gutterElement",
        this.update(e, n, r, i)
    }
    update(e, n, r, i) {
        this.height != n && (this.height = n,
        this.dom.style.height = n + "px"),
        this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""),
        Ofe(this.markers, i) || this.setMarkers(e, i)
    }
    setMarkers(e, n) {
        let r = "cm-gutterElement"
          , i = this.dom.firstChild;
        for (let s = 0, o = 0; ; ) {
            let a = o
              , l = s < n.length ? n[s++] : null
              , c = !1;
            if (l) {
                let u = l.elementClass;
                u && (r += " " + u);
                for (let h = o; h < this.markers.length; h++)
                    if (this.markers[h].compare(l)) {
                        a = h,
                        c = !0;
                        break
                    }
            } else
                a = this.markers.length;
            for (; o < a; ) {
                let u = this.markers[o++];
                if (u.toDOM) {
                    u.destroy(i);
                    let h = i.nextSibling;
                    i.remove(),
                    i = h
                }
            }
            if (!l)
                break;
            l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)),
            c && o++
        }
        this.dom.className = r,
        this.markers = n
    }
    destroy() {
        this.setMarkers(null, [])
    }
}
function Ofe(t, e) {
    if (t.length != e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (!t[n].compare(e[n]))
            return !1;
    return !0
}
const Nfe = Me.define()
  , nl = Me.define({
    combine(t) {
        return Aa(t, {
            formatNumber: String,
            domEventHandlers: {}
        }, {
            domEventHandlers(e, n) {
                let r = Object.assign({}, e);
                for (let i in n) {
                    let s = r[i]
                      , o = n[i];
                    r[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o
                }
                return r
            }
        })
    }
});
class j0 extends ls {
    constructor(e) {
        super(),
        this.number = e
    }
    eq(e) {
        return this.number == e.number
    }
    toDOM() {
        return document.createTextNode(this.number)
    }
}
function H0(t, e) {
    return t.state.facet(nl).formatNumber(e, t.state)
}
const Mfe = su.compute([nl], t => ({
    class: "cm-lineNumbers",
    renderEmptyElements: !1,
    markers(e) {
        return e.state.facet(Nfe)
    },
    lineMarker(e, n, r) {
        return r.some(i => i.toDOM) ? null : new j0(H0(e, e.state.doc.lineAt(n.from).number))
    },
    widgetMarker: () => null,
    lineMarkerChange: e => e.startState.facet(nl) != e.state.facet(nl),
    initialSpacer(e) {
        return new j0(H0(e, YT(e.state.doc.lines)))
    },
    updateSpacer(e, n) {
        let r = H0(n.view, YT(n.view.state.doc.lines));
        return r == e.number ? e : new j0(r)
    },
    domEventHandlers: t.facet(nl).domEventHandlers
}));
function Bfe(t={}) {
    return [nl.of(t), cB(), Mfe]
}
function YT(t) {
    let e = 9;
    for (; e < t; )
        e = e * 10 + 9;
    return e
}
const Ffe = new class extends ls {
    constructor() {
        super(...arguments),
        this.elementClass = "cm-activeLineGutter"
    }
}
  , jfe = If.compute(["selection"], t => {
    let e = []
      , n = -1;
    for (let r of t.selection.ranges) {
        let i = t.doc.lineAt(r.head).from;
        i > n && (n = i,
        e.push(Ffe.range(i)))
    }
    return dt.of(e)
}
);
function Hfe() {
    return jfe
}
const Ufe = 1024;
let Vfe = 0;
class Ar {
    constructor(e, n) {
        this.from = e,
        this.to = n
    }
}
class ot {
    constructor(e={}) {
        this.id = Vfe++,
        this.perNode = !!e.perNode,
        this.deserialize = e.deserialize || ( () => {
            throw new Error("This node type doesn't define a deserialize function")
        }
        )
    }
    add(e) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        return typeof e != "function" && (e = tr.match(e)),
        n => {
            let r = e(n);
            return r === void 0 ? null : [this, r]
        }
    }
}
ot.closedBy = new ot({
    deserialize: t => t.split(" ")
});
ot.openedBy = new ot({
    deserialize: t => t.split(" ")
});
ot.group = new ot({
    deserialize: t => t.split(" ")
});
ot.isolate = new ot({
    deserialize: t => {
        if (t && t != "rtl" && t != "ltr" && t != "auto")
            throw new RangeError("Invalid value for isolate: " + t);
        return t || "auto"
    }
});
ot.contextHash = new ot({
    perNode: !0
});
ot.lookAhead = new ot({
    perNode: !0
});
ot.mounted = new ot({
    perNode: !0
});
class Qu {
    constructor(e, n, r) {
        this.tree = e,
        this.overlay = n,
        this.parser = r
    }
    static get(e) {
        return e && e.props && e.props[ot.mounted.id]
    }
}
const $fe = Object.create(null);
class tr {
    constructor(e, n, r, i=0) {
        this.name = e,
        this.props = n,
        this.id = r,
        this.flags = i
    }
    static define(e) {
        let n = e.props && e.props.length ? Object.create(null) : $fe
          , r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0)
          , i = new tr(e.name || "",n,e.id,r);
        if (e.props) {
            for (let s of e.props)
                if (Array.isArray(s) || (s = s(i)),
                s) {
                    if (s[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    n[s[0].id] = s[1]
                }
        }
        return i
    }
    prop(e) {
        return this.props[e.id]
    }
    get isTop() {
        return (this.flags & 1) > 0
    }
    get isSkipped() {
        return (this.flags & 2) > 0
    }
    get isError() {
        return (this.flags & 4) > 0
    }
    get isAnonymous() {
        return (this.flags & 8) > 0
    }
    is(e) {
        if (typeof e == "string") {
            if (this.name == e)
                return !0;
            let n = this.prop(ot.group);
            return n ? n.indexOf(e) > -1 : !1
        }
        return this.id == e
    }
    static match(e) {
        let n = Object.create(null);
        for (let r in e)
            for (let i of r.split(" "))
                n[i] = e[r];
        return r => {
            for (let i = r.prop(ot.group), s = -1; s < (i ? i.length : 0); s++) {
                let o = n[s < 0 ? r.name : i[s]];
                if (o)
                    return o
            }
        }
    }
}
tr.none = new tr("",Object.create(null),0,8);
class hB {
    constructor(e) {
        this.types = e;
        for (let n = 0; n < e.length; n++)
            if (e[n].id != n)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set")
    }
    extend(...e) {
        let n = [];
        for (let r of this.types) {
            let i = null;
            for (let s of e) {
                let o = s(r);
                o && (i || (i = Object.assign({}, r.props)),
                i[o[0].id] = o[1])
            }
            n.push(i ? new tr(r.name,i,r.id,r.flags) : r)
        }
        return new hB(n)
    }
}
const Yd = new WeakMap
  , XT = new WeakMap;
var Bt;
(function(t) {
    t[t.ExcludeBuffers = 1] = "ExcludeBuffers",
    t[t.IncludeAnonymous = 2] = "IncludeAnonymous",
    t[t.IgnoreMounts = 4] = "IgnoreMounts",
    t[t.IgnoreOverlays = 8] = "IgnoreOverlays"
}
)(Bt || (Bt = {}));
class en {
    constructor(e, n, r, i, s) {
        if (this.type = e,
        this.children = n,
        this.positions = r,
        this.length = i,
        this.props = null,
        s && s.length) {
            this.props = Object.create(null);
            for (let[o,a] of s)
                this.props[typeof o == "number" ? o : o.id] = a
        }
    }
    toString() {
        let e = Qu.get(this);
        if (e && !e.overlay)
            return e.tree.toString();
        let n = "";
        for (let r of this.children) {
            let i = r.toString();
            i && (n && (n += ","),
            n += i)
        }
        return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n
    }
    cursor(e=0) {
        return new Up(this.topNode,e)
    }
    cursorAt(e, n=0, r=0) {
        let i = Yd.get(this) || this.topNode
          , s = new Up(i);
        return s.moveTo(e, n),
        Yd.set(this, s._tree),
        s
    }
    get topNode() {
        return new Dn(this,0,0,null)
    }
    resolve(e, n=0) {
        let r = Ju(Yd.get(this) || this.topNode, e, n, !1);
        return Yd.set(this, r),
        r
    }
    resolveInner(e, n=0) {
        let r = Ju(XT.get(this) || this.topNode, e, n, !0);
        return XT.set(this, r),
        r
    }
    resolveStack(e, n=0) {
        return Gfe(this, e, n)
    }
    iterate(e) {
        let {enter: n, leave: r, from: i=0, to: s=this.length} = e
          , o = e.mode || 0
          , a = (o & Bt.IncludeAnonymous) > 0;
        for (let l = this.cursor(o | Bt.IncludeAnonymous); ; ) {
            let c = !1;
            if (l.from <= s && l.to >= i && (!a && l.type.isAnonymous || n(l) !== !1)) {
                if (l.firstChild())
                    continue;
                c = !0
            }
            for (; c && r && (a || !l.type.isAnonymous) && r(l),
            !l.nextSibling(); ) {
                if (!l.parent())
                    return;
                c = !0
            }
        }
    }
    prop(e) {
        return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e)
    }
    get propValues() {
        let e = [];
        if (this.props)
            for (let n in this.props)
                e.push([+n, this.props[n]]);
        return e
    }
    balance(e={}) {
        return this.children.length <= 8 ? this : tx(tr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new en(this.type,n,r,i,this.propValues), e.makeTree || ( (n, r, i) => new en(tr.none,n,r,i)))
    }
    static build(e) {
        return qfe(e)
    }
}
en.empty = new en(tr.none,[],[],0);
class Z1 {
    constructor(e, n) {
        this.buffer = e,
        this.index = n
    }
    get id() {
        return this.buffer[this.index - 4]
    }
    get start() {
        return this.buffer[this.index - 3]
    }
    get end() {
        return this.buffer[this.index - 2]
    }
    get size() {
        return this.buffer[this.index - 1]
    }
    get pos() {
        return this.index
    }
    next() {
        this.index -= 4
    }
    fork() {
        return new Z1(this.buffer,this.index)
    }
}
class eo {
    constructor(e, n, r) {
        this.buffer = e,
        this.length = n,
        this.set = r
    }
    get type() {
        return tr.none
    }
    toString() {
        let e = [];
        for (let n = 0; n < this.buffer.length; )
            e.push(this.childString(n)),
            n = this.buffer[n + 3];
        return e.join(",")
    }
    childString(e) {
        let n = this.buffer[e]
          , r = this.buffer[e + 3]
          , i = this.set.types[n]
          , s = i.name;
        if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)),
        e += 4,
        r == e)
            return s;
        let o = [];
        for (; e < r; )
            o.push(this.childString(e)),
            e = this.buffer[e + 3];
        return s + "(" + o.join(",") + ")"
    }
    findChild(e, n, r, i, s) {
        let {buffer: o} = this
          , a = -1;
        for (let l = e; l != n && !(dB(s, i, o[l + 1], o[l + 2]) && (a = l,
        r > 0)); l = o[l + 3])
            ;
        return a
    }
    slice(e, n, r) {
        let i = this.buffer
          , s = new Uint16Array(n - e)
          , o = 0;
        for (let a = e, l = 0; a < n; ) {
            s[l++] = i[a++],
            s[l++] = i[a++] - r;
            let c = s[l++] = i[a++] - r;
            s[l++] = i[a++] - e,
            o = Math.max(o, c)
        }
        return new eo(s,o,this.set)
    }
}
function dB(t, e, n, r) {
    switch (t) {
    case -2:
        return n < e;
    case -1:
        return r >= e && n < e;
    case 0:
        return n < e && r > e;
    case 1:
        return n <= e && r > e;
    case 2:
        return r > e;
    case 4:
        return !0
    }
}
function Ju(t, e, n, r) {
    for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
        let o = !r && t instanceof Dn && t.index < 0 ? null : t.parent;
        if (!o)
            return t;
        t = o
    }
    let s = r ? 0 : Bt.IgnoreOverlays;
    if (r)
        for (let o = t, a = o.parent; a; o = a,
        a = o.parent)
            o instanceof Dn && o.index < 0 && ((i = a.enter(e, n, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = a);
    for (; ; ) {
        let o = t.enter(e, n, s);
        if (!o)
            return t;
        t = o
    }
}
class fB {
    cursor(e=0) {
        return new Up(this,e)
    }
    getChild(e, n=null, r=null) {
        let i = QT(this, e, n, r);
        return i.length ? i[0] : null
    }
    getChildren(e, n=null, r=null) {
        return QT(this, e, n, r)
    }
    resolve(e, n=0) {
        return Ju(this, e, n, !1)
    }
    resolveInner(e, n=0) {
        return Ju(this, e, n, !0)
    }
    matchContext(e) {
        return ry(this, e)
    }
    enterUnfinishedNodesBefore(e) {
        let n = this.childBefore(e)
          , r = this;
        for (; n; ) {
            let i = n.lastChild;
            if (!i || i.to != n.to)
                break;
            i.type.isError && i.from == i.to ? (r = n,
            n = i.prevSibling) : n = i
        }
        return r
    }
    get node() {
        return this
    }
    get next() {
        return this.parent
    }
}
class Dn extends fB {
    constructor(e, n, r, i) {
        super(),
        this._tree = e,
        this.from = n,
        this.index = r,
        this._parent = i
    }
    get type() {
        return this._tree.type
    }
    get name() {
        return this._tree.type.name
    }
    get to() {
        return this.from + this._tree.length
    }
    nextChild(e, n, r, i, s=0) {
        for (let o = this; ; ) {
            for (let {children: a, positions: l} = o._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
                let u = a[e]
                  , h = l[e] + o.from;
                if (dB(i, r, h, h + u.length)) {
                    if (u instanceof eo) {
                        if (s & Bt.ExcludeBuffers)
                            continue;
                        let d = u.findChild(0, u.buffer.length, n, r - h, i);
                        if (d > -1)
                            return new Ei(new zfe(o,u,e,h),null,d)
                    } else if (s & Bt.IncludeAnonymous || !u.type.isAnonymous || ex(u)) {
                        let d;
                        if (!(s & Bt.IgnoreMounts) && (d = Qu.get(u)) && !d.overlay)
                            return new Dn(d.tree,h,e,o);
                        let f = new Dn(u,h,e,o);
                        return s & Bt.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i)
                    }
                }
            }
            if (s & Bt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + n : e = n < 0 ? -1 : o._parent._tree.children.length,
            o = o._parent,
            !o))
                return null
        }
    }
    get firstChild() {
        return this.nextChild(0, 1, 0, 4)
    }
    get lastChild() {
        return this.nextChild(this._tree.children.length - 1, -1, 0, 4)
    }
    childAfter(e) {
        return this.nextChild(0, 1, e, 2)
    }
    childBefore(e) {
        return this.nextChild(this._tree.children.length - 1, -1, e, -2)
    }
    enter(e, n, r=0) {
        let i;
        if (!(r & Bt.IgnoreOverlays) && (i = Qu.get(this._tree)) && i.overlay) {
            let s = e - this.from;
            for (let {from: o, to: a} of i.overlay)
                if ((n > 0 ? o <= s : o < s) && (n < 0 ? a >= s : a > s))
                    return new Dn(i.tree,i.overlay[0].from + this.from,-1,this)
        }
        return this.nextChild(0, 1, e, n, r)
    }
    nextSignificantParent() {
        let e = this;
        for (; e.type.isAnonymous && e._parent; )
            e = e._parent;
        return e
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null
    }
    get tree() {
        return this._tree
    }
    toTree() {
        return this._tree
    }
    toString() {
        return this._tree.toString()
    }
}
function QT(t, e, n, r) {
    let i = t.cursor()
      , s = [];
    if (!i.firstChild())
        return s;
    if (n != null) {
        for (let o = !1; !o; )
            if (o = i.type.is(n),
            !i.nextSibling())
                return s
    }
    for (; ; ) {
        if (r != null && i.type.is(r))
            return s;
        if (i.type.is(e) && s.push(i.node),
        !i.nextSibling())
            return r == null ? s : []
    }
}
function ry(t, e, n=e.length - 1) {
    for (let r = t.parent; n >= 0; r = r.parent) {
        if (!r)
            return !1;
        if (!r.type.isAnonymous) {
            if (e[n] && e[n] != r.name)
                return !1;
            n--
        }
    }
    return !0
}
class zfe {
    constructor(e, n, r, i) {
        this.parent = e,
        this.buffer = n,
        this.index = r,
        this.start = i
    }
}
class Ei extends fB {
    get name() {
        return this.type.name
    }
    get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1]
    }
    get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2]
    }
    constructor(e, n, r) {
        super(),
        this.context = e,
        this._parent = n,
        this.index = r,
        this.type = e.buffer.set.types[e.buffer.buffer[r]]
    }
    child(e, n, r) {
        let {buffer: i} = this.context
          , s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
        return s < 0 ? null : new Ei(this.context,this,s)
    }
    get firstChild() {
        return this.child(1, 0, 4)
    }
    get lastChild() {
        return this.child(-1, 0, 4)
    }
    childAfter(e) {
        return this.child(1, e, 2)
    }
    childBefore(e) {
        return this.child(-1, e, -2)
    }
    enter(e, n, r=0) {
        if (r & Bt.ExcludeBuffers)
            return null;
        let {buffer: i} = this.context
          , s = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
        return s < 0 ? null : new Ei(this.context,this,s)
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent()
    }
    externalSibling(e) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4)
    }
    get nextSibling() {
        let {buffer: e} = this.context
          , n = e.buffer[this.index + 3];
        return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ei(this.context,this._parent,n) : this.externalSibling(1)
    }
    get prevSibling() {
        let {buffer: e} = this.context
          , n = this._parent ? this._parent.index + 4 : 0;
        return this.index == n ? this.externalSibling(-1) : new Ei(this.context,this._parent,e.findChild(n, this.index, -1, 0, 4))
    }
    get tree() {
        return null
    }
    toTree() {
        let e = []
          , n = []
          , {buffer: r} = this.context
          , i = this.index + 4
          , s = r.buffer[this.index + 3];
        if (s > i) {
            let o = r.buffer[this.index + 1];
            e.push(r.slice(i, s, o)),
            n.push(0)
        }
        return new en(this.type,e,n,this.to - this.from)
    }
    toString() {
        return this.context.buffer.childString(this.index)
    }
}
function pB(t) {
    if (!t.length)
        return null;
    let e = 0
      , n = t[0];
    for (let s = 1; s < t.length; s++) {
        let o = t[s];
        (o.from > n.from || o.to < n.to) && (n = o,
        e = s)
    }
    let r = n instanceof Dn && n.index < 0 ? null : n.parent
      , i = t.slice();
    return r ? i[e] = r : i.splice(e, 1),
    new Wfe(i,n)
}
class Wfe {
    constructor(e, n) {
        this.heads = e,
        this.node = n
    }
    get next() {
        return pB(this.heads)
    }
}
function Gfe(t, e, n) {
    let r = t.resolveInner(e, n)
      , i = null;
    for (let s = r instanceof Dn ? r : r.context.parent; s; s = s.parent)
        if (s.index < 0) {
            let o = s.parent;
            (i || (i = [r])).push(o.resolve(e, n)),
            s = o
        } else {
            let o = Qu.get(s.tree);
            if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
                let a = new Dn(o.tree,o.overlay[0].from + s.from,-1,s);
                (i || (i = [r])).push(Ju(a, e, n, !1))
            }
        }
    return i ? pB(i) : r
}
class Up {
    get name() {
        return this.type.name
    }
    constructor(e, n=0) {
        if (this.mode = n,
        this.buffer = null,
        this.stack = [],
        this.index = 0,
        this.bufferNode = null,
        e instanceof Dn)
            this.yieldNode(e);
        else {
            this._tree = e.context.parent,
            this.buffer = e.context;
            for (let r = e._parent; r; r = r._parent)
                this.stack.unshift(r.index);
            this.bufferNode = e,
            this.yieldBuf(e.index)
        }
    }
    yieldNode(e) {
        return e ? (this._tree = e,
        this.type = e.type,
        this.from = e.from,
        this.to = e.to,
        !0) : !1
    }
    yieldBuf(e, n) {
        this.index = e;
        let {start: r, buffer: i} = this.buffer;
        return this.type = n || i.set.types[i.buffer[e]],
        this.from = r + i.buffer[e + 1],
        this.to = r + i.buffer[e + 2],
        !0
    }
    yield(e) {
        return e ? e instanceof Dn ? (this.buffer = null,
        this.yieldNode(e)) : (this.buffer = e.context,
        this.yieldBuf(e.index, e.type)) : !1
    }
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()
    }
    enterChild(e, n, r) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
        let {buffer: i} = this.buffer
          , s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
        return s < 0 ? !1 : (this.stack.push(this.index),
        this.yieldBuf(s))
    }
    firstChild() {
        return this.enterChild(1, 0, 4)
    }
    lastChild() {
        return this.enterChild(-1, 0, 4)
    }
    childAfter(e) {
        return this.enterChild(1, e, 2)
    }
    childBefore(e) {
        return this.enterChild(-1, e, -2)
    }
    enter(e, n, r=this.mode) {
        return this.buffer ? r & Bt.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r))
    }
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.mode & Bt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let e = this.mode & Bt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        return this.buffer = null,
        this.yieldNode(e)
    }
    sibling(e) {
        if (!this.buffer)
            return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
        let {buffer: n} = this.buffer
          , r = this.stack.length - 1;
        if (e < 0) {
            let i = r < 0 ? 0 : this.stack[r] + 4;
            if (this.index != i)
                return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4))
        } else {
            let i = n.buffer[this.index + 3];
            if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
                return this.yieldBuf(i)
        }
        return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1
    }
    nextSibling() {
        return this.sibling(1)
    }
    prevSibling() {
        return this.sibling(-1)
    }
    atLastNode(e) {
        let n, r, {buffer: i} = this;
        if (i) {
            if (e > 0) {
                if (this.index < i.buffer.buffer.length)
                    return !1
            } else
                for (let s = 0; s < this.index; s++)
                    if (i.buffer.buffer[s + 3] < this.index)
                        return !1;
            ({index: n, parent: r} = i)
        } else
            ({index: n, _parent: r} = this._tree);
        for (; r; {index: n, _parent: r} = r)
            if (n > -1)
                for (let s = n + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
                    let a = r._tree.children[s];
                    if (this.mode & Bt.IncludeAnonymous || a instanceof eo || !a.type.isAnonymous || ex(a))
                        return !1
                }
        return !0
    }
    move(e, n) {
        if (n && this.enterChild(e, 0, 4))
            return !0;
        for (; ; ) {
            if (this.sibling(e))
                return !0;
            if (this.atLastNode(e) || !this.parent())
                return !1
        }
    }
    next(e=!0) {
        return this.move(1, e)
    }
    prev(e=!0) {
        return this.move(-1, e)
    }
    moveTo(e, n=0) {
        for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
            ;
        for (; this.enterChild(1, e, n); )
            ;
        return this
    }
    get node() {
        if (!this.buffer)
            return this._tree;
        let e = this.bufferNode
          , n = null
          , r = 0;
        if (e && e.context == this.buffer)
            e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
                for (let o = e; o; o = o._parent)
                    if (o.index == i) {
                        if (i == this.index)
                            return o;
                        n = o,
                        r = s + 1;
                        break e
                    }
                i = this.stack[--s]
            }
        for (let i = r; i < this.stack.length; i++)
            n = new Ei(this.buffer,n,this.stack[i]);
        return this.bufferNode = new Ei(this.buffer,n,this.index)
    }
    get tree() {
        return this.buffer ? null : this._tree._tree
    }
    iterate(e, n) {
        for (let r = 0; ; ) {
            let i = !1;
            if (this.type.isAnonymous || e(this) !== !1) {
                if (this.firstChild()) {
                    r++;
                    continue
                }
                this.type.isAnonymous || (i = !0)
            }
            for (; i && n && n(this),
            i = this.type.isAnonymous,
            !this.nextSibling(); ) {
                if (!r)
                    return;
                this.parent(),
                r--,
                i = !0
            }
        }
    }
    matchContext(e) {
        if (!this.buffer)
            return ry(this.node, e);
        let {buffer: n} = this.buffer
          , {types: r} = n.set;
        for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
            if (s < 0)
                return ry(this.node, e, i);
            let o = r[n.buffer[this.stack[s]]];
            if (!o.isAnonymous) {
                if (e[i] && e[i] != o.name)
                    return !1;
                i--
            }
        }
        return !0
    }
}
function ex(t) {
    return t.children.some(e => e instanceof eo || !e.type.isAnonymous || ex(e))
}
function qfe(t) {
    var e;
    let {buffer: n, nodeSet: r, maxBufferLength: i=Ufe, reused: s=[], minRepeatType: o=r.types.length} = t
      , a = Array.isArray(n) ? new Z1(n,n.length) : n
      , l = r.types
      , c = 0
      , u = 0;
    function h(E, w, A, C, k, I) {
        let {id: N, start: O, end: M, size: H} = a
          , $ = u;
        for (; H < 0; )
            if (a.next(),
            H == -1) {
                let L = s[N];
                A.push(L),
                C.push(O - E);
                return
            } else if (H == -3) {
                c = N;
                return
            } else if (H == -4) {
                u = N;
                return
            } else
                throw new RangeError(`Unrecognized record size: ${H}`);
        let J = l[N], Q, ee, D = O - E;
        if (M - O <= i && (ee = m(a.pos - w, k))) {
            let L = new Uint16Array(ee.size - ee.skip)
              , z = a.pos - ee.size
              , V = L.length;
            for (; a.pos > z; )
                V = p(ee.start, L, V);
            Q = new eo(L,M - ee.start,r),
            D = ee.start - E
        } else {
            let L = a.pos - H;
            a.next();
            let z = []
              , V = []
              , B = N >= o ? N : -1
              , Z = 0
              , se = M;
            for (; a.pos > L; )
                B >= 0 && a.id == B && a.size >= 0 ? (a.end <= se - i && (g(z, V, O, Z, a.end, se, B, $),
                Z = z.length,
                se = a.end),
                a.next()) : I > 2500 ? d(O, L, z, V) : h(O, L, z, V, B, I + 1);
            if (B >= 0 && Z > 0 && Z < z.length && g(z, V, O, Z, O, se, B, $),
            z.reverse(),
            V.reverse(),
            B > -1 && Z > 0) {
                let ae = f(J);
                Q = tx(J, z, V, 0, z.length, 0, M - O, ae, ae)
            } else
                Q = _(J, z, V, M - O, $ - M)
        }
        A.push(Q),
        C.push(D)
    }
    function d(E, w, A, C) {
        let k = []
          , I = 0
          , N = -1;
        for (; a.pos > w; ) {
            let {id: O, start: M, end: H, size: $} = a;
            if ($ > 4)
                a.next();
            else {
                if (N > -1 && M < N)
                    break;
                N < 0 && (N = H - i),
                k.push(O, M, H),
                I++,
                a.next()
            }
        }
        if (I) {
            let O = new Uint16Array(I * 4)
              , M = k[k.length - 2];
            for (let H = k.length - 3, $ = 0; H >= 0; H -= 3)
                O[$++] = k[H],
                O[$++] = k[H + 1] - M,
                O[$++] = k[H + 2] - M,
                O[$++] = $;
            A.push(new eo(O,k[2] - M,r)),
            C.push(M - E)
        }
    }
    function f(E) {
        return (w, A, C) => {
            let k = 0, I = w.length - 1, N, O;
            if (I >= 0 && (N = w[I])instanceof en) {
                if (!I && N.type == E && N.length == C)
                    return N;
                (O = N.prop(ot.lookAhead)) && (k = A[I] + N.length + O)
            }
            return _(E, w, A, C, k)
        }
    }
    function g(E, w, A, C, k, I, N, O) {
        let M = []
          , H = [];
        for (; E.length > C; )
            M.push(E.pop()),
            H.push(w.pop() + A - k);
        E.push(_(r.types[N], M, H, I - k, O - I)),
        w.push(k - A)
    }
    function _(E, w, A, C, k=0, I) {
        if (c) {
            let N = [ot.contextHash, c];
            I = I ? [N].concat(I) : [N]
        }
        if (k > 25) {
            let N = [ot.lookAhead, k];
            I = I ? [N].concat(I) : [N]
        }
        return new en(E,w,A,C,I)
    }
    function m(E, w) {
        let A = a.fork()
          , C = 0
          , k = 0
          , I = 0
          , N = A.end - i
          , O = {
            size: 0,
            start: 0,
            skip: 0
        };
        e: for (let M = A.pos - E; A.pos > M; ) {
            let H = A.size;
            if (A.id == w && H >= 0) {
                O.size = C,
                O.start = k,
                O.skip = I,
                I += 4,
                C += 4,
                A.next();
                continue
            }
            let $ = A.pos - H;
            if (H < 0 || $ < M || A.start < N)
                break;
            let J = A.id >= o ? 4 : 0
              , Q = A.start;
            for (A.next(); A.pos > $; ) {
                if (A.size < 0)
                    if (A.size == -3)
                        J += 4;
                    else
                        break e;
                else
                    A.id >= o && (J += 4);
                A.next()
            }
            k = Q,
            C += H,
            I += J
        }
        return (w < 0 || C == E) && (O.size = C,
        O.start = k,
        O.skip = I),
        O.size > 4 ? O : void 0
    }
    function p(E, w, A) {
        let {id: C, start: k, end: I, size: N} = a;
        if (a.next(),
        N >= 0 && C < o) {
            let O = A;
            if (N > 4) {
                let M = a.pos - (N - 4);
                for (; a.pos > M; )
                    A = p(E, w, A)
            }
            w[--A] = O,
            w[--A] = I - E,
            w[--A] = k - E,
            w[--A] = C
        } else
            N == -3 ? c = C : N == -4 && (u = C);
        return A
    }
    let b = []
      , y = [];
    for (; a.pos > 0; )
        h(t.start || 0, t.bufferStart || 0, b, y, -1, 0);
    let x = (e = t.length) !== null && e !== void 0 ? e : b.length ? y[0] + b[0].length : 0;
    return new en(l[t.topID],b.reverse(),y.reverse(),x)
}
const JT = new WeakMap;
function Pf(t, e) {
    if (!t.isAnonymous || e instanceof eo || e.type != t)
        return 1;
    let n = JT.get(e);
    if (n == null) {
        n = 1;
        for (let r of e.children) {
            if (r.type != t || !(r instanceof en)) {
                n = 1;
                break
            }
            n += Pf(t, r)
        }
        JT.set(e, n)
    }
    return n
}
function tx(t, e, n, r, i, s, o, a, l) {
    let c = 0;
    for (let g = r; g < i; g++)
        c += Pf(t, e[g]);
    let u = Math.ceil(c * 1.5 / 8)
      , h = []
      , d = [];
    function f(g, _, m, p, b) {
        for (let y = m; y < p; ) {
            let x = y
              , E = _[y]
              , w = Pf(t, g[y]);
            for (y++; y < p; y++) {
                let A = Pf(t, g[y]);
                if (w + A >= u)
                    break;
                w += A
            }
            if (y == x + 1) {
                if (w > u) {
                    let A = g[x];
                    f(A.children, A.positions, 0, A.children.length, _[x] + b);
                    continue
                }
                h.push(g[x])
            } else {
                let A = _[y - 1] + g[y - 1].length - E;
                h.push(tx(t, g, _, x, y, E, A, null, l))
            }
            d.push(E + b - s)
        }
    }
    return f(e, n, r, i, 0),
    (a || l)(h, d, o)
}
class fve {
    constructor() {
        this.map = new WeakMap
    }
    setBuffer(e, n, r) {
        let i = this.map.get(e);
        i || this.map.set(e, i = new Map),
        i.set(n, r)
    }
    getBuffer(e, n) {
        let r = this.map.get(e);
        return r && r.get(n)
    }
    set(e, n) {
        e instanceof Ei ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Dn && this.map.set(e.tree, n)
    }
    get(e) {
        return e instanceof Ei ? this.getBuffer(e.context.buffer, e.index) : e instanceof Dn ? this.map.get(e.tree) : void 0
    }
    cursorSet(e, n) {
        e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n)
    }
    cursorGet(e) {
        return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree)
    }
}
class Zi {
    constructor(e, n, r, i, s=!1, o=!1) {
        this.from = e,
        this.to = n,
        this.tree = r,
        this.offset = i,
        this.open = (s ? 1 : 0) | (o ? 2 : 0)
    }
    get openStart() {
        return (this.open & 1) > 0
    }
    get openEnd() {
        return (this.open & 2) > 0
    }
    static addTree(e, n=[], r=!1) {
        let i = [new Zi(0,e.length,e,0,!1,r)];
        for (let s of n)
            s.to > e.length && i.push(s);
        return i
    }
    static applyChanges(e, n, r=128) {
        if (!n.length)
            return e;
        let i = []
          , s = 1
          , o = e.length ? e[0] : null;
        for (let a = 0, l = 0, c = 0; ; a++) {
            let u = a < n.length ? n[a] : null
              , h = u ? u.fromA : 1e9;
            if (h - l >= r)
                for (; o && o.from < h; ) {
                    let d = o;
                    if (l >= d.from || h <= d.to || c) {
                        let f = Math.max(d.from, l) - c
                          , g = Math.min(d.to, h) - c;
                        d = f >= g ? null : new Zi(f,g,d.tree,d.offset + c,a > 0,!!u)
                    }
                    if (d && i.push(d),
                    o.to > h)
                        break;
                    o = s < e.length ? e[s++] : null
                }
            if (!u)
                break;
            l = u.toA,
            c = u.toA - u.toB
        }
        return i
    }
}
class Kfe {
    startParse(e, n, r) {
        return typeof e == "string" && (e = new Yfe(e)),
        r = r ? r.length ? r.map(i => new Ar(i.from,i.to)) : [new Ar(0,0)] : [new Ar(0,e.length)],
        this.createParse(e, n || [], r)
    }
    parse(e, n, r) {
        let i = this.startParse(e, n, r);
        for (; ; ) {
            let s = i.advance();
            if (s)
                return s
        }
    }
}
class Yfe {
    constructor(e) {
        this.string = e
    }
    get length() {
        return this.string.length
    }
    chunk(e) {
        return this.string.slice(e)
    }
    get lineChunks() {
        return !1
    }
    read(e, n) {
        return this.string.slice(e, n)
    }
}
function pve(t) {
    return (e, n, r, i) => new Qfe(e,t,n,r,i)
}
class ZT {
    constructor(e, n, r, i, s) {
        this.parser = e,
        this.parse = n,
        this.overlay = r,
        this.target = i,
        this.from = s
    }
}
function eA(t) {
    if (!t.length || t.some(e => e.from >= e.to))
        throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t))
}
class Xfe {
    constructor(e, n, r, i, s, o, a) {
        this.parser = e,
        this.predicate = n,
        this.mounts = r,
        this.index = i,
        this.start = s,
        this.target = o,
        this.prev = a,
        this.depth = 0,
        this.ranges = []
    }
}
const iy = new ot({
    perNode: !0
});
class Qfe {
    constructor(e, n, r, i, s) {
        this.nest = n,
        this.input = r,
        this.fragments = i,
        this.ranges = s,
        this.inner = [],
        this.innerDone = 0,
        this.baseTree = null,
        this.stoppedAt = null,
        this.baseParse = e
    }
    advance() {
        if (this.baseParse) {
            let r = this.baseParse.advance();
            if (!r)
                return null;
            if (this.baseParse = null,
            this.baseTree = r,
            this.startInner(),
            this.stoppedAt != null)
                for (let i of this.inner)
                    i.parse.stopAt(this.stoppedAt)
        }
        if (this.innerDone == this.inner.length) {
            let r = this.baseTree;
            return this.stoppedAt != null && (r = new en(r.type,r.children,r.positions,r.length,r.propValues.concat([[iy, this.stoppedAt]]))),
            r
        }
        let e = this.inner[this.innerDone]
          , n = e.parse.advance();
        if (n) {
            this.innerDone++;
            let r = Object.assign(Object.create(null), e.target.props);
            r[ot.mounted.id] = new Qu(n,e.overlay,e.parser),
            e.target.props = r
        }
        return null
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let e = this.input.length;
        for (let n = this.innerDone; n < this.inner.length; n++)
            this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
        return e
    }
    stopAt(e) {
        if (this.stoppedAt = e,
        this.baseParse)
            this.baseParse.stopAt(e);
        else
            for (let n = this.innerDone; n < this.inner.length; n++)
                this.inner[n].parse.stopAt(e)
    }
    startInner() {
        let e = new epe(this.fragments)
          , n = null
          , r = null
          , i = new Up(new Dn(this.baseTree,this.ranges[0].from,0,null),Bt.IncludeAnonymous | Bt.IgnoreMounts);
        e: for (let s, o; ; ) {
            let a = !0, l;
            if (this.stoppedAt != null && i.from >= this.stoppedAt)
                a = !1;
            else if (e.hasNode(i)) {
                if (n) {
                    let c = n.mounts.find(u => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
                    if (c)
                        for (let u of c.mount.overlay) {
                            let h = u.from + c.pos
                              , d = u.to + c.pos;
                            h >= i.from && d <= i.to && !n.ranges.some(f => f.from < d && f.to > h) && n.ranges.push({
                                from: h,
                                to: d
                            })
                        }
                }
                a = !1
            } else if (r && (o = Jfe(r.ranges, i.from, i.to)))
                a = o != 2;
            else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
                i.tree || Zfe(i);
                let c = e.findMounts(i.from, s.parser);
                if (typeof s.overlay == "function")
                    n = new Xfe(s.parser,s.overlay,c,this.inner.length,i.from,i.tree,n);
                else {
                    let u = rA(this.ranges, s.overlay || (i.from < i.to ? [new Ar(i.from,i.to)] : []));
                    u.length && eA(u),
                    (u.length || !s.overlay) && this.inner.push(new ZT(s.parser,u.length ? s.parser.startParse(this.input, iA(c, u), u) : s.parser.startParse(""),s.overlay ? s.overlay.map(h => new Ar(h.from - i.from,h.to - i.from)) : null,i.tree,u.length ? u[0].from : i.from)),
                    s.overlay ? u.length && (r = {
                        ranges: u,
                        depth: 0,
                        prev: r
                    }) : a = !1
                }
            } else
                n && (l = n.predicate(i)) && (l === !0 && (l = new Ar(i.from,i.to)),
                l.from < l.to && n.ranges.push(l));
            if (a && i.firstChild())
                n && n.depth++,
                r && r.depth++;
            else
                for (; !i.nextSibling(); ) {
                    if (!i.parent())
                        break e;
                    if (n && !--n.depth) {
                        let c = rA(this.ranges, n.ranges);
                        c.length && (eA(c),
                        this.inner.splice(n.index, 0, new ZT(n.parser,n.parser.startParse(this.input, iA(n.mounts, c), c),n.ranges.map(u => new Ar(u.from - n.start,u.to - n.start)),n.target,c[0].from))),
                        n = n.prev
                    }
                    r && !--r.depth && (r = r.prev)
                }
        }
    }
}
function Jfe(t, e, n) {
    for (let r of t) {
        if (r.from >= n)
            break;
        if (r.to > e)
            return r.from <= e && r.to >= n ? 2 : 1
    }
    return 0
}
function tA(t, e, n, r, i, s) {
    if (e < n) {
        let o = t.buffer[e + 1];
        r.push(t.slice(e, n, o)),
        i.push(o - s)
    }
}
function Zfe(t) {
    let {node: e} = t
      , n = []
      , r = e.context.buffer;
    do
        n.push(t.index),
        t.parent();
    while (!t.tree);
    let i = t.tree
      , s = i.children.indexOf(r)
      , o = i.children[s]
      , a = o.buffer
      , l = [s];
    function c(u, h, d, f, g, _) {
        let m = n[_]
          , p = []
          , b = [];
        tA(o, u, m, p, b, f);
        let y = a[m + 1]
          , x = a[m + 2];
        l.push(p.length);
        let E = _ ? c(m + 4, a[m + 3], o.set.types[a[m]], y, x - y, _ - 1) : e.toTree();
        return p.push(E),
        b.push(y - f),
        tA(o, a[m + 3], h, p, b, f),
        new en(d,p,b,g)
    }
    i.children[s] = c(0, a.length, tr.none, 0, o.length, n.length - 1);
    for (let u of l) {
        let h = t.tree.children[u]
          , d = t.tree.positions[u];
        t.yield(new Dn(h,d + t.from,u,t._tree))
    }
}
class nA {
    constructor(e, n) {
        this.offset = n,
        this.done = !1,
        this.cursor = e.cursor(Bt.IncludeAnonymous | Bt.IgnoreMounts)
    }
    moveTo(e) {
        let {cursor: n} = this
          , r = e - this.offset;
        for (; !this.done && n.from < r; )
            n.to >= e && n.enter(r, 1, Bt.IgnoreOverlays | Bt.ExcludeBuffers) || n.next(!1) || (this.done = !0)
    }
    hasNode(e) {
        if (this.moveTo(e.from),
        !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
            for (let n = this.cursor.tree; ; ) {
                if (n == e.tree)
                    return !0;
                if (n.children.length && n.positions[0] == 0 && n.children[0]instanceof en)
                    n = n.children[0];
                else
                    break
            }
        return !1
    }
}
class epe {
    constructor(e) {
        var n;
        if (this.fragments = e,
        this.curTo = 0,
        this.fragI = 0,
        e.length) {
            let r = this.curFrag = e[0];
            this.curTo = (n = r.tree.prop(iy)) !== null && n !== void 0 ? n : r.to,
            this.inner = new nA(r.tree,-r.offset)
        } else
            this.curFrag = this.inner = null
    }
    hasNode(e) {
        for (; this.curFrag && e.from >= this.curTo; )
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e)
    }
    nextFrag() {
        var e;
        if (this.fragI++,
        this.fragI == this.fragments.length)
            this.curFrag = this.inner = null;
        else {
            let n = this.curFrag = this.fragments[this.fragI];
            this.curTo = (e = n.tree.prop(iy)) !== null && e !== void 0 ? e : n.to,
            this.inner = new nA(n.tree,-n.offset)
        }
    }
    findMounts(e, n) {
        var r;
        let i = [];
        if (this.inner) {
            this.inner.cursor.moveTo(e, 1);
            for (let s = this.inner.cursor.node; s; s = s.parent) {
                let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(ot.mounted);
                if (o && o.parser == n)
                    for (let a = this.fragI; a < this.fragments.length; a++) {
                        let l = this.fragments[a];
                        if (l.from >= s.to)
                            break;
                        l.tree == this.curFrag.tree && i.push({
                            frag: l,
                            pos: s.from - l.offset,
                            mount: o
                        })
                    }
            }
        }
        return i
    }
}
function rA(t, e) {
    let n = null
      , r = e;
    for (let i = 1, s = 0; i < t.length; i++) {
        let o = t[i - 1].to
          , a = t[i].from;
        for (; s < r.length; s++) {
            let l = r[s];
            if (l.from >= a)
                break;
            l.to <= o || (n || (r = n = e.slice()),
            l.from < o ? (n[s] = new Ar(l.from,o),
            l.to > a && n.splice(s + 1, 0, new Ar(a,l.to))) : l.to > a ? n[s--] = new Ar(a,l.to) : n.splice(s--, 1))
        }
    }
    return r
}
function tpe(t, e, n, r) {
    let i = 0
      , s = 0
      , o = !1
      , a = !1
      , l = -1e9
      , c = [];
    for (; ; ) {
        let u = i == t.length ? 1e9 : o ? t[i].to : t[i].from
          , h = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
        if (o != a) {
            let d = Math.max(l, n)
              , f = Math.min(u, h, r);
            d < f && c.push(new Ar(d,f))
        }
        if (l = Math.min(u, h),
        l == 1e9)
            break;
        u == l && (o ? (o = !1,
        i++) : o = !0),
        h == l && (a ? (a = !1,
        s++) : a = !0)
    }
    return c
}
function iA(t, e) {
    let n = [];
    for (let {pos: r, mount: i, frag: s} of t) {
        let o = r + (i.overlay ? i.overlay[0].from : 0)
          , a = o + i.tree.length
          , l = Math.max(s.from, o)
          , c = Math.min(s.to, a);
        if (i.overlay) {
            let u = i.overlay.map(d => new Ar(d.from + r,d.to + r))
              , h = tpe(e, u, l, c);
            for (let d = 0, f = l; ; d++) {
                let g = d == h.length
                  , _ = g ? c : h[d].from;
                if (_ > f && n.push(new Zi(f,_,i.tree,-o,s.from >= f || s.openStart,s.to <= _ || s.openEnd)),
                g)
                    break;
                f = h[d].to
            }
        } else
            n.push(new Zi(l,c,i.tree,-o,s.from >= o || s.openStart,s.to <= a || s.openEnd))
    }
    return n
}
let npe = 0;
class mi {
    constructor(e, n, r) {
        this.set = e,
        this.base = n,
        this.modified = r,
        this.id = npe++
    }
    static define(e) {
        if (e?.base)
            throw new Error("Can not derive from a modified tag");
        let n = new mi([],null,[]);
        if (n.set.push(n),
        e)
            for (let r of e.set)
                n.set.push(r);
        return n
    }
    static defineModifier() {
        let e = new Vp;
        return n => n.modified.indexOf(e) > -1 ? n : Vp.get(n.base || n, n.modified.concat(e).sort( (r, i) => r.id - i.id))
    }
}
let rpe = 0;
class Vp {
    constructor() {
        this.instances = [],
        this.id = rpe++
    }
    static get(e, n) {
        if (!n.length)
            return e;
        let r = n[0].instances.find(a => a.base == e && ipe(n, a.modified));
        if (r)
            return r;
        let i = []
          , s = new mi(i,e,n);
        for (let a of n)
            a.instances.push(s);
        let o = spe(n);
        for (let a of e.set)
            if (!a.modified.length)
                for (let l of o)
                    i.push(Vp.get(a, l));
        return s
    }
}
function ipe(t, e) {
    return t.length == e.length && t.every( (n, r) => n == e[r])
}
function spe(t) {
    let e = [[]];
    for (let n = 0; n < t.length; n++)
        for (let r = 0, i = e.length; r < i; r++)
            e.push(e[r].concat(t[n]));
    return e.sort( (n, r) => r.length - n.length)
}
function ope(t) {
    let e = Object.create(null);
    for (let n in t) {
        let r = t[n];
        Array.isArray(r) || (r = [r]);
        for (let i of n.split(" "))
            if (i) {
                let s = []
                  , o = 2
                  , a = i;
                for (let h = 0; ; ) {
                    if (a == "..." && h > 0 && h + 3 == i.length) {
                        o = 1;
                        break
                    }
                    let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
                    if (!d)
                        throw new RangeError("Invalid path: " + i);
                    if (s.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]),
                    h += d[0].length,
                    h == i.length)
                        break;
                    let f = i[h++];
                    if (h == i.length && f == "!") {
                        o = 0;
                        break
                    }
                    if (f != "/")
                        throw new RangeError("Invalid path: " + i);
                    a = i.slice(h)
                }
                let l = s.length - 1
                  , c = s[l];
                if (!c)
                    throw new RangeError("Invalid path: " + i);
                let u = new $p(r,o,l > 0 ? s.slice(0, l) : null);
                e[c] = u.sort(e[c])
            }
    }
    return mB.add(e)
}
const mB = new ot;
class $p {
    constructor(e, n, r, i) {
        this.tags = e,
        this.mode = n,
        this.context = r,
        this.next = i
    }
    get opaque() {
        return this.mode == 0
    }
    get inherit() {
        return this.mode == 1
    }
    sort(e) {
        return !e || e.depth < this.depth ? (this.next = e,
        this) : (e.next = this.sort(e.next),
        e)
    }
    get depth() {
        return this.context ? this.context.length : 0
    }
}
$p.empty = new $p([],2,null);
function gB(t, e) {
    let n = Object.create(null);
    for (let s of t)
        if (!Array.isArray(s.tag))
            n[s.tag.id] = s.class;
        else
            for (let o of s.tag)
                n[o.id] = s.class;
    let {scope: r, all: i=null} = e || {};
    return {
        style: s => {
            let o = i;
            for (let a of s)
                for (let l of a.set) {
                    let c = n[l.id];
                    if (c) {
                        o = o ? o + " " + c : c;
                        break
                    }
                }
            return o
        }
        ,
        scope: r
    }
}
function ape(t, e) {
    let n = null;
    for (let r of t) {
        let i = r.style(e);
        i && (n = n ? n + " " + i : i)
    }
    return n
}
function lpe(t, e, n, r=0, i=t.length) {
    let s = new cpe(r,Array.isArray(e) ? e : [e],n);
    s.highlightRange(t.cursor(), r, i, "", s.highlighters),
    s.flush(i)
}
class cpe {
    constructor(e, n, r) {
        this.at = e,
        this.highlighters = n,
        this.span = r,
        this.class = ""
    }
    startSpan(e, n) {
        n != this.class && (this.flush(e),
        e > this.at && (this.at = e),
        this.class = n)
    }
    flush(e) {
        e > this.at && this.class && this.span(this.at, e, this.class)
    }
    highlightRange(e, n, r, i, s) {
        let {type: o, from: a, to: l} = e;
        if (a >= r || l <= n)
            return;
        o.isTop && (s = this.highlighters.filter(f => !f.scope || f.scope(o)));
        let c = i
          , u = upe(e) || $p.empty
          , h = ape(s, u.tags);
        if (h && (c && (c += " "),
        c += h,
        u.mode == 1 && (i += (i ? " " : "") + h)),
        this.startSpan(Math.max(n, a), c),
        u.opaque)
            return;
        let d = e.tree && e.tree.prop(ot.mounted);
        if (d && d.overlay) {
            let f = e.node.enter(d.overlay[0].from + a, 1)
              , g = this.highlighters.filter(m => !m.scope || m.scope(d.tree.type))
              , _ = e.firstChild();
            for (let m = 0, p = a; ; m++) {
                let b = m < d.overlay.length ? d.overlay[m] : null
                  , y = b ? b.from + a : l
                  , x = Math.max(n, p)
                  , E = Math.min(r, y);
                if (x < E && _)
                    for (; e.from < E && (this.highlightRange(e, x, E, i, s),
                    this.startSpan(Math.min(E, e.to), c),
                    !(e.to >= y || !e.nextSibling())); )
                        ;
                if (!b || y > r)
                    break;
                p = b.to + a,
                p > n && (this.highlightRange(f.cursor(), Math.max(n, b.from + a), Math.min(r, p), "", g),
                this.startSpan(Math.min(r, p), c))
            }
            _ && e.parent()
        } else if (e.firstChild()) {
            d && (i = "");
            do
                if (!(e.to <= n)) {
                    if (e.from >= r)
                        break;
                    this.highlightRange(e, n, r, i, s),
                    this.startSpan(Math.min(r, e.to), c)
                }
            while (e.nextSibling());
            e.parent()
        }
    }
}
function upe(t) {
    let e = t.type.prop(mB);
    for (; e && e.context && !t.matchContext(e.context); )
        e = e.next;
    return e || null
}
const Ae = mi.define
  , Xd = Ae()
  , Ss = Ae()
  , sA = Ae(Ss)
  , oA = Ae(Ss)
  , ws = Ae()
  , Qd = Ae(ws)
  , U0 = Ae(ws)
  , di = Ae()
  , bo = Ae(di)
  , ci = Ae()
  , ui = Ae()
  , sy = Ae()
  , gc = Ae(sy)
  , Jd = Ae()
  , te = {
    comment: Xd,
    lineComment: Ae(Xd),
    blockComment: Ae(Xd),
    docComment: Ae(Xd),
    name: Ss,
    variableName: Ae(Ss),
    typeName: sA,
    tagName: Ae(sA),
    propertyName: oA,
    attributeName: Ae(oA),
    className: Ae(Ss),
    labelName: Ae(Ss),
    namespace: Ae(Ss),
    macroName: Ae(Ss),
    literal: ws,
    string: Qd,
    docString: Ae(Qd),
    character: Ae(Qd),
    attributeValue: Ae(Qd),
    number: U0,
    integer: Ae(U0),
    float: Ae(U0),
    bool: Ae(ws),
    regexp: Ae(ws),
    escape: Ae(ws),
    color: Ae(ws),
    url: Ae(ws),
    keyword: ci,
    self: Ae(ci),
    null: Ae(ci),
    atom: Ae(ci),
    unit: Ae(ci),
    modifier: Ae(ci),
    operatorKeyword: Ae(ci),
    controlKeyword: Ae(ci),
    definitionKeyword: Ae(ci),
    moduleKeyword: Ae(ci),
    operator: ui,
    derefOperator: Ae(ui),
    arithmeticOperator: Ae(ui),
    logicOperator: Ae(ui),
    bitwiseOperator: Ae(ui),
    compareOperator: Ae(ui),
    updateOperator: Ae(ui),
    definitionOperator: Ae(ui),
    typeOperator: Ae(ui),
    controlOperator: Ae(ui),
    punctuation: sy,
    separator: Ae(sy),
    bracket: gc,
    angleBracket: Ae(gc),
    squareBracket: Ae(gc),
    paren: Ae(gc),
    brace: Ae(gc),
    content: di,
    heading: bo,
    heading1: Ae(bo),
    heading2: Ae(bo),
    heading3: Ae(bo),
    heading4: Ae(bo),
    heading5: Ae(bo),
    heading6: Ae(bo),
    contentSeparator: Ae(di),
    list: Ae(di),
    quote: Ae(di),
    emphasis: Ae(di),
    strong: Ae(di),
    link: Ae(di),
    monospace: Ae(di),
    strikethrough: Ae(di),
    inserted: Ae(),
    deleted: Ae(),
    changed: Ae(),
    invalid: Ae(),
    meta: Jd,
    documentMeta: Ae(Jd),
    annotation: Ae(Jd),
    processingInstruction: Ae(Jd),
    definition: mi.defineModifier(),
    constant: mi.defineModifier(),
    function: mi.defineModifier(),
    standard: mi.defineModifier(),
    local: mi.defineModifier(),
    special: mi.defineModifier()
};
gB([{
    tag: te.link,
    class: "tok-link"
}, {
    tag: te.heading,
    class: "tok-heading"
}, {
    tag: te.emphasis,
    class: "tok-emphasis"
}, {
    tag: te.strong,
    class: "tok-strong"
}, {
    tag: te.keyword,
    class: "tok-keyword"
}, {
    tag: te.atom,
    class: "tok-atom"
}, {
    tag: te.bool,
    class: "tok-bool"
}, {
    tag: te.url,
    class: "tok-url"
}, {
    tag: te.labelName,
    class: "tok-labelName"
}, {
    tag: te.inserted,
    class: "tok-inserted"
}, {
    tag: te.deleted,
    class: "tok-deleted"
}, {
    tag: te.literal,
    class: "tok-literal"
}, {
    tag: te.string,
    class: "tok-string"
}, {
    tag: te.number,
    class: "tok-number"
}, {
    tag: [te.regexp, te.escape, te.special(te.string)],
    class: "tok-string2"
}, {
    tag: te.variableName,
    class: "tok-variableName"
}, {
    tag: te.local(te.variableName),
    class: "tok-variableName tok-local"
}, {
    tag: te.definition(te.variableName),
    class: "tok-variableName tok-definition"
}, {
    tag: te.special(te.variableName),
    class: "tok-variableName2"
}, {
    tag: te.definition(te.propertyName),
    class: "tok-propertyName tok-definition"
}, {
    tag: te.typeName,
    class: "tok-typeName"
}, {
    tag: te.namespace,
    class: "tok-namespace"
}, {
    tag: te.className,
    class: "tok-className"
}, {
    tag: te.macroName,
    class: "tok-macroName"
}, {
    tag: te.propertyName,
    class: "tok-propertyName"
}, {
    tag: te.operator,
    class: "tok-operator"
}, {
    tag: te.comment,
    class: "tok-comment"
}, {
    tag: te.meta,
    class: "tok-meta"
}, {
    tag: te.invalid,
    class: "tok-invalid"
}, {
    tag: te.punctuation,
    class: "tok-punctuation"
}]);
var V0;
const rl = new ot;
function hpe(t) {
    return Me.define({
        combine: t ? e => e.concat(t) : void 0
    })
}
const dpe = new ot;
class Kr {
    constructor(e, n, r=[], i="") {
        this.data = e,
        this.name = i,
        lt.prototype.hasOwnProperty("tree") || Object.defineProperty(lt.prototype, "tree", {
            get() {
                return En(this)
            }
        }),
        this.parser = n,
        this.extension = [to.of(this), lt.languageData.of( (s, o, a) => {
            let l = aA(s, o, a)
              , c = l.type.prop(rl);
            if (!c)
                return [];
            let u = s.facet(c)
              , h = l.type.prop(dpe);
            if (h) {
                let d = l.resolve(o - l.from, a);
                for (let f of h)
                    if (f.test(d, s)) {
                        let g = s.facet(f.facet);
                        return f.type == "replace" ? g : g.concat(u)
                    }
            }
            return u
        }
        )].concat(r)
    }
    isActiveAt(e, n, r=-1) {
        return aA(e, n, r).type.prop(rl) == this.data
    }
    findRegions(e) {
        let n = e.facet(to);
        if (n?.data == this.data)
            return [{
                from: 0,
                to: e.doc.length
            }];
        if (!n || !n.allowsNesting)
            return [];
        let r = []
          , i = (s, o) => {
            if (s.prop(rl) == this.data) {
                r.push({
                    from: o,
                    to: o + s.length
                });
                return
            }
            let a = s.prop(ot.mounted);
            if (a) {
                if (a.tree.prop(rl) == this.data) {
                    if (a.overlay)
                        for (let l of a.overlay)
                            r.push({
                                from: l.from + o,
                                to: l.to + o
                            });
                    else
                        r.push({
                            from: o,
                            to: o + s.length
                        });
                    return
                } else if (a.overlay) {
                    let l = r.length;
                    if (i(a.tree, a.overlay[0].from + o),
                    r.length > l)
                        return
                }
            }
            for (let l = 0; l < s.children.length; l++) {
                let c = s.children[l];
                c instanceof en && i(c, s.positions[l] + o)
            }
        }
        ;
        return i(En(e), 0),
        r
    }
    get allowsNesting() {
        return !0
    }
}
Kr.setState = Je.define();
function aA(t, e, n) {
    let r = t.facet(to)
      , i = En(t).topNode;
    if (!r || r.allowsNesting)
        for (let s = i; s; s = s.enter(e, n, Bt.ExcludeBuffers))
            s.type.isTop && (i = s);
    return i
}
class oy extends Kr {
    constructor(e, n, r) {
        super(e, n, [], r),
        this.parser = n
    }
    static define(e) {
        let n = hpe(e.languageData);
        return new oy(n,e.parser.configure({
            props: [rl.add(r => r.isTop ? n : void 0)]
        }),e.name)
    }
    configure(e, n) {
        return new oy(this.data,this.parser.configure(e),n || this.name)
    }
    get allowsNesting() {
        return this.parser.hasWrappers()
    }
}
function En(t) {
    let e = t.field(Kr.state, !1);
    return e ? e.tree : en.empty
}
class fpe {
    constructor(e) {
        this.doc = e,
        this.cursorPos = 0,
        this.string = "",
        this.cursor = e.iter()
    }
    get length() {
        return this.doc.length
    }
    syncTo(e) {
        return this.string = this.cursor.next(e - this.cursorPos).value,
        this.cursorPos = e + this.string.length,
        this.cursorPos - this.string.length
    }
    chunk(e) {
        return this.syncTo(e),
        this.string
    }
    get lineChunks() {
        return !0
    }
    read(e, n) {
        let r = this.cursorPos - this.string.length;
        return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r)
    }
}
let _c = null;
class zp {
    constructor(e, n, r=[], i, s, o, a, l) {
        this.parser = e,
        this.state = n,
        this.fragments = r,
        this.tree = i,
        this.treeLen = s,
        this.viewport = o,
        this.skipped = a,
        this.scheduleOn = l,
        this.parse = null,
        this.tempSkipped = []
    }
    static create(e, n, r) {
        return new zp(e,n,[],en.empty,0,r,[],null)
    }
    startParse() {
        return this.parser.startParse(new fpe(this.state.doc), this.fragments)
    }
    work(e, n) {
        return n != null && n >= this.state.doc.length && (n = void 0),
        this.tree != en.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(),
        !0) : this.withContext( () => {
            var r;
            if (typeof e == "number") {
                let i = Date.now() + e;
                e = () => Date.now() > i
            }
            for (this.parse || (this.parse = this.startParse()),
            n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
                let i = this.parse.advance();
                if (i)
                    if (this.fragments = this.withoutTempSkipped(Zi.addTree(i, this.fragments, this.parse.stoppedAt != null)),
                    this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length,
                    this.tree = i,
                    this.parse = null,
                    this.treeLen < (n ?? this.state.doc.length))
                        this.parse = this.startParse();
                    else
                        return !0;
                if (e())
                    return !1
            }
        }
        )
    }
    takeTree() {
        let e, n;
        this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e),
        this.withContext( () => {
            for (; !(n = this.parse.advance()); )
                ;
        }
        ),
        this.treeLen = e,
        this.tree = n,
        this.fragments = this.withoutTempSkipped(Zi.addTree(this.tree, this.fragments, !0)),
        this.parse = null)
    }
    withContext(e) {
        let n = _c;
        _c = this;
        try {
            return e()
        } finally {
            _c = n
        }
    }
    withoutTempSkipped(e) {
        for (let n; n = this.tempSkipped.pop(); )
            e = lA(e, n.from, n.to);
        return e
    }
    changes(e, n) {
        let {fragments: r, tree: i, treeLen: s, viewport: o, skipped: a} = this;
        if (this.takeTree(),
        !e.empty) {
            let l = [];
            if (e.iterChangedRanges( (c, u, h, d) => l.push({
                fromA: c,
                toA: u,
                fromB: h,
                toB: d
            })),
            r = Zi.applyChanges(r, l),
            i = en.empty,
            s = 0,
            o = {
                from: e.mapPos(o.from, -1),
                to: e.mapPos(o.to, 1)
            },
            this.skipped.length) {
                a = [];
                for (let c of this.skipped) {
                    let u = e.mapPos(c.from, 1)
                      , h = e.mapPos(c.to, -1);
                    u < h && a.push({
                        from: u,
                        to: h
                    })
                }
            }
        }
        return new zp(this.parser,n,r,i,s,o,a,this.scheduleOn)
    }
    updateViewport(e) {
        if (this.viewport.from == e.from && this.viewport.to == e.to)
            return !1;
        this.viewport = e;
        let n = this.skipped.length;
        for (let r = 0; r < this.skipped.length; r++) {
            let {from: i, to: s} = this.skipped[r];
            i < e.to && s > e.from && (this.fragments = lA(this.fragments, i, s),
            this.skipped.splice(r--, 1))
        }
        return this.skipped.length >= n ? !1 : (this.reset(),
        !0)
    }
    reset() {
        this.parse && (this.takeTree(),
        this.parse = null)
    }
    skipUntilInView(e, n) {
        this.skipped.push({
            from: e,
            to: n
        })
    }
    static getSkippingParser(e) {
        return new class extends Kfe {
            createParse(n, r, i) {
                let s = i[0].from
                  , o = i[i.length - 1].to;
                return {
                    parsedPos: s,
                    advance() {
                        let l = _c;
                        if (l) {
                            for (let c of i)
                                l.tempSkipped.push(c);
                            e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e)
                        }
                        return this.parsedPos = o,
                        new en(tr.none,[],[],o - s)
                    },
                    stoppedAt: null,
                    stopAt() {}
                }
            }
        }
    }
    isDone(e) {
        e = Math.min(e, this.state.doc.length);
        let n = this.fragments;
        return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e
    }
    static get() {
        return _c
    }
}
function lA(t, e, n) {
    return Zi.applyChanges(t, [{
        fromA: e,
        toA: n,
        fromB: e,
        toB: n
    }])
}
class Ml {
    constructor(e) {
        this.context = e,
        this.tree = e.tree
    }
    apply(e) {
        if (!e.docChanged && this.tree == this.context.tree)
            return this;
        let n = this.context.changes(e.changes, e.state)
          , r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
        return n.work(20, r) || n.takeTree(),
        new Ml(n)
    }
    static init(e) {
        let n = Math.min(3e3, e.doc.length)
          , r = zp.create(e.facet(to).parser, e, {
            from: 0,
            to: n
        });
        return r.work(20, n) || r.takeTree(),
        new Ml(r)
    }
}
Kr.state = Qt.define({
    create: Ml.init,
    update(t, e) {
        for (let n of e.effects)
            if (n.is(Kr.setState))
                return n.value;
        return e.startState.facet(to) != e.state.facet(to) ? Ml.init(e.state) : t.apply(e)
    }
});
let _B = t => {
    let e = setTimeout( () => t(), 500);
    return () => clearTimeout(e)
}
;
typeof requestIdleCallback < "u" && (_B = t => {
    let e = -1
      , n = setTimeout( () => {
        e = requestIdleCallback(t, {
            timeout: 400
        })
    }
    , 100);
    return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e)
}
);
const $0 = typeof navigator < "u" && (!((V0 = navigator.scheduling) === null || V0 === void 0) && V0.isInputPending) ? () => navigator.scheduling.isInputPending() : null
  , ppe = xn.fromClass(class {
    constructor(e) {
        this.view = e,
        this.working = null,
        this.workScheduled = 0,
        this.chunkEnd = -1,
        this.chunkBudget = -1,
        this.work = this.work.bind(this),
        this.scheduleWork()
    }
    update(e) {
        let n = this.view.state.field(Kr.state).context;
        (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(),
        (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50),
        this.scheduleWork()),
        this.checkAsyncSchedule(n)
    }
    scheduleWork() {
        if (this.working)
            return;
        let {state: e} = this.view
          , n = e.field(Kr.state);
        (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = _B(this.work))
    }
    work(e) {
        this.working = null;
        let n = Date.now();
        if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4,
        this.chunkBudget = 3e3),
        this.chunkBudget <= 0)
            return;
        let {state: r, viewport: {to: i}} = this.view
          , s = r.field(Kr.state);
        if (s.tree == s.context.tree && s.context.isDone(i + 1e5))
            return;
        let o = Date.now() + Math.min(this.chunkBudget, 100, e && !$0 ? Math.max(25, e.timeRemaining() - 5) : 1e9)
          , a = s.context.treeLen < i && r.doc.length > i + 1e3
          , l = s.context.work( () => $0 && $0() || Date.now() > o, i + (a ? 0 : 1e5));
        this.chunkBudget -= Date.now() - n,
        (l || this.chunkBudget <= 0) && (s.context.takeTree(),
        this.view.dispatch({
            effects: Kr.setState.of(new Ml(s.context))
        })),
        this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(),
        this.checkAsyncSchedule(s.context)
    }
    checkAsyncSchedule(e) {
        e.scheduleOn && (this.workScheduled++,
        e.scheduleOn.then( () => this.scheduleWork()).catch(n => fr(this.view.state, n)).then( () => this.workScheduled--),
        e.scheduleOn = null)
    }
    destroy() {
        this.working && this.working()
    }
    isWorking() {
        return !!(this.working || this.workScheduled > 0)
    }
}
, {
    eventHandlers: {
        focus() {
            this.scheduleWork()
        }
    }
})
  , to = Me.define({
    combine(t) {
        return t.length ? t[0] : null
    },
    enables: t => [Kr.state, ppe, Oe.contentAttributes.compute([t], e => {
        let n = e.facet(t);
        return n && n.name ? {
            "data-language": n.name
        } : {}
    }
    )]
});
class gve {
    constructor(e, n=[]) {
        this.language = e,
        this.support = n,
        this.extension = [e, n]
    }
}
class on {
    constructor(e, n, r, i, s, o=void 0) {
        this.name = e,
        this.alias = n,
        this.extensions = r,
        this.filename = i,
        this.loadFunc = s,
        this.support = o,
        this.loading = null
    }
    load() {
        return this.loading || (this.loading = this.loadFunc().then(e => this.support = e, e => {
            throw this.loading = null,
            e
        }
        ))
    }
    static of(e) {
        let {load: n, support: r} = e;
        if (!n) {
            if (!r)
                throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            n = () => Promise.resolve(r)
        }
        return new on(e.name,(e.alias || []).concat(e.name).map(i => i.toLowerCase()),e.extensions || [],e.filename,n,r)
    }
    static matchFilename(e, n) {
        for (let i of e)
            if (i.filename && i.filename.test(n))
                return i;
        let r = /\.([^.]+)$/.exec(n);
        if (r) {
            for (let i of e)
                if (i.extensions.indexOf(r[1]) > -1)
                    return i
        }
        return null
    }
    static matchLanguageName(e, n, r=!0) {
        n = n.toLowerCase();
        for (let i of e)
            if (i.alias.some(s => s == n))
                return i;
        if (r)
            for (let i of e)
                for (let s of i.alias) {
                    let o = n.indexOf(s);
                    if (o > -1 && (s.length > 2 || !/\w/.test(n[o - 1]) && !/\w/.test(n[o + s.length])))
                        return i
                }
        return null
    }
}
const mpe = Me.define()
  , Ql = Me.define({
    combine: t => {
        if (!t.length)
            return "  ";
        let e = t[0];
        if (!e || /\S/.test(e) || Array.from(e).some(n => n != e[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
        return e
    }
});
function Wp(t) {
    let e = t.facet(Ql);
    return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length
}
function Zu(t, e) {
    let n = ""
      , r = t.tabSize
      , i = t.facet(Ql)[0];
    if (i == "	") {
        for (; e >= r; )
            n += "	",
            e -= r;
        i = " "
    }
    for (let s = 0; s < e; s++)
        n += i;
    return n
}
function nx(t, e) {
    t instanceof lt && (t = new fg(t));
    for (let r of t.state.facet(mpe)) {
        let i = r(t, e);
        if (i !== void 0)
            return i
    }
    let n = En(t.state);
    return n.length >= e ? _pe(t, n, e) : null
}
class fg {
    constructor(e, n={}) {
        this.state = e,
        this.options = n,
        this.unit = Wp(e)
    }
    lineAt(e, n=1) {
        let r = this.state.doc.lineAt(e)
          , {simulateBreak: i, simulateDoubleBreak: s} = this.options;
        return i != null && i >= r.from && i <= r.to ? s && i == e ? {
            text: "",
            from: e
        } : (n < 0 ? i < e : i <= e) ? {
            text: r.text.slice(i - r.from),
            from: i
        } : {
            text: r.text.slice(0, i - r.from),
            from: r.from
        } : r
    }
    textAfterPos(e, n=1) {
        if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
            return "";
        let {text: r, from: i} = this.lineAt(e, n);
        return r.slice(e - i, Math.min(r.length, e + 100 - i))
    }
    column(e, n=1) {
        let {text: r, from: i} = this.lineAt(e, n)
          , s = this.countColumn(r, e - i)
          , o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
        return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))),
        s
    }
    countColumn(e, n=e.length) {
        return lg(e, this.state.tabSize, n)
    }
    lineIndent(e, n=1) {
        let {text: r, from: i} = this.lineAt(e, n)
          , s = this.options.overrideIndentation;
        if (s) {
            let o = s(i);
            if (o > -1)
                return o
        }
        return this.countColumn(r, r.search(/\S|$/))
    }
    get simulatedBreak() {
        return this.options.simulateBreak || null
    }
}
const gpe = new ot;
function _pe(t, e, n) {
    let r = e.resolveStack(n)
      , i = r.node.enterUnfinishedNodesBefore(n);
    if (i != r.node) {
        let s = [];
        for (let o = i; o != r.node; o = o.parent)
            s.push(o);
        for (let o = s.length - 1; o >= 0; o--)
            r = {
                node: s[o],
                next: r
            }
    }
    return bB(r, t, n)
}
function bB(t, e, n) {
    for (let r = t; r; r = r.next) {
        let i = ype(r.node);
        if (i)
            return i(rx.create(e, n, r))
    }
    return 0
}
function bpe(t) {
    return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak
}
function ype(t) {
    let e = t.type.prop(gpe);
    if (e)
        return e;
    let n = t.firstChild, r;
    if (n && (r = n.type.prop(ot.closedBy))) {
        let i = t.lastChild
          , s = i && r.indexOf(i.name) > -1;
        return o => yB(o, !0, 1, void 0, s && !bpe(o) ? i.from : void 0)
    }
    return t.parent == null ? vpe : null
}
function vpe() {
    return 0
}
class rx extends fg {
    constructor(e, n, r) {
        super(e.state, e.options),
        this.base = e,
        this.pos = n,
        this.context = r
    }
    get node() {
        return this.context.node
    }
    static create(e, n, r) {
        return new rx(e,n,r)
    }
    get textAfter() {
        return this.textAfterPos(this.pos)
    }
    get baseIndent() {
        return this.baseIndentFor(this.node)
    }
    baseIndentFor(e) {
        let n = this.state.doc.lineAt(e.from);
        for (; ; ) {
            let r = e.resolve(n.from);
            for (; r.parent && r.parent.from == r.from; )
                r = r.parent;
            if (xpe(r, e))
                break;
            n = this.state.doc.lineAt(r.from)
        }
        return this.lineIndent(n.from)
    }
    continue() {
        return bB(this.context.next, this.base, this.pos)
    }
}
function xpe(t, e) {
    for (let n = e; n; n = n.parent)
        if (t == n)
            return !0;
    return !1
}
function Epe(t) {
    let e = t.node
      , n = e.childAfter(e.from)
      , r = e.lastChild;
    if (!n)
        return null;
    let i = t.options.simulateBreak
      , s = t.state.doc.lineAt(n.from)
      , o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
    for (let a = n.to; ; ) {
        let l = e.childAfter(a);
        if (!l || l == r)
            return null;
        if (!l.type.isSkipped)
            return l.from < o ? n : null;
        a = l.to
    }
}
function _ve({closing: t, align: e=!0, units: n=1}) {
    return r => yB(r, e, n, t)
}
function yB(t, e, n, r, i) {
    let s = t.textAfter
      , o = s.match(/^\s*/)[0].length
      , a = r && s.slice(o, o + r.length) == r || i == t.pos + o
      , l = e ? Epe(t) : null;
    return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n)
}
const bve = t => t.baseIndent;
function yve({except: t, units: e=1}={}) {
    return n => {
        let r = t && t.test(n.textAfter);
        return n.baseIndent + (r ? 0 : e * n.unit)
    }
}
const Spe = 200;
function wpe() {
    return lt.transactionFilter.of(t => {
        if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
            return t;
        let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
        if (!e.length)
            return t;
        let n = t.newDoc
          , {head: r} = t.newSelection.main
          , i = n.lineAt(r);
        if (r > i.from + Spe)
            return t;
        let s = n.sliceString(i.from, r);
        if (!e.some(c => c.test(s)))
            return t;
        let {state: o} = t
          , a = -1
          , l = [];
        for (let {head: c} of o.selection.ranges) {
            let u = o.doc.lineAt(c);
            if (u.from == a)
                continue;
            a = u.from;
            let h = nx(o, u.from);
            if (h == null)
                continue;
            let d = /^\s*/.exec(u.text)[0]
              , f = Zu(o, h);
            d != f && l.push({
                from: u.from,
                to: u.from + d.length,
                insert: f
            })
        }
        return l.length ? [t, {
            changes: l,
            sequential: !0
        }] : t
    }
    )
}
const Cpe = Me.define()
  , Tpe = new ot;
function vve(t) {
    let e = t.firstChild
      , n = t.lastChild;
    return e && e.to < n.from ? {
        from: e.to,
        to: n.type.isError ? t.to : n.from
    } : null
}
function Ape(t, e, n) {
    let r = En(t);
    if (r.length < n)
        return null;
    let i = r.resolveStack(n, 1)
      , s = null;
    for (let o = i; o; o = o.next) {
        let a = o.node;
        if (a.to <= n || a.from > n)
            continue;
        if (s && a.from < e)
            break;
        let l = a.type.prop(Tpe);
        if (l && (a.to < r.length - 50 || r.length == t.doc.length || !kpe(a))) {
            let c = l(a, t);
            c && c.from <= n && c.from >= e && c.to > n && (s = c)
        }
    }
    return s
}
function kpe(t) {
    let e = t.lastChild;
    return e && e.to == t.to && e.type.isError
}
function cA(t, e, n) {
    for (let r of t.facet(Cpe)) {
        let i = r(t, e, n);
        if (i)
            return i
    }
    return Ape(t, e, n)
}
function vB(t, e) {
    let n = e.mapPos(t.from, 1)
      , r = e.mapPos(t.to, -1);
    return n >= r ? void 0 : {
        from: n,
        to: r
    }
}
const xB = Je.define({
    map: vB
})
  , ix = Je.define({
    map: vB
})
  , Gp = Qt.define({
    create() {
        return at.none
    },
    update(t, e) {
        t = t.map(e.changes);
        for (let n of e.effects)
            if (n.is(xB) && !Rpe(t, n.value.from, n.value.to)) {
                let {preparePlaceholder: r} = e.state.facet(EB)
                  , i = r ? at.replace({
                    widget: new Dpe(r(e.state, n.value))
                }) : uA;
                t = t.update({
                    add: [i.range(n.value.from, n.value.to)]
                })
            } else
                n.is(ix) && (t = t.update({
                    filter: (r, i) => n.value.from != r || n.value.to != i,
                    filterFrom: n.value.from,
                    filterTo: n.value.to
                }));
        if (e.selection) {
            let n = !1
              , {head: r} = e.selection.main;
            t.between(r, r, (i, s) => {
                i < r && s > r && (n = !0)
            }
            ),
            n && (t = t.update({
                filterFrom: r,
                filterTo: r,
                filter: (i, s) => s <= r || i >= r
            }))
        }
        return t
    },
    provide: t => Oe.decorations.from(t),
    toJSON(t, e) {
        let n = [];
        return t.between(0, e.doc.length, (r, i) => {
            n.push(r, i)
        }
        ),
        n
    },
    fromJSON(t) {
        if (!Array.isArray(t) || t.length % 2)
            throw new RangeError("Invalid JSON for fold state");
        let e = [];
        for (let n = 0; n < t.length; ) {
            let r = t[n++]
              , i = t[n++];
            if (typeof r != "number" || typeof i != "number")
                throw new RangeError("Invalid JSON for fold state");
            e.push(uA.range(r, i))
        }
        return at.set(e, !0)
    }
});
function ay(t, e, n) {
    var r;
    let i = null;
    return (r = t.field(Gp, !1)) === null || r === void 0 || r.between(e, n, (s, o) => {
        (!i || i.from > s) && (i = {
            from: s,
            to: o
        })
    }
    ),
    i
}
function Rpe(t, e, n) {
    let r = !1;
    return t.between(e, e, (i, s) => {
        i == e && s == n && (r = !0)
    }
    ),
    r
}
const Ipe = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: ""
}
  , EB = Me.define({
    combine(t) {
        return Aa(t, Ipe)
    }
});
function Ppe(t) {
    return [Gp, Npe]
}
function SB(t, e) {
    let {state: n} = t
      , r = n.facet(EB)
      , i = o => {
        let a = t.lineBlockAt(t.posAtDOM(o.target))
          , l = ay(t.state, a.from, a.to);
        l && t.dispatch({
            effects: ix.of(l)
        }),
        o.preventDefault()
    }
    ;
    if (r.placeholderDOM)
        return r.placeholderDOM(t, i, e);
    let s = document.createElement("span");
    return s.textContent = r.placeholderText,
    s.setAttribute("aria-label", n.phrase("folded code")),
    s.title = n.phrase("unfold"),
    s.className = "cm-foldPlaceholder",
    s.onclick = i,
    s
}
const uA = at.replace({
    widget: new class extends Xl {
        toDOM(t) {
            return SB(t, null)
        }
    }
});
class Dpe extends Xl {
    constructor(e) {
        super(),
        this.value = e
    }
    eq(e) {
        return this.value == e.value
    }
    toDOM(e) {
        return SB(e, this.value)
    }
}
const Lpe = {
    openText: "",
    closedText: "",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => !1
};
class z0 extends ls {
    constructor(e, n) {
        super(),
        this.config = e,
        this.open = n
    }
    eq(e) {
        return this.config == e.config && this.open == e.open
    }
    toDOM(e) {
        if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
        let n = document.createElement("span");
        return n.textContent = this.open ? this.config.openText : this.config.closedText,
        n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"),
        n
    }
}
function Ope(t={}) {
    let e = Object.assign(Object.assign({}, Lpe), t)
      , n = new z0(e,!0)
      , r = new z0(e,!1)
      , i = xn.fromClass(class {
        constructor(o) {
            this.from = o.viewport.from,
            this.markers = this.buildMarkers(o)
        }
        update(o) {
            (o.docChanged || o.viewportChanged || o.startState.facet(to) != o.state.facet(to) || o.startState.field(Gp, !1) != o.state.field(Gp, !1) || En(o.startState) != En(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view))
        }
        buildMarkers(o) {
            let a = new la;
            for (let l of o.viewportLineBlocks) {
                let c = ay(o.state, l.from, l.to) ? r : cA(o.state, l.from, l.to) ? n : null;
                c && a.add(l.from, l.from, c)
            }
            return a.finish()
        }
    }
    )
      , {domEventHandlers: s} = e;
    return [i, Pfe({
        class: "cm-foldGutter",
        markers(o) {
            var a;
            return ((a = o.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || dt.empty
        },
        initialSpacer() {
            return new z0(e,!1)
        },
        domEventHandlers: Object.assign(Object.assign({}, s), {
            click: (o, a, l) => {
                if (s.click && s.click(o, a, l))
                    return !0;
                let c = ay(o.state, a.from, a.to);
                if (c)
                    return o.dispatch({
                        effects: ix.of(c)
                    }),
                    !0;
                let u = cA(o.state, a.from, a.to);
                return u ? (o.dispatch({
                    effects: xB.of(u)
                }),
                !0) : !1
            }
        })
    }), Ppe()]
}
const Npe = Oe.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});
class id {
    constructor(e, n) {
        this.specs = e;
        let r;
        function i(a) {
            let l = Qs.newName();
            return (r || (r = Object.create(null)))["." + l] = a,
            l
        }
        const s = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0
          , o = n.scope;
        this.scope = o instanceof Kr ? a => a.prop(rl) == o.data : o ? a => a == o : void 0,
        this.style = gB(e.map(a => ({
            tag: a.tag,
            class: a.class || i(Object.assign({}, a, {
                tag: null
            }))
        })), {
            all: s
        }).style,
        this.module = r ? new Qs(r) : null,
        this.themeType = n.themeType
    }
    static define(e, n) {
        return new id(e,n || {})
    }
}
const ly = Me.define()
  , Mpe = Me.define({
    combine(t) {
        return t.length ? [t[0]] : null
    }
});
function W0(t) {
    let e = t.facet(ly);
    return e.length ? e : t.facet(Mpe)
}
function Bpe(t, e) {
    let n = [jpe], r;
    return t instanceof id && (t.module && n.push(Oe.styleModule.of(t.module)),
    r = t.themeType),
    r ? n.push(ly.computeN([Oe.darkTheme], i => i.facet(Oe.darkTheme) == (r == "dark") ? [t] : [])) : n.push(ly.of(t)),
    n
}
class Fpe {
    constructor(e) {
        this.markCache = Object.create(null),
        this.tree = En(e.state),
        this.decorations = this.buildDeco(e, W0(e.state)),
        this.decoratedTo = e.viewport.to
    }
    update(e) {
        let n = En(e.state)
          , r = W0(e.state)
          , i = r != W0(e.startState)
          , {viewport: s} = e.view
          , o = e.changes.mapPos(this.decoratedTo, 1);
        n.length < s.to && !i && n.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes),
        this.decoratedTo = o) : (n != this.tree || e.viewportChanged || i) && (this.tree = n,
        this.decorations = this.buildDeco(e.view, r),
        this.decoratedTo = s.to)
    }
    buildDeco(e, n) {
        if (!n || !this.tree.length)
            return at.none;
        let r = new la;
        for (let {from: i, to: s} of e.visibleRanges)
            lpe(this.tree, n, (o, a, l) => {
                r.add(o, a, this.markCache[l] || (this.markCache[l] = at.mark({
                    class: l
                })))
            }
            , i, s);
        return r.finish()
    }
}
const jpe = co.high(xn.fromClass(Fpe, {
    decorations: t => t.decorations
}));
te.meta,
te.link,
te.heading,
te.emphasis,
te.strong,
te.strikethrough,
te.keyword,
te.atom,
te.bool,
te.url,
te.contentSeparator,
te.labelName,
te.literal,
te.inserted,
te.string,
te.deleted,
te.regexp,
te.escape,
te.string,
te.variableName,
te.variableName,
te.typeName,
te.namespace,
te.className,
te.variableName,
te.macroName,
te.propertyName,
te.comment,
te.invalid;
const Hpe = Oe.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
        backgroundColor: "#328c8252"
    },
    "&.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "#bb555544"
    }
})
  , wB = 1e4
  , CB = "()[]{}"
  , TB = Me.define({
    combine(t) {
        return Aa(t, {
            afterCursor: !0,
            brackets: CB,
            maxScanDistance: wB,
            renderMatch: $pe
        })
    }
})
  , Upe = at.mark({
    class: "cm-matchingBracket"
})
  , Vpe = at.mark({
    class: "cm-nonmatchingBracket"
});
function $pe(t) {
    let e = []
      , n = t.matched ? Upe : Vpe;
    return e.push(n.range(t.start.from, t.start.to)),
    t.end && e.push(n.range(t.end.from, t.end.to)),
    e
}
const zpe = Qt.define({
    create() {
        return at.none
    },
    update(t, e) {
        if (!e.docChanged && !e.selection)
            return t;
        let n = []
          , r = e.state.facet(TB);
        for (let i of e.state.selection.ranges) {
            if (!i.empty)
                continue;
            let s = Si(e.state, i.head, -1, r) || i.head > 0 && Si(e.state, i.head - 1, 1, r) || r.afterCursor && (Si(e.state, i.head, 1, r) || i.head < e.state.doc.length && Si(e.state, i.head + 1, -1, r));
            s && (n = n.concat(r.renderMatch(s, e.state)))
        }
        return at.set(n, !0)
    },
    provide: t => Oe.decorations.from(t)
})
  , Wpe = [zpe, Hpe];
function Gpe(t={}) {
    return [TB.of(t), Wpe]
}
const qpe = new ot;
function cy(t, e, n) {
    let r = t.prop(e < 0 ? ot.openedBy : ot.closedBy);
    if (r)
        return r;
    if (t.name.length == 1) {
        let i = n.indexOf(t.name);
        if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
            return [n[i + e]]
    }
    return null
}
function uy(t) {
    let e = t.type.prop(qpe);
    return e ? e(t.node) : t
}
function Si(t, e, n, r={}) {
    let i = r.maxScanDistance || wB
      , s = r.brackets || CB
      , o = En(t)
      , a = o.resolveInner(e, n);
    for (let l = a; l; l = l.parent) {
        let c = cy(l.type, n, s);
        if (c && l.from < l.to) {
            let u = uy(l);
            if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
                return Kpe(t, e, n, l, u, c, s)
        }
    }
    return Ype(t, e, n, o, a.type, i, s)
}
function Kpe(t, e, n, r, i, s, o) {
    let a = r.parent
      , l = {
        from: i.from,
        to: i.to
    }
      , c = 0
      , u = a?.cursor();
    if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
        do
            if (n < 0 ? u.to <= r.from : u.from >= r.to) {
                if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
                    let h = uy(u);
                    return {
                        start: l,
                        end: h ? {
                            from: h.from,
                            to: h.to
                        } : void 0,
                        matched: !0
                    }
                } else if (cy(u.type, n, o))
                    c++;
                else if (cy(u.type, -n, o)) {
                    if (c == 0) {
                        let h = uy(u);
                        return {
                            start: l,
                            end: h && h.from < h.to ? {
                                from: h.from,
                                to: h.to
                            } : void 0,
                            matched: !1
                        }
                    }
                    c--
                }
            }
        while (n < 0 ? u.prevSibling() : u.nextSibling());
    return {
        start: l,
        matched: !1
    }
}
function Ype(t, e, n, r, i, s, o) {
    let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1)
      , l = o.indexOf(a);
    if (l < 0 || l % 2 == 0 != n > 0)
        return null;
    let c = {
        from: n < 0 ? e - 1 : e,
        to: n > 0 ? e + 1 : e
    }
      , u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0)
      , h = 0;
    for (let d = 0; !u.next().done && d <= s; ) {
        let f = u.value;
        n < 0 && (d += f.length);
        let g = e + d * n;
        for (let _ = n > 0 ? 0 : f.length - 1, m = n > 0 ? f.length : -1; _ != m; _ += n) {
            let p = o.indexOf(f[_]);
            if (!(p < 0 || r.resolveInner(g + _, 1).type != i))
                if (p % 2 == 0 == n > 0)
                    h++;
                else {
                    if (h == 1)
                        return {
                            start: c,
                            end: {
                                from: g + _,
                                to: g + _ + 1
                            },
                            matched: p >> 1 == l >> 1
                        };
                    h--
                }
        }
        n > 0 && (d += f.length)
    }
    return u.done ? {
        start: c,
        matched: !1
    } : null
}
const Xpe = Object.create(null)
  , hA = [tr.none]
  , dA = []
  , fA = Object.create(null)
  , Qpe = Object.create(null);
for (let[t,e] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]])
    Qpe[t] = Jpe(Xpe, e);
function G0(t, e) {
    dA.indexOf(t) > -1 || (dA.push(t),
    console.warn(e))
}
function Jpe(t, e) {
    let n = [];
    for (let a of e.split(" ")) {
        let l = [];
        for (let c of a.split(".")) {
            let u = t[c] || te[c];
            u ? typeof u == "function" ? l.length ? l = l.map(u) : G0(c, `Modifier ${c} used at start of tag`) : l.length ? G0(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : G0(c, `Unknown highlighting tag ${c}`)
        }
        for (let c of l)
            n.push(c)
    }
    if (!n.length)
        return 0;
    let r = e.replace(/ /g, "_")
      , i = r + " " + n.map(a => a.id)
      , s = fA[i];
    if (s)
        return s.id;
    let o = fA[i] = tr.define({
        id: hA.length,
        name: r,
        props: [ope({
            [r]: n
        })]
    });
    return hA.push(o),
    o.id
}
Nt.RTL,
Nt.LTR;
class AB {
    constructor(e, n, r, i) {
        this.state = e,
        this.pos = n,
        this.explicit = r,
        this.view = i,
        this.abortListeners = []
    }
    tokenBefore(e) {
        let n = En(this.state).resolveInner(this.pos, -1);
        for (; n && e.indexOf(n.name) < 0; )
            n = n.parent;
        return n ? {
            from: n.from,
            to: this.pos,
            text: this.state.sliceDoc(n.from, this.pos),
            type: n.type
        } : null
    }
    matchBefore(e) {
        let n = this.state.doc.lineAt(this.pos)
          , r = Math.max(n.from, this.pos - 250)
          , i = n.text.slice(r - n.from, this.pos - n.from)
          , s = i.search(kB(e, !1));
        return s < 0 ? null : {
            from: r + s,
            to: this.pos,
            text: i.slice(s)
        }
    }
    get aborted() {
        return this.abortListeners == null
    }
    addEventListener(e, n) {
        e == "abort" && this.abortListeners && this.abortListeners.push(n)
    }
}
function pA(t) {
    let e = Object.keys(t).join("")
      , n = /\w/.test(e);
    return n && (e = e.replace(/\w/g, "")),
    `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`
}
function Zpe(t) {
    let e = Object.create(null)
      , n = Object.create(null);
    for (let {label: i} of t) {
        e[i[0]] = !0;
        for (let s = 1; s < i.length; s++)
            n[i[s]] = !0
    }
    let r = pA(e) + pA(n) + "*$";
    return [new RegExp("^" + r), new RegExp(r)]
}
function eme(t) {
    let e = t.map(i => typeof i == "string" ? {
        label: i
    } : i)
      , [n,r] = e.every(i => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : Zpe(e);
    return i => {
        let s = i.matchBefore(r);
        return s || i.explicit ? {
            from: s ? s.from : i.pos,
            options: e,
            validFor: n
        } : null
    }
}
function xve(t, e) {
    return n => {
        for (let r = En(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
            if (t.indexOf(r.name) > -1)
                return null;
            if (r.type.isTop)
                break
        }
        return e(n)
    }
}
class mA {
    constructor(e, n, r, i) {
        this.completion = e,
        this.source = n,
        this.match = r,
        this.score = i
    }
}
function Ms(t) {
    return t.selection.main.from
}
function kB(t, e) {
    var n;
    let {source: r} = t
      , i = e && r[0] != "^"
      , s = r[r.length - 1] != "$";
    return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`,(n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "")
}
const sx = fs.define();
function tme(t, e, n, r) {
    let {main: i} = t.selection
      , s = n - i.from
      , o = r - i.from;
    return Object.assign(Object.assign({}, t.changeByRange(a => a != i && n != r && t.sliceDoc(a.from + s, a.from + o) != t.sliceDoc(n, r) ? {
        range: a
    } : {
        changes: {
            from: a.from + s,
            to: r == i.from ? a.to : a.from + o,
            insert: e
        },
        range: ge.cursor(a.from + s + e.length)
    })), {
        scrollIntoView: !0,
        userEvent: "input.complete"
    })
}
const gA = new WeakMap;
function nme(t) {
    if (!Array.isArray(t))
        return t;
    let e = gA.get(t);
    return e || gA.set(t, e = eme(t)),
    e
}
const qp = Je.define()
  , eh = Je.define();
class rme {
    constructor(e) {
        this.pattern = e,
        this.chars = [],
        this.folded = [],
        this.any = [],
        this.precise = [],
        this.byWord = [],
        this.score = 0,
        this.matched = [];
        for (let n = 0; n < e.length; ) {
            let r = Xn(e, n)
              , i = Wr(r);
            this.chars.push(r);
            let s = e.slice(n, n + i)
              , o = s.toUpperCase();
            this.folded.push(Xn(o == s ? s.toLowerCase() : o, 0)),
            n += i
        }
        this.astral = e.length != this.chars.length
    }
    ret(e, n) {
        return this.score = e,
        this.matched = n,
        this
    }
    match(e) {
        if (this.pattern.length == 0)
            return this.ret(-100, []);
        if (e.length < this.pattern.length)
            return null;
        let {chars: n, folded: r, any: i, precise: s, byWord: o} = this;
        if (n.length == 1) {
            let b = Xn(e, 0)
              , y = Wr(b)
              , x = y == e.length ? 0 : -100;
            if (b != n[0])
                if (b == r[0])
                    x += -200;
                else
                    return null;
            return this.ret(x, [0, y])
        }
        let a = e.indexOf(this.pattern);
        if (a == 0)
            return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
        let l = n.length
          , c = 0;
        if (a < 0) {
            for (let b = 0, y = Math.min(e.length, 200); b < y && c < l; ) {
                let x = Xn(e, b);
                (x == n[c] || x == r[c]) && (i[c++] = b),
                b += Wr(x)
            }
            if (c < l)
                return null
        }
        let u = 0
          , h = 0
          , d = !1
          , f = 0
          , g = -1
          , _ = -1
          , m = /[a-z]/.test(e)
          , p = !0;
        for (let b = 0, y = Math.min(e.length, 200), x = 0; b < y && h < l; ) {
            let E = Xn(e, b);
            a < 0 && (u < l && E == n[u] && (s[u++] = b),
            f < l && (E == n[f] || E == r[f] ? (f == 0 && (g = b),
            _ = b + 1,
            f++) : f = 0));
            let w, A = E < 255 ? E >= 48 && E <= 57 || E >= 97 && E <= 122 ? 2 : E >= 65 && E <= 90 ? 1 : 0 : (w = $1(E)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
            (!b || A == 1 && m || x == 0 && A != 0) && (n[h] == E || r[h] == E && (d = !0) ? o[h++] = b : o.length && (p = !1)),
            x = A,
            b += Wr(E)
        }
        return h == l && o[0] == 0 && p ? this.result(-100 + (d ? -200 : 0), o, e) : f == l && g == 0 ? this.ret(-200 - e.length + (_ == e.length ? 0 : -100), [0, _]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : f == l ? this.ret(-900 - e.length, [g, _]) : h == l ? this.result(-100 + (d ? -200 : 0) + -700 + (p ? 0 : -1100), o, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e)
    }
    result(e, n, r) {
        let i = []
          , s = 0;
        for (let o of n) {
            let a = o + (this.astral ? Wr(Xn(r, o)) : 1);
            s && i[s - 1] == o ? i[s - 1] = a : (i[s++] = o,
            i[s++] = a)
        }
        return this.ret(e - r.length, i)
    }
}
class ime {
    constructor(e) {
        this.pattern = e,
        this.matched = [],
        this.score = 0,
        this.folded = e.toLowerCase()
    }
    match(e) {
        if (e.length < this.pattern.length)
            return null;
        let n = e.slice(0, this.pattern.length)
          , r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
        return r == null ? null : (this.matched = [0, n.length],
        this.score = r + (e.length == this.pattern.length ? 0 : -100),
        this)
    }
}
const _n = Me.define({
    combine(t) {
        return Aa(t, {
            activateOnTyping: !0,
            activateOnCompletion: () => !1,
            activateOnTypingDelay: 100,
            selectOnOpen: !0,
            override: null,
            closeOnBlur: !0,
            maxRenderedOptions: 100,
            defaultKeymap: !0,
            tooltipClass: () => "",
            optionClass: () => "",
            aboveCursor: !1,
            icons: !0,
            addToOptions: [],
            positionInfo: sme,
            filterStrict: !1,
            compareCompletions: (e, n) => e.label.localeCompare(n.label),
            interactionDelay: 75,
            updateSyncTime: 100
        }, {
            defaultKeymap: (e, n) => e && n,
            closeOnBlur: (e, n) => e && n,
            icons: (e, n) => e && n,
            tooltipClass: (e, n) => r => _A(e(r), n(r)),
            optionClass: (e, n) => r => _A(e(r), n(r)),
            addToOptions: (e, n) => e.concat(n),
            filterStrict: (e, n) => e || n
        })
    }
});
function _A(t, e) {
    return t ? e ? t + " " + e : t : e
}
function sme(t, e, n, r, i, s) {
    let o = t.textDirection == Nt.RTL, a = o, l = !1, c = "top", u, h, d = e.left - i.left, f = i.right - e.right, g = r.right - r.left, _ = r.bottom - r.top;
    if (a && d < Math.min(g, f) ? a = !1 : !a && f < Math.min(g, d) && (a = !0),
    g <= (a ? d : f))
        u = Math.max(i.top, Math.min(n.top, i.bottom - _)) - e.top,
        h = Math.min(400, a ? d : f);
    else {
        l = !0,
        h = Math.min(400, (o ? e.right : i.right - e.left) - 30);
        let b = i.bottom - e.bottom;
        b >= _ || b > e.top ? u = n.bottom - e.top : (c = "bottom",
        u = e.bottom - n.top)
    }
    let m = (e.bottom - e.top) / s.offsetHeight
      , p = (e.right - e.left) / s.offsetWidth;
    return {
        style: `${c}: ${u / m}px; max-width: ${h / p}px`,
        class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
    }
}
function ome(t) {
    let e = t.addToOptions.slice();
    return t.icons && e.push({
        render(n) {
            let r = document.createElement("div");
            return r.classList.add("cm-completionIcon"),
            n.type && r.classList.add(...n.type.split(/\s+/g).map(i => "cm-completionIcon-" + i)),
            r.setAttribute("aria-hidden", "true"),
            r
        },
        position: 20
    }),
    e.push({
        render(n, r, i, s) {
            let o = document.createElement("span");
            o.className = "cm-completionLabel";
            let a = n.displayLabel || n.label
              , l = 0;
            for (let c = 0; c < s.length; ) {
                let u = s[c++]
                  , h = s[c++];
                u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
                let d = o.appendChild(document.createElement("span"));
                d.appendChild(document.createTextNode(a.slice(u, h))),
                d.className = "cm-completionMatchedText",
                l = h
            }
            return l < a.length && o.appendChild(document.createTextNode(a.slice(l))),
            o
        },
        position: 50
    }, {
        render(n) {
            if (!n.detail)
                return null;
            let r = document.createElement("span");
            return r.className = "cm-completionDetail",
            r.textContent = n.detail,
            r
        },
        position: 80
    }),
    e.sort( (n, r) => n.position - r.position).map(n => n.render)
}
function q0(t, e, n) {
    if (t <= n)
        return {
            from: 0,
            to: t
        };
    if (e < 0 && (e = 0),
    e <= t >> 1) {
        let i = Math.floor(e / n);
        return {
            from: i * n,
            to: (i + 1) * n
        }
    }
    let r = Math.floor((t - e) / n);
    return {
        from: t - (r + 1) * n,
        to: t - r * n
    }
}
class ame {
    constructor(e, n, r) {
        this.view = e,
        this.stateField = n,
        this.applyCompletion = r,
        this.info = null,
        this.infoDestroy = null,
        this.placeInfoReq = {
            read: () => this.measureInfo(),
            write: l => this.placeInfo(l),
            key: this
        },
        this.space = null,
        this.currentClass = "";
        let i = e.state.field(n)
          , {options: s, selected: o} = i.open
          , a = e.state.facet(_n);
        this.optionContent = ome(a),
        this.optionClass = a.optionClass,
        this.tooltipClass = a.tooltipClass,
        this.range = q0(s.length, o, a.maxRenderedOptions),
        this.dom = document.createElement("div"),
        this.dom.className = "cm-tooltip-autocomplete",
        this.updateTooltipClass(e.state),
        this.dom.addEventListener("mousedown", l => {
            let {options: c} = e.state.field(n).open;
            for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
                if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
                    this.applyCompletion(e, c[+h[1]]),
                    l.preventDefault();
                    return
                }
        }
        ),
        this.dom.addEventListener("focusout", l => {
            let c = e.state.field(this.stateField, !1);
            c && c.tooltip && e.state.facet(_n).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({
                effects: eh.of(null)
            })
        }
        ),
        this.showOptions(s, i.id)
    }
    mount() {
        this.updateSel()
    }
    showOptions(e, n) {
        this.list && this.list.remove(),
        this.list = this.dom.appendChild(this.createListBox(e, n, this.range)),
        this.list.addEventListener("scroll", () => {
            this.info && this.view.requestMeasure(this.placeInfoReq)
        }
        )
    }
    update(e) {
        var n;
        let r = e.state.field(this.stateField)
          , i = e.startState.field(this.stateField);
        if (this.updateTooltipClass(e.state),
        r != i) {
            let {options: s, selected: o, disabled: a} = r.open;
            (!i.open || i.open.options != s) && (this.range = q0(s.length, o, e.state.facet(_n).maxRenderedOptions),
            this.showOptions(s, r.id)),
            this.updateSel(),
            a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a)
        }
    }
    updateTooltipClass(e) {
        let n = this.tooltipClass(e);
        if (n != this.currentClass) {
            for (let r of this.currentClass.split(" "))
                r && this.dom.classList.remove(r);
            for (let r of n.split(" "))
                r && this.dom.classList.add(r);
            this.currentClass = n
        }
    }
    positioned(e) {
        this.space = e,
        this.info && this.view.requestMeasure(this.placeInfoReq)
    }
    updateSel() {
        let e = this.view.state.field(this.stateField)
          , n = e.open;
        if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = q0(n.options.length, n.selected, this.view.state.facet(_n).maxRenderedOptions),
        this.showOptions(n.options, e.id)),
        this.updateSelectedOption(n.selected)) {
            this.destroyInfo();
            let {completion: r} = n.options[n.selected]
              , {info: i} = r;
            if (!i)
                return;
            let s = typeof i == "string" ? document.createTextNode(i) : i(r);
            if (!s)
                return;
            "then"in s ? s.then(o => {
                o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r)
            }
            ).catch(o => fr(this.view.state, o, "completion info")) : this.addInfoPane(s, r)
        }
    }
    addInfoPane(e, n) {
        this.destroyInfo();
        let r = this.info = document.createElement("div");
        if (r.className = "cm-tooltip cm-completionInfo",
        e.nodeType != null)
            r.appendChild(e),
            this.infoDestroy = null;
        else {
            let {dom: i, destroy: s} = e;
            r.appendChild(i),
            this.infoDestroy = s || null
        }
        this.dom.appendChild(r),
        this.view.requestMeasure(this.placeInfoReq)
    }
    updateSelectedOption(e) {
        let n = null;
        for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling,
        i++)
            r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"),
            n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
        return n && cme(this.list, n),
        n
    }
    measureInfo() {
        let e = this.dom.querySelector("[aria-selected]");
        if (!e || !this.info)
            return null;
        let n = this.dom.getBoundingClientRect()
          , r = this.info.getBoundingClientRect()
          , i = e.getBoundingClientRect()
          , s = this.space;
        if (!s) {
            let o = this.dom.ownerDocument.defaultView || window;
            s = {
                left: 0,
                top: 0,
                right: o.innerWidth,
                bottom: o.innerHeight
            }
        }
        return i.top > Math.min(s.bottom, n.bottom) - 10 || i.bottom < Math.max(s.top, n.top) + 10 ? null : this.view.state.facet(_n).positionInfo(this.view, n, i, r, s, this.dom)
    }
    placeInfo(e) {
        this.info && (e ? (e.style && (this.info.style.cssText = e.style),
        this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px")
    }
    createListBox(e, n, r) {
        const i = document.createElement("ul");
        i.id = n,
        i.setAttribute("role", "listbox"),
        i.setAttribute("aria-expanded", "true"),
        i.setAttribute("aria-label", this.view.state.phrase("Completions"));
        let s = null;
        for (let o = r.from; o < r.to; o++) {
            let {completion: a, match: l} = e[o]
              , {section: c} = a;
            if (c) {
                let d = typeof c == "string" ? c : c.name;
                if (d != s && (o > r.from || r.from == 0))
                    if (s = d,
                    typeof c != "string" && c.header)
                        i.appendChild(c.header(c));
                    else {
                        let f = i.appendChild(document.createElement("completion-section"));
                        f.textContent = d
                    }
            }
            const u = i.appendChild(document.createElement("li"));
            u.id = n + "-" + o,
            u.setAttribute("role", "option");
            let h = this.optionClass(a);
            h && (u.className = h);
            for (let d of this.optionContent) {
                let f = d(a, this.view.state, this.view, l);
                f && u.appendChild(f)
            }
        }
        return r.from && i.classList.add("cm-completionListIncompleteTop"),
        r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"),
        i
    }
    destroyInfo() {
        this.info && (this.infoDestroy && this.infoDestroy(),
        this.info.remove(),
        this.info = null)
    }
    destroy() {
        this.destroyInfo()
    }
}
function lme(t, e) {
    return n => new ame(n,t,e)
}
function cme(t, e) {
    let n = t.getBoundingClientRect()
      , r = e.getBoundingClientRect()
      , i = n.height / t.offsetHeight;
    r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i)
}
function bA(t) {
    return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0)
}
function ume(t, e) {
    let n = []
      , r = null
      , i = c => {
        n.push(c);
        let {section: u} = c.completion;
        if (u) {
            r || (r = []);
            let h = typeof u == "string" ? u : u.name;
            r.some(d => d.name == h) || r.push(typeof u == "string" ? {
                name: h
            } : u)
        }
    }
      , s = e.facet(_n);
    for (let c of t)
        if (c.hasResult()) {
            let u = c.result.getMatch;
            if (c.result.filter === !1)
                for (let h of c.result.options)
                    i(new mA(h,c.source,u ? u(h) : [],1e9 - n.length));
            else {
                let h = e.sliceDoc(c.from, c.to), d, f = s.filterStrict ? new ime(h) : new rme(h);
                for (let g of c.result.options)
                    if (d = f.match(g.label)) {
                        let _ = g.displayLabel ? u ? u(g, d.matched) : [] : d.matched;
                        i(new mA(g,c.source,_,d.score + (g.boost || 0)))
                    }
            }
        }
    if (r) {
        let c = Object.create(null)
          , u = 0
          , h = (d, f) => {
            var g, _;
            return ((g = d.rank) !== null && g !== void 0 ? g : 1e9) - ((_ = f.rank) !== null && _ !== void 0 ? _ : 1e9) || (d.name < f.name ? -1 : 1)
        }
        ;
        for (let d of r.sort(h))
            u -= 1e5,
            c[d.name] = u;
        for (let d of n) {
            let {section: f} = d.completion;
            f && (d.score += c[typeof f == "string" ? f : f.name])
        }
    }
    let o = []
      , a = null
      , l = s.compareCompletions;
    for (let c of n.sort( (u, h) => h.score - u.score || l(u.completion, h.completion))) {
        let u = c.completion;
        !a || a.label != u.label || a.detail != u.detail || a.type != null && u.type != null && a.type != u.type || a.apply != u.apply || a.boost != u.boost ? o.push(c) : bA(c.completion) > bA(a) && (o[o.length - 1] = c),
        a = c.completion
    }
    return o
}
class il {
    constructor(e, n, r, i, s, o) {
        this.options = e,
        this.attrs = n,
        this.tooltip = r,
        this.timestamp = i,
        this.selected = s,
        this.disabled = o
    }
    setSelected(e, n) {
        return e == this.selected || e >= this.options.length ? this : new il(this.options,yA(n, e),this.tooltip,this.timestamp,e,this.disabled)
    }
    static build(e, n, r, i, s) {
        let o = ume(e, n);
        if (!o.length)
            return i && e.some(l => l.state == 1) ? new il(i.options,i.attrs,i.tooltip,i.timestamp,i.selected,!0) : null;
        let a = n.facet(_n).selectOnOpen ? 0 : -1;
        if (i && i.selected != a && i.selected != -1) {
            let l = i.options[i.selected].completion;
            for (let c = 0; c < o.length; c++)
                if (o[c].completion == l) {
                    a = c;
                    break
                }
        }
        return new il(o,yA(r, a),{
            pos: e.reduce( (l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
            create: gme,
            above: s.aboveCursor
        },i ? i.timestamp : Date.now(),a,!1)
    }
    map(e) {
        return new il(this.options,this.attrs,Object.assign(Object.assign({}, this.tooltip), {
            pos: e.mapPos(this.tooltip.pos)
        }),this.timestamp,this.selected,this.disabled)
    }
}
class Kp {
    constructor(e, n, r) {
        this.active = e,
        this.id = n,
        this.open = r
    }
    static start() {
        return new Kp(pme,"cm-ac-" + Math.floor(Math.random() * 2e6).toString(36),null)
    }
    update(e) {
        let {state: n} = e
          , r = n.facet(_n)
          , s = (r.override || n.languageDataAt("autocomplete", Ms(n)).map(nme)).map(a => (this.active.find(c => c.source == a) || new dr(a,this.active.some(c => c.state != 0) ? 1 : 0)).update(e, r));
        s.length == this.active.length && s.every( (a, l) => a == this.active[l]) && (s = this.active);
        let o = this.open;
        o && e.docChanged && (o = o.map(e.changes)),
        e.selection || s.some(a => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !hme(s, this.active) ? o = il.build(s, n, this.id, o, r) : o && o.disabled && !s.some(a => a.state == 1) && (o = null),
        !o && s.every(a => a.state != 1) && s.some(a => a.hasResult()) && (s = s.map(a => a.hasResult() ? new dr(a.source,0) : a));
        for (let a of e.effects)
            a.is(PB) && (o = o && o.setSelected(a.value, this.id));
        return s == this.active && o == this.open ? this : new Kp(s,this.id,o)
    }
    get tooltip() {
        return this.open ? this.open.tooltip : null
    }
    get attrs() {
        return this.open ? this.open.attrs : this.active.length ? dme : fme
    }
}
function hme(t, e) {
    if (t == e)
        return !0;
    for (let n = 0, r = 0; ; ) {
        for (; n < t.length && !t[n].hasResult; )
            n++;
        for (; r < e.length && !e[r].hasResult; )
            r++;
        let i = n == t.length
          , s = r == e.length;
        if (i || s)
            return i == s;
        if (t[n++].result != e[r++].result)
            return !1
    }
}
const dme = {
    "aria-autocomplete": "list"
}
  , fme = {};
function yA(t, e) {
    let n = {
        "aria-autocomplete": "list",
        "aria-haspopup": "listbox",
        "aria-controls": t
    };
    return e > -1 && (n["aria-activedescendant"] = t + "-" + e),
    n
}
const pme = [];
function RB(t, e) {
    if (t.isUserEvent("input.complete")) {
        let r = t.annotation(sx);
        if (r && e.activateOnCompletion(r))
            return 12
    }
    let n = t.isUserEvent("input.type");
    return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0
}
class dr {
    constructor(e, n, r=-1) {
        this.source = e,
        this.state = n,
        this.explicitPos = r
    }
    hasResult() {
        return !1
    }
    update(e, n) {
        let r = RB(e, n)
          , i = this;
        (r & 8 || r & 16 && this.touches(e)) && (i = new dr(i.source,0)),
        r & 4 && i.state == 0 && (i = new dr(this.source,1)),
        i = i.updateFor(e, r);
        for (let s of e.effects)
            if (s.is(qp))
                i = new dr(i.source,1,s.value ? Ms(e.state) : -1);
            else if (s.is(eh))
                i = new dr(i.source,0);
            else if (s.is(IB))
                for (let o of s.value)
                    o.source == i.source && (i = o);
        return i
    }
    updateFor(e, n) {
        return this.map(e.changes)
    }
    map(e) {
        return e.empty || this.explicitPos < 0 ? this : new dr(this.source,this.state,e.mapPos(this.explicitPos))
    }
    touches(e) {
        return e.changes.touchesRange(Ms(e.state))
    }
}
class bl extends dr {
    constructor(e, n, r, i, s) {
        super(e, 2, n),
        this.result = r,
        this.from = i,
        this.to = s
    }
    hasResult() {
        return !0
    }
    updateFor(e, n) {
        var r;
        if (!(n & 3))
            return this.map(e.changes);
        let i = this.result;
        i.map && !e.changes.empty && (i = i.map(i, e.changes));
        let s = e.changes.mapPos(this.from)
          , o = e.changes.mapPos(this.to, 1)
          , a = Ms(e.state);
        if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || !i || n & 2 && Ms(e.startState) == this.from)
            return new dr(this.source,n & 4 ? 1 : 0);
        let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
        return mme(i.validFor, e.state, s, o) ? new bl(this.source,l,i,s,o) : i.update && (i = i.update(i, s, o, new AB(e.state,a,l >= 0))) ? new bl(this.source,l,i,i.from,(r = i.to) !== null && r !== void 0 ? r : Ms(e.state)) : new dr(this.source,1,l)
    }
    map(e) {
        return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new bl(this.source,this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos),this.result,e.mapPos(this.from),e.mapPos(this.to, 1)) : new dr(this.source,0)
    }
    touches(e) {
        return e.changes.touchesRange(this.from, this.to)
    }
}
function mme(t, e, n, r) {
    if (!t)
        return !1;
    let i = e.sliceDoc(n, r);
    return typeof t == "function" ? t(i, n, r, e) : kB(t, !0).test(i)
}
const IB = Je.define({
    map(t, e) {
        return t.map(n => n.map(e))
    }
})
  , PB = Je.define()
  , Jn = Qt.define({
    create() {
        return Kp.start()
    },
    update(t, e) {
        return t.update(e)
    },
    provide: t => [dg.from(t, e => e.tooltip), Oe.contentAttributes.from(t, e => e.attrs)]
});
function ox(t, e) {
    const n = e.completion.apply || e.completion.label;
    let r = t.state.field(Jn).active.find(i => i.source == e.source);
    return r instanceof bl ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, tme(t.state, n, r.from, r.to)), {
        annotations: sx.of(e.completion)
    })) : n(t, e.completion, r.from, r.to),
    !0) : !1
}
const gme = lme(Jn, ox);
function Zd(t, e="option") {
    return n => {
        let r = n.state.field(Jn, !1);
        if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(_n).interactionDelay)
            return !1;
        let i = 1, s;
        e == "page" && (s = aB(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
        let {length: o} = r.open.options
          , a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
        return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0),
        n.dispatch({
            effects: PB.of(a)
        }),
        !0
    }
}
const DB = t => {
    let e = t.state.field(Jn, !1);
    return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(_n).interactionDelay ? !1 : ox(t, e.open.options[e.open.selected])
}
  , _me = t => t.state.field(Jn, !1) ? (t.dispatch({
    effects: qp.of(!0)
}),
!0) : !1
  , bme = t => {
    let e = t.state.field(Jn, !1);
    return !e || !e.active.some(n => n.state != 0) ? !1 : (t.dispatch({
        effects: eh.of(null)
    }),
    !0)
}
;
class yme {
    constructor(e, n) {
        this.active = e,
        this.context = n,
        this.time = Date.now(),
        this.updates = [],
        this.done = void 0
    }
}
const vme = 50
  , xme = 1e3
  , Eme = xn.fromClass(class {
    constructor(t) {
        this.view = t,
        this.debounceUpdate = -1,
        this.running = [],
        this.debounceAccept = -1,
        this.pendingStart = !1,
        this.composing = 0;
        for (let e of t.state.field(Jn).active)
            e.state == 1 && this.startQuery(e)
    }
    update(t) {
        let e = t.state.field(Jn)
          , n = t.state.facet(_n);
        if (!t.selectionSet && !t.docChanged && t.startState.field(Jn) == e)
            return;
        let r = t.transactions.some(s => {
            let o = RB(s, n);
            return o & 8 || (s.selection || s.docChanged) && !(o & 3)
        }
        );
        for (let s = 0; s < this.running.length; s++) {
            let o = this.running[s];
            if (r || o.updates.length + t.transactions.length > vme && Date.now() - o.time > xme) {
                for (let a of o.context.abortListeners)
                    try {
                        a()
                    } catch (l) {
                        fr(this.view.state, l)
                    }
                o.context.abortListeners = null,
                this.running.splice(s--, 1)
            } else
                o.updates.push(...t.transactions)
        }
        this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
        t.transactions.some(s => s.effects.some(o => o.is(qp))) && (this.pendingStart = !0);
        let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
        if (this.debounceUpdate = e.active.some(s => s.state == 1 && !this.running.some(o => o.active.source == s.source)) ? setTimeout( () => this.startUpdate(), i) : -1,
        this.composing != 0)
            for (let s of t.transactions)
                s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3)
    }
    startUpdate() {
        this.debounceUpdate = -1,
        this.pendingStart = !1;
        let {state: t} = this.view
          , e = t.field(Jn);
        for (let n of e.active)
            n.state == 1 && !this.running.some(r => r.active.source == n.source) && this.startQuery(n)
    }
    startQuery(t) {
        let {state: e} = this.view
          , n = Ms(e)
          , r = new AB(e,n,t.explicitPos == n,this.view)
          , i = new yme(t,r);
        this.running.push(i),
        Promise.resolve(t.source(r)).then(s => {
            i.context.aborted || (i.done = s || null,
            this.scheduleAccept())
        }
        , s => {
            this.view.dispatch({
                effects: eh.of(null)
            }),
            fr(this.view.state, s)
        }
        )
    }
    scheduleAccept() {
        this.running.every(t => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout( () => this.accept(), this.view.state.facet(_n).updateSyncTime))
    }
    accept() {
        var t;
        this.debounceAccept > -1 && clearTimeout(this.debounceAccept),
        this.debounceAccept = -1;
        let e = []
          , n = this.view.state.facet(_n);
        for (let r = 0; r < this.running.length; r++) {
            let i = this.running[r];
            if (i.done === void 0)
                continue;
            if (this.running.splice(r--, 1),
            i.done) {
                let o = new bl(i.active.source,i.active.explicitPos,i.done,i.done.from,(t = i.done.to) !== null && t !== void 0 ? t : Ms(i.updates.length ? i.updates[0].startState : this.view.state));
                for (let a of i.updates)
                    o = o.update(a, n);
                if (o.hasResult()) {
                    e.push(o);
                    continue
                }
            }
            let s = this.view.state.field(Jn).active.find(o => o.source == i.active.source);
            if (s && s.state == 1)
                if (i.done == null) {
                    let o = new dr(i.active.source,0);
                    for (let a of i.updates)
                        o = o.update(a, n);
                    o.state != 1 && e.push(o)
                } else
                    this.startQuery(s)
        }
        e.length && this.view.dispatch({
            effects: IB.of(e)
        })
    }
}
, {
    eventHandlers: {
        blur(t) {
            let e = this.view.state.field(Jn, !1);
            if (e && e.tooltip && this.view.state.facet(_n).closeOnBlur) {
                let n = e.open && aB(this.view, e.open.tooltip);
                (!n || !n.dom.contains(t.relatedTarget)) && setTimeout( () => this.view.dispatch({
                    effects: eh.of(null)
                }), 10)
            }
        },
        compositionstart() {
            this.composing = 1
        },
        compositionend() {
            this.composing == 3 && setTimeout( () => this.view.dispatch({
                effects: qp.of(!1)
            }), 20),
            this.composing = 0
        }
    }
})
  , Sme = typeof navigator == "object" && /Win/.test(navigator.platform)
  , wme = co.highest(Oe.domEventHandlers({
    keydown(t, e) {
        let n = e.state.field(Jn, !1);
        if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(Sme && t.altKey) || t.metaKey)
            return !1;
        let r = n.open.options[n.open.selected]
          , i = n.active.find(o => o.source == r.source)
          , s = r.completion.commitCharacters || i.result.commitCharacters;
        return s && s.indexOf(t.key) > -1 && ox(e, r),
        !1
    }
}))
  , LB = Oe.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            height: "100%",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li, & > completion-section": {
                padding: "1px 3px",
                lineHeight: 1.2
            },
            "& > li": {
                overflowX: "hidden",
                textOverflow: "ellipsis",
                cursor: "pointer"
            },
            "& > completion-section": {
                display: "list-item",
                borderBottom: "1px solid silver",
                paddingLeft: "0.5em",
                opacity: .7
            }
        }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '""',
        opacity: .5,
        display: "block",
        textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: "400px",
        boxSizing: "border-box"
    },
    ".cm-completionInfo.cm-completionInfo-left": {
        right: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-right": {
        left: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-left-narrow": {
        right: "30px"
    },
    ".cm-completionInfo.cm-completionInfo-right-narrow": {
        left: "30px"
    },
    "&light .cm-snippetField": {
        backgroundColor: "#00000022"
    },
    "&dark .cm-snippetField": {
        backgroundColor: "#ffffff22"
    },
    ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        display: "inline-block",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
        textDecoration: "underline"
    },
    ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
    },
    ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6",
        boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-class": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-interface": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-variable": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-constant": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-type": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-enum": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-property": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-keyword": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-namespace": {
        "&:after": {
            content: "''"
        }
    },
    ".cm-completionIcon-text": {
        "&:after": {
            content: "'abc'",
            fontSize: "50%",
            verticalAlign: "middle"
        }
    }
});
class Cme {
    constructor(e, n, r, i) {
        this.field = e,
        this.line = n,
        this.from = r,
        this.to = i
    }
}
class ax {
    constructor(e, n, r) {
        this.field = e,
        this.from = n,
        this.to = r
    }
    map(e) {
        let n = e.mapPos(this.from, -1, kn.TrackDel)
          , r = e.mapPos(this.to, 1, kn.TrackDel);
        return n == null || r == null ? null : new ax(this.field,n,r)
    }
}
class lx {
    constructor(e, n) {
        this.lines = e,
        this.fieldPositions = n
    }
    instantiate(e, n) {
        let r = []
          , i = [n]
          , s = e.doc.lineAt(n)
          , o = /^\s*/.exec(s.text)[0];
        for (let l of this.lines) {
            if (r.length) {
                let c = o
                  , u = /^\t*/.exec(l)[0].length;
                for (let h = 0; h < u; h++)
                    c += e.facet(Ql);
                i.push(n + c.length - u),
                l = c + l.slice(u)
            }
            r.push(l),
            n += l.length + 1
        }
        let a = this.fieldPositions.map(l => new ax(l.field,i[l.line] + l.from,i[l.line] + l.to));
        return {
            text: r,
            ranges: a
        }
    }
    static parse(e) {
        let n = [], r = [], i = [], s;
        for (let o of e.split(/\r\n?|\n/)) {
            for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o); ) {
                let a = s[1] ? +s[1] : null
                  , l = s[2] || s[3] || ""
                  , c = -1
                  , u = l.replace(/\\[{}]/g, h => h[1]);
                for (let h = 0; h < n.length; h++)
                    (a != null ? n[h].seq == a : u && n[h].name == u) && (c = h);
                if (c < 0) {
                    let h = 0;
                    for (; h < n.length && (a == null || n[h].seq != null && n[h].seq < a); )
                        h++;
                    n.splice(h, 0, {
                        seq: a,
                        name: u
                    }),
                    c = h;
                    for (let d of i)
                        d.field >= c && d.field++
                }
                i.push(new Cme(c,r.length,s.index,s.index + u.length)),
                o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length)
            }
            o = o.replace(/\\([{}])/g, (a, l, c) => {
                for (let u of i)
                    u.line == r.length && u.from > c && (u.from--,
                    u.to--);
                return l
            }
            ),
            r.push(o)
        }
        return new lx(r,i)
    }
}
let Tme = at.widget({
    widget: new class extends Xl {
        toDOM() {
            let t = document.createElement("span");
            return t.className = "cm-snippetFieldPosition",
            t
        }
        ignoreEvent() {
            return !1
        }
    }
})
  , Ame = at.mark({
    class: "cm-snippetField"
});
class Jl {
    constructor(e, n) {
        this.ranges = e,
        this.active = n,
        this.deco = at.set(e.map(r => (r.from == r.to ? Tme : Ame).range(r.from, r.to)))
    }
    map(e) {
        let n = [];
        for (let r of this.ranges) {
            let i = r.map(e);
            if (!i)
                return null;
            n.push(i)
        }
        return new Jl(n,this.active)
    }
    selectionInsideField(e) {
        return e.ranges.every(n => this.ranges.some(r => r.field == this.active && r.from <= n.from && r.to >= n.to))
    }
}
const sd = Je.define({
    map(t, e) {
        return t && t.map(e)
    }
})
  , kme = Je.define()
  , th = Qt.define({
    create() {
        return null
    },
    update(t, e) {
        for (let n of e.effects) {
            if (n.is(sd))
                return n.value;
            if (n.is(kme) && t)
                return new Jl(t.ranges,n.value)
        }
        return t && e.docChanged && (t = t.map(e.changes)),
        t && e.selection && !t.selectionInsideField(e.selection) && (t = null),
        t
    },
    provide: t => Oe.decorations.from(t, e => e ? e.deco : at.none)
});
function cx(t, e) {
    return ge.create(t.filter(n => n.field == e).map(n => ge.range(n.from, n.to)))
}
function Rme(t) {
    let e = lx.parse(t);
    return (n, r, i, s) => {
        let {text: o, ranges: a} = e.instantiate(n.state, i)
          , l = {
            changes: {
                from: i,
                to: s,
                insert: gt.of(o)
            },
            scrollIntoView: !0,
            annotations: r ? [sx.of(r), Yt.userEvent.of("input.complete")] : void 0
        };
        if (a.length && (l.selection = cx(a, 0)),
        a.some(c => c.field > 0)) {
            let c = new Jl(a,0)
              , u = l.effects = [sd.of(c)];
            n.state.field(th, !1) === void 0 && u.push(Je.appendConfig.of([th, Ome, Nme, LB]))
        }
        n.dispatch(n.state.update(l))
    }
}
function OB(t) {
    return ({state: e, dispatch: n}) => {
        let r = e.field(th, !1);
        if (!r || t < 0 && r.active == 0)
            return !1;
        let i = r.active + t
          , s = t > 0 && !r.ranges.some(o => o.field == i + t);
        return n(e.update({
            selection: cx(r.ranges, i),
            effects: sd.of(s ? null : new Jl(r.ranges,i)),
            scrollIntoView: !0
        })),
        !0
    }
}
const Ime = ({state: t, dispatch: e}) => t.field(th, !1) ? (e(t.update({
    effects: sd.of(null)
})),
!0) : !1
  , Pme = OB(1)
  , Dme = OB(-1)
  , Lme = [{
    key: "Tab",
    run: Pme,
    shift: Dme
}, {
    key: "Escape",
    run: Ime
}]
  , vA = Me.define({
    combine(t) {
        return t.length ? t[0] : Lme
    }
})
  , Ome = co.highest(hg.compute([vA], t => t.facet(vA)));
function Eve(t, e) {
    return Object.assign(Object.assign({}, e), {
        apply: Rme(t)
    })
}
const Nme = Oe.domEventHandlers({
    mousedown(t, e) {
        let n = e.state.field(th, !1), r;
        if (!n || (r = e.posAtCoords({
            x: t.clientX,
            y: t.clientY
        })) == null)
            return !1;
        let i = n.ranges.find(s => s.from <= r && s.to >= r);
        return !i || i.field == n.active ? !1 : (e.dispatch({
            selection: cx(n.ranges, i.field),
            effects: sd.of(n.ranges.some(s => s.field > i.field) ? new Jl(n.ranges,i.field) : null),
            scrollIntoView: !0
        }),
        !0)
    }
})
  , Yp = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
}
  , Oo = Je.define({
    map(t, e) {
        let n = e.mapPos(t, -1, kn.TrackAfter);
        return n ?? void 0
    }
})
  , ux = new class extends aa {
}
;
ux.startSide = 1;
ux.endSide = -1;
const NB = Qt.define({
    create() {
        return dt.empty
    },
    update(t, e) {
        if (t = t.map(e.changes),
        e.selection) {
            let n = e.state.doc.lineAt(e.selection.main.head);
            t = t.update({
                filter: r => r >= n.from && r <= n.to
            })
        }
        for (let n of e.effects)
            n.is(Oo) && (t = t.update({
                add: [ux.range(n.value, n.value + 1)]
            }));
        return t
    }
});
function Mme() {
    return [Hme, NB]
}
const K0 = "()[]{}<>";
function Bme(t) {
    for (let e = 0; e < K0.length; e += 2)
        if (K0.charCodeAt(e) == t)
            return K0.charAt(e + 1);
    return $1(t < 128 ? t : t + 1)
}
function Fme(t, e) {
    return t.languageDataAt("closeBrackets", e)[0] || Yp
}
const jme = typeof navigator == "object" && /Android\b/.test(navigator.userAgent)
  , Hme = Oe.inputHandler.of( (t, e, n, r) => {
    if ((jme ? t.composing : t.compositionStarted) || t.state.readOnly)
        return !1;
    let i = t.state.selection.main;
    if (r.length > 2 || r.length == 2 && Wr(Xn(r, 0)) == 1 || e != i.from || n != i.to)
        return !1;
    let s = Ume(t.state, r);
    return s ? (t.dispatch(s),
    !0) : !1
}
);
function Ume(t, e) {
    let n = Fme(t, t.selection.main.head)
      , r = n.brackets || Yp.brackets;
    for (let i of r) {
        let s = Bme(Xn(i, 0));
        if (e == i)
            return s == i ? zme(t, i, r.indexOf(i + i + i) > -1, n) : Vme(t, i, s, n.before || Yp.before);
        if (e == s && MB(t, t.selection.main.from))
            return $me(t, i, s)
    }
    return null
}
function MB(t, e) {
    let n = !1;
    return t.field(NB).between(0, t.doc.length, r => {
        r == e && (n = !0)
    }
    ),
    n
}
function hx(t, e) {
    let n = t.sliceString(e, e + 2);
    return n.slice(0, Wr(Xn(n, 0)))
}
function Vme(t, e, n, r) {
    let i = null
      , s = t.changeByRange(o => {
        if (!o.empty)
            return {
                changes: [{
                    insert: e,
                    from: o.from
                }, {
                    insert: n,
                    from: o.to
                }],
                effects: Oo.of(o.to + e.length),
                range: ge.range(o.anchor + e.length, o.head + e.length)
            };
        let a = hx(t.doc, o.head);
        return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
            changes: {
                insert: e + n,
                from: o.head
            },
            effects: Oo.of(o.head + e.length),
            range: ge.cursor(o.head + e.length)
        } : {
            range: i = o
        }
    }
    );
    return i ? null : t.update(s, {
        scrollIntoView: !0,
        userEvent: "input.type"
    })
}
function $me(t, e, n) {
    let r = null
      , i = t.changeByRange(s => s.empty && hx(t.doc, s.head) == n ? {
        changes: {
            from: s.head,
            to: s.head + n.length,
            insert: n
        },
        range: ge.cursor(s.head + n.length)
    } : r = {
        range: s
    });
    return r ? null : t.update(i, {
        scrollIntoView: !0,
        userEvent: "input.type"
    })
}
function zme(t, e, n, r) {
    let i = r.stringPrefixes || Yp.stringPrefixes
      , s = null
      , o = t.changeByRange(a => {
        if (!a.empty)
            return {
                changes: [{
                    insert: e,
                    from: a.from
                }, {
                    insert: e,
                    from: a.to
                }],
                effects: Oo.of(a.to + e.length),
                range: ge.range(a.anchor + e.length, a.head + e.length)
            };
        let l = a.head, c = hx(t.doc, l), u;
        if (c == e) {
            if (xA(t, l))
                return {
                    changes: {
                        insert: e + e,
                        from: l
                    },
                    effects: Oo.of(l + e.length),
                    range: ge.cursor(l + e.length)
                };
            if (MB(t, l)) {
                let d = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
                return {
                    changes: {
                        from: l,
                        to: l + d.length,
                        insert: d
                    },
                    range: ge.cursor(l + d.length)
                }
            }
        } else {
            if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = EA(t, l - 2 * e.length, i)) > -1 && xA(t, u))
                return {
                    changes: {
                        insert: e + e + e + e,
                        from: l
                    },
                    effects: Oo.of(l + e.length),
                    range: ge.cursor(l + e.length)
                };
            if (t.charCategorizer(l)(c) != Xt.Word && EA(t, l, i) > -1 && !Wme(t, l, e, i))
                return {
                    changes: {
                        insert: e + e,
                        from: l
                    },
                    effects: Oo.of(l + e.length),
                    range: ge.cursor(l + e.length)
                }
        }
        return {
            range: s = a
        }
    }
    );
    return s ? null : t.update(o, {
        scrollIntoView: !0,
        userEvent: "input.type"
    })
}
function xA(t, e) {
    let n = En(t).resolveInner(e + 1);
    return n.parent && n.from == e
}
function Wme(t, e, n, r) {
    let i = En(t).resolveInner(e, -1)
      , s = r.reduce( (o, a) => Math.max(o, a.length), 0);
    for (let o = 0; o < 5; o++) {
        let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + s))
          , l = a.indexOf(n);
        if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
            let u = i.firstChild;
            for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
                if (t.sliceDoc(u.to - n.length, u.to) == n)
                    return !1;
                u = u.firstChild
            }
            return !0
        }
        let c = i.to == e && i.parent;
        if (!c)
            break;
        i = c
    }
    return !1
}
function EA(t, e, n) {
    let r = t.charCategorizer(e);
    if (r(t.sliceDoc(e - 1, e)) != Xt.Word)
        return e;
    for (let i of n) {
        let s = e - i.length;
        if (t.sliceDoc(s, e) == i && r(t.sliceDoc(s - 1, s)) != Xt.Word)
            return s
    }
    return -1
}
function Gme(t={}) {
    return [wme, Jn, _n.of(t), Eme, Kme, LB]
}
const qme = [{
    key: "Ctrl-Space",
    run: _me
}, {
    key: "Escape",
    run: bme
}, {
    key: "ArrowDown",
    run: Zd(!0)
}, {
    key: "ArrowUp",
    run: Zd(!1)
}, {
    key: "PageDown",
    run: Zd(!0, "page")
}, {
    key: "PageUp",
    run: Zd(!1, "page")
}, {
    key: "Enter",
    run: DB
}]
  , Kme = co.highest(hg.computeN([_n], t => t.facet(_n).defaultKeymap ? [qme] : []))
  , Yme = t => {
    let {state: e} = t
      , n = e.doc.lineAt(e.selection.main.from)
      , r = fx(t.state, n.from);
    return r.line ? Xme(t) : r.block ? Jme(t) : !1
}
;
function dx(t, e) {
    return ({state: n, dispatch: r}) => {
        if (n.readOnly)
            return !1;
        let i = t(e, n);
        return i ? (r(n.update(i)),
        !0) : !1
    }
}
const Xme = dx(tge, 0)
  , Qme = dx(BB, 0)
  , Jme = dx( (t, e) => BB(t, e, ege(e)), 0);
function fx(t, e) {
    let n = t.languageDataAt("commentTokens", e);
    return n.length ? n[0] : {}
}
const bc = 50;
function Zme(t, {open: e, close: n}, r, i) {
    let s = t.sliceDoc(r - bc, r)
      , o = t.sliceDoc(i, i + bc)
      , a = /\s*$/.exec(s)[0].length
      , l = /^\s*/.exec(o)[0].length
      , c = s.length - a;
    if (s.slice(c - e.length, c) == e && o.slice(l, l + n.length) == n)
        return {
            open: {
                pos: r - a,
                margin: a && 1
            },
            close: {
                pos: i + l,
                margin: l && 1
            }
        };
    let u, h;
    i - r <= 2 * bc ? u = h = t.sliceDoc(r, i) : (u = t.sliceDoc(r, r + bc),
    h = t.sliceDoc(i - bc, i));
    let d = /^\s*/.exec(u)[0].length
      , f = /\s*$/.exec(h)[0].length
      , g = h.length - f - n.length;
    return u.slice(d, d + e.length) == e && h.slice(g, g + n.length) == n ? {
        open: {
            pos: r + d + e.length,
            margin: /\s/.test(u.charAt(d + e.length)) ? 1 : 0
        },
        close: {
            pos: i - f - n.length,
            margin: /\s/.test(h.charAt(g - 1)) ? 1 : 0
        }
    } : null
}
function ege(t) {
    let e = [];
    for (let n of t.selection.ranges) {
        let r = t.doc.lineAt(n.from)
          , i = n.to <= r.to ? r : t.doc.lineAt(n.to)
          , s = e.length - 1;
        s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({
            from: r.from + /^\s*/.exec(r.text)[0].length,
            to: i.to
        })
    }
    return e
}
function BB(t, e, n=e.selection.ranges) {
    let r = n.map(s => fx(e, s.from).block);
    if (!r.every(s => s))
        return null;
    let i = n.map( (s, o) => Zme(e, r[o], s.from, s.to));
    if (t != 2 && !i.every(s => s))
        return {
            changes: e.changes(n.map( (s, o) => i[o] ? [] : [{
                from: s.from,
                insert: r[o].open + " "
            }, {
                from: s.to,
                insert: " " + r[o].close
            }]))
        };
    if (t != 1 && i.some(s => s)) {
        let s = [];
        for (let o = 0, a; o < i.length; o++)
            if (a = i[o]) {
                let l = r[o]
                  , {open: c, close: u} = a;
                s.push({
                    from: c.pos - l.open.length,
                    to: c.pos + c.margin
                }, {
                    from: u.pos - u.margin,
                    to: u.pos + l.close.length
                })
            }
        return {
            changes: s
        }
    }
    return null
}
function tge(t, e, n=e.selection.ranges) {
    let r = []
      , i = -1;
    for (let {from: s, to: o} of n) {
        let a = r.length
          , l = 1e9
          , c = fx(e, s).line;
        if (c) {
            for (let u = s; u <= o; ) {
                let h = e.doc.lineAt(u);
                if (h.from > i && (s == o || o > h.from)) {
                    i = h.from;
                    let d = /^\s*/.exec(h.text)[0].length
                      , f = d == h.length
                      , g = h.text.slice(d, d + c.length) == c ? d : -1;
                    d < h.text.length && d < l && (l = d),
                    r.push({
                        line: h,
                        comment: g,
                        token: c,
                        indent: d,
                        empty: f,
                        single: !1
                    })
                }
                u = h.to + 1
            }
            if (l < 1e9)
                for (let u = a; u < r.length; u++)
                    r[u].indent < r[u].line.text.length && (r[u].indent = l);
            r.length == a + 1 && (r[a].single = !0)
        }
    }
    if (t != 2 && r.some(s => s.comment < 0 && (!s.empty || s.single))) {
        let s = [];
        for (let {line: a, token: l, indent: c, empty: u, single: h} of r)
            (h || !u) && s.push({
                from: a.from + c,
                insert: l + " "
            });
        let o = e.changes(s);
        return {
            changes: o,
            selection: e.selection.map(o, 1)
        }
    } else if (t != 1 && r.some(s => s.comment >= 0)) {
        let s = [];
        for (let {line: o, comment: a, token: l} of r)
            if (a >= 0) {
                let c = o.from + a
                  , u = c + l.length;
                o.text[u - o.from] == " " && u++,
                s.push({
                    from: c,
                    to: u
                })
            }
        return {
            changes: s
        }
    }
    return null
}
const hy = fs.define()
  , nge = fs.define()
  , rge = Me.define()
  , FB = Me.define({
    combine(t) {
        return Aa(t, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (e, n) => n
        }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
        })
    }
})
  , jB = Qt.define({
    create() {
        return wi.empty
    },
    update(t, e) {
        let n = e.state.facet(FB)
          , r = e.annotation(hy);
        if (r) {
            let l = er.fromTransaction(e, r.selection)
              , c = r.side
              , u = c == 0 ? t.undone : t.done;
            return l ? u = Xp(u, u.length, n.minDepth, l) : u = VB(u, e.startState.selection),
            new wi(c == 0 ? r.rest : u,c == 0 ? u : r.rest)
        }
        let i = e.annotation(nge);
        if ((i == "full" || i == "before") && (t = t.isolate()),
        e.annotation(Yt.addToHistory) === !1)
            return e.changes.empty ? t : t.addMapping(e.changes.desc);
        let s = er.fromTransaction(e)
          , o = e.annotation(Yt.time)
          , a = e.annotation(Yt.userEvent);
        return s ? t = t.addChanges(s, o, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, o, a, n.newGroupDelay)),
        (i == "full" || i == "after") && (t = t.isolate()),
        t
    },
    toJSON(t) {
        return {
            done: t.done.map(e => e.toJSON()),
            undone: t.undone.map(e => e.toJSON())
        }
    },
    fromJSON(t) {
        return new wi(t.done.map(er.fromJSON),t.undone.map(er.fromJSON))
    }
});
function ige(t={}) {
    return [jB, FB.of(t), Oe.domEventHandlers({
        beforeinput(e, n) {
            let r = e.inputType == "historyUndo" ? HB : e.inputType == "historyRedo" ? dy : null;
            return r ? (e.preventDefault(),
            r(n)) : !1
        }
    })]
}
function pg(t, e) {
    return function({state: n, dispatch: r}) {
        if (!e && n.readOnly)
            return !1;
        let i = n.field(jB, !1);
        if (!i)
            return !1;
        let s = i.pop(t, n, e);
        return s ? (r(s),
        !0) : !1
    }
}
const HB = pg(0, !1)
  , dy = pg(1, !1)
  , sge = pg(0, !0)
  , oge = pg(1, !0);
class er {
    constructor(e, n, r, i, s) {
        this.changes = e,
        this.effects = n,
        this.mapped = r,
        this.startSelection = i,
        this.selectionsAfter = s
    }
    setSelAfter(e) {
        return new er(this.changes,this.effects,this.mapped,this.startSelection,e)
    }
    toJSON() {
        var e, n, r;
        return {
            changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
            mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
            startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
            selectionsAfter: this.selectionsAfter.map(i => i.toJSON())
        }
    }
    static fromJSON(e) {
        return new er(e.changes && Zt.fromJSON(e.changes),[],e.mapped && Ri.fromJSON(e.mapped),e.startSelection && ge.fromJSON(e.startSelection),e.selectionsAfter.map(ge.fromJSON))
    }
    static fromTransaction(e, n) {
        let r = kr;
        for (let i of e.startState.facet(rge)) {
            let s = i(e);
            s.length && (r = r.concat(s))
        }
        return !r.length && e.changes.empty ? null : new er(e.changes.invert(e.startState.doc),r,void 0,n || e.startState.selection,kr)
    }
    static selection(e) {
        return new er(void 0,kr,void 0,void 0,e)
    }
}
function Xp(t, e, n, r) {
    let i = e + 1 > n + 20 ? e - n - 1 : 0
      , s = t.slice(i, e);
    return s.push(r),
    s
}
function age(t, e) {
    let n = []
      , r = !1;
    return t.iterChangedRanges( (i, s) => n.push(i, s)),
    e.iterChangedRanges( (i, s, o, a) => {
        for (let l = 0; l < n.length; ) {
            let c = n[l++]
              , u = n[l++];
            a >= c && o <= u && (r = !0)
        }
    }
    ),
    r
}
function lge(t, e) {
    return t.ranges.length == e.ranges.length && t.ranges.filter( (n, r) => n.empty != e.ranges[r].empty).length === 0
}
function UB(t, e) {
    return t.length ? e.length ? t.concat(e) : t : e
}
const kr = []
  , cge = 200;
function VB(t, e) {
    if (t.length) {
        let n = t[t.length - 1]
          , r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - cge));
        return r.length && r[r.length - 1].eq(e) ? t : (r.push(e),
        Xp(t, t.length - 1, 1e9, n.setSelAfter(r)))
    } else
        return [er.selection([e])]
}
function uge(t) {
    let e = t[t.length - 1]
      , n = t.slice();
    return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)),
    n
}
function Y0(t, e) {
    if (!t.length)
        return t;
    let n = t.length
      , r = kr;
    for (; n; ) {
        let i = hge(t[n - 1], e, r);
        if (i.changes && !i.changes.empty || i.effects.length) {
            let s = t.slice(0, n);
            return s[n - 1] = i,
            s
        } else
            e = i.mapped,
            n--,
            r = i.selectionsAfter
    }
    return r.length ? [er.selection(r)] : kr
}
function hge(t, e, n) {
    let r = UB(t.selectionsAfter.length ? t.selectionsAfter.map(a => a.map(e)) : kr, n);
    if (!t.changes)
        return er.selection(r);
    let i = t.changes.map(e)
      , s = e.mapDesc(t.changes, !0)
      , o = t.mapped ? t.mapped.composeDesc(s) : s;
    return new er(i,Je.mapEffects(t.effects, e),o,t.startSelection.map(s),r)
}
const dge = /^(input\.type|delete)($|\.)/;
class wi {
    constructor(e, n, r=0, i=void 0) {
        this.done = e,
        this.undone = n,
        this.prevTime = r,
        this.prevUserEvent = i
    }
    isolate() {
        return this.prevTime ? new wi(this.done,this.undone) : this
    }
    addChanges(e, n, r, i, s) {
        let o = this.done
          , a = o[o.length - 1];
        return a && a.changes && !a.changes.empty && e.changes && (!r || dge.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(s, age(a.changes, e.changes)) || r == "input.type.compose") ? o = Xp(o, o.length - 1, i.minDepth, new er(e.changes.compose(a.changes),UB(e.effects, a.effects),a.mapped,a.startSelection,kr)) : o = Xp(o, o.length, i.minDepth, e),
        new wi(o,kr,n,r)
    }
    addSelection(e, n, r, i) {
        let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : kr;
        return s.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && lge(s[s.length - 1], e) ? this : new wi(VB(this.done, e),this.undone,n,r)
    }
    addMapping(e) {
        return new wi(Y0(this.done, e),Y0(this.undone, e),this.prevTime,this.prevUserEvent)
    }
    pop(e, n, r) {
        let i = e == 0 ? this.done : this.undone;
        if (i.length == 0)
            return null;
        let s = i[i.length - 1]
          , o = s.selectionsAfter[0] || n.selection;
        if (r && s.selectionsAfter.length)
            return n.update({
                selection: s.selectionsAfter[s.selectionsAfter.length - 1],
                annotations: hy.of({
                    side: e,
                    rest: uge(i),
                    selection: o
                }),
                userEvent: e == 0 ? "select.undo" : "select.redo",
                scrollIntoView: !0
            });
        if (s.changes) {
            let a = i.length == 1 ? kr : i.slice(0, i.length - 1);
            return s.mapped && (a = Y0(a, s.mapped)),
            n.update({
                changes: s.changes,
                selection: s.startSelection,
                effects: s.effects,
                annotations: hy.of({
                    side: e,
                    rest: a,
                    selection: o
                }),
                filter: !1,
                userEvent: e == 0 ? "undo" : "redo",
                scrollIntoView: !0
            })
        } else
            return null
    }
}
wi.empty = new wi(kr,kr);
const fge = [{
    key: "Mod-z",
    run: HB,
    preventDefault: !0
}, {
    key: "Mod-y",
    mac: "Mod-Shift-z",
    run: dy,
    preventDefault: !0
}, {
    linux: "Ctrl-Shift-z",
    run: dy,
    preventDefault: !0
}, {
    key: "Mod-u",
    run: sge,
    preventDefault: !0
}, {
    key: "Alt-u",
    mac: "Mod-Shift-u",
    run: oge,
    preventDefault: !0
}];
function Zl(t, e) {
    return ge.create(t.ranges.map(e), t.mainIndex)
}
function Mi(t, e) {
    return t.update({
        selection: e,
        scrollIntoView: !0,
        userEvent: "select"
    })
}
function oi({state: t, dispatch: e}, n) {
    let r = Zl(t.selection, n);
    return r.eq(t.selection, !0) ? !1 : (e(Mi(t, r)),
    !0)
}
function mg(t, e) {
    return ge.cursor(e ? t.to : t.from)
}
function $B(t, e) {
    return oi(t, n => n.empty ? t.moveByChar(n, e) : mg(n, e))
}
function Mn(t) {
    return t.textDirectionAt(t.state.selection.main.head) == Nt.LTR
}
const zB = t => $B(t, !Mn(t))
  , WB = t => $B(t, Mn(t));
function GB(t, e) {
    return oi(t, n => n.empty ? t.moveByGroup(n, e) : mg(n, e))
}
const pge = t => GB(t, !Mn(t))
  , mge = t => GB(t, Mn(t));
function gge(t, e, n) {
    if (e.type.prop(n))
        return !0;
    let r = e.to - e.from;
    return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild
}
function gg(t, e, n) {
    let r = En(t).resolveInner(e.head)
      , i = n ? ot.closedBy : ot.openedBy;
    for (let l = e.head; ; ) {
        let c = n ? r.childAfter(l) : r.childBefore(l);
        if (!c)
            break;
        gge(t, c, i) ? r = c : l = n ? c.to : c.from
    }
    let s = r.type.prop(i), o, a;
    return s && (o = n ? Si(t, r.from, 1) : Si(t, r.to, -1)) && o.matched ? a = n ? o.end.to : o.end.from : a = n ? r.to : r.from,
    ge.cursor(a, n ? -1 : 1)
}
const _ge = t => oi(t, e => gg(t.state, e, !Mn(t)))
  , bge = t => oi(t, e => gg(t.state, e, Mn(t)));
function qB(t, e) {
    return oi(t, n => {
        if (!n.empty)
            return mg(n, e);
        let r = t.moveVertically(n, e);
        return r.head != n.head ? r : t.moveToLineBoundary(n, e)
    }
    )
}
const KB = t => qB(t, !1)
  , YB = t => qB(t, !0);
function XB(t) {
    let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
    if (e) {
        for (let s of t.state.facet(Oe.scrollMargins)) {
            let o = s(t);
            o?.top && (n = Math.max(o?.top, n)),
            o?.bottom && (r = Math.max(o?.bottom, r))
        }
        i = t.scrollDOM.clientHeight - n - r
    } else
        i = (t.dom.ownerDocument.defaultView || window).innerHeight;
    return {
        marginTop: n,
        marginBottom: r,
        selfScroll: e,
        height: Math.max(t.defaultLineHeight, i - 5)
    }
}
function QB(t, e) {
    let n = XB(t)
      , {state: r} = t
      , i = Zl(r.selection, o => o.empty ? t.moveVertically(o, e, n.height) : mg(o, e));
    if (i.eq(r.selection))
        return !1;
    let s;
    if (n.selfScroll) {
        let o = t.coordsAtPos(r.selection.main.head)
          , a = t.scrollDOM.getBoundingClientRect()
          , l = a.top + n.marginTop
          , c = a.bottom - n.marginBottom;
        o && o.top > l && o.bottom < c && (s = Oe.scrollIntoView(i.main.head, {
            y: "start",
            yMargin: o.top - l
        }))
    }
    return t.dispatch(Mi(r, i), {
        effects: s
    }),
    !0
}
const SA = t => QB(t, !1)
  , fy = t => QB(t, !0);
function uo(t, e, n) {
    let r = t.lineBlockAt(e.head)
      , i = t.moveToLineBoundary(e, n);
    if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, !1)),
    !n && i.head == r.from && r.length) {
        let s = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
        s && e.head != r.from + s && (i = ge.cursor(r.from + s))
    }
    return i
}
const yge = t => oi(t, e => uo(t, e, !0))
  , vge = t => oi(t, e => uo(t, e, !1))
  , xge = t => oi(t, e => uo(t, e, !Mn(t)))
  , Ege = t => oi(t, e => uo(t, e, Mn(t)))
  , Sge = t => oi(t, e => ge.cursor(t.lineBlockAt(e.head).from, 1))
  , wge = t => oi(t, e => ge.cursor(t.lineBlockAt(e.head).to, -1));
function Cge(t, e, n) {
    let r = !1
      , i = Zl(t.selection, s => {
        let o = Si(t, s.head, -1) || Si(t, s.head, 1) || s.head > 0 && Si(t, s.head - 1, 1) || s.head < t.doc.length && Si(t, s.head + 1, -1);
        if (!o || !o.end)
            return s;
        r = !0;
        let a = o.start.from == s.head ? o.end.to : o.end.from;
        return ge.cursor(a)
    }
    );
    return r ? (e(Mi(t, i)),
    !0) : !1
}
const Tge = ({state: t, dispatch: e}) => Cge(t, e);
function Hr(t, e) {
    let n = Zl(t.state.selection, r => {
        let i = e(r);
        return ge.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0)
    }
    );
    return n.eq(t.state.selection) ? !1 : (t.dispatch(Mi(t.state, n)),
    !0)
}
function JB(t, e) {
    return Hr(t, n => t.moveByChar(n, e))
}
const ZB = t => JB(t, !Mn(t))
  , eF = t => JB(t, Mn(t));
function tF(t, e) {
    return Hr(t, n => t.moveByGroup(n, e))
}
const Age = t => tF(t, !Mn(t))
  , kge = t => tF(t, Mn(t))
  , Rge = t => Hr(t, e => gg(t.state, e, !Mn(t)))
  , Ige = t => Hr(t, e => gg(t.state, e, Mn(t)));
function nF(t, e) {
    return Hr(t, n => t.moveVertically(n, e))
}
const rF = t => nF(t, !1)
  , iF = t => nF(t, !0);
function sF(t, e) {
    return Hr(t, n => t.moveVertically(n, e, XB(t).height))
}
const wA = t => sF(t, !1)
  , CA = t => sF(t, !0)
  , Pge = t => Hr(t, e => uo(t, e, !0))
  , Dge = t => Hr(t, e => uo(t, e, !1))
  , Lge = t => Hr(t, e => uo(t, e, !Mn(t)))
  , Oge = t => Hr(t, e => uo(t, e, Mn(t)))
  , Nge = t => Hr(t, e => ge.cursor(t.lineBlockAt(e.head).from))
  , Mge = t => Hr(t, e => ge.cursor(t.lineBlockAt(e.head).to))
  , TA = ({state: t, dispatch: e}) => (e(Mi(t, {
    anchor: 0
})),
!0)
  , AA = ({state: t, dispatch: e}) => (e(Mi(t, {
    anchor: t.doc.length
})),
!0)
  , kA = ({state: t, dispatch: e}) => (e(Mi(t, {
    anchor: t.selection.main.anchor,
    head: 0
})),
!0)
  , RA = ({state: t, dispatch: e}) => (e(Mi(t, {
    anchor: t.selection.main.anchor,
    head: t.doc.length
})),
!0)
  , Bge = ({state: t, dispatch: e}) => (e(t.update({
    selection: {
        anchor: 0,
        head: t.doc.length
    },
    userEvent: "select"
})),
!0)
  , Fge = ({state: t, dispatch: e}) => {
    let n = _g(t).map( ({from: r, to: i}) => ge.range(r, Math.min(i + 1, t.doc.length)));
    return e(t.update({
        selection: ge.create(n),
        userEvent: "select"
    })),
    !0
}
  , jge = ({state: t, dispatch: e}) => {
    let n = Zl(t.selection, r => {
        var i;
        let s = En(t).resolveStack(r.from, 1);
        for (let o = s; o; o = o.next) {
            let {node: a} = o;
            if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && (!((i = a.parent) === null || i === void 0) && i.parent))
                return ge.range(a.to, a.from)
        }
        return r
    }
    );
    return e(Mi(t, n)),
    !0
}
  , Hge = ({state: t, dispatch: e}) => {
    let n = t.selection
      , r = null;
    return n.ranges.length > 1 ? r = ge.create([n.main]) : n.main.empty || (r = ge.create([ge.cursor(n.main.head)])),
    r ? (e(Mi(t, r)),
    !0) : !1
}
;
function od(t, e) {
    if (t.state.readOnly)
        return !1;
    let n = "delete.selection"
      , {state: r} = t
      , i = r.changeByRange(s => {
        let {from: o, to: a} = s;
        if (o == a) {
            let l = e(s);
            l < o ? (n = "delete.backward",
            l = ef(t, l, !1)) : l > o && (n = "delete.forward",
            l = ef(t, l, !0)),
            o = Math.min(o, l),
            a = Math.max(a, l)
        } else
            o = ef(t, o, !1),
            a = ef(t, a, !0);
        return o == a ? {
            range: s
        } : {
            changes: {
                from: o,
                to: a
            },
            range: ge.cursor(o, o < s.head ? -1 : 1)
        }
    }
    );
    return i.changes.empty ? !1 : (t.dispatch(r.update(i, {
        scrollIntoView: !0,
        userEvent: n,
        effects: n == "delete.selection" ? Oe.announce.of(r.phrase("Selection deleted")) : void 0
    })),
    !0)
}
function ef(t, e, n) {
    if (t instanceof Oe)
        for (let r of t.state.facet(Oe.atomicRanges).map(i => i(t)))
            r.between(e, e, (i, s) => {
                i < e && s > e && (e = n ? s : i)
            }
            );
    return e
}
const oF = (t, e, n) => od(t, r => {
    let i = r.from, {state: s} = t, o = s.doc.lineAt(i), a, l;
    if (n && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, i - o.from))) {
        if (a[a.length - 1] == "	")
            return i - 1;
        let c = lg(a, s.tabSize)
          , u = c % Wp(s) || Wp(s);
        for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++)
            i--;
        l = i
    } else
        l = yn(o.text, i - o.from, e, e) + o.from,
        l == i && o.number != (e ? s.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, i - o.from)) && (l = yn(o.text, l - o.from, !1, !1) + o.from);
    return l
}
)
  , py = t => oF(t, !1, !0)
  , aF = t => oF(t, !0, !1)
  , lF = (t, e) => od(t, n => {
    let r = n.head
      , {state: i} = t
      , s = i.doc.lineAt(r)
      , o = i.charCategorizer(r);
    for (let a = null; ; ) {
        if (r == (e ? s.to : s.from)) {
            r == n.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
            break
        }
        let l = yn(s.text, r - s.from, e) + s.from
          , c = s.text.slice(Math.min(r, l) - s.from, Math.max(r, l) - s.from)
          , u = o(c);
        if (a != null && u != a)
            break;
        (c != " " || r != n.head) && (a = u),
        r = l
    }
    return r
}
)
  , cF = t => lF(t, !1)
  , Uge = t => lF(t, !0)
  , Vge = t => od(t, e => {
    let n = t.lineBlockAt(e.head).to;
    return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1)
}
)
  , $ge = t => od(t, e => {
    let n = t.moveToLineBoundary(e, !1).head;
    return e.head > n ? n : Math.max(0, e.head - 1)
}
)
  , zge = t => od(t, e => {
    let n = t.moveToLineBoundary(e, !0).head;
    return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1)
}
)
  , Wge = ({state: t, dispatch: e}) => {
    if (t.readOnly)
        return !1;
    let n = t.changeByRange(r => ({
        changes: {
            from: r.from,
            to: r.to,
            insert: gt.of(["", ""])
        },
        range: ge.cursor(r.from)
    }));
    return e(t.update(n, {
        scrollIntoView: !0,
        userEvent: "input"
    })),
    !0
}
  , Gge = ({state: t, dispatch: e}) => {
    if (t.readOnly)
        return !1;
    let n = t.changeByRange(r => {
        if (!r.empty || r.from == 0 || r.from == t.doc.length)
            return {
                range: r
            };
        let i = r.from
          , s = t.doc.lineAt(i)
          , o = i == s.from ? i - 1 : yn(s.text, i - s.from, !1) + s.from
          , a = i == s.to ? i + 1 : yn(s.text, i - s.from, !0) + s.from;
        return {
            changes: {
                from: o,
                to: a,
                insert: t.doc.slice(i, a).append(t.doc.slice(o, i))
            },
            range: ge.cursor(a)
        }
    }
    );
    return n.changes.empty ? !1 : (e(t.update(n, {
        scrollIntoView: !0,
        userEvent: "move.character"
    })),
    !0)
}
;
function _g(t) {
    let e = []
      , n = -1;
    for (let r of t.selection.ranges) {
        let i = t.doc.lineAt(r.from)
          , s = t.doc.lineAt(r.to);
        if (!r.empty && r.to == s.from && (s = t.doc.lineAt(r.to - 1)),
        n >= i.number) {
            let o = e[e.length - 1];
            o.to = s.to,
            o.ranges.push(r)
        } else
            e.push({
                from: i.from,
                to: s.to,
                ranges: [r]
            });
        n = s.number + 1
    }
    return e
}
function uF(t, e, n) {
    if (t.readOnly)
        return !1;
    let r = []
      , i = [];
    for (let s of _g(t)) {
        if (n ? s.to == t.doc.length : s.from == 0)
            continue;
        let o = t.doc.lineAt(n ? s.to + 1 : s.from - 1)
          , a = o.length + 1;
        if (n) {
            r.push({
                from: s.to,
                to: o.to
            }, {
                from: s.from,
                insert: o.text + t.lineBreak
            });
            for (let l of s.ranges)
                i.push(ge.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)))
        } else {
            r.push({
                from: o.from,
                to: s.from
            }, {
                from: s.to,
                insert: t.lineBreak + o.text
            });
            for (let l of s.ranges)
                i.push(ge.range(l.anchor - a, l.head - a))
        }
    }
    return r.length ? (e(t.update({
        changes: r,
        scrollIntoView: !0,
        selection: ge.create(i, t.selection.mainIndex),
        userEvent: "move.line"
    })),
    !0) : !1
}
const qge = ({state: t, dispatch: e}) => uF(t, e, !1)
  , Kge = ({state: t, dispatch: e}) => uF(t, e, !0);
function hF(t, e, n) {
    if (t.readOnly)
        return !1;
    let r = [];
    for (let i of _g(t))
        n ? r.push({
            from: i.from,
            insert: t.doc.slice(i.from, i.to) + t.lineBreak
        }) : r.push({
            from: i.to,
            insert: t.lineBreak + t.doc.slice(i.from, i.to)
        });
    return e(t.update({
        changes: r,
        scrollIntoView: !0,
        userEvent: "input.copyline"
    })),
    !0
}
const Yge = ({state: t, dispatch: e}) => hF(t, e, !1)
  , Xge = ({state: t, dispatch: e}) => hF(t, e, !0)
  , Qge = t => {
    if (t.state.readOnly)
        return !1;
    let {state: e} = t
      , n = e.changes(_g(e).map( ({from: i, to: s}) => (i > 0 ? i-- : s < e.doc.length && s++,
    {
        from: i,
        to: s
    })))
      , r = Zl(e.selection, i => {
        let s;
        if (t.lineWrapping) {
            let o = t.lineBlockAt(i.head)
              , a = t.coordsAtPos(i.head, i.assoc || 1);
            a && (s = o.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2)
        }
        return t.moveVertically(i, !0, s)
    }
    ).map(n);
    return t.dispatch({
        changes: n,
        selection: r,
        scrollIntoView: !0,
        userEvent: "delete.line"
    }),
    !0
}
;
function Jge(t, e) {
    if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
        return {
            from: e,
            to: e
        };
    let n = En(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), s;
    return r && i && r.to <= e && i.from >= e && (s = r.type.prop(ot.closedBy)) && s.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? {
        from: r.to,
        to: i.from
    } : null
}
const Zge = dF(!1)
  , e0e = dF(!0);
function dF(t) {
    return ({state: e, dispatch: n}) => {
        if (e.readOnly)
            return !1;
        let r = e.changeByRange(i => {
            let {from: s, to: o} = i
              , a = e.doc.lineAt(s)
              , l = !t && s == o && Jge(e, s);
            t && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
            let c = new fg(e,{
                simulateBreak: s,
                simulateDoubleBreak: !!l
            })
              , u = nx(c, s);
            for (u == null && (u = lg(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
                o++;
            l ? {from: s, to: o} = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
            let h = ["", Zu(e, u)];
            return l && h.push(Zu(e, c.lineIndent(a.from, -1))),
            {
                changes: {
                    from: s,
                    to: o,
                    insert: gt.of(h)
                },
                range: ge.cursor(s + 1 + h[1].length)
            }
        }
        );
        return n(e.update(r, {
            scrollIntoView: !0,
            userEvent: "input"
        })),
        !0
    }
}
function px(t, e) {
    let n = -1;
    return t.changeByRange(r => {
        let i = [];
        for (let o = r.from; o <= r.to; ) {
            let a = t.doc.lineAt(o);
            a.number > n && (r.empty || r.to > a.from) && (e(a, i, r),
            n = a.number),
            o = a.to + 1
        }
        let s = t.changes(i);
        return {
            changes: i,
            range: ge.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
        }
    }
    )
}
const t0e = ({state: t, dispatch: e}) => {
    if (t.readOnly)
        return !1;
    let n = Object.create(null)
      , r = new fg(t,{
        overrideIndentation: s => {
            let o = n[s];
            return o ?? -1
        }
    })
      , i = px(t, (s, o, a) => {
        let l = nx(r, s.from);
        if (l == null)
            return;
        /\S/.test(s.text) || (l = 0);
        let c = /^\s*/.exec(s.text)[0]
          , u = Zu(t, l);
        (c != u || a.from < s.from + c.length) && (n[s.from] = l,
        o.push({
            from: s.from,
            to: s.from + c.length,
            insert: u
        }))
    }
    );
    return i.changes.empty || e(t.update(i, {
        userEvent: "indent"
    })),
    !0
}
  , n0e = ({state: t, dispatch: e}) => t.readOnly ? !1 : (e(t.update(px(t, (n, r) => {
    r.push({
        from: n.from,
        insert: t.facet(Ql)
    })
}
), {
    userEvent: "input.indent"
})),
!0)
  , fF = ({state: t, dispatch: e}) => t.readOnly ? !1 : (e(t.update(px(t, (n, r) => {
    let i = /^\s*/.exec(n.text)[0];
    if (!i)
        return;
    let s = lg(i, t.tabSize)
      , o = 0
      , a = Zu(t, Math.max(0, s - Wp(t)));
    for (; o < i.length && o < a.length && i.charCodeAt(o) == a.charCodeAt(o); )
        o++;
    r.push({
        from: n.from + o,
        to: n.from + i.length,
        insert: a.slice(o)
    })
}
), {
    userEvent: "delete.dedent"
})),
!0)
  , r0e = t => (t.setTabFocusMode(),
!0)
  , i0e = [{
    key: "Ctrl-b",
    run: zB,
    shift: ZB,
    preventDefault: !0
}, {
    key: "Ctrl-f",
    run: WB,
    shift: eF
}, {
    key: "Ctrl-p",
    run: KB,
    shift: rF
}, {
    key: "Ctrl-n",
    run: YB,
    shift: iF
}, {
    key: "Ctrl-a",
    run: Sge,
    shift: Nge
}, {
    key: "Ctrl-e",
    run: wge,
    shift: Mge
}, {
    key: "Ctrl-d",
    run: aF
}, {
    key: "Ctrl-h",
    run: py
}, {
    key: "Ctrl-k",
    run: Vge
}, {
    key: "Ctrl-Alt-h",
    run: cF
}, {
    key: "Ctrl-o",
    run: Wge
}, {
    key: "Ctrl-t",
    run: Gge
}, {
    key: "Ctrl-v",
    run: fy
}]
  , s0e = [{
    key: "ArrowLeft",
    run: zB,
    shift: ZB,
    preventDefault: !0
}, {
    key: "Mod-ArrowLeft",
    mac: "Alt-ArrowLeft",
    run: pge,
    shift: Age,
    preventDefault: !0
}, {
    mac: "Cmd-ArrowLeft",
    run: xge,
    shift: Lge,
    preventDefault: !0
}, {
    key: "ArrowRight",
    run: WB,
    shift: eF,
    preventDefault: !0
}, {
    key: "Mod-ArrowRight",
    mac: "Alt-ArrowRight",
    run: mge,
    shift: kge,
    preventDefault: !0
}, {
    mac: "Cmd-ArrowRight",
    run: Ege,
    shift: Oge,
    preventDefault: !0
}, {
    key: "ArrowUp",
    run: KB,
    shift: rF,
    preventDefault: !0
}, {
    mac: "Cmd-ArrowUp",
    run: TA,
    shift: kA
}, {
    mac: "Ctrl-ArrowUp",
    run: SA,
    shift: wA
}, {
    key: "ArrowDown",
    run: YB,
    shift: iF,
    preventDefault: !0
}, {
    mac: "Cmd-ArrowDown",
    run: AA,
    shift: RA
}, {
    mac: "Ctrl-ArrowDown",
    run: fy,
    shift: CA
}, {
    key: "PageUp",
    run: SA,
    shift: wA
}, {
    key: "PageDown",
    run: fy,
    shift: CA
}, {
    key: "Home",
    run: vge,
    shift: Dge,
    preventDefault: !0
}, {
    key: "Mod-Home",
    run: TA,
    shift: kA
}, {
    key: "End",
    run: yge,
    shift: Pge,
    preventDefault: !0
}, {
    key: "Mod-End",
    run: AA,
    shift: RA
}, {
    key: "Enter",
    run: Zge
}, {
    key: "Mod-a",
    run: Bge
}, {
    key: "Backspace",
    run: py,
    shift: py
}, {
    key: "Delete",
    run: aF
}, {
    key: "Mod-Backspace",
    mac: "Alt-Backspace",
    run: cF
}, {
    key: "Mod-Delete",
    mac: "Alt-Delete",
    run: Uge
}, {
    mac: "Mod-Backspace",
    run: $ge
}, {
    mac: "Mod-Delete",
    run: zge
}].concat(i0e.map(t => ({
    mac: t.key,
    run: t.run,
    shift: t.shift
})))
  , o0e = [{
    key: "Alt-ArrowLeft",
    mac: "Ctrl-ArrowLeft",
    run: _ge,
    shift: Rge
}, {
    key: "Alt-ArrowRight",
    mac: "Ctrl-ArrowRight",
    run: bge,
    shift: Ige
}, {
    key: "Alt-ArrowUp",
    run: qge
}, {
    key: "Shift-Alt-ArrowUp",
    run: Yge
}, {
    key: "Alt-ArrowDown",
    run: Kge
}, {
    key: "Shift-Alt-ArrowDown",
    run: Xge
}, {
    key: "Escape",
    run: Hge
}, {
    key: "Mod-Enter",
    run: e0e
}, {
    key: "Alt-l",
    mac: "Ctrl-l",
    run: Fge
}, {
    key: "Mod-i",
    run: jge,
    preventDefault: !0
}, {
    key: "Mod-[",
    run: fF
}, {
    key: "Mod-]",
    run: n0e
}, {
    key: "Mod-Alt-\\",
    run: t0e
}, {
    key: "Shift-Mod-k",
    run: Qge
}, {
    key: "Shift-Mod-\\",
    run: Tge
}, {
    key: "Mod-/",
    run: Yme
}, {
    key: "Alt-A",
    run: Qme
}, {
    key: "Ctrl-m",
    mac: "Shift-Alt-m",
    run: r0e
}].concat(s0e);
function wn() {
    var t = arguments[0];
    typeof t == "string" && (t = document.createElement(t));
    var e = 1
      , n = arguments[1];
    if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
        for (var r in n)
            if (Object.prototype.hasOwnProperty.call(n, r)) {
                var i = n[r];
                typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i)
            }
        e++
    }
    for (; e < arguments.length; e++)
        pF(t, arguments[e]);
    return t
}
function pF(t, e) {
    if (typeof e == "string")
        t.appendChild(document.createTextNode(e));
    else if (e != null)
        if (e.nodeType != null)
            t.appendChild(e);
        else if (Array.isArray(e))
            for (var n = 0; n < e.length; n++)
                pF(t, e[n]);
        else
            throw new RangeError("Unsupported child node: " + e)
}
const IA = typeof String.prototype.normalize == "function" ? t => t.normalize("NFKD") : t => t;
class nh {
    constructor(e, n, r=0, i=e.length, s, o) {
        this.test = o,
        this.value = {
            from: 0,
            to: 0
        },
        this.done = !1,
        this.matches = [],
        this.buffer = "",
        this.bufferPos = 0,
        this.iter = e.iterRange(r, i),
        this.bufferStart = r,
        this.normalize = s ? a => s(IA(a)) : IA,
        this.query = this.normalize(n)
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            if (this.bufferStart += this.buffer.length,
            this.iter.next(),
            this.iter.done)
                return -1;
            this.bufferPos = 0,
            this.buffer = this.iter.value
        }
        return Xn(this.buffer, this.bufferPos)
    }
    next() {
        for (; this.matches.length; )
            this.matches.pop();
        return this.nextOverlapping()
    }
    nextOverlapping() {
        for (; ; ) {
            let e = this.peek();
            if (e < 0)
                return this.done = !0,
                this;
            let n = $1(e)
              , r = this.bufferStart + this.bufferPos;
            this.bufferPos += Wr(e);
            let i = this.normalize(n);
            for (let s = 0, o = r; ; s++) {
                let a = i.charCodeAt(s)
                  , l = this.match(a, o, this.bufferPos + this.bufferStart);
                if (s == i.length - 1) {
                    if (l)
                        return this.value = l,
                        this;
                    break
                }
                o == r && s < n.length && n.charCodeAt(s) == a && o++
            }
        }
    }
    match(e, n, r) {
        let i = null;
        for (let s = 0; s < this.matches.length; s += 2) {
            let o = this.matches[s]
              , a = !1;
            this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = {
                from: this.matches[s + 1],
                to: r
            } : (this.matches[s]++,
            a = !0)),
            a || (this.matches.splice(s, 2),
            s -= 2)
        }
        return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = {
            from: n,
            to: r
        } : this.matches.push(1, n)),
        i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null),
        i
    }
}
typeof Symbol < "u" && (nh.prototype[Symbol.iterator] = function() {
    return this
}
);
const mF = {
    from: -1,
    to: -1,
    match: /.*/.exec("")
}
  , mx = "gm" + (/x/.unicode == null ? "" : "u");
class gF {
    constructor(e, n, r, i=0, s=e.length) {
        if (this.text = e,
        this.to = s,
        this.curLine = "",
        this.done = !1,
        this.value = mF,
        /\\[sWDnr]|\n|\r|\[\^/.test(n))
            return new _F(e,n,r,i,s);
        this.re = new RegExp(n,mx + (r?.ignoreCase ? "i" : "")),
        this.test = r?.test,
        this.iter = e.iter();
        let o = e.lineAt(i);
        this.curLineStart = o.from,
        this.matchPos = Qp(e, i),
        this.getLine(this.curLineStart)
    }
    getLine(e) {
        this.iter.next(e),
        this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value,
        this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)),
        this.iter.next())
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1,
        this.curLineStart > this.to ? this.curLine = "" : this.getLine(0)
    }
    next() {
        for (let e = this.matchPos - this.curLineStart; ; ) {
            this.re.lastIndex = e;
            let n = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (n) {
                let r = this.curLineStart + n.index
                  , i = r + n[0].length;
                if (this.matchPos = Qp(this.text, i + (r == i ? 1 : 0)),
                r == this.curLineStart + this.curLine.length && this.nextLine(),
                (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
                    return this.value = {
                        from: r,
                        to: i,
                        match: n
                    },
                    this;
                e = this.matchPos - this.curLineStart
            } else if (this.curLineStart + this.curLine.length < this.to)
                this.nextLine(),
                e = 0;
            else
                return this.done = !0,
                this
        }
    }
}
const X0 = new WeakMap;
class yl {
    constructor(e, n) {
        this.from = e,
        this.text = n
    }
    get to() {
        return this.from + this.text.length
    }
    static get(e, n, r) {
        let i = X0.get(e);
        if (!i || i.from >= r || i.to <= n) {
            let a = new yl(n,e.sliceString(n, r));
            return X0.set(e, a),
            a
        }
        if (i.from == n && i.to == r)
            return i;
        let {text: s, from: o} = i;
        return o > n && (s = e.sliceString(n, o) + s,
        o = n),
        i.to < r && (s += e.sliceString(i.to, r)),
        X0.set(e, new yl(o,s)),
        new yl(n,s.slice(n - o, r - o))
    }
}
class _F {
    constructor(e, n, r, i, s) {
        this.text = e,
        this.to = s,
        this.done = !1,
        this.value = mF,
        this.matchPos = Qp(e, i),
        this.re = new RegExp(n,mx + (r?.ignoreCase ? "i" : "")),
        this.test = r?.test,
        this.flat = yl.get(e, i, this.chunkEnd(i + 5e3))
    }
    chunkEnd(e) {
        return e >= this.to ? this.to : this.text.lineAt(e).to
    }
    next() {
        for (; ; ) {
            let e = this.re.lastIndex = this.matchPos - this.flat.from
              , n = this.re.exec(this.flat.text);
            if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1,
            n = this.re.exec(this.flat.text)),
            n) {
                let r = this.flat.from + n.index
                  , i = r + n[0].length;
                if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
                    return this.value = {
                        from: r,
                        to: i,
                        match: n
                    },
                    this.matchPos = Qp(this.text, i + (r == i ? 1 : 0)),
                    this
            }
            if (this.flat.to == this.to)
                return this.done = !0,
                this;
            this.flat = yl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2))
        }
    }
}
typeof Symbol < "u" && (gF.prototype[Symbol.iterator] = _F.prototype[Symbol.iterator] = function() {
    return this
}
);
function a0e(t) {
    try {
        return new RegExp(t,mx),
        !0
    } catch {
        return !1
    }
}
function Qp(t, e) {
    if (e >= t.length)
        return e;
    let n = t.lineAt(e), r;
    for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
        e++;
    return e
}
function my(t) {
    let e = String(t.state.doc.lineAt(t.state.selection.main.head).number)
      , n = wn("input", {
        class: "cm-textfield",
        name: "line",
        value: e
    })
      , r = wn("form", {
        class: "cm-gotoLine",
        onkeydown: s => {
            s.keyCode == 27 ? (s.preventDefault(),
            t.dispatch({
                effects: Jp.of(!1)
            }),
            t.focus()) : s.keyCode == 13 && (s.preventDefault(),
            i())
        }
        ,
        onsubmit: s => {
            s.preventDefault(),
            i()
        }
    }, wn("label", t.state.phrase("Go to line"), ": ", n), " ", wn("button", {
        class: "cm-button",
        type: "submit"
    }, t.state.phrase("go")));
    function i() {
        let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
        if (!s)
            return;
        let {state: o} = t
          , a = o.doc.lineAt(o.selection.main.head)
          , [,l,c,u,h] = s
          , d = u ? +u.slice(1) : 0
          , f = c ? +c : a.number;
        if (c && h) {
            let m = f / 100;
            l && (m = m * (l == "-" ? -1 : 1) + a.number / o.doc.lines),
            f = Math.round(o.doc.lines * m)
        } else
            c && l && (f = f * (l == "-" ? -1 : 1) + a.number);
        let g = o.doc.line(Math.max(1, Math.min(o.doc.lines, f)))
          , _ = ge.cursor(g.from + Math.max(0, Math.min(d, g.length)));
        t.dispatch({
            effects: [Jp.of(!1), Oe.scrollIntoView(_.from, {
                y: "center"
            })],
            selection: _
        }),
        t.focus()
    }
    return {
        dom: r
    }
}
const Jp = Je.define()
  , PA = Qt.define({
    create() {
        return !0
    },
    update(t, e) {
        for (let n of e.effects)
            n.is(Jp) && (t = n.value);
        return t
    },
    provide: t => Hp.from(t, e => e ? my : null)
})
  , l0e = t => {
    let e = jp(t, my);
    if (!e) {
        let n = [Jp.of(!0)];
        t.state.field(PA, !1) == null && n.push(Je.appendConfig.of([PA, c0e])),
        t.dispatch({
            effects: n
        }),
        e = jp(t, my)
    }
    return e && e.dom.querySelector("input").select(),
    !0
}
  , c0e = Oe.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        "& label": {
            fontSize: "80%"
        }
    }
})
  , u0e = ({state: t, dispatch: e}) => {
    let {selection: n} = t
      , r = ge.create(n.ranges.map(i => t.wordAt(i.head) || ge.cursor(i.head)), n.mainIndex);
    return r.eq(n) ? !1 : (e(t.update({
        selection: r
    })),
    !0)
}
;
function h0e(t, e) {
    let {main: n, ranges: r} = t.selection
      , i = t.wordAt(n.head)
      , s = i && i.from == n.from && i.to == n.to;
    for (let o = !1, a = new nh(t.doc,e,r[r.length - 1].to); ; )
        if (a.next(),
        a.done) {
            if (o)
                return null;
            a = new nh(t.doc,e,0,Math.max(0, r[r.length - 1].from - 1)),
            o = !0
        } else {
            if (o && r.some(l => l.from == a.value.from))
                continue;
            if (s) {
                let l = t.wordAt(a.value.from);
                if (!l || l.from != a.value.from || l.to != a.value.to)
                    continue
            }
            return a.value
        }
}
const d0e = ({state: t, dispatch: e}) => {
    let {ranges: n} = t.selection;
    if (n.some(s => s.from === s.to))
        return u0e({
            state: t,
            dispatch: e
        });
    let r = t.sliceDoc(n[0].from, n[0].to);
    if (t.selection.ranges.some(s => t.sliceDoc(s.from, s.to) != r))
        return !1;
    let i = h0e(t, r);
    return i ? (e(t.update({
        selection: t.selection.addRange(ge.range(i.from, i.to), !1),
        effects: Oe.scrollIntoView(i.to)
    })),
    !0) : !1
}
  , ec = Me.define({
    combine(t) {
        return Aa(t, {
            top: !1,
            caseSensitive: !1,
            literal: !1,
            regexp: !1,
            wholeWord: !1,
            createPanel: e => new w0e(e),
            scrollToMatch: e => Oe.scrollIntoView(e)
        })
    }
});
class bF {
    constructor(e) {
        this.search = e.search,
        this.caseSensitive = !!e.caseSensitive,
        this.literal = !!e.literal,
        this.regexp = !!e.regexp,
        this.replace = e.replace || "",
        this.valid = !!this.search && (!this.regexp || a0e(this.search)),
        this.unquoted = this.unquote(this.search),
        this.wholeWord = !!e.wholeWord
    }
    unquote(e) {
        return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\")
    }
    eq(e) {
        return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord
    }
    create() {
        return this.regexp ? new g0e(this) : new p0e(this)
    }
    getCursor(e, n=0, r) {
        let i = e.doc ? e : lt.create({
            doc: e
        });
        return r == null && (r = i.doc.length),
        this.regexp ? Ga(this, i, n, r) : Wa(this, i, n, r)
    }
}
class yF {
    constructor(e) {
        this.spec = e
    }
}
function Wa(t, e, n, r) {
    return new nh(e.doc,t.unquoted,n,r,t.caseSensitive ? void 0 : i => i.toLowerCase(),t.wholeWord ? f0e(e.doc, e.charCategorizer(e.selection.main.head)) : void 0)
}
function f0e(t, e) {
    return (n, r, i, s) => ((s > n || s + i.length < r) && (s = Math.max(0, n - 2),
    i = t.sliceString(s, Math.min(t.length, r + 2))),
    (e(Zp(i, n - s)) != Xt.Word || e(em(i, n - s)) != Xt.Word) && (e(em(i, r - s)) != Xt.Word || e(Zp(i, r - s)) != Xt.Word))
}
class p0e extends yF {
    constructor(e) {
        super(e)
    }
    nextMatch(e, n, r) {
        let i = Wa(this.spec, e, r, e.doc.length).nextOverlapping();
        return i.done && (i = Wa(this.spec, e, 0, n).nextOverlapping()),
        i.done ? null : i.value
    }
    prevMatchInRange(e, n, r) {
        for (let i = r; ; ) {
            let s = Math.max(n, i - 1e4 - this.spec.unquoted.length)
              , o = Wa(this.spec, e, s, i)
              , a = null;
            for (; !o.nextOverlapping().done; )
                a = o.value;
            if (a)
                return a;
            if (s == n)
                return null;
            i -= 1e4
        }
    }
    prevMatch(e, n, r) {
        return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length)
    }
    getReplacement(e) {
        return this.spec.unquote(this.spec.replace)
    }
    matchAll(e, n) {
        let r = Wa(this.spec, e, 0, e.doc.length)
          , i = [];
        for (; !r.next().done; ) {
            if (i.length >= n)
                return null;
            i.push(r.value)
        }
        return i
    }
    highlight(e, n, r, i) {
        let s = Wa(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
        for (; !s.next().done; )
            i(s.value.from, s.value.to)
    }
}
function Ga(t, e, n, r) {
    return new gF(e.doc,t.search,{
        ignoreCase: !t.caseSensitive,
        test: t.wholeWord ? m0e(e.charCategorizer(e.selection.main.head)) : void 0
    },n,r)
}
function Zp(t, e) {
    return t.slice(yn(t, e, !1), e)
}
function em(t, e) {
    return t.slice(e, yn(t, e))
}
function m0e(t) {
    return (e, n, r) => !r[0].length || (t(Zp(r.input, r.index)) != Xt.Word || t(em(r.input, r.index)) != Xt.Word) && (t(em(r.input, r.index + r[0].length)) != Xt.Word || t(Zp(r.input, r.index + r[0].length)) != Xt.Word)
}
class g0e extends yF {
    nextMatch(e, n, r) {
        let i = Ga(this.spec, e, r, e.doc.length).next();
        return i.done && (i = Ga(this.spec, e, 0, n).next()),
        i.done ? null : i.value
    }
    prevMatchInRange(e, n, r) {
        for (let i = 1; ; i++) {
            let s = Math.max(n, r - i * 1e4)
              , o = Ga(this.spec, e, s, r)
              , a = null;
            for (; !o.next().done; )
                a = o.value;
            if (a && (s == n || a.from > s + 10))
                return a;
            if (s == n)
                return null
        }
    }
    prevMatch(e, n, r) {
        return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length)
    }
    getReplacement(e) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, r) => r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : n)
    }
    matchAll(e, n) {
        let r = Ga(this.spec, e, 0, e.doc.length)
          , i = [];
        for (; !r.next().done; ) {
            if (i.length >= n)
                return null;
            i.push(r.value)
        }
        return i
    }
    highlight(e, n, r, i) {
        let s = Ga(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
        for (; !s.next().done; )
            i(s.value.from, s.value.to)
    }
}
const rh = Je.define()
  , gx = Je.define()
  , Bs = Qt.define({
    create(t) {
        return new Q0(gy(t).create(),null)
    },
    update(t, e) {
        for (let n of e.effects)
            n.is(rh) ? t = new Q0(n.value.create(),t.panel) : n.is(gx) && (t = new Q0(t.query,n.value ? _x : null));
        return t
    },
    provide: t => Hp.from(t, e => e.panel)
});
class Q0 {
    constructor(e, n) {
        this.query = e,
        this.panel = n
    }
}
const _0e = at.mark({
    class: "cm-searchMatch"
})
  , b0e = at.mark({
    class: "cm-searchMatch cm-searchMatch-selected"
})
  , y0e = xn.fromClass(class {
    constructor(t) {
        this.view = t,
        this.decorations = this.highlight(t.state.field(Bs))
    }
    update(t) {
        let e = t.state.field(Bs);
        (e != t.startState.field(Bs) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e))
    }
    highlight({query: t, panel: e}) {
        if (!e || !t.spec.valid)
            return at.none;
        let {view: n} = this
          , r = new la;
        for (let i = 0, s = n.visibleRanges, o = s.length; i < o; i++) {
            let {from: a, to: l} = s[i];
            for (; i < o - 1 && l > s[i + 1].from - 2 * 250; )
                l = s[++i].to;
            t.highlight(n.state, a, l, (c, u) => {
                let h = n.state.selection.ranges.some(d => d.from == c && d.to == u);
                r.add(c, u, h ? b0e : _0e)
            }
            )
        }
        return r.finish()
    }
}
, {
    decorations: t => t.decorations
});
function ad(t) {
    return e => {
        let n = e.state.field(Bs, !1);
        return n && n.query.spec.valid ? t(e, n) : EF(e)
    }
}
const tm = ad( (t, {query: e}) => {
    let {to: n} = t.state.selection.main
      , r = e.nextMatch(t.state, n, n);
    if (!r)
        return !1;
    let i = ge.single(r.from, r.to)
      , s = t.state.facet(ec);
    return t.dispatch({
        selection: i,
        effects: [bx(t, r), s.scrollToMatch(i.main, t)],
        userEvent: "select.search"
    }),
    xF(t),
    !0
}
)
  , nm = ad( (t, {query: e}) => {
    let {state: n} = t
      , {from: r} = n.selection.main
      , i = e.prevMatch(n, r, r);
    if (!i)
        return !1;
    let s = ge.single(i.from, i.to)
      , o = t.state.facet(ec);
    return t.dispatch({
        selection: s,
        effects: [bx(t, i), o.scrollToMatch(s.main, t)],
        userEvent: "select.search"
    }),
    xF(t),
    !0
}
)
  , v0e = ad( (t, {query: e}) => {
    let n = e.matchAll(t.state, 1e3);
    return !n || !n.length ? !1 : (t.dispatch({
        selection: ge.create(n.map(r => ge.range(r.from, r.to))),
        userEvent: "select.search.matches"
    }),
    !0)
}
)
  , x0e = ({state: t, dispatch: e}) => {
    let n = t.selection;
    if (n.ranges.length > 1 || n.main.empty)
        return !1;
    let {from: r, to: i} = n.main
      , s = []
      , o = 0;
    for (let a = new nh(t.doc,t.sliceDoc(r, i)); !a.next().done; ) {
        if (s.length > 1e3)
            return !1;
        a.value.from == r && (o = s.length),
        s.push(ge.range(a.value.from, a.value.to))
    }
    return e(t.update({
        selection: ge.create(s, o),
        userEvent: "select.search.matches"
    })),
    !0
}
  , DA = ad( (t, {query: e}) => {
    let {state: n} = t
      , {from: r, to: i} = n.selection.main;
    if (n.readOnly)
        return !1;
    let s = e.nextMatch(n, r, r);
    if (!s)
        return !1;
    let o = [], a, l, c = [];
    if (s.from == r && s.to == i && (l = n.toText(e.getReplacement(s)),
    o.push({
        from: s.from,
        to: s.to,
        insert: l
    }),
    s = e.nextMatch(n, s.from, s.to),
    c.push(Oe.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))),
    s) {
        let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length;
        a = ge.single(s.from - u, s.to - u),
        c.push(bx(t, s)),
        c.push(n.facet(ec).scrollToMatch(a.main, t))
    }
    return t.dispatch({
        changes: o,
        selection: a,
        effects: c,
        userEvent: "input.replace"
    }),
    !0
}
)
  , E0e = ad( (t, {query: e}) => {
    if (t.state.readOnly)
        return !1;
    let n = e.matchAll(t.state, 1e9).map(i => {
        let {from: s, to: o} = i;
        return {
            from: s,
            to: o,
            insert: e.getReplacement(i)
        }
    }
    );
    if (!n.length)
        return !1;
    let r = t.state.phrase("replaced $ matches", n.length) + ".";
    return t.dispatch({
        changes: n,
        effects: Oe.announce.of(r),
        userEvent: "input.replace.all"
    }),
    !0
}
);
function _x(t) {
    return t.state.facet(ec).createPanel(t)
}
function gy(t, e) {
    var n, r, i, s, o;
    let a = t.selection.main
      , l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
    if (e && !l)
        return e;
    let c = t.facet(ec);
    return new bF({
        search: ((n = e?.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
        caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
        literal: (i = e?.literal) !== null && i !== void 0 ? i : c.literal,
        regexp: (s = e?.regexp) !== null && s !== void 0 ? s : c.regexp,
        wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
    })
}
function vF(t) {
    let e = jp(t, _x);
    return e && e.dom.querySelector("[main-field]")
}
function xF(t) {
    let e = vF(t);
    e && e == t.root.activeElement && e.select()
}
const EF = t => {
    let e = t.state.field(Bs, !1);
    if (e && e.panel) {
        let n = vF(t);
        if (n && n != t.root.activeElement) {
            let r = gy(t.state, e.query.spec);
            r.valid && t.dispatch({
                effects: rh.of(r)
            }),
            n.focus(),
            n.select()
        }
    } else
        t.dispatch({
            effects: [gx.of(!0), e ? rh.of(gy(t.state, e.query.spec)) : Je.appendConfig.of(T0e)]
        });
    return !0
}
  , SF = t => {
    let e = t.state.field(Bs, !1);
    if (!e || !e.panel)
        return !1;
    let n = jp(t, _x);
    return n && n.dom.contains(t.root.activeElement) && t.focus(),
    t.dispatch({
        effects: gx.of(!1)
    }),
    !0
}
  , S0e = [{
    key: "Mod-f",
    run: EF,
    scope: "editor search-panel"
}, {
    key: "F3",
    run: tm,
    shift: nm,
    scope: "editor search-panel",
    preventDefault: !0
}, {
    key: "Mod-g",
    run: tm,
    shift: nm,
    scope: "editor search-panel",
    preventDefault: !0
}, {
    key: "Escape",
    run: SF,
    scope: "editor search-panel"
}, {
    key: "Mod-Shift-l",
    run: x0e
}, {
    key: "Mod-Alt-g",
    run: l0e
}, {
    key: "Mod-d",
    run: d0e,
    preventDefault: !0
}];
class w0e {
    constructor(e) {
        this.view = e;
        let n = this.query = e.state.field(Bs).query.spec;
        this.commit = this.commit.bind(this),
        this.searchField = wn("input", {
            value: n.search,
            placeholder: ir(e, "Find"),
            "aria-label": ir(e, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
        }),
        this.replaceField = wn("input", {
            value: n.replace,
            placeholder: ir(e, "Replace"),
            "aria-label": ir(e, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
        }),
        this.caseField = wn("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: n.caseSensitive,
            onchange: this.commit
        }),
        this.reField = wn("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: n.regexp,
            onchange: this.commit
        }),
        this.wordField = wn("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: n.wholeWord,
            onchange: this.commit
        });
        function r(i, s, o) {
            return wn("button", {
                class: "cm-button",
                name: i,
                onclick: s,
                type: "button"
            }, o)
        }
        this.dom = wn("div", {
            onkeydown: i => this.keydown(i),
            class: "cm-search"
        }, [this.searchField, r("next", () => tm(e), [ir(e, "next")]), r("prev", () => nm(e), [ir(e, "previous")]), r("select", () => v0e(e), [ir(e, "all")]), wn("label", null, [this.caseField, ir(e, "match case")]), wn("label", null, [this.reField, ir(e, "regexp")]), wn("label", null, [this.wordField, ir(e, "by word")]), ...e.state.readOnly ? [] : [wn("br"), this.replaceField, r("replace", () => DA(e), [ir(e, "replace")]), r("replaceAll", () => E0e(e), [ir(e, "replace all")])], wn("button", {
            name: "close",
            onclick: () => SF(e),
            "aria-label": ir(e, "close"),
            type: "button"
        }, [""])])
    }
    commit() {
        let e = new bF({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value
        });
        e.eq(this.query) || (this.query = e,
        this.view.dispatch({
            effects: rh.of(e)
        }))
    }
    keydown(e) {
        cfe(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(),
        (e.shiftKey ? nm : tm)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(),
        DA(this.view))
    }
    update(e) {
        for (let n of e.transactions)
            for (let r of n.effects)
                r.is(rh) && !r.value.eq(this.query) && this.setQuery(r.value)
    }
    setQuery(e) {
        this.query = e,
        this.searchField.value = e.search,
        this.replaceField.value = e.replace,
        this.caseField.checked = e.caseSensitive,
        this.reField.checked = e.regexp,
        this.wordField.checked = e.wholeWord
    }
    mount() {
        this.searchField.select()
    }
    get pos() {
        return 80
    }
    get top() {
        return this.view.state.facet(ec).top
    }
}
function ir(t, e) {
    return t.state.phrase(e)
}
const tf = 30
  , nf = /[\s\.,:;?!]/;
function bx(t, {from: e, to: n}) {
    let r = t.state.doc.lineAt(e)
      , i = t.state.doc.lineAt(n).to
      , s = Math.max(r.from, e - tf)
      , o = Math.min(i, n + tf)
      , a = t.state.sliceDoc(s, o);
    if (s != r.from) {
        for (let l = 0; l < tf; l++)
            if (!nf.test(a[l + 1]) && nf.test(a[l])) {
                a = a.slice(l);
                break
            }
    }
    if (o != i) {
        for (let l = a.length - 1; l > a.length - tf; l--)
            if (!nf.test(a[l - 1]) && nf.test(a[l])) {
                a = a.slice(0, l);
                break
            }
    }
    return Oe.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${r.number}.`)
}
const C0e = Oe.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
        }
    },
    "&light .cm-searchMatch": {
        backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
        backgroundColor: "#00ffff8a"
    },
    "&light .cm-searchMatch-selected": {
        backgroundColor: "#ff6a0054"
    },
    "&dark .cm-searchMatch-selected": {
        backgroundColor: "#ff00ff8a"
    }
})
  , T0e = [Bs, co.low(y0e), C0e];
function A0e() {
    return v.jsx("div", {
        className: "flex items-center justify-center absolute inset-0 z-10 text-sm bg-tk-elements-app-backgroundColor text-tk-elements-app-textColor",
        children: "File format cannot be displayed."
    })
}
const wF = Je.define()
  , CF = Qt.define({
    create: () => null,
    update(t, e) {
        for (const n of e.effects)
            if (n.is(wF))
                return n.value;
        return t
    }
})
  , ou = Je.define()
  , k0e = Qt.define({
    create: () => [],
    update(t, e) {
        if (e.state.readOnly)
            return [];
        for (const n of e.effects)
            if (n.is(ou) && n.value)
                return R0e(e.state);
        return []
    },
    provide: t => dg.computeN([t], e => e.field(t))
});
function R0e(t) {
    return t.readOnly ? [] : t.selection.ranges.filter(e => !e.empty).map(e => new I0e(t,e.head))
}
class I0e {
    constructor(e, n) {
        this._state = e,
        this.pos = n,
        this._state.selection.main.from === this._state.selection.main.head && (this.above = !0)
    }
    above = !1;
    strictSide = !1;
    arrow = !1;
    create() {
        const e = document.createElement("div");
        e.className = "cm-ai-tooltip",
        e.setAttribute("style", `transform: translateY(${this.above ? "-" : ""}4px)`);
        const n = document.createElement("button");
        n.className = "px-2 py-1 flex items-center gap-1 text-md";
        const r = document.createElement("span");
        r.className = "i-bolt:stars";
        const i = document.createTextNode("Ask Bolt");
        n.appendChild(r),
        n.appendChild(i);
        const s = o => {
            o.preventDefault(),
            o.stopPropagation();
            const a = this._state.selection.main
              , l = this._state.doc.lineAt(a.from)
              , c = this._state.doc.lineAt(a.to)
              , u = P0e(this._state.sliceDoc(l.from, c.to))
              , h = this._state.field(CF);
            He.addToSelection({
                filePath: h ?? "",
                text: u,
                range: {
                    from: l.from,
                    to: c.to
                }
            })
        }
        ;
        return n.addEventListener("mousedown", s),
        e.appendChild(n),
        {
            dom: e,
            destroy: () => {
                n.removeEventListener("mousedown", s)
            }
        }
    }
}
function P0e(t) {
    const e = t.split(`
`)
      , n = e.filter(r => r.trim().length > 0).reduce( (r, i) => Math.min(r, i.length - i.trimStart().length), 1 / 0);
    return e.map(r => {
        const i = r.length - r.trimStart().length;
        return " ".repeat(Math.max(0, i - n)) + r.trim()
    }
    ).join(`
`)
}
function rm() {
    return rm = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    rm.apply(null, arguments)
}
var TF = t => {
    var {theme: e, settings: n={}, styles: r=[]} = t
      , i = {
        ".cm-gutters": {}
    }
      , s = {};
    n.background && (s.backgroundColor = n.background),
    n.backgroundImage && (s.backgroundImage = n.backgroundImage),
    n.foreground && (s.color = n.foreground),
    n.fontSize && (s.fontSize = n.fontSize),
    (n.background || n.foreground) && (i["&"] = s),
    n.fontFamily && (i["&.cm-editor .cm-scroller"] = {
        fontFamily: n.fontFamily
    }),
    n.gutterBackground && (i[".cm-gutters"].backgroundColor = n.gutterBackground),
    n.gutterForeground && (i[".cm-gutters"].color = n.gutterForeground),
    n.gutterBorder && (i[".cm-gutters"].borderRightColor = n.gutterBorder),
    n.caret && (i[".cm-content"] = {
        caretColor: n.caret
    },
    i[".cm-cursor, .cm-dropCursor"] = {
        borderLeftColor: n.caret
    });
    var o = {};
    n.gutterActiveForeground && (o.color = n.gutterActiveForeground),
    n.lineHighlight && (i[".cm-activeLine"] = {
        backgroundColor: n.lineHighlight
    },
    o.backgroundColor = n.lineHighlight),
    i[".cm-activeLineGutter"] = o,
    n.selection && (i["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
        background: n.selection + " !important"
    }),
    n.selectionMatch && (i["& .cm-selectionMatch"] = {
        backgroundColor: n.selectionMatch
    });
    var a = Oe.theme(i, {
        dark: e === "dark"
    })
      , l = id.define(r)
      , c = [a, Bpe(l)];
    return c
}
  , D0e = {
    background: "#ffffff",
    foreground: "#383a42",
    caret: "#000",
    selection: "#add6ff",
    selectionMatch: "#a8ac94",
    lineHighlight: "#f0f0f0",
    gutterBackground: "#fff",
    gutterForeground: "#237893",
    gutterActiveForeground: "#0b216f",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace'
}
  , L0e = [{
    tag: [te.keyword, te.operatorKeyword, te.modifier, te.color, te.constant(te.name), te.standard(te.name), te.standard(te.tagName), te.special(te.brace), te.atom, te.bool, te.special(te.variableName)],
    color: "#0000ff"
}, {
    tag: [te.moduleKeyword, te.controlKeyword],
    color: "#af00db"
}, {
    tag: [te.name, te.deleted, te.character, te.macroName, te.propertyName, te.variableName, te.labelName, te.definition(te.name)],
    color: "#0070c1"
}, {
    tag: te.heading,
    fontWeight: "bold",
    color: "#0070c1"
}, {
    tag: [te.typeName, te.className, te.tagName, te.number, te.changed, te.annotation, te.self, te.namespace],
    color: "#267f99"
}, {
    tag: [te.function(te.variableName), te.function(te.propertyName)],
    color: "#795e26"
}, {
    tag: [te.number],
    color: "#098658"
}, {
    tag: [te.operator, te.punctuation, te.separator, te.url, te.escape, te.regexp],
    color: "#383a42"
}, {
    tag: [te.regexp],
    color: "#af00db"
}, {
    tag: [te.special(te.string), te.processingInstruction, te.string, te.inserted],
    color: "#a31515"
}, {
    tag: [te.angleBracket],
    color: "#383a42"
}, {
    tag: te.strong,
    fontWeight: "bold"
}, {
    tag: te.emphasis,
    fontStyle: "italic"
}, {
    tag: te.strikethrough,
    textDecoration: "line-through"
}, {
    tag: [te.meta, te.comment],
    color: "#008000"
}, {
    tag: te.link,
    color: "#4078f2",
    textDecoration: "underline"
}, {
    tag: te.invalid,
    color: "#e45649"
}];
function O0e(t) {
    var {theme: e="dark", settings: n={}, styles: r=[]} = {};
    return TF({
        theme: e,
        settings: rm({}, D0e, n),
        styles: [...L0e, ...r]
    })
}
var N0e = O0e()
  , M0e = {
    background: "#1e1e1e",
    foreground: "#9cdcfe",
    caret: "#c6c6c6",
    selection: "#6199ff2f",
    selectionMatch: "#72a1ff59",
    lineHighlight: "#ffffff0f",
    gutterBackground: "#1e1e1e",
    gutterForeground: "#838383",
    gutterActiveForeground: "#fff",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace'
}
  , B0e = [{
    tag: [te.keyword, te.operatorKeyword, te.modifier, te.color, te.constant(te.name), te.standard(te.name), te.standard(te.tagName), te.special(te.brace), te.atom, te.bool, te.special(te.variableName)],
    color: "#569cd6"
}, {
    tag: [te.controlKeyword, te.moduleKeyword],
    color: "#c586c0"
}, {
    tag: [te.name, te.deleted, te.character, te.macroName, te.propertyName, te.variableName, te.labelName, te.definition(te.name)],
    color: "#9cdcfe"
}, {
    tag: te.heading,
    fontWeight: "bold",
    color: "#9cdcfe"
}, {
    tag: [te.typeName, te.className, te.tagName, te.number, te.changed, te.annotation, te.self, te.namespace],
    color: "#4ec9b0"
}, {
    tag: [te.function(te.variableName), te.function(te.propertyName)],
    color: "#dcdcaa"
}, {
    tag: [te.number],
    color: "#b5cea8"
}, {
    tag: [te.operator, te.punctuation, te.separator, te.url, te.escape, te.regexp],
    color: "#d4d4d4"
}, {
    tag: [te.regexp],
    color: "#d16969"
}, {
    tag: [te.special(te.string), te.processingInstruction, te.string, te.inserted],
    color: "#ce9178"
}, {
    tag: [te.angleBracket],
    color: "#808080"
}, {
    tag: te.strong,
    fontWeight: "bold"
}, {
    tag: te.emphasis,
    fontStyle: "italic"
}, {
    tag: te.strikethrough,
    textDecoration: "line-through"
}, {
    tag: [te.meta, te.comment],
    color: "#6a9955"
}, {
    tag: te.link,
    color: "#6a9955",
    textDecoration: "underline"
}, {
    tag: te.invalid,
    color: "#ff0000"
}];
function F0e(t) {
    var {theme: e="dark", settings: n={}, styles: r=[]} = {};
    return TF({
        theme: e,
        settings: rm({}, M0e, n),
        styles: [...B0e, ...r]
    })
}
var j0e = F0e();
Oe.theme({}, {
    dark: !0
});
const _y = new oa;
function H0e(t, e={}) {
    return [U0e(e), t === "dark" ? _y.of([RF()]) : _y.of([kF()])]
}
function AF(t) {
    return _y.reconfigure(t === "dark" ? RF() : kF())
}
function U0e(t) {
    return Oe.theme({
        "&": {
            fontSize: t.fontSize ?? "12px"
        },
        "&.cm-editor": {
            height: "100%",
            background: "var(--cm-backgroundColor)",
            color: "var(--cm-textColor)"
        },
        ".cm-cursor": {
            borderLeft: "var(--cm-cursor-width) solid var(--cm-cursor-backgroundColor)"
        },
        ".cm-scroller": {
            lineHeight: "1.5",
            "&:focus-visible": {
                outline: "none"
            }
        },
        ".cm-line": {
            padding: "0 0 0 4px"
        },
        "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
            backgroundColor: "var(--cm-selection-backgroundColorFocused) !important",
            opacity: "var(--cm-selection-backgroundOpacityFocused, 0.3)"
        },
        "&:not(.cm-focused) > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
            backgroundColor: "var(--cm-selection-backgroundColorBlured)",
            opacity: "var(--cm-selection-backgroundOpacityBlured, 0.3)"
        },
        "&.cm-focused > .cm-scroller .cm-matchingBracket": {
            backgroundColor: "var(--cm-matching-bracket)"
        },
        ".cm-activeLine": {
            background: "var(--cm-activeLineBackgroundColor)"
        },
        ".cm-gutters": {
            background: "var(--cm-gutter-backgroundColor)",
            borderRight: 0,
            color: "var(--cm-gutter-textColor)"
        },
        ".cm-gutter": {
            "&.cm-lineNumbers": {
                fontFamily: "var(--bolt-font-monospace)",
                fontSize: t.gutterFontSize ?? t.fontSize ?? "12px",
                minWidth: "40px"
            },
            "& .cm-activeLineGutter": {
                background: "transparent",
                color: "var(--cm-gutter-activeLineTextColor)"
            },
            "&.cm-foldGutter .cm-gutterElement > .fold-icon": {
                cursor: "pointer",
                color: "var(--cm-foldGutter-textColor)",
                transform: "translateY(2px)",
                "&:hover": {
                    color: "var(--cm-foldGutter-textColorHover)"
                }
            }
        },
        ".cm-foldGutter .cm-gutterElement": {
            padding: "0 4px"
        },
        ".cm-tooltip-autocomplete > ul > li": {
            minHeight: "18px"
        },
        ".cm-panel.cm-search label": {
            marginLeft: "2px",
            fontSize: "12px"
        },
        ".cm-panel.cm-search .cm-button": {
            fontSize: "12px"
        },
        ".cm-panel.cm-search .cm-textfield": {
            fontSize: "12px"
        },
        ".cm-panel.cm-search input[type=checkbox]": {
            position: "relative",
            transform: "translateY(2px)",
            marginRight: "4px"
        },
        ".cm-panels": {
            borderColor: "var(--cm-panels-borderColor)"
        },
        ".cm-panels-bottom": {
            borderTop: "1px solid var(--cm-panels-borderColor)",
            backgroundColor: "transparent"
        },
        ".cm-panel.cm-search": {
            background: "var(--cm-search-backgroundColor)",
            color: "var(--cm-search-textColor)",
            padding: "8px"
        },
        ".cm-search .cm-button": {
            background: "var(--cm-search-button-backgroundColor)",
            borderColor: "var(--cm-search-button-borderColor)",
            color: "var(--cm-search-button-textColor)",
            borderRadius: "4px",
            "&:hover": {
                color: "var(--cm-search-button-textColorHover)"
            },
            "&:focus-visible": {
                outline: "none",
                borderColor: "var(--cm-search-button-borderColorFocused)"
            },
            "&:hover:not(:focus-visible)": {
                background: "var(--cm-search-button-backgroundColorHover)",
                borderColor: "var(--cm-search-button-borderColorHover)"
            },
            "&:hover:focus-visible": {
                background: "var(--cm-search-button-backgroundColorHover)",
                borderColor: "var(--cm-search-button-borderColorFocused)"
            }
        },
        ".cm-panel.cm-search [name=close]": {
            top: "6px",
            right: "6px",
            padding: "0 6px",
            fontSize: "1rem",
            backgroundColor: "var(--cm-search-closeButton-backgroundColor)",
            color: "var(--cm-search-closeButton-textColor)",
            "&:hover": {
                "border-radius": "6px",
                color: "var(--cm-search-closeButton-textColorHover)",
                backgroundColor: "var(--cm-search-closeButton-backgroundColorHover)"
            }
        },
        ".cm-search input": {
            background: "var(--cm-search-input-backgroundColor)",
            borderColor: "var(--cm-search-input-borderColor)",
            color: "var(--cm-search-input-textColor)",
            outline: "none",
            borderRadius: "4px",
            "&:focus-visible": {
                borderColor: "var(--cm-search-input-borderColorFocused)"
            }
        },
        ".cm-tooltip": {
            background: "var(--cm-tooltip-backgroundColor)",
            border: "1px solid transparent",
            borderColor: "var(--cm-tooltip-borderColor)",
            color: "var(--cm-tooltip-textColor)"
        },
        ".cm-tooltip.cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "var(--cm-tooltip-backgroundColorSelected)",
            color: "var(--cm-tooltip-textColorSelected)"
        },
        ".cm-searchMatch": {
            backgroundColor: "var(--cm-searchMatch-backgroundColor)"
        },
        ".cm-tooltip.cm-readonly-tooltip": {
            padding: "4px",
            whiteSpace: "nowrap",
            backgroundColor: "var(--bolt-elements-bg-depth-2)",
            borderColor: "var(--bolt-elements-borderColorActive)",
            "& .cm-tooltip-arrow:before": {
                borderTopColor: "var(--bolt-elements-borderColorActive)"
            },
            "& .cm-tooltip-arrow:after": {
                borderTopColor: "transparent"
            }
        }
    })
}
function kF() {
    return N0e
}
function RF() {
    return j0e
}
const V0e = {
    key: "Tab",
    run: $0e,
    shift: fF
};
function $0e({state: t, dispatch: e}) {
    return t.readOnly ? !1 : (e(t.update(z0e(t, (n, r, i) => {
        i.push({
            from: n,
            to: r,
            insert: t.facet(Ql)
        })
    }
    ), {
        userEvent: "input.indent"
    })),
    !0)
}
function z0e(t, e) {
    return t.changeByRange(n => {
        const r = []
          , i = t.doc.lineAt(n.from);
        if (n.from === n.to)
            e(n.from, void 0, r, i);
        else if (n.from < n.to && n.to <= i.to)
            e(n.from, n.to, r, i);
        else {
            let o = -1;
            for (let a = n.from; a <= n.to; ) {
                const l = t.doc.lineAt(a);
                l.number > o && (n.empty || n.to > l.from) && (e(l.from, void 0, r, l),
                o = l.number),
                a = l.to + 1
            }
        }
        const s = t.changes(r);
        return {
            changes: r,
            range: ge.range(s.mapPos(n.anchor, 1), s.mapPos(n.head, 1))
        }
    }
    )
}
const W0e = [on.of({
    name: "TS",
    extensions: ["ts"],
    async load() {
        return K( () => import("./index-Cim1HUmG.js").then(t => t.i), __vite__mapDeps([119, 120, 117, 115])).then(t => t.javascript({
            typescript: !0
        }))
    }
}), on.of({
    name: "JS",
    extensions: ["js", "mjs", "cjs"],
    async load() {
        return K( () => import("./index-Cim1HUmG.js").then(t => t.i), __vite__mapDeps([119, 120, 117, 115])).then(t => t.javascript())
    }
}), on.of({
    name: "TSX",
    extensions: ["tsx"],
    async load() {
        return K( () => import("./index-Cim1HUmG.js").then(t => t.i), __vite__mapDeps([119, 120, 117, 115])).then(t => t.javascript({
            jsx: !0,
            typescript: !0
        }))
    }
}), on.of({
    name: "JSX",
    extensions: ["jsx"],
    async load() {
        return K( () => import("./index-Cim1HUmG.js").then(t => t.i), __vite__mapDeps([119, 120, 117, 115])).then(t => t.javascript({
            jsx: !0
        }))
    }
}), on.of({
    name: "HTML",
    extensions: ["html"],
    async load() {
        return K( () => import("./index-DlE5WDmH.js"), __vite__mapDeps([121, 120, 117, 115, 122, 116, 118, 123, 124, 119])).then(t => t.html())
    }
}), on.of({
    name: "CSS",
    extensions: ["css"],
    async load() {
        return K( () => import("./index-eoFC3xUZ.js"), __vite__mapDeps([122, 120, 117, 115, 116, 118, 123, 124])).then(t => t.css())
    }
}), on.of({
    name: "SASS",
    extensions: ["sass"],
    async load() {
        return K( () => import("./index-CB4veLy4.js"), __vite__mapDeps([125, 120, 117, 115, 122, 116, 118, 123, 124])).then(t => t.sass({
            indented: !0
        }))
    }
}), on.of({
    name: "SCSS",
    extensions: ["scss"],
    async load() {
        return K( () => import("./index-CB4veLy4.js"), __vite__mapDeps([125, 120, 117, 115, 122, 116, 118, 123, 124])).then(t => t.sass({
            indented: !1
        }))
    }
}), on.of({
    name: "JSON",
    extensions: ["json"],
    async load() {
        return K( () => import("./index-CNyZagvz.js"), __vite__mapDeps([126, 120, 117, 115, 116, 118, 123, 124])).then(t => t.json())
    }
}), on.of({
    name: "Markdown",
    extensions: ["md"],
    async load() {
        return K( () => import("./index-CmQ84u7v.js"), __vite__mapDeps([127, 121, 120, 117, 115, 122, 116, 118, 123, 124, 119])).then(t => t.markdown())
    }
}), on.of({
    name: "Wasm",
    extensions: ["wat"],
    async load() {
        return K( () => import("./index-CzIEtgTK.js"), __vite__mapDeps([128, 120, 117, 115, 116, 118, 123, 124])).then(t => t.wast())
    }
}), on.of({
    name: "Python",
    extensions: ["py"],
    async load() {
        return K( () => import("./index-DgC2sezN.js"), __vite__mapDeps([129, 120, 117, 115, 116, 118, 123, 124])).then(t => t.python())
    }
}), on.of({
    name: "C++",
    extensions: ["cpp"],
    async load() {
        return K( () => import("./index-CXL-M3S7.js"), __vite__mapDeps([130, 120, 117, 115, 116, 118, 123, 124])).then(t => t.cpp())
    }
}), on.of({
    name: "Vue",
    extensions: ["vue"],
    async load() {
        return K( () => import("./index-CdaH1m_X.js"), __vite__mapDeps([131, 121, 120, 117, 115, 122, 116, 118, 123, 124, 119])).then(t => t.vue())
    }
}), on.of({
    name: "Svelte",
    extensions: ["svelte"],
    async load() {
        return K( () => import("./index-Cq3hXmRr.js"), __vite__mapDeps([132, 120, 117, 115, 122, 116, 118, 123, 124, 119, 121])).then(t => t.svelte())
    }
})];
async function G0e(t) {
    const e = on.matchFilename(W0e, t);
    if (e)
        return await e.load()
}
const yx = Je.define()
  , q0e = Qt.define({
    create: () => [],
    update(t, e) {
        if (!e.state.readOnly)
            return [];
        for (const n of e.effects)
            if (n.is(yx)) {
                const {value: r} = n
                  , i = typeof r == "boolean" ? r : r.show
                  , s = typeof r != "boolean" ? r.text : void 0;
                if (i)
                    return K0e(e.state, s)
            }
        return []
    },
    provide: t => dg.computeN([t], e => e.field(t))
});
function K0e(t, e) {
    return t.readOnly ? t.selection.ranges.map(n => ({
        pos: n.head,
        above: !0,
        strictSide: !0,
        arrow: !0,
        create: () => {
            const r = document.createElement("div");
            return r.className = "cm-readonly-tooltip",
            r.textContent = e ?? "Cannot edit file while AI response is being generated",
            {
                dom: r
            }
        }
    })) : []
}
const Y0e = nr("CodeMirrorEditor")
  , vx = Je.define()
  , LA = Qt.define({
    create() {
        return !0
    },
    update(t, e) {
        for (const n of e.effects)
            if (n.is(vx))
                return n.value;
        return t
    }
})
  , IF = S.memo( ({id: t, doc: e, autoFocusOnDocumentChange: n=!1, editable: r=!0, onScroll: i, onChange: s, onSave: o, theme: a, settings: l, className: c=""}) => {
    _r.trace("CodeMirrorEditor");
    const [u] = S.useState(new oa)
      , [h] = S.useState(new oa)
      , d = S.useRef(null)
      , f = S.useRef()
      , g = S.useRef()
      , _ = S.useRef()
      , m = S.useRef()
      , p = S.useRef(i)
      , b = S.useRef(s)
      , y = S.useRef(o);
    return S.useEffect( () => {
        p.current = i,
        b.current = s,
        y.current = o,
        _.current = e,
        g.current = a
    }
    ),
    S.useEffect( () => {
        const x = C => {
            b.current?.(C)
        }
          , E = new Oe({
            parent: d.current,
            dispatchTransactions(C) {
                const k = E.state.selection;
                E.update(C);
                const I = E.state.selection
                  , N = I !== k && (I === void 0 || k === void 0 || !I.eq(k));
                _.current && (C.some(O => O.docChanged) || N) && (x({
                    selection: E.state.selection,
                    content: E.state.doc.toString()
                }),
                m.current.set(_.current.filePath, E.state))
            }
        });
        f.current = E;
        const w = Pl.subscribe(C => {
            E.dispatch({
                effects: [h.reconfigure(C.lineWrapping ? [Oe.lineWrapping] : [])]
            })
        }
        )
          , A = me.currentView.subscribe( () => {
            E.dispatch({
                effects: [yx.of(!1), ou.of(!1)]
            })
        }
        );
        return () => {
            f.current?.destroy(),
            f.current = void 0,
            A(),
            w()
        }
    }
    , []),
    S.useEffect( () => {
        f.current && f.current.dispatch({
            effects: [AF(a)]
        })
    }
    , [a]),
    S.useEffect( () => {
        m.current = new Map
    }
    , [t]),
    S.useEffect( () => {
        const x = m.current
          , E = f.current
          , w = g.current;
        if (!e) {
            const I = OA(void 0, w, l, p, y, [u.of([])]);
            E.setState(I),
            X0e(E);
            return
        }
        if (e.isBinary)
            return;
        e.filePath === "" && Y0e.warn("File path should not be empty");
        let A = x.get(e.filePath);
        const C = Pl.get().lineWrapping;
        A || (A = OA(e.value, w, l, p, y, [u.of([]), h.of(C ? [Oe.lineWrapping] : [])]),
        x.set(e.filePath, A));
        const k = E.state.doc.toString();
        (e.value === k || !e.value.startsWith(k)) && E.setState(A),
        Q0e(E, w, r, C, h, u, n, e)
    }
    , [e?.value, r, e?.filePath, n]),
    v.jsxs("div", {
        className: be("relative h-full", c),
        children: [e?.isBinary && v.jsx(A0e, {}), v.jsx("div", {
            className: "h-full overflow-hidden",
            ref: d
        })]
    })
}
);
IF.displayName = "CodeMirrorEditor";
function OA(t, e, n, r, i, s) {
    return lt.create({
        doc: t ?? "",
        extensions: [Oe.domEventHandlers({
            scroll: (o, a) => {
                o.target === a.scrollDOM && r.current?.({
                    left: a.scrollDOM.scrollLeft,
                    top: a.scrollDOM.scrollTop
                })
            }
            ,
            mousedown: (o, a) => (a.dispatch({
                effects: [ou.of(!1)]
            }),
            !1),
            mouseup: (o, a) => (a.dispatch({
                effects: [ou.of(!a.state.selection.main.empty && a.hasFocus)]
            }),
            !1),
            keyup: (o, a) => (o.key === "Shift" && a.dispatch({
                effects: [ou.of(!a.state.selection.main.empty && o.key === "Shift")]
            }),
            !1),
            keydown: (o, a) => a.state.readOnly ? (a.dispatch({
                effects: [yx.of({
                    show: o.key !== "Escape",
                    text: t === void 0 ? "No file selected" : void 0
                })]
            }),
            !0) : !1
        }), H0e(e, n), ige(), hg.of([...o0e, ...fge, ...S0e, {
            key: "Tab",
            run: DB
        }, {
            key: "Mod-s",
            preventDefault: !0,
            run: () => (i.current?.(),
            !0)
        }, V0e]), Ql.of("  "), Gme({
            closeOnBlur: !1
        }), Tfe({
            position: "absolute",
            parent: document.body,
            tooltipSpace: o => {
                const a = o.dom.getBoundingClientRect();
                return {
                    top: a.top - 50,
                    left: a.left,
                    bottom: a.bottom,
                    right: a.right + 10
                }
            }
        }), Mme(), Bfe(), xfe(), vfe(), mfe(), Gpe(), lt.tabSize.of(n?.tabSize ?? 2), wpe(), CF, k0e, q0e, LA, lt.readOnly.from(LA, o => !o), Hfe(), Efe(), Ope({
            markerDOM: o => {
                const a = document.createElement("div");
                return a.className = `fold-icon ${o ? "i-ph-caret-down-bold" : "i-ph-caret-right-bold"}`,
                a
            }
        }), ...s]
    })
}
function X0e(t) {
    t.dispatch({
        selection: {
            anchor: 0
        },
        effects: [vx.of(!1)],
        changes: {
            from: 0,
            to: t.state.doc.length,
            insert: ""
        }
    }),
    t.scrollDOM.scrollTo(0, 0)
}
function Q0e(t, e, n, r, i, s, o, a) {
    const l = t.state.doc.toString();
    let c = !1;
    a.value !== l && (a.value.startsWith(l) ? (t.dispatch({
        changes: {
            from: t.state.doc.length,
            insert: a.value.slice(l.length)
        }
    }),
    c = !0) : t.dispatch({
        selection: {
            anchor: 0
        },
        changes: {
            from: 0,
            to: t.state.doc.length,
            insert: a.value
        }
    })),
    t.dispatch({
        effects: [wF.of(a.filePath), vx.of(n && !a.isBinary), ...r ? [i.reconfigure(Oe.lineWrapping)] : []]
    }),
    G0e(a.filePath).then(u => {
        u && (t.dispatch({
            effects: [s.reconfigure([u]), AF(e)]
        }),
        requestAnimationFrame( () => {
            if (c)
                return;
            const h = t.scrollDOM.scrollLeft
              , d = t.scrollDOM.scrollTop
              , f = a.scroll?.left ?? 0
              , g = a.scroll?.top ?? 0;
            o && n && (h !== f || d !== g ? t.scrollDOM.addEventListener("scroll", () => {
                t.focus()
            }
            , {
                once: !0
            }) : t.focus()),
            t.scrollDOM.scrollTo(f, g)
        }
        ))
    }
    )
}
const NA = S.memo( ({className: t, disabledClassName: e, disabled: n=!1, children: r, onClick: i}) => v.jsx("button", {
    className: be("flex items-center shrink-0 gap-1.5 px-1.5 rounded-md py-0.5 text-bolt-elements-item-contentDefault bg-transparent enabled:hover:text-bolt-elements-item-contentActive enabled:hover:bg-bolt-elements-item-backgroundActive disabled:cursor-not-allowed", {
        [be("opacity-30", e)]: n
    }, t),
    disabled: n,
    onClick: s => {
        n || i?.(s)
    }
    ,
    children: r
}));
function J0e(t) {
    const [e,n] = S.useState(!1);
    S.useEffect( () => {
        const i = l => {
            l.preventDefault(),
            n(!0)
        }
          , s = l => {
            l.preventDefault(),
            (l.clientX <= 0 || l.clientX >= window.innerWidth || l.clientY <= 0 || l.clientY >= window.innerHeight) && n(!1)
        }
          , o = l => {
            l.preventDefault()
        }
          , a = l => {
            l.preventDefault(),
            n(!1)
        }
        ;
        return document.addEventListener("dragenter", i),
        document.addEventListener("dragleave", s),
        document.addEventListener("dragover", o),
        document.addEventListener("drop", a),
        () => {
            document.removeEventListener("dragenter", i),
            document.removeEventListener("dragleave", s),
            document.removeEventListener("dragover", o),
            document.removeEventListener("drop", a)
        }
    }
    , []);
    const r = S.useCallback(async i => {
        n(!1);
        const {items: s} = i.dataTransfer;
        for (let o = 0; o < s.length; o++)
            if (s[o].kind === "file") {
                const a = s[o].getAsFile();
                if (!VL(a))
                    break;
                a && (i.preventDefault(),
                await t?.(a))
            }
    }
    , [t]);
    return {
        isDragging: e,
        handleDrop: r
    }
}
function Z0e(t) {
    const e = ["ROOT"];
    let n = -1
      , r = null;
    function i(l, c, u) {
        switch (l) {
        case '"':
            {
                n = c,
                e.pop(),
                e.push(u),
                e.push("INSIDE_STRING");
                break
            }
        case "f":
        case "t":
        case "n":
            {
                n = c,
                r = c,
                e.pop(),
                e.push(u),
                e.push("INSIDE_LITERAL");
                break
            }
        case "-":
            {
                e.pop(),
                e.push(u),
                e.push("INSIDE_NUMBER");
                break
            }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
            {
                n = c,
                e.pop(),
                e.push(u),
                e.push("INSIDE_NUMBER");
                break
            }
        case "{":
            {
                n = c,
                e.pop(),
                e.push(u),
                e.push("INSIDE_OBJECT_START");
                break
            }
        case "[":
            {
                n = c,
                e.pop(),
                e.push(u),
                e.push("INSIDE_ARRAY_START");
                break
            }
        }
    }
    function s(l, c) {
        switch (l) {
        case ",":
            {
                e.pop(),
                e.push("INSIDE_OBJECT_AFTER_COMMA");
                break
            }
        case "}":
            {
                n = c,
                e.pop();
                break
            }
        }
    }
    function o(l, c) {
        switch (l) {
        case ",":
            {
                e.pop(),
                e.push("INSIDE_ARRAY_AFTER_COMMA");
                break
            }
        case "]":
            {
                n = c,
                e.pop();
                break
            }
        }
    }
    for (let l = 0; l < t.length; l++) {
        const c = t[l];
        switch (e[e.length - 1]) {
        case "ROOT":
            i(c, l, "FINISH");
            break;
        case "INSIDE_OBJECT_START":
            {
                switch (c) {
                case '"':
                    {
                        e.pop(),
                        e.push("INSIDE_OBJECT_KEY");
                        break
                    }
                case "}":
                    {
                        n = l,
                        e.pop();
                        break
                    }
                }
                break
            }
        case "INSIDE_OBJECT_AFTER_COMMA":
            {
                switch (c) {
                case '"':
                    {
                        e.pop(),
                        e.push("INSIDE_OBJECT_KEY");
                        break
                    }
                }
                break
            }
        case "INSIDE_OBJECT_KEY":
            {
                switch (c) {
                case '"':
                    {
                        e.pop(),
                        e.push("INSIDE_OBJECT_AFTER_KEY");
                        break
                    }
                }
                break
            }
        case "INSIDE_OBJECT_AFTER_KEY":
            {
                switch (c) {
                case ":":
                    {
                        e.pop(),
                        e.push("INSIDE_OBJECT_BEFORE_VALUE");
                        break
                    }
                }
                break
            }
        case "INSIDE_OBJECT_BEFORE_VALUE":
            {
                i(c, l, "INSIDE_OBJECT_AFTER_VALUE");
                break
            }
        case "INSIDE_OBJECT_AFTER_VALUE":
            {
                s(c, l);
                break
            }
        case "INSIDE_STRING":
            {
                switch (c) {
                case '"':
                    {
                        e.pop(),
                        n = l;
                        break
                    }
                case "\\":
                    {
                        e.push("INSIDE_STRING_ESCAPE");
                        break
                    }
                default:
                    n = l
                }
                break
            }
        case "INSIDE_ARRAY_START":
            {
                switch (c) {
                case "]":
                    {
                        n = l,
                        e.pop();
                        break
                    }
                default:
                    {
                        n = l,
                        i(c, l, "INSIDE_ARRAY_AFTER_VALUE");
                        break
                    }
                }
                break
            }
        case "INSIDE_ARRAY_AFTER_VALUE":
            {
                switch (c) {
                case ",":
                    {
                        e.pop(),
                        e.push("INSIDE_ARRAY_AFTER_COMMA");
                        break
                    }
                case "]":
                    {
                        n = l,
                        e.pop();
                        break
                    }
                default:
                    {
                        n = l;
                        break
                    }
                }
                break
            }
        case "INSIDE_ARRAY_AFTER_COMMA":
            {
                i(c, l, "INSIDE_ARRAY_AFTER_VALUE");
                break
            }
        case "INSIDE_STRING_ESCAPE":
            {
                e.pop(),
                n = l;
                break
            }
        case "INSIDE_NUMBER":
            {
                switch (c) {
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        n = l;
                        break
                    }
                case "e":
                case "E":
                case "-":
                case ".":
                    break;
                case ",":
                    {
                        e.pop(),
                        e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l),
                        e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(c, l);
                        break
                    }
                case "}":
                    {
                        e.pop(),
                        e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && s(c, l);
                        break
                    }
                case "]":
                    {
                        e.pop(),
                        e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l);
                        break
                    }
                default:
                    {
                        e.pop();
                        break
                    }
                }
                break
            }
        case "INSIDE_LITERAL":
            {
                const h = t.substring(r, l + 1);
                !"false".startsWith(h) && !"true".startsWith(h) && !"null".startsWith(h) ? (e.pop(),
                e[e.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? s(c, l) : e[e.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && o(c, l)) : n = l;
                break
            }
        }
    }
    let a = t.slice(0, n + 1);
    for (let l = e.length - 1; l >= 0; l--)
        switch (e[l]) {
        case "INSIDE_STRING":
            {
                a += '"';
                break
            }
        case "INSIDE_OBJECT_KEY":
        case "INSIDE_OBJECT_AFTER_KEY":
        case "INSIDE_OBJECT_AFTER_COMMA":
        case "INSIDE_OBJECT_START":
        case "INSIDE_OBJECT_BEFORE_VALUE":
        case "INSIDE_OBJECT_AFTER_VALUE":
            {
                a += "}";
                break
            }
        case "INSIDE_ARRAY_START":
        case "INSIDE_ARRAY_AFTER_COMMA":
        case "INSIDE_ARRAY_AFTER_VALUE":
            {
                a += "]";
                break
            }
        case "INSIDE_LITERAL":
            {
                const u = t.substring(r, t.length);
                "true".startsWith(u) ? a += "true".slice(u.length) : "false".startsWith(u) ? a += "false".slice(u.length) : "null".startsWith(u) && (a += "null".slice(u.length))
            }
        }
    return a
}
function e_e(t) {
    if (t === void 0)
        return {
            value: void 0,
            state: "undefined-input"
        };
    try {
        return {
            value: mC.parse(t),
            state: "successful-parse"
        }
    } catch {
        try {
            return {
                value: mC.parse(Z0e(t)),
                state: "repaired-parse"
            }
        } catch {}
    }
    return {
        value: void 0,
        state: "failed-parse"
    }
}
var ih = {
    code: "0",
    name: "text",
    parse: t => {
        if (typeof t != "string")
            throw new Error('"text" parts expect a string value.');
        return {
            type: "text",
            value: t
        }
    }
}
  , sh = {
    code: "1",
    name: "function_call",
    parse: t => {
        if (t == null || typeof t != "object" || !("function_call"in t) || typeof t.function_call != "object" || t.function_call == null || !("name"in t.function_call) || !("arguments"in t.function_call) || typeof t.function_call.name != "string" || typeof t.function_call.arguments != "string")
            throw new Error('"function_call" parts expect an object with a "function_call" property.');
        return {
            type: "function_call",
            value: t
        }
    }
}
  , oh = {
    code: "2",
    name: "data",
    parse: t => {
        if (!Array.isArray(t))
            throw new Error('"data" parts expect an array value.');
        return {
            type: "data",
            value: t
        }
    }
}
  , ah = {
    code: "3",
    name: "error",
    parse: t => {
        if (typeof t != "string")
            throw new Error('"error" parts expect a string value.');
        return {
            type: "error",
            value: t
        }
    }
}
  , lh = {
    code: "4",
    name: "assistant_message",
    parse: t => {
        if (t == null || typeof t != "object" || !("id"in t) || !("role"in t) || !("content"in t) || typeof t.id != "string" || typeof t.role != "string" || t.role !== "assistant" || !Array.isArray(t.content) || !t.content.every(e => e != null && typeof e == "object" && "type"in e && e.type === "text" && "text"in e && e.text != null && typeof e.text == "object" && "value"in e.text && typeof e.text.value == "string"))
            throw new Error('"assistant_message" parts expect an object with an "id", "role", and "content" property.');
        return {
            type: "assistant_message",
            value: t
        }
    }
}
  , ch = {
    code: "5",
    name: "assistant_control_data",
    parse: t => {
        if (t == null || typeof t != "object" || !("threadId"in t) || !("messageId"in t) || typeof t.threadId != "string" || typeof t.messageId != "string")
            throw new Error('"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.');
        return {
            type: "assistant_control_data",
            value: {
                threadId: t.threadId,
                messageId: t.messageId
            }
        }
    }
}
  , uh = {
    code: "6",
    name: "data_message",
    parse: t => {
        if (t == null || typeof t != "object" || !("role"in t) || !("data"in t) || typeof t.role != "string" || t.role !== "data")
            throw new Error('"data_message" parts expect an object with a "role" and "data" property.');
        return {
            type: "data_message",
            value: t
        }
    }
}
  , hh = {
    code: "7",
    name: "tool_calls",
    parse: t => {
        if (t == null || typeof t != "object" || !("tool_calls"in t) || typeof t.tool_calls != "object" || t.tool_calls == null || !Array.isArray(t.tool_calls) || t.tool_calls.some(e => e == null || typeof e != "object" || !("id"in e) || typeof e.id != "string" || !("type"in e) || typeof e.type != "string" || !("function"in e) || e.function == null || typeof e.function != "object" || !("arguments"in e.function) || typeof e.function.name != "string" || typeof e.function.arguments != "string"))
            throw new Error('"tool_calls" parts expect an object with a ToolCallPayload.');
        return {
            type: "tool_calls",
            value: t
        }
    }
}
  , dh = {
    code: "8",
    name: "message_annotations",
    parse: t => {
        if (!Array.isArray(t))
            throw new Error('"message_annotations" parts expect an array value.');
        return {
            type: "message_annotations",
            value: t
        }
    }
}
  , fh = {
    code: "9",
    name: "tool_call",
    parse: t => {
        if (t == null || typeof t != "object" || !("toolCallId"in t) || typeof t.toolCallId != "string" || !("toolName"in t) || typeof t.toolName != "string" || !("args"in t) || typeof t.args != "object")
            throw new Error('"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.');
        return {
            type: "tool_call",
            value: t
        }
    }
}
  , ph = {
    code: "a",
    name: "tool_result",
    parse: t => {
        if (t == null || typeof t != "object" || !("toolCallId"in t) || typeof t.toolCallId != "string" || !("result"in t))
            throw new Error('"tool_result" parts expect an object with a "toolCallId" and a "result" property.');
        return {
            type: "tool_result",
            value: t
        }
    }
}
  , mh = {
    code: "b",
    name: "tool_call_streaming_start",
    parse: t => {
        if (t == null || typeof t != "object" || !("toolCallId"in t) || typeof t.toolCallId != "string" || !("toolName"in t) || typeof t.toolName != "string")
            throw new Error('"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.');
        return {
            type: "tool_call_streaming_start",
            value: t
        }
    }
}
  , gh = {
    code: "c",
    name: "tool_call_delta",
    parse: t => {
        if (t == null || typeof t != "object" || !("toolCallId"in t) || typeof t.toolCallId != "string" || !("argsTextDelta"in t) || typeof t.argsTextDelta != "string")
            throw new Error('"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.');
        return {
            type: "tool_call_delta",
            value: t
        }
    }
}
  , _h = {
    code: "d",
    name: "finish_message",
    parse: t => {
        if (t == null || typeof t != "object" || !("finishReason"in t) || typeof t.finishReason != "string")
            throw new Error('"finish_message" parts expect an object with a "finishReason" property.');
        const e = {
            finishReason: t.finishReason
        };
        return "usage"in t && t.usage != null && typeof t.usage == "object" && "promptTokens"in t.usage && "completionTokens"in t.usage && (e.usage = {
            promptTokens: typeof t.usage.promptTokens == "number" ? t.usage.promptTokens : Number.NaN,
            completionTokens: typeof t.usage.completionTokens == "number" ? t.usage.completionTokens : Number.NaN
        }),
        {
            type: "finish_message",
            value: e
        }
    }
}
  , bh = {
    code: "e",
    name: "finish_roundtrip",
    parse: t => {
        if (t == null || typeof t != "object" || !("finishReason"in t) || typeof t.finishReason != "string")
            throw new Error('"finish_roundtrip" parts expect an object with a "finishReason" property.');
        const e = {
            finishReason: t.finishReason
        };
        return "usage"in t && t.usage != null && typeof t.usage == "object" && "promptTokens"in t.usage && "completionTokens"in t.usage && (e.usage = {
            promptTokens: typeof t.usage.promptTokens == "number" ? t.usage.promptTokens : Number.NaN,
            completionTokens: typeof t.usage.completionTokens == "number" ? t.usage.completionTokens : Number.NaN
        }),
        {
            type: "finish_roundtrip",
            value: e
        }
    }
}
  , t_e = [ih, sh, oh, ah, lh, ch, uh, hh, dh, fh, ph, mh, gh, _h, bh]
  , n_e = {
    [ih.code]: ih,
    [sh.code]: sh,
    [oh.code]: oh,
    [ah.code]: ah,
    [lh.code]: lh,
    [ch.code]: ch,
    [uh.code]: uh,
    [hh.code]: hh,
    [dh.code]: dh,
    [fh.code]: fh,
    [ph.code]: ph,
    [mh.code]: mh,
    [gh.code]: gh,
    [_h.code]: _h,
    [bh.code]: bh
};
ih.name + "",
ih.code,
sh.name + "",
sh.code,
oh.name + "",
oh.code,
ah.name + "",
ah.code,
lh.name + "",
lh.code,
ch.name + "",
ch.code,
uh.name + "",
uh.code,
hh.name + "",
hh.code,
dh.name + "",
dh.code,
fh.name + "",
fh.code,
ph.name + "",
ph.code,
mh.name + "",
mh.code,
gh.name + "",
gh.code,
_h.name + "",
_h.code,
bh.name + "",
bh.code;
var r_e = t_e.map(t => t.code)
  , i_e = t => {
    const e = t.indexOf(":");
    if (e === -1)
        throw new Error("Failed to parse stream string. No separator found.");
    const n = t.slice(0, e);
    if (!r_e.includes(n))
        throw new Error(`Failed to parse stream string. Invalid code ${n}.`);
    const r = n
      , i = t.slice(e + 1)
      , s = JSON.parse(i);
    return n_e[r].parse(s)
}
  , s_e = 10;
function o_e(t, e) {
    const n = new Uint8Array(e);
    let r = 0;
    for (const i of t)
        n.set(i, r),
        r += i.length;
    return t.length = 0,
    n
}
async function *a_e(t, {isAborted: e}={}) {
    const n = new TextDecoder
      , r = [];
    let i = 0;
    for (; ; ) {
        const {value: s} = await t.read();
        if (s && (r.push(s),
        i += s.length,
        s[s.length - 1] !== s_e))
            continue;
        if (r.length === 0)
            break;
        const o = o_e(r, i);
        i = 0;
        const a = n.decode(o, {
            stream: !0
        }).split(`
`).filter(l => l !== "").map(i_e);
        for (const l of a)
            yield l;
        if (e?.()) {
            t.cancel();
            break
        }
    }
}
function rf(t, e) {
    return !t || !e || !e.length ? t : {
        ...t,
        annotations: [...e]
    }
}
async function l_e({reader: t, abortControllerRef: e, update: n, onToolCall: r, onFinish: i, generateId: s=Gh, getCurrentDate: o= () => new Date}) {
    var a;
    const l = o();
    let c = {}, u;
    const h = []
      , d = [];
    let f;
    const g = {};
    let _ = {
        completionTokens: NaN,
        promptTokens: NaN,
        totalTokens: NaN
    }
      , m = "unknown";
    for await(const {type: p, value: b} of a_e(t, {
        isAborted: () => e?.current === null
    })) {
        if (p === "error")
            throw new Error(b);
        if (p === "finish_roundtrip") {
            u = {};
            continue
        }
        if (p === "finish_message") {
            if (m = b.finishReason,
            b.usage != null) {
                const {completionTokens: A, promptTokens: C} = b.usage;
                _ = {
                    completionTokens: A,
                    promptTokens: C,
                    totalTokens: A + C
                }
            }
            continue
        }
        if (u && (c.text && h.push(c.text),
        c.function_call && h.push(c.function_call),
        c.tool_calls && h.push(c.tool_calls),
        c = u,
        u = void 0),
        p === "text" && (c.text ? c.text = {
            ...c.text,
            content: (c.text.content || "") + b
        } : c.text = {
            id: s(),
            role: "assistant",
            content: b,
            createdAt: l
        }),
        p === "tool_call_streaming_start")
            c.text == null && (c.text = {
                id: s(),
                role: "assistant",
                content: "",
                createdAt: l
            }),
            c.text.toolInvocations == null && (c.text.toolInvocations = []),
            g[b.toolCallId] = {
                text: "",
                toolName: b.toolName,
                prefixMapIndex: c.text.toolInvocations.length
            },
            c.text.toolInvocations.push({
                state: "partial-call",
                toolCallId: b.toolCallId,
                toolName: b.toolName,
                args: void 0
            });
        else if (p === "tool_call_delta") {
            const A = g[b.toolCallId];
            A.text += b.argsTextDelta;
            const {value: C} = e_e(A.text);
            c.text.toolInvocations[A.prefixMapIndex] = {
                state: "partial-call",
                toolCallId: b.toolCallId,
                toolName: A.toolName,
                args: C
            },
            c.text.internalUpdateId = s()
        } else if (p === "tool_call") {
            if (g[b.toolCallId] != null ? c.text.toolInvocations[g[b.toolCallId].prefixMapIndex] = {
                state: "call",
                ...b
            } : (c.text == null && (c.text = {
                id: s(),
                role: "assistant",
                content: "",
                createdAt: l
            }),
            c.text.toolInvocations == null && (c.text.toolInvocations = []),
            c.text.toolInvocations.push({
                state: "call",
                ...b
            })),
            c.text.internalUpdateId = s(),
            r) {
                const A = await r({
                    toolCall: b
                });
                A != null && (c.text.toolInvocations[c.text.toolInvocations.length - 1] = {
                    state: "result",
                    ...b,
                    result: A
                })
            }
        } else if (p === "tool_result") {
            const A = (a = c.text) == null ? void 0 : a.toolInvocations;
            if (A == null)
                throw new Error("tool_result must be preceded by a tool_call");
            const C = A.findIndex(k => k.toolCallId === b.toolCallId);
            if (C === -1)
                throw new Error("tool_result must be preceded by a tool_call with the same toolCallId");
            A[C] = {
                ...A[C],
                state: "result",
                ...b
            }
        }
        let y = null;
        p === "function_call" && (c.function_call = {
            id: s(),
            role: "assistant",
            content: "",
            function_call: b.function_call,
            name: b.function_call.name,
            createdAt: l
        },
        y = c.function_call);
        let x = null;
        p === "tool_calls" && (c.tool_calls = {
            id: s(),
            role: "assistant",
            content: "",
            tool_calls: b.tool_calls,
            createdAt: l
        },
        x = c.tool_calls),
        p === "data" && d.push(...b);
        let E = c.text;
        p === "message_annotations" && (f ? f.push(...b) : f = [...b],
        y = rf(c.function_call, f),
        x = rf(c.tool_calls, f),
        E = rf(c.text, f)),
        f?.length && (c.text && (c.text.annotations = [...f]),
        c.function_call && (c.function_call.annotations = [...f]),
        c.tool_calls && (c.tool_calls.annotations = [...f]));
        const w = [y, x, E].filter(Boolean).map(A => ({
            ...rf(A, f)
        }));
        n([...h, ...w], [...d])
    }
    return i?.({
        message: c.text,
        finishReason: m,
        usage: _
    }),
    {
        messages: [c.text, c.function_call, c.tool_calls].filter(Boolean),
        data: d
    }
}
var c_e = () => fetch;
async function u_e({api: t, body: e, streamProtocol: n="data", credentials: r, headers: i, abortController: s, restoreMessagesOnFailure: o, onResponse: a, onUpdate: l, onFinish: c, onToolCall: u, generateId: h, fetch: d=c_e()}) {
    var f, g;
    const _ = await d(t, {
        method: "POST",
        body: JSON.stringify(e),
        headers: {
            "Content-Type": "application/json",
            ...i
        },
        signal: (f = s?.()) == null ? void 0 : f.signal,
        credentials: r
    }).catch(p => {
        throw o(),
        p
    }
    );
    if (a)
        try {
            await a(_)
        } catch (p) {
            throw p
        }
    if (!_.ok)
        throw o(),
        new Error((g = await _.text()) != null ? g : "Failed to fetch the chat response.");
    if (!_.body)
        throw new Error("The response body is empty.");
    const m = _.body.getReader();
    switch (n) {
    case "text":
        {
            const p = h_e()
              , b = {
                id: h(),
                createdAt: new Date,
                role: "assistant",
                content: ""
            };
            for (; ; ) {
                const {done: y, value: x} = await m.read();
                if (y)
                    break;
                if (b.content += p(x),
                l([{
                    ...b
                }], []),
                s?.() === null) {
                    m.cancel();
                    break
                }
            }
            console.log('swc:', b)
            return c?.(b, {
                usage: {
                    completionTokens: NaN,
                    promptTokens: NaN,
                    totalTokens: NaN
                },
                finishReason: "unknown"
            }),
            {
                messages: [b],
                data: []
            }
        }
    case "data":
        return await l_e({
            reader: m,
            abortControllerRef: s != null ? {
                current: s()
            } : void 0,
            update: l,
            onToolCall: u,
            onFinish({message: p, finishReason: b, usage: y}) {
                console.log('p :', p)
                c && p != null && c(p, {
                    usage: y,
                    finishReason: b
                })
            },
            generateId: h
        });
    default:
        {
            const p = n;
            throw new Error(`Unknown stream protocol: ${p}`)
        }
    }
}
function h_e(t) {
    const e = new TextDecoder;
    return function(n) {
        return n ? e.decode(n, {
            stream: !0
        }) : ""
    }
}
async function d_e({getStreamedResponse: t, experimental_onFunctionCall: e, experimental_onToolCall: n, updateChatRequest: r, getCurrentMessages: i}) {
    for (; ; ) {
        const s = await t();
        if ("messages"in s) {
            let o = !1;
            for (const a of s.messages)
                if (!((a.function_call === void 0 || typeof a.function_call == "string") && (a.tool_calls === void 0 || typeof a.tool_calls == "string"))) {
                    if (o = !0,
                    e) {
                        const l = a.function_call;
                        if (typeof l != "object") {
                            console.warn("experimental_onFunctionCall should not be defined when using tools");
                            continue
                        }
                        const c = await e(i(), l);
                        if (c === void 0) {
                            o = !1;
                            break
                        }
                        r(c)
                    }
                    if (n) {
                        const l = a.tool_calls;
                        if (!Array.isArray(l) || l.some(u => typeof u != "object")) {
                            console.warn("experimental_onToolCall should not be defined when using tools");
                            continue
                        }
                        const c = await n(i(), l);
                        if (c === void 0) {
                            o = !1;
                            break
                        }
                        r(c)
                    }
                }
            if (!o)
                break
        } else {
            let o = function(l) {
                for (const c of l.messages) {
                    if (c.tool_calls !== void 0)
                        for (const u of c.tool_calls)
                            typeof u == "object" && u.function.arguments && typeof u.function.arguments != "string" && (u.function.arguments = JSON.stringify(u.function.arguments));
                    c.function_call !== void 0 && typeof c.function_call == "object" && c.function_call.arguments && typeof c.function_call.arguments != "string" && (c.function_call.arguments = JSON.stringify(c.function_call.arguments))
                }
            };
            const a = s;
            if ((a.function_call === void 0 || typeof a.function_call == "string") && (a.tool_calls === void 0 || typeof a.tool_calls == "string"))
                break;
            if (e) {
                const l = a.function_call;
                if (typeof l != "object") {
                    console.warn("experimental_onFunctionCall should not be defined when using tools");
                    continue
                }
                const c = await e(i(), l);
                if (c === void 0)
                    break;
                o(c),
                r(c)
            }
            if (n) {
                const l = a.tool_calls;
                if (typeof l != "object") {
                    console.warn("experimental_onToolCall should not be defined when using functions");
                    continue
                }
                const c = await n(i(), l);
                if (c === void 0)
                    break;
                o(c),
                r(c)
            }
        }
    }
}
var PF = {
    exports: {}
}
  , DF = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Bl = S;
function f_e(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var p_e = typeof Object.is == "function" ? Object.is : f_e
  , m_e = Bl.useState
  , g_e = Bl.useEffect
  , __e = Bl.useLayoutEffect
  , b_e = Bl.useDebugValue;
function y_e(t, e) {
    var n = e()
      , r = m_e({
        inst: {
            value: n,
            getSnapshot: e
        }
    })
      , i = r[0].inst
      , s = r[1];
    return __e(function() {
        i.value = n,
        i.getSnapshot = e,
        J0(i) && s({
            inst: i
        })
    }, [t, n, e]),
    g_e(function() {
        return J0(i) && s({
            inst: i
        }),
        t(function() {
            J0(i) && s({
                inst: i
            })
        })
    }, [t]),
    b_e(n),
    n
}
function J0(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !p_e(t, n)
    } catch {
        return !0
    }
}
function v_e(t, e) {
    return e()
}
var x_e = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? v_e : y_e;
DF.useSyncExternalStore = Bl.useSyncExternalStore !== void 0 ? Bl.useSyncExternalStore : x_e;
PF.exports = DF;
var E_e = PF.exports;
const Ps = () => {}
  , Zn = Ps()
  , Z0 = Object
  , ft = t => t === Zn
  , yi = t => typeof t == "function"
  , no = (t, e) => ({
    ...t,
    ...e
})
  , S_e = t => yi(t.then)
  , sf = new WeakMap;
let w_e = 0;
const yh = t => {
    const e = typeof t
      , n = t && t.constructor
      , r = n == Date;
    let i, s;
    if (Z0(t) === t && !r && n != RegExp) {
        if (i = sf.get(t),
        i)
            return i;
        if (i = ++w_e + "~",
        sf.set(t, i),
        n == Array) {
            for (i = "@",
            s = 0; s < t.length; s++)
                i += yh(t[s]) + ",";
            sf.set(t, i)
        }
        if (n == Z0) {
            i = "#";
            const o = Z0.keys(t).sort();
            for (; !ft(s = o.pop()); )
                ft(t[s]) || (i += s + ":" + yh(t[s]) + ",");
            sf.set(t, i)
        }
    } else
        i = r ? t.toJSON() : e == "symbol" ? t.toString() : e == "string" ? JSON.stringify(t) : "" + t;
    return i
}
  , zi = new WeakMap
  , e_ = {}
  , of = {}
  , xx = "undefined"
  , bg = typeof window != xx
  , by = typeof document != xx
  , C_e = () => bg && typeof window.requestAnimationFrame != xx
  , LF = (t, e) => {
    const n = zi.get(t);
    return [ () => !ft(e) && t.get(e) || e_, r => {
        if (!ft(e)) {
            const i = t.get(e);
            e in of || (of[e] = i),
            n[5](e, no(i, r), i || e_)
        }
    }
    , n[6], () => !ft(e) && e in of ? of[e] : !ft(e) && t.get(e) || e_]
}
;
let yy = !0;
const T_e = () => yy
  , [vy,xy] = bg && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [Ps, Ps]
  , A_e = () => {
    const t = by && document.visibilityState;
    return ft(t) || t !== "hidden"
}
  , k_e = t => (by && document.addEventListener("visibilitychange", t),
vy("focus", t),
() => {
    by && document.removeEventListener("visibilitychange", t),
    xy("focus", t)
}
)
  , R_e = t => {
    const e = () => {
        yy = !0,
        t()
    }
      , n = () => {
        yy = !1
    }
    ;
    return vy("online", e),
    vy("offline", n),
    () => {
        xy("online", e),
        xy("offline", n)
    }
}
  , I_e = {
    isOnline: T_e,
    isVisible: A_e
}
  , P_e = {
    initFocus: k_e,
    initReconnect: R_e
}
  , MA = !Cr.useId
  , vh = !bg || "Deno"in window
  , D_e = t => C_e() ? window.requestAnimationFrame(t) : setTimeout(t, 1)
  , t_ = vh ? S.useEffect : S.useLayoutEffect
  , n_ = typeof navigator < "u" && navigator.connection
  , BA = !vh && n_ && (["slow-2g", "2g"].includes(n_.effectiveType) || n_.saveData)
  , Ex = t => {
    if (yi(t))
        try {
            t = t()
        } catch {
            t = ""
        }
    const e = t;
    return t = typeof t == "string" ? t : (Array.isArray(t) ? t.length : t) ? yh(t) : "",
    [t, e]
}
;
let L_e = 0;
const Ey = () => ++L_e
  , OF = 0
  , NF = 1
  , MF = 2
  , O_e = 3;
var yc = {
    __proto__: null,
    ERROR_REVALIDATE_EVENT: O_e,
    FOCUS_EVENT: OF,
    MUTATE_EVENT: MF,
    RECONNECT_EVENT: NF
};
async function BF(...t) {
    const [e,n,r,i] = t
      , s = no({
        populateCache: !0,
        throwOnError: !0
    }, typeof i == "boolean" ? {
        revalidate: i
    } : i || {});
    let o = s.populateCache;
    const a = s.rollbackOnError;
    let l = s.optimisticData;
    const c = d => typeof a == "function" ? a(d) : a !== !1
      , u = s.throwOnError;
    if (yi(n)) {
        const d = n
          , f = []
          , g = e.keys();
        for (const _ of g)
            !/^\$(inf|sub)\$/.test(_) && d(e.get(_)._k) && f.push(_);
        return Promise.all(f.map(h))
    }
    return h(n);
    async function h(d) {
        const [f] = Ex(d);
        if (!f)
            return;
        const [g,_] = LF(e, f)
          , [m,p,b,y] = zi.get(e)
          , x = () => {
            const M = m[f];
            return (yi(s.revalidate) ? s.revalidate(g().data, d) : s.revalidate !== !1) && (delete b[f],
            delete y[f],
            M && M[0]) ? M[0](MF).then( () => g().data) : g().data
        }
        ;
        if (t.length < 3)
            return x();
        let E = r, w;
        const A = Ey();
        p[f] = [A, 0];
        const C = !ft(l)
          , k = g()
          , I = k.data
          , N = k._c
          , O = ft(N) ? I : N;
        if (C && (l = yi(l) ? l(O, I) : l,
        _({
            data: l,
            _c: O
        })),
        yi(E))
            try {
                E = E(O)
            } catch (M) {
                w = M
            }
        if (E && S_e(E))
            if (E = await E.catch(M => {
                w = M
            }
            ),
            A !== p[f][0]) {
                if (w)
                    throw w;
                return E
            } else
                w && C && c(w) && (o = !0,
                _({
                    data: O,
                    _c: Zn
                }));
        if (o && !w)
            if (yi(o)) {
                const M = o(E, O);
                _({
                    data: M,
                    error: Zn,
                    _c: Zn
                })
            } else
                _({
                    data: E,
                    error: Zn,
                    _c: Zn
                });
        if (p[f][1] = Ey(),
        Promise.resolve(x()).then( () => {
            _({
                _c: Zn
            })
        }
        ),
        w) {
            if (u)
                throw w;
            return
        }
        return E
    }
}
const FA = (t, e) => {
    for (const n in t)
        t[n][0] && t[n][0](e)
}
  , N_e = (t, e) => {
    if (!zi.has(t)) {
        const n = no(P_e, e)
          , r = {}
          , i = BF.bind(Zn, t);
        let s = Ps;
        const o = {}
          , a = (u, h) => {
            const d = o[u] || [];
            return o[u] = d,
            d.push(h),
            () => d.splice(d.indexOf(h), 1)
        }
          , l = (u, h, d) => {
            t.set(u, h);
            const f = o[u];
            if (f)
                for (const g of f)
                    g(h, d)
        }
          , c = () => {
            if (!zi.has(t) && (zi.set(t, [r, {}, {}, {}, i, l, a]),
            !vh)) {
                const u = n.initFocus(setTimeout.bind(Zn, FA.bind(Zn, r, OF)))
                  , h = n.initReconnect(setTimeout.bind(Zn, FA.bind(Zn, r, NF)));
                s = () => {
                    u && u(),
                    h && h(),
                    zi.delete(t)
                }
            }
        }
        ;
        return c(),
        [t, i, c, s]
    }
    return [t, zi.get(t)[4]]
}
  , M_e = (t, e, n, r, i) => {
    const s = n.errorRetryCount
      , o = i.retryCount
      , a = ~~((Math.random() + .5) * (1 << (o < 8 ? o : 8))) * n.errorRetryInterval;
    !ft(s) && o > s || setTimeout(r, a, i)
}
  , B_e = (t, e) => yh(t) == yh(e)
  , [FF,F_e] = N_e(new Map)
  , j_e = no({
    onLoadingSlow: Ps,
    onSuccess: Ps,
    onError: Ps,
    onErrorRetry: M_e,
    onDiscarded: Ps,
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    errorRetryInterval: BA ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: BA ? 5e3 : 3e3,
    compare: B_e,
    isPaused: () => !1,
    cache: FF,
    mutate: F_e,
    fallback: {}
}, I_e)
  , H_e = (t, e) => {
    const n = no(t, e);
    if (e) {
        const {use: r, fallback: i} = t
          , {use: s, fallback: o} = e;
        r && s && (n.use = r.concat(s)),
        i && o && (n.fallback = no(i, o))
    }
    return n
}
  , U_e = S.createContext({})
  , V_e = "$inf$"
  , jF = bg && window.__SWR_DEVTOOLS_USE__
  , $_e = jF ? window.__SWR_DEVTOOLS_USE__ : []
  , z_e = () => {
    jF && (window.__SWR_DEVTOOLS_REACT__ = Cr)
}
  , W_e = t => yi(t[1]) ? [t[0], t[1], t[2] || {}] : [t[0], null, (t[1] === null ? t[2] : t[1]) || {}]
  , G_e = () => no(j_e, S.useContext(U_e))
  , q_e = t => (e, n, r) => t(e, n && ( (...s) => {
    const [o] = Ex(e)
      , [,,,a] = zi.get(FF);
    if (o.startsWith(V_e))
        return n(...s);
    const l = a[o];
    return ft(l) ? n(...s) : (delete a[o],
    l)
}
), r)
  , K_e = $_e.concat(q_e)
  , Y_e = t => function(...n) {
    const r = G_e()
      , [i,s,o] = W_e(n)
      , a = H_e(r, o);
    let l = t;
    const {use: c} = a
      , u = (c || []).concat(K_e);
    for (let h = u.length; h--; )
        l = u[h](l);
    return l(i, s || a.fetcher || null, a)
}
  , X_e = (t, e, n) => {
    const r = e[t] || (e[t] = []);
    return r.push(n),
    () => {
        const i = r.indexOf(n);
        i >= 0 && (r[i] = r[r.length - 1],
        r.pop())
    }
}
;
z_e();
const jA = Cr.use || (t => {
    if (t.status === "pending")
        throw t;
    if (t.status === "fulfilled")
        return t.value;
    throw t.status === "rejected" ? t.reason : (t.status = "pending",
    t.then(e => {
        t.status = "fulfilled",
        t.value = e
    }
    , e => {
        t.status = "rejected",
        t.reason = e
    }
    ),
    t)
}
)
  , r_ = {
    dedupe: !0
}
  , Q_e = (t, e, n) => {
    const {cache: r, compare: i, suspense: s, fallbackData: o, revalidateOnMount: a, revalidateIfStale: l, refreshInterval: c, refreshWhenHidden: u, refreshWhenOffline: h, keepPreviousData: d} = n
      , [f,g,_,m] = zi.get(r)
      , [p,b] = Ex(t)
      , y = S.useRef(!1)
      , x = S.useRef(!1)
      , E = S.useRef(p)
      , w = S.useRef(e)
      , A = S.useRef(n)
      , C = () => A.current
      , k = () => C().isVisible() && C().isOnline()
      , [I,N,O,M] = LF(r, p)
      , H = S.useRef({}).current
      , $ = ft(o) ? n.fallback[p] : o
      , J = (ne, pe) => {
        for (const Te in H) {
            const Ce = Te;
            if (Ce === "data") {
                if (!i(ne[Ce], pe[Ce]) && (!ft(ne[Ce]) || !i(se, pe[Ce])))
                    return !1
            } else if (pe[Ce] !== ne[Ce])
                return !1
        }
        return !0
    }
      , Q = S.useMemo( () => {
        const ne = !p || !e ? !1 : ft(a) ? C().isPaused() || s ? !1 : ft(l) ? !0 : l : a
          , pe = qe => {
            const et = no(qe);
            return delete et._k,
            ne ? {
                isValidating: !0,
                isLoading: !0,
                ...et
            } : et
        }
          , Te = I()
          , Ce = M()
          , Re = pe(Te)
          , we = Te === Ce ? Re : pe(Ce);
        let ze = Re;
        return [ () => {
            const qe = pe(I());
            return J(qe, ze) ? (ze.data = qe.data,
            ze.isLoading = qe.isLoading,
            ze.isValidating = qe.isValidating,
            ze.error = qe.error,
            ze) : (ze = qe,
            qe)
        }
        , () => we]
    }
    , [r, p])
      , ee = E_e.useSyncExternalStore(S.useCallback(ne => O(p, (pe, Te) => {
        J(Te, pe) || ne()
    }
    ), [r, p]), Q[0], Q[1])
      , D = !y.current
      , L = f[p] && f[p].length > 0
      , z = ee.data
      , V = ft(z) ? $ : z
      , B = ee.error
      , Z = S.useRef(V)
      , se = d ? ft(z) ? Z.current : z : V
      , ae = L && !ft(B) ? !1 : D && !ft(a) ? a : C().isPaused() ? !1 : s ? ft(V) ? !1 : l : ft(V) || l
      , G = !!(p && e && D && ae)
      , j = ft(ee.isValidating) ? G : ee.isValidating
      , oe = ft(ee.isLoading) ? G : ee.isLoading
      , le = S.useCallback(async ne => {
        const pe = w.current;
        if (!p || !pe || x.current || C().isPaused())
            return !1;
        let Te, Ce, Re = !0;
        const we = ne || {}
          , ze = !_[p] || !we.dedupe
          , qe = () => MA ? !x.current && p === E.current && y.current : p === E.current
          , et = {
            isValidating: !1,
            isLoading: !1
        }
          , $t = () => {
            N(et)
        }
          , Jt = () => {
            const St = _[p];
            St && St[1] === Ce && delete _[p]
        }
          , _t = {
            isValidating: !0
        };
        ft(I().data) && (_t.isLoading = !0);
        try {
            if (ze && (N(_t),
            n.loadingTimeout && ft(I().data) && setTimeout( () => {
                Re && qe() && C().onLoadingSlow(p, n)
            }
            , n.loadingTimeout),
            _[p] = [pe(b), Ey()]),
            [Te,Ce] = _[p],
            Te = await Te,
            ze && setTimeout(Jt, n.dedupingInterval),
            !_[p] || _[p][1] !== Ce)
                return ze && qe() && C().onDiscarded(p),
                !1;
            et.error = Zn;
            const St = g[p];
            if (!ft(St) && (Ce <= St[0] || Ce <= St[1] || St[1] === 0))
                return $t(),
                ze && qe() && C().onDiscarded(p),
                !1;
            const it = I().data;
            et.data = i(it, Te) ? it : Te,
            ze && qe() && C().onSuccess(Te, p, n)
        } catch (St) {
            Jt();
            const it = C()
              , {shouldRetryOnError: he} = it;
            it.isPaused() || (et.error = St,
            ze && qe() && (it.onError(St, p, it),
            (he === !0 || yi(he) && he(St)) && (!C().revalidateOnFocus || !C().revalidateOnReconnect || k()) && it.onErrorRetry(St, p, it, Se => {
                const De = f[p];
                De && De[0] && De[0](yc.ERROR_REVALIDATE_EVENT, Se)
            }
            , {
                retryCount: (we.retryCount || 0) + 1,
                dedupe: !0
            })))
        }
        return Re = !1,
        $t(),
        !0
    }
    , [p, r])
      , de = S.useCallback( (...ne) => BF(r, E.current, ...ne), []);
    if (t_( () => {
        w.current = e,
        A.current = n,
        ft(z) || (Z.current = z)
    }
    ),
    t_( () => {
        if (!p)
            return;
        const ne = le.bind(Zn, r_);
        let pe = 0;
        const Ce = X_e(p, f, (Re, we={}) => {
            if (Re == yc.FOCUS_EVENT) {
                const ze = Date.now();
                C().revalidateOnFocus && ze > pe && k() && (pe = ze + C().focusThrottleInterval,
                ne())
            } else if (Re == yc.RECONNECT_EVENT)
                C().revalidateOnReconnect && k() && ne();
            else {
                if (Re == yc.MUTATE_EVENT)
                    return le();
                if (Re == yc.ERROR_REVALIDATE_EVENT)
                    return le(we)
            }
        }
        );
        return x.current = !1,
        E.current = p,
        y.current = !0,
        N({
            _k: b
        }),
        ae && (ft(V) || vh ? ne() : D_e(ne)),
        () => {
            x.current = !0,
            Ce()
        }
    }
    , [p]),
    t_( () => {
        let ne;
        function pe() {
            const Ce = yi(c) ? c(I().data) : c;
            Ce && ne !== -1 && (ne = setTimeout(Te, Ce))
        }
        function Te() {
            !I().error && (u || C().isVisible()) && (h || C().isOnline()) ? le(r_).then(pe) : pe()
        }
        return pe(),
        () => {
            ne && (clearTimeout(ne),
            ne = -1)
        }
    }
    , [c, u, h, p]),
    S.useDebugValue(se),
    s && ft(V) && p) {
        if (!MA && vh)
            throw new Error("Fallback data is required when using suspense in SSR.");
        w.current = e,
        A.current = n,
        x.current = !1;
        const ne = m[p];
        if (!ft(ne)) {
            const pe = de(ne);
            jA(pe)
        }
        if (ft(B)) {
            const pe = le(r_);
            ft(se) || (pe.status = "fulfilled",
            pe.value = !0),
            jA(pe)
        } else
            throw B
    }
    return {
        mutate: de,
        get data() {
            return H.data = !0,
            se
        },
        get error() {
            return H.error = !0,
            B
        },
        get isValidating() {
            return H.isValidating = !0,
            j
        },
        get isLoading() {
            return H.isLoading = !0,
            oe
        }
    }
}
  , af = Y_e(Q_e);
var J_e = async (t, e, n, r, i, s, o, a, l, c, u, h, d, f, g, _, m) => {
    var p;
    const b = o.current;
    n(e.messages, !1);
    const y = f ? e.messages : e.messages.map( ({role: x, content: E, experimental_attachments: w, name: A, data: C, annotations: k, toolInvocations: I, function_call: N, tool_calls: O, tool_call_id: M}) => ({
        role: x,
        content: E,
        ...w !== void 0 && {
            experimental_attachments: w
        },
        ...A !== void 0 && {
            name: A
        },
        ...C !== void 0 && {
            data: C
        },
        ...k !== void 0 && {
            annotations: k
        },
        ...I !== void 0 && {
            toolInvocations: I
        },
        tool_call_id: M,
        ...N !== void 0 && {
            function_call: N
        },
        ...O !== void 0 && {
            tool_calls: O
        }
    }));
    return await u_e({
        api: t,
        body: (p = g?.({
            messages: e.messages,
            requestData: e.data,
            requestBody: e.body
        })) != null ? p : {
            messages: y,
            data: e.data,
            ...s.current.body,
            ...e.body,
            ...e.functions !== void 0 && {
                functions: e.functions
            },
            ...e.function_call !== void 0 && {
                function_call: e.function_call
            },
            ...e.tools !== void 0 && {
                tools: e.tools
            },
            ...e.tool_choice !== void 0 && {
                tool_choice: e.tool_choice
            }
        },
        streamProtocol: c,
        credentials: s.current.credentials,
        headers: {
            ...s.current.headers,
            ...e.headers
        },
        abortController: () => a.current,
        restoreMessagesOnFailure() {
            m || n(b, !1)
        },
        onResponse: h,
        onUpdate(x, E) {
            n([...e.messages, ...x], !1),
            r([...i || [], ...E || []], !1)
        },
        onToolCall: d,
        onFinish: u,
        generateId: l,
        fetch: _
    })
}
;
function Z_e({api: t="/api/chat", id: e, initialMessages: n, initialInput: r="", sendExtraMessageFields: i, experimental_onFunctionCall: s, experimental_onToolCall: o, onToolCall: a, experimental_prepareRequestBody: l, experimental_maxAutomaticRoundtrips: c=0, maxAutomaticRoundtrips: u=c, maxToolRoundtrips: h=u, streamMode: d, streamProtocol: f, onResponse: g, onFinish: _, onError: m, credentials: p, headers: b, body: y, generateId: x=Gh, fetch: E, keepLastMessageOnError: w=!1}={}) {
    d && (f ?? (f = d === "text" ? "text" : void 0));
    const A = S.useId()
      , C = e ?? A
      , k = typeof t == "string" ? [t, C] : C
      , [I] = S.useState([])
      , {data: N, mutate: O} = af([k, "messages"], null, {
        fallbackData: n ?? I
    })
      , {data: M=!1, mutate: H} = af([k, "loading"], null)
      , {data: $, mutate: J} = af([k, "streamData"], null)
      , {data: Q=void 0, mutate: ee} = af([k, "error"], null)
      , D = S.useRef(N || []);
    S.useEffect( () => {
        D.current = N || []
    }
    , [N]);
    const L = S.useRef(null)
      , z = S.useRef({
        credentials: p,
        headers: b,
        body: y
    });
    S.useEffect( () => {
        z.current = {
            credentials: p,
            headers: b,
            body: y
        }
    }
    , [p, b, y]);
    const V = S.useCallback(async ne => {
        const pe = D.current.length;
        try {
            H(!0),
            ee(void 0);
            const Re = new AbortController;
            L.current = Re,
            await d_e({
                getStreamedResponse: () => J_e(t, ne, O, J, $, z, D, L, x, f, _, g, a, i, l, E, w),
                experimental_onFunctionCall: s,
                experimental_onToolCall: o,
                updateChatRequest: we => {
                    ne = we
                }
                ,
                getCurrentMessages: () => D.current
            }),
            L.current = null
        } catch (Re) {
            if (Re.name === "AbortError")
                return L.current = null,
                null;
            m && Re instanceof Error && m(Re),
            ee(Re)
        } finally {
            H(!1)
        }
        const Te = D.current
          , Ce = Te[Te.length - 1];
        Te.length > pe && Ce != null && h > 0 && HA(Ce) && ebe(Te) <= h && await V({
            messages: Te
        })
    }
    , [O, H, t, z, g, _, m, ee, J, $, f, i, s, o, l, a, h, D, L, x, E, w])
      , B = S.useCallback(async (ne, {options: pe, functions: Te, function_call: Ce, tools: Re, tool_choice: we, data: ze, headers: qe, body: et, experimental_attachments: $t}={}) => {
        ne.id || (ne.id = x());
        const Jt = await UA($t)
          , _t = {
            headers: qe ?? pe?.headers,
            body: et ?? pe?.body
        }
          , it = {
            messages: D.current.concat({
                id: x(),
                createdAt: new Date,
                role: "user",
                content: ne.content,
                experimental_attachments: Jt.length > 0 ? Jt : void 0
            }),
            options: _t,
            headers: _t.headers,
            body: _t.body,
            data: ze,
            ...Te !== void 0 && {
                functions: Te
            },
            ...Ce !== void 0 && {
                function_call: Ce
            },
            ...Re !== void 0 && {
                tools: Re
            },
            ...we !== void 0 && {
                tool_choice: we
            }
        };
        return V(it)
    }
    , [V, x])
      , Z = S.useCallback(async ({options: ne, functions: pe, function_call: Te, tools: Ce, tool_choice: Re, data: we, headers: ze, body: qe}={}) => {
        if (D.current.length === 0)
            return null;
        const et = {
            headers: ze ?? ne?.headers,
            body: qe ?? ne?.body
        };
        if (D.current[D.current.length - 1].role === "assistant") {
            const _t = {
                messages: D.current.slice(0, -1),
                options: et,
                headers: et.headers,
                body: et.body,
                data: we,
                ...pe !== void 0 && {
                    functions: pe
                },
                ...Te !== void 0 && {
                    function_call: Te
                },
                ...Ce !== void 0 && {
                    tools: Ce
                },
                ...Re !== void 0 && {
                    tool_choice: Re
                }
            };
            return V(_t)
        }
        const Jt = {
            messages: D.current,
            options: et,
            headers: et.headers,
            body: et.body,
            data: we,
            ...pe !== void 0 && {
                functions: pe
            },
            ...Te !== void 0 && {
                function_call: Te
            },
            ...Ce !== void 0 && {
                tools: Ce
            },
            ...Re !== void 0 && {
                tool_choice: Re
            }
        };
        return V(Jt)
    }
    , [V])
      , se = S.useCallback( () => {
        L.current && (L.current.abort(),
        L.current = null)
    }
    , [])
      , ae = S.useCallback(ne => {
        typeof ne == "function" && (ne = ne(D.current)),
        O(ne, !1),
        D.current = ne
    }
    , [O])
      , [G,j] = S.useState(r)
      , oe = S.useCallback(async (ne, pe={}, Te) => {
        var Ce, Re, we, ze, qe;
        if ((Ce = ne?.preventDefault) == null || Ce.call(ne),
        !G && !pe.allowEmptySubmit)
            return;
        Te && (z.current = {
            ...z.current,
            ...Te
        });
        const et = await UA(pe.experimental_attachments)
          , $t = {
            headers: (we = pe.headers) != null ? we : (Re = pe.options) == null ? void 0 : Re.headers,
            body: (qe = pe.body) != null ? qe : (ze = pe.options) == null ? void 0 : ze.body
        }
          , _t = {
            messages: !G && !et.length && pe.allowEmptySubmit ? D.current : D.current.concat({
                id: x(),
                createdAt: new Date,
                role: "user",
                content: G,
                experimental_attachments: et.length > 0 ? et : void 0
            }),
            options: $t,
            headers: $t.headers,
            body: $t.body,
            data: pe.data
        };
        V(_t),
        j("")
    }
    , [G, x, V])
      , le = ne => {
        j(ne.target.value)
    }
      , de = ({toolCallId: ne, result: pe}) => {
        const Te = D.current.map( (Re, we, ze) => we === ze.length - 1 && Re.role === "assistant" && Re.toolInvocations ? {
            ...Re,
            toolInvocations: Re.toolInvocations.map(qe => qe.toolCallId === ne ? {
                ...qe,
                result: pe
            } : qe)
        } : Re);
        O(Te, !1);
        const Ce = Te[Te.length - 1];
        HA(Ce) && V({
            messages: Te
        })
    }
    ;
    return {
        messages: N || [],
        error: Q,
        append: B,
        reload: Z,
        stop: se,
        setMessages: ae,
        input: G,
        setInput: j,
        handleInputChange: le,
        handleSubmit: oe,
        isLoading: M,
        data: $,
        addToolResult: de,
        experimental_addToolResult: de
    }
}
function HA(t) {
    return t.role === "assistant" && t.toolInvocations && t.toolInvocations.length > 0 && t.toolInvocations.every(e => "result"in e)
}
function ebe(t) {
    let e = 0;
    for (let n = t.length - 1; n >= 0 && t[n].role === "assistant"; n--)
        e++;
    return e
}
async function UA(t) {
    if (t == null)
        return [];
    if (t instanceof FileList)
        return Promise.all(Array.from(t).map(async e => {
            const {name: n, type: r} = e
              , i = await new Promise( (s, o) => {
                const a = new FileReader;
                a.onload = l => {
                    var c;
                    s((c = l.target) == null ? void 0 : c.result)
                }
                ,
                a.onerror = l => o(l),
                a.readAsDataURL(e)
            }
            );
            return {
                name: n,
                contentType: r,
                url: i
            }
        }
        ));
    if (Array.isArray(t))
        return t;
    throw new Error("Invalid attachments type")
}
var tbe = Z_e;
function i_(t) {
    fetch("/api/error", {
        method: "POST",
        body: JSON.stringify({
            message: t
        })
    }).catch( () => {}
    )
}
const VA = "<kill>"
  , $A = "</kill>"
  , lf = "<boltArtifact"
  , zA = "</boltArtifact>"
  , nbe = "<boltAction"
  , s_ = "</boltAction>"
  , cf = nr("MessageParser");
class rbe {
    constructor(e={}) {
        this._options = e
    }
    #t = 1;
    #e = 1;
    #n = new Map;
    parse(e, n, r=!1) {
        let i = this.#n.get(e);
        i || (i = {
            position: 0,
            insideAction: !1,
            insideArtifact: !1,
            streamingFile: !1,
            output: ""
        },
        this.#n.set(e, i));
        let s = ""
          , o = i.position
          , a = !1;
        for (; o < n.length; ) {
            if (i.insideArtifact) {
                const l = i.currentArtifact;
                if (l === void 0 && jo("Artifact not initialized"),
                i.insideAction) {
                    const c = n.indexOf(s_, o)
                      , u = i.currentAction;
                    if (c !== -1) {
                        if (u) {
                            const h = (u.content.value + n.slice(o, c)).trim();
                            if (u.content.set(h),
                            u instanceof Xs ? this.#o(h, u) : u.type === "build-and-deploy" && this.#l(h, u),
                            i.currentAction?.type === "file") {
                                const d = Pt(i.currentAction.filePath);
                                i.streamingFile = !1,
                                this._options.callbacks?.onFileStream?.({
                                    path: d,
                                    content: h,
                                    status: "end"
                                })
                            }
                            this._options.callbacks?.onActionClose?.({
                                artifactId: l.id,
                                messageId: e,
                                action: u
                            }, r),
                            i.insideAction = !1,
                            i.currentAction = void 0
                        }
                        o = c + s_.length
                    } else {
                        if (i.currentAction?.type === "file") {
                            const h = !i.streamingFile;
                            h && (i.streamingFile = !0);
                            const d = Pt(i.currentAction.filePath);
                            this._options.callbacks?.onFileStream?.({
                                path: d,
                                content: n.slice(o, -s_.length).trim(),
                                status: h ? "start" : "stream"
                            })
                        }
                        break
                    }
                } else {
                    const c = n.indexOf(nbe, o)
                      , u = n.indexOf(zA, o);
                    if (c !== -1 && (u === -1 || c < u)) {
                        const h = n.indexOf(">", c);
                        if (h !== -1)
                            i.insideAction = !0,
                            i.currentAction = this.#i(l.id, e, n, c, h),
                            i.currentAction && this._options.callbacks?.onActionOpen?.({
                                artifactId: l.id,
                                messageId: e,
                                action: i.currentAction
                            }, r),
                            o = h + 1;
                        else
                            break
                    } else if (u !== -1)
                        this._options.callbacks?.onArtifactClose?.({
                            messageId: e,
                            ...l
                        }, r),
                        i.insideArtifact = !1,
                        i.currentArtifact = void 0,
                        o = u + zA.length;
                    else
                        break
                }
            } else if (n[o] === "<" && n[o + 1] !== "/") {
                let l = o
                  , c = "";
                for (; l < n.length && c.length < lf.length; ) {
                    if (c += n[l],
                    c === lf) {
                        const u = n[l + 1];
                        if (u && u !== ">" && u !== " ") {
                            s += n.slice(o, l + 1),
                            o = l + 1;
                            break
                        }
                        const h = n.indexOf(">", l);
                        if (h !== -1) {
                            const d = n.slice(o, h + 1)
                              , f = this.#s(d, "title")
                              , g = this.#s(d, "id");
                            f || cf.warn("Artifact title missing"),
                            g || cf.warn("Artifact id missing"),
                            i.insideArtifact = !0;
                            const _ = {
                                id: `${this.#t++}:${g}`,
                                slug: g,
                                title: f
                            };
                            i.currentArtifact = _,
                            this._options.callbacks?.onArtifactOpen?.({
                                messageId: e,
                                ..._
                            }, r);
                            const m = this._options.artifactElement ?? ibe;
                            s += m({
                                artifactId: _.id,
                                runningActions: r.toString()
                            }),
                            o = h + 1
                        } else
                            a = !0;
                        break
                    } else if (!lf.startsWith(c)) {
                        s += n.slice(o, l + 1),
                        o = l + 1;
                        break
                    }
                    l++
                }
                if (l === n.length && lf.startsWith(c))
                    break
            } else
                s += n[o],
                o++;
            if (a)
                break
        }
        return i.position = o,
        i.output += s,
        i.output
    }
    reset() {
        this.#e = 1,
        this.#t = 1,
        this.#n.clear()
    }
    #r() {
        return String(this.#e++)
    }
    #i(e, n, r, i, s) {
        const o = r.slice(i, s + 1)
          , a = this.#s(o, "type")
          , l = this.#r();
        if (a === "file") {
            const c = this.#s(o, "filePath");
            return c || cf.debug("File path not specified"),
            new IY(e,n,l,c)
        }
        if (a === "start")
            return new Bm(e,n,l,!1);
        if (a === "shell")
            return new yP(e,n,l);
        if (a === "import") {
            const c = this.#s(o, "target");
            return new PY(e,n,l,c)
        }
        if (a === "deploy") {
            const c = this.#s(o, "provider")
              , u = this.#s(o, "deployId");
            return new MY(e,n,l,c,u)
        }
        cf.warn(`Unknown action type '${a}'`)
    }
    #o(e, n) {
        const r = this.#a(e, "command");
        let i = 0;
        for (; (i = e.indexOf(VA, i)) !== -1; ) {
            const s = e.indexOf($A, i);
            if (s !== -1)
                e.slice(i + VA.length, s).trim(),
                i = s + $A.length;
            else
                break
        }
        n.content.set(r ?? "")
    }
    #l(e, n) {
        const r = this.#a(e, "build");
        if (r) {
            const i = this.#a(r, "command")
              , s = this.#a(r, "output");
            i && s && n.setBuildConfig({
                command: i,
                output: s
            })
        }
    }
    #a(e, n) {
        const r = e.match(new RegExp(`<${n}>([\\s\\S]*?)</${n}>`));
        return r ? r[1].trim() : void 0
    }
    #s(e, n) {
        const r = e.match(new RegExp(`${n}="([^"]*)"`,"i"));
        return r ? r[1] : void 0
    }
}
const ibe = t => `<div ${['class="__boltArtifact__"', ...Object.entries(t).map( ([n,r]) => `data-${sbe(n)}=${JSON.stringify(r)}`)].join(" ")}></div>`;
function sbe(t) {
    return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
}
function obe(t) {
    const e = Date.now()
      , n = {};
    for (const [r,i] of Object.entries(t)) {
        let s = !1
          , o = "";
        typeof i == "string" ? o = i : "binary"in i && (s = !0,
        o = i.binary),
        n[r] = {
            type: "file",
            name: Hn.basename(r),
            fullPath: r,
            contents: o,
            lastModified: e,
            isBinary: s
        }
    }
    return n
}
const WA = nr("TemplateStore");
class abe {
    template;
    ready;
    async tryFetchTemplate(e, n) {
        const r = Qi();
        try {
            this.ready = r.promise;
            const i = await fetch("/api/template", {
                method: "POST",
                signal: n,
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    message: e
                })
            })
              , {template: s} = await i.json();
            let o;
            if (s) {
                this.template = {
                    id: s.id,
                    files: obe(s.files)
                };
                const {boltActions: a, hiddenFiles: l} = Kv(this.template.files)
                  , c = qv({
                    title: "Project Files",
                    boltActions: a,
                    hiddenFiles: l
                });
                o = {
                    id: au,
                    type: "chat",
                    status: "complete",
                    fileSelections: [],
                    content: c,
                    role: "user",
                    hidden: !0,
                    ephemeral: !0
                }
            }
            WA.debug("Template fetched"),
            r.resolve(o)
        } catch (i) {
            WA.error("Failed to fetch template"),
            r.reject(i)
        }
        return r.promise
    }
}
const No = new abe;
function lbe(t) {
    return [`<${Ox}>`, ...t.map( ({command: e}) => `<command>${e}</command>`), `</${Ox}>`].join(`
`)
}
function ho() {}
ho.prototype = {
    diff: function(e, n) {
        var r, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = i.callback;
        typeof i == "function" && (s = i,
        i = {}),
        this.options = i;
        var o = this;
        function a(x) {
            return s ? (setTimeout(function() {
                s(void 0, x)
            }, 0),
            !0) : x
        }
        e = this.castInput(e),
        n = this.castInput(n),
        e = this.removeEmpty(this.tokenize(e)),
        n = this.removeEmpty(this.tokenize(n));
        var l = n.length
          , c = e.length
          , u = 1
          , h = l + c;
        i.maxEditLength && (h = Math.min(h, i.maxEditLength));
        var d = (r = i.timeout) !== null && r !== void 0 ? r : 1 / 0
          , f = Date.now() + d
          , g = [{
            oldPos: -1,
            lastComponent: void 0
        }]
          , _ = this.extractCommon(g[0], n, e, 0);
        if (g[0].oldPos + 1 >= c && _ + 1 >= l)
            return a([{
                value: this.join(n),
                count: n.length
            }]);
        var m = -1 / 0
          , p = 1 / 0;
        function b() {
            for (var x = Math.max(m, -u); x <= Math.min(p, u); x += 2) {
                var E = void 0
                  , w = g[x - 1]
                  , A = g[x + 1];
                w && (g[x - 1] = void 0);
                var C = !1;
                if (A) {
                    var k = A.oldPos - x;
                    C = A && 0 <= k && k < l
                }
                var I = w && w.oldPos + 1 < c;
                if (!C && !I) {
                    g[x] = void 0;
                    continue
                }
                if (!I || C && w.oldPos + 1 < A.oldPos ? E = o.addToPath(A, !0, void 0, 0) : E = o.addToPath(w, void 0, !0, 1),
                _ = o.extractCommon(E, n, e, x),
                E.oldPos + 1 >= c && _ + 1 >= l)
                    return a(cbe(o, E.lastComponent, n, e, o.useLongestToken));
                g[x] = E,
                E.oldPos + 1 >= c && (p = Math.min(p, x - 1)),
                _ + 1 >= l && (m = Math.max(m, x + 1))
            }
            u++
        }
        if (s)
            (function x() {
                setTimeout(function() {
                    if (u > h || Date.now() > f)
                        return s();
                    b() || x()
                }, 0)
            }
            )();
        else
            for (; u <= h && Date.now() <= f; ) {
                var y = b();
                if (y)
                    return y
            }
    },
    addToPath: function(e, n, r, i) {
        var s = e.lastComponent;
        return s && s.added === n && s.removed === r ? {
            oldPos: e.oldPos + i,
            lastComponent: {
                count: s.count + 1,
                added: n,
                removed: r,
                previousComponent: s.previousComponent
            }
        } : {
            oldPos: e.oldPos + i,
            lastComponent: {
                count: 1,
                added: n,
                removed: r,
                previousComponent: s
            }
        }
    },
    extractCommon: function(e, n, r, i) {
        for (var s = n.length, o = r.length, a = e.oldPos, l = a - i, c = 0; l + 1 < s && a + 1 < o && this.equals(n[l + 1], r[a + 1]); )
            l++,
            a++,
            c++;
        return c && (e.lastComponent = {
            count: c,
            previousComponent: e.lastComponent
        }),
        e.oldPos = a,
        l
    },
    equals: function(e, n) {
        return this.options.comparator ? this.options.comparator(e, n) : e === n || this.options.ignoreCase && e.toLowerCase() === n.toLowerCase()
    },
    removeEmpty: function(e) {
        for (var n = [], r = 0; r < e.length; r++)
            e[r] && n.push(e[r]);
        return n
    },
    castInput: function(e) {
        return e
    },
    tokenize: function(e) {
        return e.split("")
    },
    join: function(e) {
        return e.join("")
    }
};
function cbe(t, e, n, r, i) {
    for (var s = [], o; e; )
        s.push(e),
        o = e.previousComponent,
        delete e.previousComponent,
        e = o;
    s.reverse();
    for (var a = 0, l = s.length, c = 0, u = 0; a < l; a++) {
        var h = s[a];
        if (h.removed) {
            if (h.value = t.join(r.slice(u, u + h.count)),
            u += h.count,
            a && s[a - 1].added) {
                var f = s[a - 1];
                s[a - 1] = s[a],
                s[a] = f
            }
        } else {
            if (!h.added && i) {
                var d = n.slice(c, c + h.count);
                d = d.map(function(_, m) {
                    var p = r[u + m];
                    return p.length > _.length ? p : _
                }),
                h.value = t.join(d)
            } else
                h.value = t.join(n.slice(c, c + h.count));
            c += h.count,
            h.added || (u += h.count)
        }
    }
    var g = s[l - 1];
    return l > 1 && typeof g.value == "string" && (g.added || g.removed) && t.equals("", g.value) && (s[l - 2].value += g.value,
    s.pop()),
    s
}
var GA = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/
  , qA = /\S/
  , HF = new ho;
HF.equals = function(t, e) {
    return this.options.ignoreCase && (t = t.toLowerCase(),
    e = e.toLowerCase()),
    t === e || this.options.ignoreWhitespace && !qA.test(t) && !qA.test(e)
}
;
HF.tokenize = function(t) {
    for (var e = t.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n = 0; n < e.length - 1; n++)
        !e[n + 1] && e[n + 2] && GA.test(e[n]) && GA.test(e[n + 2]) && (e[n] += e[n + 2],
        e.splice(n + 1, 2),
        n--);
    return e
}
;
var Sx = new ho;
Sx.tokenize = function(t) {
    this.options.stripTrailingCr && (t = t.replace(/\r\n/g, `
`));
    var e = []
      , n = t.split(/(\n|\r\n)/);
    n[n.length - 1] || n.pop();
    for (var r = 0; r < n.length; r++) {
        var i = n[r];
        r % 2 && !this.options.newlineIsToken ? e[e.length - 1] += i : (this.options.ignoreWhitespace && (i = i.trim()),
        e.push(i))
    }
    return e
}
;
function ube(t, e, n) {
    return Sx.diff(t, e, n)
}
var hbe = new ho;
hbe.tokenize = function(t) {
    return t.split(/(\S.+?[.!?])(?=\s+|$)/)
}
;
var dbe = new ho;
dbe.tokenize = function(t) {
    return t.split(/([{}:;,]|\s+)/)
}
;
function Df(t) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Df = function(e) {
        return typeof e
    }
    : Df = function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Df(t)
}
function o_(t) {
    return fbe(t) || pbe(t) || mbe(t) || gbe()
}
function fbe(t) {
    if (Array.isArray(t))
        return Sy(t)
}
function pbe(t) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(t))
        return Array.from(t)
}
function mbe(t, e) {
    if (t) {
        if (typeof t == "string")
            return Sy(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return Sy(t, e)
    }
}
function Sy(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++)
        r[n] = t[n];
    return r
}
function gbe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var _be = Object.prototype.toString
  , xh = new ho;
xh.useLongestToken = !0;
xh.tokenize = Sx.tokenize;
xh.castInput = function(t) {
    var e = this.options
      , n = e.undefinedReplacement
      , r = e.stringifyReplacer
      , i = r === void 0 ? function(s, o) {
        return typeof o > "u" ? n : o
    }
    : r;
    return typeof t == "string" ? t : JSON.stringify(wy(t, null, null, i), i, "  ")
}
;
xh.equals = function(t, e) {
    return ho.prototype.equals.call(xh, t.replace(/,([\r\n])/g, "$1"), e.replace(/,([\r\n])/g, "$1"))
}
;
function wy(t, e, n, r, i) {
    e = e || [],
    n = n || [],
    r && (t = r(i, t));
    var s;
    for (s = 0; s < e.length; s += 1)
        if (e[s] === t)
            return n[s];
    var o;
    if (_be.call(t) === "[object Array]") {
        for (e.push(t),
        o = new Array(t.length),
        n.push(o),
        s = 0; s < t.length; s += 1)
            o[s] = wy(t[s], e, n, r, i);
        return e.pop(),
        n.pop(),
        o
    }
    if (t && t.toJSON && (t = t.toJSON()),
    Df(t) === "object" && t !== null) {
        e.push(t),
        o = {},
        n.push(o);
        var a = [], l;
        for (l in t)
            t.hasOwnProperty(l) && a.push(l);
        for (a.sort(),
        s = 0; s < a.length; s += 1)
            l = a[s],
            o[l] = wy(t[l], e, n, r, l);
        e.pop(),
        n.pop()
    } else
        o = t;
    return o
}
var Cy = new ho;
Cy.tokenize = function(t) {
    return t.slice()
}
;
Cy.join = Cy.removeEmpty = function(t) {
    return t
}
;
function bbe(t, e, n, r, i, s, o) {
    o || (o = {}),
    typeof o.context > "u" && (o.context = 4);
    var a = ube(n, r, o);
    if (!a)
        return;
    a.push({
        value: "",
        lines: []
    });
    function l(p) {
        return p.map(function(b) {
            return " " + b
        })
    }
    for (var c = [], u = 0, h = 0, d = [], f = 1, g = 1, _ = function(b) {
        var y = a[b]
          , x = y.lines || y.value.replace(/\n$/, "").split(`
`);
        if (y.lines = x,
        y.added || y.removed) {
            var E;
            if (!u) {
                var w = a[b - 1];
                u = f,
                h = g,
                w && (d = o.context > 0 ? l(w.lines.slice(-o.context)) : [],
                u -= d.length,
                h -= d.length)
            }
            (E = d).push.apply(E, o_(x.map(function(H) {
                return (y.added ? "+" : "-") + H
            }))),
            y.added ? g += x.length : f += x.length
        } else {
            if (u)
                if (x.length <= o.context * 2 && b < a.length - 2) {
                    var A;
                    (A = d).push.apply(A, o_(l(x)))
                } else {
                    var C, k = Math.min(x.length, o.context);
                    (C = d).push.apply(C, o_(l(x.slice(0, k))));
                    var I = {
                        oldStart: u,
                        oldLines: f - u + k,
                        newStart: h,
                        newLines: g - h + k,
                        lines: d
                    };
                    if (b >= a.length - 2 && x.length <= o.context) {
                        var N = /\n$/.test(n)
                          , O = /\n$/.test(r)
                          , M = x.length == 0 && d.length > I.oldLines;
                        !N && M && n.length > 0 && d.splice(I.oldLines, 0, "\\ No newline at end of file"),
                        (!N && !M || !O) && d.push("\\ No newline at end of file")
                    }
                    c.push(I),
                    u = 0,
                    h = 0,
                    d = []
                }
            f += x.length,
            g += x.length
        }
    }, m = 0; m < a.length; m++)
        _(m);
    return {
        oldFileName: t,
        newFileName: e,
        oldHeader: i,
        newHeader: s,
        hunks: c
    }
}
function UF(t) {
    if (Array.isArray(t))
        return t.map(UF).join(`
`);
    var e = [];
    t.oldFileName == t.newFileName && e.push("Index: " + t.oldFileName),
    e.push("==================================================================="),
    e.push("--- " + t.oldFileName + (typeof t.oldHeader > "u" ? "" : "	" + t.oldHeader)),
    e.push("+++ " + t.newFileName + (typeof t.newHeader > "u" ? "" : "	" + t.newHeader));
    for (var n = 0; n < t.hunks.length; n++) {
        var r = t.hunks[n];
        r.oldLines === 0 && (r.oldStart -= 1),
        r.newLines === 0 && (r.newStart -= 1),
        e.push("@@ -" + r.oldStart + "," + r.oldLines + " +" + r.newStart + "," + r.newLines + " @@"),
        e.push.apply(e, r.lines)
    }
    return e.join(`
`) + `
`
}
function ybe(t, e, n, r, i, s, o) {
    return UF(bbe(t, e, n, r, i, s, o))
}
function vbe(t, e, n, r) {
    let i = ybe(t, t, e, n, void 0, void 0, r);
    const s = `--- ${t}
+++ ${t}
`
      , o = i.indexOf(s);
    if (o >= 0 && (i = i.slice(o + s.length)),
    i !== "")
        return i
}
function xbe(t, e) {
    const n = []
      , r = Ly(e);
    for (const [i,s] of Object.entries(e)) {
        if (s === void 0)
            continue;
        const o = Fn(i)
          , a = Hn.basename(i)
          , l = t[o]
          , c = e[i];
        if (c?.type === "file") {
            if (r({
                path: i,
                contents: c.content,
                isBinary: c.isBinary
            })) {
                l || n.push(`<file path=${JSON.stringify(i)} type="hidden"></file>`);
                continue
            }
            if (l?.type !== "file") {
                const u = `<content>${c.content}</content>`;
                n.push(`<file path=${JSON.stringify(o)} type="modified">${u}</file>`)
            } else if (l.contents !== c.content) {
                const u = vbe(a, l.contents, c.content, {
                    context: 0
                })
                  , d = u && u.length < c.content.length * .85 ? `<diff>${u}</diff>` : `<content>${c.content}</content>`;
                n.push(`<file path=${JSON.stringify(o)} type="modified">${d}</file>`)
            }
        }
    }
    for (const [i,s] of Object.entries(t)) {
        if (s.type !== "file")
            continue;
        const o = Pt(i);
        e[o] || n.push(`<file path=${JSON.stringify(i)} type="removed"></file>`)
    }
    if (n.length !== 0 && n.length)
        return `<${Lx}>
${n.join(`
`)}
</${Lx}>`
}
function Ebe(t) {
    let e = "There are some restrictions that apply for this request. If you have to modify files, please make sure to ";
    return t.targetedFiles.length > 0 ? (e += `ONLY make modifications to the following file paths:
`,
    e += t.targetedFiles.map(n => `  - ${n}`).join(`
`)) : t.lockedFiles.length > 0 && (e += `NOT make ANY modifications to the following file paths:
`,
    e += t.lockedFiles.map(n => `  - ${n}`).join(`
`)),
    e += `

CRITICAL: In the case where you need to modify restricted files, you must ask me to change the restricted files configuration first.`,
    e
}
function Sbe(t) {
    return [`<${Dx}>`, ...t.map( ({text: e, filePath: n, range: r}) => `<selection path=${JSON.stringify(n)} range="${r.from}:${r.to}">${e}</selection>`), `</${Dx}>`].join(`
`)
}
const Bi = nr("useMessages");
function wbe({initialMessages: t, previewRef: e, storeMessageHistory: n, resetInput: r}) {
    const [i,s] = S.useState(Id)
      , o = S.useRef(!1)
      , a = S.useRef()
      , l = S.useCallback(k => {
        a.current?.(),
        k && h({
            code: "api-error",
            message: Tbe(k),
            isRetryable: !0
        })
    }
    , [])
      , c = S.useMemo( () => new Set, [])
      , u = S.useMemo( () => new rbe({
        callbacks: {
            onArtifactOpen: k => {
                Bi.trace("onArtifactOpen", k),
                requestAnimationFrame( () => {
                    me.showWorkbench.set(!0)
                }
                );
                const I = !me.firstArtifact;
                if (me.addArtifact(k),
                I && No.template) {
                    Bi.debug("Create ImportTemplateAction");
                    const N = {
                        artifactId: k.id,
                        messageId: k.messageId,
                        action: new LY(k.id,k.messageId,`importTemplate:${k.id}`,No.template)
                    };
                    me.addAction(N, !0),
                    me.runAction(N)
                }
            }
            ,
            onArtifactClose: (k, I) => {
                Bi.trace("onArtifactClose"),
                me.updateArtifact(k, {
                    closed: !0
                }, I)
            }
            ,
            onActionOpen: (k, I) => {
                Bi.trace("onActionOpen", k.action),
                k.action.type === "file" && !me.isAIAllowedToEdit(k.action.filePath) && (l("focused-file-error"),
                k.action.abort()),
                k.action.type !== "shell" && me.addAction(k, I)
            }
            ,
            onActionClose: (k, I) => {
                Bi.trace("onActionClose", k.action),
                k.action.type === "shell" && me.addAction(k, I),
                I && me.runAction(k).catch(N => {
                    const O = Vi.parse(Vi, N, "An unknown error occured while running an action.");
                    h(O)
                }
                )
            }
            ,
            onFileStream: k => {
                me.setStreamingFile(k)
            }
        }
    }), [])
      , h = S.useCallback(k => {
        r?.(),
        k.code === "free-user-rate-limited" ? (Kt.freeUserRateLimited.set(!0),
        Rr({
            action: Ir.Track,
            payload: {
                event: Yr.BoltConcurrentFreeUsers
            }
        })) : k.code === "rate-limited" && Kt.rateLimitReached.set(!0),
        m(I => {
            const N = [...I]
              , O = N.at(-1);
            return O?.type === "chat" && (O.role === "user" ? N[N.length - 1] = {
                ...O,
                error: k,
                ignore: !0,
                status: "unsent"
            } : N[N.length - 1] = {
                ...O,
                error: k,
                status: "incomplete"
            }),
            N
        }
        )
    }
    , [])
      , d = tbe({
        api: "/api/chat",
        experimental_prepareRequestBody: k => {
            const I = k.messages.findLastIndex( ({role: O}) => O === "assistant")
              , N = k.messages.flatMap( (O, M) => {
                const H = M === k.messages.length - 1;
                if (O.role !== "user" && M !== I || O.ignore || O.type === "problems" && !O.resolved)
                    return [];
                let {content: $} = O;
                const J = O.role === "user"
                  , Q = O.type === "chat";
                if (J) {
                    $ = $.trim();
                    const D = [];
                    if (Q && (O.fileSelections.length && D.push(Sbe(O.fileSelections)),
                    O.focusedFiles && H && D.push(Ebe(O.focusedFiles))),
                    H) {
                        const L = xbe(me.getInitialFiles() ?? {}, me.files.get());
                        D.unshift(lbe(me.runningCommands)),
                        L && D.push(L)
                    }
                    D.push($),
                    $ = D.join(`

`)
                }
                J && Q && O.ephemeral && ($ = [{
                    type: "text",
                    text: $,
                    experimental_providerMetadata: {
                        anthropic: {
                            cacheControl: {
                                type: "ephemeral"
                            }
                        }
                    }
                }]);
                const ee = O.experimental_attachments?.length ? O.experimental_attachments.map(D => {
                    const L = D.contentType?.includes("image/svg");
                    return {
                        ...D,
                        contentType: L ? "text/plain" : D.contentType
                    }
                }
                ) : void 0;
                return {
                    role: O.role,
                    content: $,
                    experimental_attachments: ee,
                    name: O.name,
                    data: O.data,
                    annotations: O.annotations,
                    toolInvocations: O.toolInvocations?.filter(D => D.toolName !== "downloadTemplateContents"),
                    tool_call_id: O.tool_call_id,
                    function_call: O.function_call,
                    tool_calls: O.tool_calls
                }
            }
            );
            if (No.template) {
                const O = No.template.files[a_];
                O && O.type === "file" && O.contents && N.unshift({
                    role: "user",
                    content: O.contents,
                    experimental_attachments: void 0,
                    name: ak,
                    data: void 0,
                    annotations: void 0,
                    toolInvocations: void 0,
                    tool_call_id: void 0,
                    function_call: void 0,
                    tool_calls: void 0
                })
            }
            return {
                messages: N,
                conversationId: He.conversationId,
                data: k.requestData,
                ...k.requestBody
            }
        }
        ,
        keepLastMessageOnError: !0,
        maxToolRoundtrips: 1,
        onToolCall: async ({toolCall: k}) => {
            if (k.toolName === "getDeploymentStatus") {
                const I = me.lastArtifact?.runner.getDeployStatus();
                return I || "Use the deploy status we already know or tell the user something went wrong in case no status is known"
            }
        }
        ,
        async onResponse(k) {
            if (k.ok) {
                Kt.freeUserRateLimited.set(!1),
                He.requestStatus.set("COMPLETE");
                const N = k.headers.get("tokenStats");
                if (N)
                    try {
                        He.tokenStats.set(JSON.parse(N))
                    } catch (O) {
                        console.error(O)
                    }
                return
            }
            const I = await _P.parse(Vi, k, "An unknown error occured while processing the servers response.");
            throw He.requestStatus.set("ERROR"),
            i_(`onResponse parsing failed with: ${I.message}`),
            I
        },
        onError(k) {
            Bi.error(k);
            const I = Vi.parse(Vi, k, "An error occured while streaming this message.");
            i_(`onError handler triggered with: ${k.message}`),
            h(I)
        },
        onFinish: ({id: k}, {finishReason: I}) => {
            I === "content-filter" ? h({
                code: "content-filter",
                message: "Safety filter activated. Try rewording your message.",
                isRetryable: !1
            }) : I === "stop" ? c.add(k) : i_(`onFinish triggered with reason: ${I}`),
            fetch("/api/rate-limits").then(N => N.json()).then(N => {
                He.setTokenStats(N)
            }
            ).catch(N => {
                Bi.error(N),
                ct.error("Failed to update token usage")
            }
            ),
            Bi.debug("Finished streaming")
        }
    })
      , {reload: f, stop: g, isLoading: _} = d;
    a.current = g;
    const m = d.setMessages
      , p = S.useCallback(async k => {
        await E(!1);
        let I = !1;
        Ne.projectTooBig.get() || (m(N => {
            const O = [...N]
              , M = mn.get().deploymentInfo;
            if (M?.deploy_id && !O.find( ({id: $}) => $ === l_)) {
                const $ = [`This project was deployed before with the deploy ID "${M.deploy_id}" and URL "${M.deploy_url}".`];
                M.claim_url && $.push(`The project can be claimed via the following claim URL: ${M.claim_url}.`),
                O.unshift({
                    id: l_,
                    type: "chat",
                    status: "complete",
                    fileSelections: [],
                    content: $.join(" "),
                    role: "user",
                    hidden: !0
                })
            }
            if (!O.find( ({id: $}) => $ === au)) {
                const $ = me.getInitialFiles()
                  , J = me.files.get();
                if ($ && Object.keys($).length > 0 || Object.keys(J).length > 0) {
                    let Q, ee;
                    $ ? {boltActions: Q, hiddenFiles: ee} = Kv($) : {boltActions: Q, hiddenFiles: ee} = YY(J);
                    const D = qv({
                        title: "Project Files",
                        boltActions: Q,
                        hiddenFiles: ee
                    });
                    O.unshift({
                        id: au,
                        type: "chat",
                        status: "complete",
                        fileSelections: [],
                        content: D,
                        role: "user",
                        hidden: !0,
                        ephemeral: !0
                    })
                }
            }
            const H = O.at(-1);
            return k.type === "chat" && H?.type === "chat" && H.status !== "complete" && k.role === H.role && k.content === H.content && p1(k.experimental_attachments, H.experimental_attachments) ? (H.error && (delete H.error,
            H.ignore = !1),
            I = !0,
            O) : (O.push(k),
            I = !0,
            O)
        }
        ),
        I && f())
    }
    , [])
      , b = S.useMemo( () => {
        const k = d.messages.map(O => {
            if ("type"in O)
                return O;
            const {role: M} = O;
            switch (M) {
            case "user":
                return {
                    fileSelections: [],
                    ...O,
                    type: "chat",
                    role: M
                };
            case "assistant":
                return {
                    ...O,
                    type: "chat",
                    role: M
                }
            }
            return {
                ...O,
                type: "chat",
                role: M
            }
        }
        )
          , I = k.findLastIndex( ({role: O}) => O === "user")
          , N = k.map( (O, M) => {
            if ("error"in O && O.error || "status"in O && O.status === "complete")
                return O;
            const H = _ && M >= I
              , $ = k?.[M + 1]
              , J = $?.type === "chat" && $.role === "assistant" && !!$.createdAt;
            let Q = c.delete(O.id);
            Q ||= O.role === "assistant" && J,
            Q ||= M >= I && k.slice(I).some( ({id: D}) => c.has(D));
            const ee = Q ? "complete" : H ? "streaming" : "incomplete";
            return O.role === "user" ? {
                ...O,
                status: ee === "incomplete" && !J ? "unsent" : ee
            } : {
                ...O,
                status: ee
            }
        }
        );
        if (N.some(O => O.id === im) && !Ne.projectTooBig.get()) {
            const O = me.files.get()
              , M = Kt.getTierStore().get() ?? {
                plan: "personal",
                level: 0
            };
            bn(M);
            const H = W6(O);
            if (yk(M.plan, H)) {
                Ne.setTooBig(!0),
                Rr({
                    action: Ir.Track,
                    payload: {
                        event: Yr.MessageTokenLimt
                    }
                });
                let $ = "Chat disabled because this project is too large for prompting. You can use the Bolt editor or export to StackBlitz to continue building this project manually.";
                (!M || M.plan === "personal") && ($ += `

 Or <a class="__boltUpgradePlan__">Upgrade</a> to get started now.`),
                N.push({
                    type: "chat",
                    id: "project-too-big",
                    status: "incomplete",
                    error: {
                        code: "project-too-big",
                        message: $,
                        isRetryable: !1
                    },
                    role: "assistant",
                    ignore: !0,
                    content: ""
                })
            }
        }
        return Object.assign(d.messages, N),
        i.problems.length && N.push(i),
        N
    }
    , [_, d.messages, i]);
    S.useEffect( () => {
        !_ && me.isStreaming.get() && (e.current?.reload(),
        me.previews.get().length > 0 && me.currentView.set("preview")),
        o.current = _,
        me.isStreaming.set(_)
    }
    , [_]);
    const y = S.useCallback( () => e.current?.reload(), [])
      , x = S.useCallback( (...k) => {
        k.length && s( ({problems: I, ...N}) => {
            const O = [...I];
            let M = !1;
            for (const H of k) {
                const $ = O.findIndex( ({id: J}) => J === H.id);
                $ === -1 ? (M = !0,
                O.push(H)) : O[$] = H
            }
            return Id({
                ...N,
                problems: O,
                ...M && {
                    resolved: !1
                }
            })
        }
        )
    }
    , [])
      , E = S.useCallback(async (k=!0) => {
        await new Promise(I => s(N => (N.problems.length && m(O => [...O, {
            ...N,
            resolved: k
        }]),
        I(k && f()),
        Id())))
    }
    , [])
      , w = S.useCallback(k => {
        s( ({problems: I, ...N}) => Id({
            problems: typeof k == "function" ? I.filter(k) : [],
            ...N
        }))
    }
    , []);
    YA( () => {
        const k = Nr.then(O => O.on("preview-message", M => {
            zre.includes(M.type) && !o.current && (M.stack = M.stack?.replace(/https:\/\/.*?webcontainer-api\.io/g, ""),
            x({
                type: "preview",
                error: M,
                id: Gh()
            }))
        }
        ))
          , I = new Set
          , N = me.subscribeToActions(O => {
            const $ = O.flatMap(J => J instanceof Xs ? J : []).filter(J => J.status.value === "failed").flatMap(J => {
                const Q = `${J.messageId}:${J.id}`;
                return I.has(Q) ? [] : (I.add(Q),
                {
                    type: "shell",
                    id: Q,
                    exitCode: J.exitCode,
                    command: J.command,
                    output: J.output
                })
            }
            );
            x(...$)
        }
        );
        return () => {
            k.then(O => O()),
            N()
        }
    }
    , []);
    const [A,C] = S.useState([]);
    return YA( () => {
        Cbe(t, b) || n?.(b).catch(Bi.error);
        const k = [];
        for (let I = 0; I < b.length; I++) {
            const N = {
                ...b[I]
            };
            if (N.type === "chat" && N.hidden)
                continue;
            if (N.type !== "chat" || N.role !== "assistant") {
                k.push(N);
                continue
            }
            for (; b[I + 1]?.role === "assistant"; ) {
                const M = b[I + 1];
                if (M.merge === !1)
                    break;
                N.content += M.content,
                N.status = M.status,
                I++
            }
            const O = !N.error && !N.skipAction;
            N.content = u.parse(N.id, N.content, O),
            k.push(N)
        }
        C(k)
    }
    , [b, _]),
    {
        ...d,
        stop: l,
        append: p,
        clearProblems: w,
        resolveProblems: E,
        setMessages: m,
        reloadPreview: y,
        messages: A
    }
}
function Cbe(t, e) {
    return p1(t.map( ({role: n, content: r, type: i, status: s, error: o}) => ({
        role: n,
        content: r,
        type: i,
        status: s,
        error: o
    })), e.map( ({role: n, content: r, type: i, status: s, error: o}) => ({
        role: n,
        content: r,
        type: i,
        status: s,
        error: o
    })))
}
function Tbe(t) {
    return t === "focused-file-error" ? "This message was terminated to preserve your tokens because Bolt attempted to write to restricted files. If this isn't what you intended, update your restricted files configuration to allow Bolt to write to that destination. If this is what you intended, please try again with a slightly modified prompt." : "You cancelled this message."
}
const KA = nr("usePromptEnhancement");
function Abe() {
    const [t,e] = S.useState(!1)
      , [n,r] = S.useState(!1);
    return {
        enhancingPrompt: t,
        promptEnhanced: n,
        enhancePrompt: async (o, a) => {
            e(!0),
            r(!1);
            const c = (await fetch("/api/enhancer", {
                method: "POST",
                body: JSON.stringify({
                    message: o
                })
            })).body?.getReader()
              , u = o;
            if (c) {
                const h = new TextDecoder;
                let d = "", f;
                try {
                    for (a(""); ; ) {
                        const {value: g, done: _} = await c.read();
                        if (_)
                            break;
                        d += h.decode(g),
                        KA.trace("Set input", d),
                        a(d)
                    }
                } catch (g) {
                    f = g,
                    a(u)
                } finally {
                    f && KA.error(f),
                    e(!1),
                    r(!0),
                    setTimeout( () => {
                        a(d)
                    }
                    )
                }
            }
        }
        ,
        resetEnhancer: () => {
            e(!1),
            r(!1)
        }
    }
}
const VF = new JF;
function kbe(t) {
    const e = Ie(v1);
    S.useEffect( () => {
        const n = r => {
            const {key: i, ctrlKey: s, shiftKey: o, altKey: a, metaKey: l} = r;
            for (const c in e) {
                const u = e[c];
                if (u.key.toLowerCase() === i.toLowerCase() && (u.ctrlOrMetaKey ? s || l : (u.ctrlKey === void 0 || u.ctrlKey === s) && (u.metaKey === void 0 || u.metaKey === l)) && (u.shiftKey === void 0 || u.shiftKey === o) && (u.altKey === void 0 || u.altKey === a)) {
                    VF.dispatch(c),
                    r.preventDefault(),
                    r.stopPropagation(),
                    t[c]?.();
                    break
                }
            }
        }
        ;
        return window.addEventListener("keydown", n),
        () => {
            window.removeEventListener("keydown", n)
        }
    }
    , [e])
}
const YA = S.useLayoutEffect
  , Rbe = 4
  , Ty = 25
  , Ibe = 100 - Ty
  , vc = -1
  , Pbe = {
    tabSize: 2
}
  , Dbe = S.memo( ({files: t, unsavedFiles: e, editorDocument: n, selectedFile: r, isStreaming: i, onFileSelect: s, onEditorChange: o, onEditorScroll: a, onFileSave: l, onFileReset: c, onFileChange: u}) => {
    _r.trace("EditorPanel");
    const h = Ie(da)
      , d = Ie(me.showTerminal)
      , f = S.useRef(null)
      , g = S.useRef(!1)
      , _ = S.useMemo( () => {
        if (n)
            return n.filePath.split("/")
    }
    , [n])
      , m = S.useMemo( () => n !== void 0 && e?.has(n.filePath), [n, e]);
    return S.useEffect( () => {
        const p = VF.on("toggleTerminal", () => {
            g.current = !0
        }
        );
        return () => {
            p()
        }
    }
    , []),
    S.useEffect( () => {
        const {current: p} = f;
        if (!p)
            return;
        const b = p.isCollapsed();
        !d && !b ? p.collapse() : d && b && p.resize(Ty),
        g.current = !1
    }
    , [d]),
    v.jsxs(Ap, {
        direction: "vertical",
        children: [v.jsx(Io, {
            defaultSize: d ? Ibe : 100,
            minSize: 20,
            children: v.jsxs(Ap, {
                direction: "horizontal",
                children: [v.jsx(Io, {
                    defaultSize: 20,
                    minSize: 10,
                    collapsible: !0,
                    children: v.jsx(ohe, {
                        files: t,
                        onFileSelect: s,
                        onFileChange: u,
                        rootFolder: jt,
                        selectedFile: r,
                        unsavedFiles: e
                    })
                }), v.jsx(kp, {}), v.jsxs(Io, {
                    className: "flex flex-col",
                    defaultSize: 80,
                    minSize: 20,
                    children: [v.jsx(V1, {
                        className: "overflow-x-auto",
                        children: _?.length && v.jsxs("div", {
                            className: "flex items-center flex-1 text-sm",
                            children: [v.jsx(she, {
                                pathSegments: _,
                                files: t,
                                onFileSelect: s
                            }), m && v.jsxs("div", {
                                className: "flex gap-1 ml-auto -mr-1.5",
                                children: [v.jsxs(NA, {
                                    onClick: l,
                                    children: [v.jsx("div", {
                                        className: "i-ph:floppy-disk-duotone"
                                    }), "Save"]
                                }), v.jsxs(NA, {
                                    onClick: c,
                                    children: [v.jsx("div", {
                                        className: "i-ph:clock-counter-clockwise-duotone"
                                    }), "Reset"]
                                })]
                            })]
                        })
                    }), v.jsx("div", {
                        className: "h-full flex-1 overflow-hidden",
                        children: v.jsx(IF, {
                            theme: h,
                            editable: !i && n !== void 0,
                            settings: Pbe,
                            doc: n,
                            autoFocusOnDocumentChange: !1,
                            onScroll: a,
                            onChange: o,
                            onSave: l
                        })
                    })]
                })]
            })
        }), v.jsx(kp, {}), v.jsx(Io, {
            ref: f,
            defaultSize: d ? Ty : 0,
            minSize: 10,
            collapsible: !0,
            className: "min-h-[calc(var(--panel-header-height)-1px)]",
            onExpand: () => {
                g.current || me.toggleTerminal(!0)
            }
            ,
            onCollapse: () => {
                g.current || me.toggleTerminal(!1)
            }
            ,
            children: v.jsx(Lbe, {
                isClosed: !d,
                onToggle: p => me.toggleTerminal(p)
            })
        })]
    })
}
);
let XA = 0;
function Lbe({isClosed: t, onToggle: e}) {
    const [n,r] = S.useState( () => [vc, XA++])
      , [i,s] = S.useState(0)
      , o = n.length
      , a = o > 1;
    function l() {
        const h = n.length;
        r(d => [...d, XA++]),
        s(h)
    }
    function c(h) {
        s(h),
        t && e?.(!0)
    }
    function u(h) {
        if (!a)
            return !1;
        const d = n.filter(g => g !== h)
          , f = Math.min(i, d.length - 1);
        return f < i && s(f),
        r(d),
        !0
    }
    return v.jsx("div", {
        className: "h-full",
        children: v.jsxs("div", {
            className: "bg-bolt-elements-terminals-background h-full flex flex-col",
            children: [v.jsxs("div", {
                className: "flex items-center bg-bolt-elements-background-depth-2 border-y border-bolt-elements-borderColor gap-1.5 min-h-[var(--panel-header-height)] p-2",
                children: [n.map( (h, d) => {
                    const f = i === d
                      , g = h === vc ? "i-ph:lightning-duotone" : "i-ph:terminal-window-duotone"
                      , _ = h === vc ? "Bolt" : "Terminal";
                    return v.jsxs("button", {
                        className: be("flex items-center text-sm cursor-pointer gap-1.5 px-3 py-2 h-full whitespace-nowrap rounded-full", {
                            "bg-bolt-elements-terminals-buttonBackground text-bolt-elements-textPrimary": f,
                            "bg-bolt-elements-background-depth-2 text-bolt-elements-textSecondary hover:bg-bolt-elements-terminals-buttonBackground": !f
                        }),
                        onClick: () => c(d),
                        children: [v.jsx("div", {
                            className: `${g} text-lg`
                        }), _, " ", h !== vc && o > 2 && d]
                    }, d)
                }
                ), o < Rbe && v.jsx(tn, {
                    icon: "i-ph:plus",
                    size: "md",
                    onClick: l
                }), v.jsx(tn, {
                    className: "ml-auto",
                    icon: t ? "i-ph:caret-up" : "i-ph:caret-down",
                    title: t ? "Open" : "Close",
                    size: "md",
                    onClick: () => e?.()
                })]
            }), n.map( (h, d) => {
                const f = i === d;
                return h === vc ? v.jsx(fhe, {
                    driver: me.terminalDriver,
                    className: be("h-full overflow-hidden", {
                        hidden: !f
                    })
                }, h) : v.jsx(phe, {
                    className: be("h-full overflow-hidden", {
                        hidden: !f
                    }),
                    onTryExit: () => u(h)
                }, h)
            }
            )]
        })
    })
}
const Obe = S.memo( ({activePreviewIndex: t, setActivePreviewIndex: e, isDropdownOpen: n, setIsDropdownOpen: r, setHasSelectedPreview: i, previews: s}) => {
    const o = S.useRef(null)
      , a = s.map( (l, c) => ({
        ...l,
        index: c
    })).sort( (l, c) => l.port - c.port);
    return S.useEffect( () => {
        const l = c => {
            o.current && !o.current.contains(c.target) && r(!1)
        }
        ;
        return n ? window.addEventListener("mousedown", l) : window.removeEventListener("mousedown", l),
        () => {
            window.removeEventListener("mousedown", l)
        }
    }
    , [n]),
    v.jsxs("div", {
        className: "relative z-port-dropdown grid",
        ref: o,
        children: [v.jsxs("button", {
            className: "flex items-center group-focus-within:text-bolt-elements-preview-addressBar-text bg-white group-focus-within:bg-bolt-elements-preview-addressBar-background dark:bg-bolt-elements-preview-addressBar-backgroundHover rounded-full px-2 gap-1.5",
            onClick: () => r(!n),
            children: [v.jsx("div", {
                className: "i-ph:plug"
            }), v.jsx("div", {
                className: "text-xs",
                children: s[t].port
            })]
        }), n && v.jsxs("div", {
            className: "absolute left-0 top-[calc(100%+2px)] bg-bolt-elements-background-depth-2 border border-bolt-elements-borderColor rounded shadow-sm min-w-[140px] dropdown-animation",
            children: [v.jsx("div", {
                className: "px-4 py-2 border-b border-bolt-elements-borderColor text-sm font-semibold text-bolt-elements-textPrimary",
                children: "Ports"
            }), a.map(l => v.jsx("div", {
                className: be("flex items-center px-4 py-2 cursor-pointer hover:bg-bolt-elements-item-backgroundActive", t === l.index ? "text-bolt-elements-item-contentAccent" : "text-bolt-elements-item-contentDefault hover:text-bolt-elements-item-contentActive"),
                onClick: () => {
                    e(l.index),
                    r(!1),
                    i(!0)
                }
                ,
                children: l.port
            }, l.port))]
        })]
    })
}
)
  , Nbe = ["magnetometer", "accelerometer", "gyroscope", "geolocation", "microphone", "camera", "payment", "autoplay", "serial", "xr-spatial-tracking", "cross-origin-isolated"]
  , Mbe = (document.featurePolicy?.allowedFeatures() ?? Nbe).join("; ")
  , Bbe = S.forwardRef( ({onReload: t}, e) => {
    const n = S.useRef(null)
      , r = S.useRef(null)
      , i = S.useRef(!1)
      , [s,o] = S.useState(0)
      , [a,l] = S.useState(!1)
      , [c,u] = S.useState("")
      , [h,d] = S.useState()
      , [f,g] = S.useState(0)
      , [_] = S.useState( () => {
        const N = document.createElement("div");
        return N.classList.add("fixed", "inset-0", "z-max"),
        N
    }
    )
      , [m,p] = S.useState(!1)
      , [b,y] = S.useState(!1)
      , x = Ie(me.previews)
      , E = x[s];
    S.useEffect( () => {
        if (!E) {
            u(""),
            d(void 0);
            return
        }
        const {baseUrl: N} = E
          , {pathname: O} = new URL(E.baseUrl);
        u(O),
        d(N)
    }
    , [E]),
    S.useEffect( () => {
        if (f !== 1)
            return;
        const N = setTimeout( () => g(2), 5e3);
        return () => clearTimeout(N)
    }
    , [f]),
    S.useEffect( () => {
        if (x.length > 1 && !i.current) {
            const N = x.reduce(k, 0);
            o(N)
        }
    }
    , [x]),
    S.useImperativeHandle(e, () => ({
        async reload() {
            n.current && (t?.(),
            await Nx(n.current))
        }
    }), [t]);
    const w = () => {
        n.current && (y(!0),
        requestAnimationFrame( () => {
            p(N => {
                const O = !N;
                return O ? document.body.appendChild(_) : document.body.removeChild(_),
                O
            }
            ),
            setTimeout( () => {
                y(!1)
            }
            , 100)
        }
        ))
    }
      , A = () => {
        n.current && Nx(n.current).catch( () => {}
        ),
        t?.()
    }
      , C = N => {
        E && N.key === "Enter" && u(O => {
            let M = O;
            /^(?:www.|https?:\/\/)/.test(O) ? M = "/" : O.startsWith("/") || (M = `/${O}`);
            try {
                const H = new URL(E.baseUrl + M.replace(/^\/+/, "/"));
                d(H.toString())
            } catch {
                M = "/",
                d(E.baseUrl)
            }
            return r.current && r.current.blur(),
            M
        }
        )
    }
      , k = S.useCallback( (N, O, M, H) => O.port < H[N].port ? M : N, [])
      , I = v.jsxs("div", {
        className: "size-full flex flex-col",
        children: [a && v.jsx("div", {
            className: "z-iframe-overlay size-full absolute",
            onClick: () => l(!1)
        }), v.jsxs("div", {
            className: "bg-bolt-elements-background-depth-2 p-2 flex items-center gap-1.5",
            children: [v.jsx(tn, {
                icon: "i-ph:arrow-clockwise",
                onClick: A
            }), v.jsx("div", {
                className: `group flex items-center gap-1 flex-grow bg-bolt-elements-preview-addressBar-background border border-bolt-elements-borderColor text-bolt-elements-preview-addressBar-text rounded-full pl-1 pr-3 py-1 text-sm hover:bg-bolt-elements-preview-addressBar-backgroundHover hover:focus-within:bg-bolt-elements-preview-addressBar-backgroundActive focus-within:bg-bolt-elements-preview-addressBar-backgroundActive
        focus-within-border-bolt-elements-borderColorActive focus-within:text-bolt-elements-preview-addressBar-textActive`,
                children: v.jsxs("div", {
                    className: "flex gap-1.5 w-full",
                    children: [E && v.jsx(Obe, {
                        activePreviewIndex: s,
                        setActivePreviewIndex: o,
                        isDropdownOpen: a,
                        setHasSelectedPreview: N => i.current = N,
                        setIsDropdownOpen: l,
                        previews: x
                    }), v.jsx("input", {
                        ref: r,
                        className: "w-full bg-transparent outline-none",
                        type: "text",
                        value: c,
                        onChange: N => {
                            u(N.target.value)
                        }
                        ,
                        onKeyDown: C
                    })]
                })
            }), v.jsx(tn, {
                icon: m ? "i-ph:corners-in" : "i-ph:corners-out",
                onClick: w
            })]
        }), v.jsxs("div", {
            className: "flex-1 border-t border-bolt-elements-borderColor relative",
            children: [b && v.jsx("div", {
                className: "absolute inset-0 z-100 bg-bolt-elements-background-depth-2"
            }), E ? v.jsxs(v.Fragment, {
                children: [v.jsxs("div", {
                    className: "flex gap-3 flex-col size-full justify-center items-center bg-bolt-elements-background-depth-2 absolute inset-0 -z-1",
                    children: [v.jsx("div", {
                        className: "i-svg-spinners:ring-resize text-bolt-elements-item-contentAccent text-4xl"
                    }), v.jsx("div", {
                        className: "text-bolt-elements-textSecondary",
                        children: "Waiting for preview to load"
                    })]
                }), v.jsx("iframe", {
                    ref: n,
                    className: be("border-none size-full bg-white transition-opacity", {
                        hidden: f !== 2
                    }),
                    src: h,
                    allow: Mbe,
                    onLoad: () => {
                        g(N => N === 0 ? 1 : 2)
                    }
                })]
            }) : v.jsx("div", {
                className: "flex size-full justify-center items-center bg-white",
                children: "No preview available"
            })]
        })]
    });
    return m ? fa.createPortal(I, _) : I
}
)
  , Fbe = S.memo(Bbe);
function QA() {
    return globalThis.innerWidth >= 1024
}
function jbe(t, e=100) {
    if (e === 0)
        return t;
    let n;
    return function(...r) {
        const i = this;
        clearTimeout(n),
        n = window.setTimeout( () => {
            t.apply(i, r)
        }
        , e)
    }
}
const Hbe = {
    ease: Ft
}
  , Ube = {
    left: {
        value: "code",
        text: "Code"
    },
    right: {
        value: "preview",
        text: "Preview"
    }
}
  , Vbe = {
    closed: {
        width: 0,
        transition: {
            duration: .2,
            ease: Ft
        }
    },
    open: {
        width: "var(--workbench-width)",
        transition: {
            duration: .2,
            ease: Ft
        }
    }
}
  , JA = t => {
    me.currentView.set(t)
}
  , $be = t => {
    me.setCurrentDocumentContent(t.content)
}
  , zbe = t => {
    me.setCurrentDocumentScrollPosition(t)
}
  , Wbe = t => {
    me.setSelectedFile(t)
}
  , Gbe = () => {
    me.saveCurrentDocument().catch( () => {
        ct.error("Failed to update file content")
    }
    )
}
  , qbe = () => {
    me.resetCurrentDocument()
}
  , Kbe = async t => {
    if (t.method === "rename")
        return me.rename(Fn(t.oldPath), Fn(t.newPath));
    if (t.method === "cut")
        return t.oldPath === t.newPath ? void 0 : me.cut(Fn(t.oldPath), Fn(t.newPath), t.type);
    if (t.method === "copy") {
        const n = Fn(t.oldPath)
          , r = Fn(t.newPath);
        if (t.type === "file") {
            const i = await me.copyFile(n, r);
            me.setSelectedFile(i);
            return
        }
        return me.copyDirectory(n, r)
    }
    const e = Fn(t.path);
    if (t.type === "file")
        switch (t.method) {
        case "add":
            {
                try {
                    await me.writeFile(e, {
                        type: "file",
                        content: "",
                        isBinary: !1,
                        isFakeBinary: !1
                    }, {
                        errorIfExists: !0,
                        errorIfIgnored: !0
                    })
                } catch (n) {
                    if (!(n instanceof Er) || n.code !== "EEXISTS")
                        throw n
                }
                me.setSelectedFile(t.path);
                return
            }
        case "remove":
            return me.removeFile(e)
        }
    switch (t.method) {
    case "add":
        {
            await me.createDirectory(e, {
                errorIfIgnored: !0
            });
            break
        }
    case "remove":
        return me.removeDirectory(e)
    }
}
  , Ybe = () => {
    He.showChat.set(!He.showChat.get())
}
  , Xbe = S.memo(t => {
    const {chatStarted: e, isStreaming: n, initialView: r, previewRef: i, onPreviewReload: s} = t;
    _r.trace("Workbench");
    const o = Ie(He.showChat)
      , a = Ie(sl(me.previews, A => A.length > 0))
      , l = Ie(me.hasArtifacts)
      , c = Ie(me.showWorkbench)
      , u = Ie(me.selectedFile)
      , h = Ie(me.currentDocument)
      , d = Ie(me.unsavedFiles)
      , f = Ie(me.files)
      , g = Ie(me.currentView)
      , _ = S.useRef(null)
      , [m,p] = S.useState(!0)
      , [b,y] = S.useState(QA())
      , [x] = S.useState( () => {
        const A = document.createElement("div");
        return A.classList.add("contents"),
        A
    }
    )
      , E = fa.createPortal(v.jsx(Dbe, {
        editorDocument: h,
        isStreaming: n,
        selectedFile: u,
        files: f,
        unsavedFiles: d,
        onFileSelect: Wbe,
        onEditorScroll: zbe,
        onEditorChange: $be,
        onFileSave: Gbe,
        onFileReset: qbe,
        onFileChange: Kbe
    }), x);
    S.useEffect( () => {
        p(!1);
        const A = jbe( () => {
            y(QA())
        }
        , 50);
        return window.addEventListener("resize", A),
        () => {
            window.removeEventListener("resize", A)
        }
    }
    , []),
    S.useEffect( () => {
        a && JA("preview")
    }
    , [a]),
    S.useEffect( () => {
        me.setDocuments(f)
    }
    , [f]),
    S.useLayoutEffect( () => {
        _.current && x && _.current.replaceWith(x)
    }
    , [o, x, _.current]);
    const w = v.jsx(Fbe, {
        onReload: s,
        ref: i
    });
    return e && v.jsxs(v.Fragment, {
        children: [E, v.jsx(It.div, {
            initial: r ?? "closed",
            animate: c ? "open" : "closed",
            variants: Vbe,
            className: "z-workbench",
            children: v.jsxs("div", {
                className: be("fixed top-[calc(var(--header-height)+1rem)] bottom-4 w-[var(--workbench-inner-width)] z-0 transition-[left,width] duration-200 bolt-ease-cubic-bezier", {
                    "left-[var(--workbench-left)]": m ? r === "open" : c,
                    "left-[100%]": m ? r === "closed" : !c
                }),
                children: [l && v.jsx("button", {
                    className: "absolute bg-transparent text-bolt-elements-textTertiary hover:text-bolt-elements-textPrimary cursor-pointer top-[50%] -translate-y-[50%] -left-[32px] z-1",
                    onClick: Ybe,
                    children: v.jsx(ga, {
                        children: v.jsxs(Vs, {
                            delayDuration: 300,
                            children: [v.jsx(qo, {
                                asChild: !0,
                                children: v.jsx("div", {
                                    className: be("size-6", o ? "i-ph:caret-left" : "i-ph:caret-right")
                                })
                            }), v.jsx(Ko, {
                                children: v.jsx(na, {
                                    side: "top",
                                    align: "center",
                                    sideOffset: 2,
                                    children: o ? "Hide Chat" : "Show Chat"
                                })
                            })]
                        })
                    })
                }), v.jsx("div", {
                    className: "select-none absolute inset-0",
                    children: v.jsxs("div", {
                        className: "h-full flex flex-col bg-bolt-elements-background-depth-2 border border-bolt-elements-borderColor shadow-sm rounded-lg overflow-hidden",
                        children: [v.jsx("div", {
                            className: "flex items-center px-3 py-2 border-b border-bolt-elements-borderColor min-h-[var(--panel-header-height)]",
                            children: (o || !b) && v.jsx(RO, {
                                selected: g,
                                options: Ube,
                                setSelected: JA
                            })
                        }), o || !b ? v.jsxs("div", {
                            className: "relative flex-1 overflow-hidden",
                            children: [v.jsx(ZA, {
                                initial: {
                                    x: g === "code" ? 0 : "-100%"
                                },
                                animate: {
                                    x: g === "code" ? 0 : "-100%"
                                },
                                children: v.jsx("div", {
                                    ref: _
                                })
                            }), v.jsx(ZA, {
                                initial: {
                                    x: g === "preview" ? 0 : "100%"
                                },
                                animate: {
                                    x: g === "preview" ? 0 : "100%"
                                },
                                children: w
                            })]
                        }) : v.jsxs(Ap, {
                            className: "flex h-full",
                            direction: "horizontal",
                            children: [v.jsx(Io, {
                                className: "border-r border-bolt-elements-borderColor w-full",
                                defaultSize: 50,
                                children: v.jsx("div", {
                                    ref: _
                                })
                            }), v.jsx(kp, {}), v.jsx(Io, {
                                className: "w-full",
                                defaultSize: 50,
                                children: w
                            })]
                        })]
                    })
                })]
            })
        })]
    })
}
)
  , ZA = S.memo( ({children: t, ...e}) => v.jsx(It.div, {
    className: "absolute inset-0",
    transition: Hbe,
    ...e,
    children: t
}))
  , Qbe = [{
    text: "Terms",
    href: "https://stackblitz.com/terms-of-service"
}, {
    text: "Privacy",
    href: "https://stackblitz.com/privacy-policy"
}]
  , Jbe = [{
    text: "Start a blog with Astro",
    href: "/~/bolt-astro-blog"
}, {
    text: "Build a mobile app with NativeScript",
    href: "/~/bolt-nativescript-js"
}, {
    text: "Create a docs site with Vitepress",
    href: "/~/bolt-vitepress"
}, {
    text: "Scaffold UI with shadcn",
    href: "/~/bolt-shadcn"
}, {
    text: "Draft a presentation with Slidev",
    href: "/~/bolt-slidev"
}, {
    text: "Code a video with Remotion",
    href: "/~/bolt-remotion"
}]
  , ek = [{
    href: "/~/bolt-astro-basic",
    tooltip: "Astro",
    icon: "i-bolt:frameworks-astro",
    style: {
        default: "opacity-30",
        hover: "hover:opacity-75"
    }
}, {
    href: "/~/bolt-vanilla-vite",
    tooltip: "Vite",
    icon: "i-bolt:frameworks-vite"
}, {
    href: "/~/bolt-nextjs-shadcn",
    tooltip: "Next.js",
    icon: "i-bolt:frameworks-next"
}, {
    href: "/~/bolt-nativescript-js",
    tooltip: "NativeScript",
    icon: "i-bolt:frameworks-nativescript",
    style: {
        hover: "hover:opacity-75"
    }
}, {
    href: "/~/bolt-nuxt",
    tooltip: "Nuxt.js",
    icon: "i-bolt:frameworks-nuxt",
    style: {
        hover: "hover:opacity-75"
    }
}, {
    href: "/~/bolt-slidev",
    tooltip: "Slidev",
    icon: "i-bolt:frameworks-slidev"
}, {
    href: "/~/bolt-vue",
    tooltip: "Vue.js",
    icon: "i-bolt:frameworks-vue",
    style: {
        hover: "hover:opacity-55"
    }
}, {
    href: "/~/bolt-sveltekit",
    tooltip: "Svelte",
    icon: "i-bolt:frameworks-svelte",
    style: {
        default: "opacity-30",
        hover: "hover:opacity-80"
    }
}, {
    href: "/~/bolt-remix",
    tooltip: "Remix",
    icon: "i-bolt:frameworks-remix",
    style: {
        hover: "hover:opacity-75"
    }
}, {
    href: "/~/bolt-ts",
    tooltip: "TypeScript",
    icon: "i-bolt:frameworks-typescript"
}, {
    href: "/~/bolt-vite-react",
    tooltip: "React",
    icon: "i-bolt:frameworks-react",
    style: {
        default: "opacity-35",
        hover: "hover:opacity-80"
    }
}, {
    href: "/~/bolt-remotion",
    tooltip: "Remotion",
    icon: "i-bolt:frameworks-remotion"
}, {
    href: "/~/bolt-angular",
    tooltip: "Angular",
    icon: "i-bolt:frameworks-angular"
}, {
    href: "/~/bolt-qwik",
    tooltip: "Qwik",
    icon: "i-bolt:frameworks-qwik"
}]
  , Zbe = [{
    href: "https://twitter.com/stackblitz",
    icon: "i-bolt:logos-x?mask text-4"
}, {
    href: "https://github.com/stackblitz/bolt.new",
    icon: "i-bolt:logos-github?mask text-4.5"
}, {
    href: "https://discord.com/invite/stackblitz",
    icon: "i-bolt:logos-discord?mask text-5"
}]
  , eye = "_BaseChat_4d1mx_1"
  , tye = "_Chat_4d1mx_5"
  , nye = "_ExamplePrompts_4d1mx_13"
  , rye = "_Stacks_4d1mx_18"
  , iye = "_StackBlitzLogo_4d1mx_23"
  , sye = "_RayContainer_4d1mx_34"
  , oye = "_LightRay_4d1mx_56"
  , aye = "_RayOne_4d1mx_61"
  , lye = "_RayTwo_4d1mx_69"
  , cye = "_RayThree_4d1mx_79"
  , uye = "_RayFour_4d1mx_88"
  , hye = "_RayFive_4d1mx_98"
  , Sn = {
    BaseChat: eye,
    Chat: tye,
    ExamplePrompts: nye,
    "fade-and-move-in": "_fade-and-move-in_4d1mx_1",
    Stacks: rye,
    StackBlitzLogo: iye,
    RayContainer: sye,
    "fade-in": "_fade-in_4d1mx_1",
    LightRay: oye,
    RayOne: aye,
    RayTwo: lye,
    RayThree: cye,
    RayFour: uye,
    RayFive: hye
}
  , $F = Cr.forwardRef( ({textareaRef: t, showChat: e=!0, chatStarted: n=!1, isStreaming: r=!1, isDragging: i=!1, enhancingPrompt: s=!1, promptEnhanced: o=!1, disableInput: a=!1, initialView: l, previewRef: c, messages: u, input: h="", fileSelections: d=[], attachments: f=[], onRollback: g, onUndo: _, resolveProblems: m, clearProblems: p, handleDrop: b, onUploadFile: y, onRemoveFileSelection: x, onRemoveAttachment: E, sendMessage: w, handleInputChange: A, enhancePrompt: C, handleStop: k, resubmit: I}, N) => {
    const [O,M] = S.useState(0)
      , H = Ie(da)
      , $ = Ie(Kt.user)
      , J = Ie(Kt.loggedIn)
      , {scrollRef: Q, contentRef: ee, scrollToBottom: D, isAtBottom: L} = j5({
        initial: {
            stiffness: .1
        }
    })
      , z = S.useRef(null)
      , V = S.useRef();
    S.useEffect( () => {
        if (!z?.current)
            return;
        const Z = new ResizeObserver( ([se]) => {
            M(se.contentRect.height)
        }
        );
        return Z.observe(z.current),
        () => Z.disconnect()
    }
    , []);
    const B = u?.findLast( ({type: Z, role: se}) => Z === "chat" && se === "user");
    return S.useEffect( () => {
        V.current && D({
            animation: {
                mass: 1
            },
            ignoreEscapes: !0
        }),
        V.current = B?.id
    }
    , [B?.id]),
    v.jsxs("div", {
        ref: N,
        className: be(Sn.BaseChat, "relative flex h-full w-full overflow-hidden bg-bolt-elements-background-depth-1"),
        "data-chat-visible": e,
        children: [!n && v.jsxs("a", {
            id: "announcement",
            href: "https://x.com/stackblitz/status/1841873251313844631",
            className: "fixed top-10 left-1/2 -translate-x-1/2 group flex items-center gap-2 border border-bolt-elements-borderColor rounded-full px-4 py-1.5 inline-block mb-4.5 text-xs hover:bg-alpha-gray-2 dark:hover:bg-gray-900 transition-theme",
            target: "_blank",
            children: [v.jsx("div", {
                className: "i-bolt:logos-x?mask text-bolt-elements-textPrimary size-4"
            }), "Introducing bolt.new: Dev sandbox with AI from StackBlitz", v.jsx("span", {
                className: "absolute -top-px left-[2.5rem] h-px w-[calc(100%-5rem)] bg-gradient-to-r from-accent-600/0 via-accent-600/80 to-accent-600/0 opacity-0 group-hover:opacity-100 transition-opacity transition-theme"
            }), v.jsx("span", {
                className: "absolute -top-px left-1/2 -translate-x-1/2 h-px w-[60px] bg-gradient-to-r from-accent-300/0 via-accent-300/50 to-accent-300/0 mix-blend-overlay opacity-0 group-hover:opacity-100 transition-opacity transition-theme"
            })]
        }), v.jsx(hr, {
            children: () => v.jsxs("div", {
                className: Sn.RayContainer,
                "data-theme": H,
                "data-chat-started": n,
                children: [v.jsx("div", {
                    className: be(Sn.LightRay, Sn.RayOne)
                }), v.jsx("div", {
                    className: be(Sn.LightRay, Sn.RayTwo)
                }), v.jsx("div", {
                    className: be(Sn.LightRay, Sn.RayThree)
                }), v.jsx("div", {
                    className: be(Sn.LightRay, Sn.RayFour)
                }), v.jsx("div", {
                    className: be(Sn.LightRay, Sn.RayFive)
                })]
            })
        }), v.jsx(hr, {
            children: () => v.jsx(oae, {
                user: $,
                loggedIn: J
            })
        }), v.jsxs("div", {
            ref: Q,
            className: be("flex overflow-auto size-full", {
                "flex-col": !n
            }),
            children: [v.jsxs("div", {
                className: be(Sn.Chat, "selection-accent flex flex-col flex-grow min-w-[var(--chat-min-width)]"),
                children: [!n && v.jsxs("div", {
                    id: "intro",
                    className: "flex flex-col mt-[22vh] mx-auto",
                    children: [v.jsx("h1", {
                        className: "text-[44px] text-center font-semibold text-bolt-elements-textPrimary tracking-tight",
                        children: "What do you want to build?"
                    }), v.jsx("p", {
                        className: "mb-6 text-center text-bolt-elements-textSecondary",
                        children: "Prompt, run, edit, and deploy full-stack web apps."
                    })]
                }), v.jsxs("div", {
                    className: be({
                        "h-full flex flex-col": n
                    }),
                    children: [v.jsx(hr, {
                        children: () => n ? v.jsx(pie, {
                            ref: ee,
                            messageBoxHeight: O,
                            className: "flex flex-col gap-5 w-full flex-1 max-w-chat py-6 mx-auto z-1 text-sm",
                            messages: u,
                            isAtBottom: L,
                            onRollback: g,
                            onUndo: _,
                            resubmit: I,
                            resolveProblems: m,
                            clearProblems: p,
                            isStreaming: r,
                            scrollToBottom: D,
                            user: $
                        }) : null
                    }), v.jsx(Pie, {
                        ref: z,
                        textareaRef: t,
                        chatStarted: n,
                        isDragging: i,
                        isStreaming: r,
                        disableInput: a,
                        enhancingPrompt: s,
                        promptEnhanced: o,
                        input: h,
                        fileSelections: d,
                        attachments: f,
                        handleDrop: b,
                        onUploadFile: y,
                        onRemoveFileSelection: x,
                        onRemoveAttachment: E,
                        handleStop: k,
                        sendMessage: w,
                        handleInputChange: A,
                        enhancePrompt: C
                    })]
                }), v.jsx(hr, {
                    children: () => !n && v.jsxs("div", {
                        id: "example-prompts-and-stacks",
                        className: "relative flex flex-col gap-9 w-full max-w-3xl mx-auto flex justify-center mt-6",
                        children: [!1, v.jsx("div", {
                            className: be(Sn.ExamplePrompts, "flex flex-wrap justify-center gap-2"),
                            children: Jbe.map( ({text: Z, href: se}, ae) => v.jsx("a", {
                                href: se,
                                className: "border border-bolt-elements-borderColor rounded-full bg-gray-50 hover:bg-gray-100 dark:bg-gray-950 dark:hover:bg-gray-900 text-bolt-elements-textSecondary hover:text-bolt-elements-textPrimary px-3 py-1 text-xs transition-theme",
                                children: Z
                            }, ae))
                        }), v.jsx(ga, {
                            disableHoverableContent: !0,
                            children: v.jsxs("div", {
                                className: be(Sn.Stacks, "flex flex-col items-center"),
                                children: [v.jsx("span", {
                                    className: "text-bolt-elements-textTertiary text-sm",
                                    children: "or start a blank app with your favorite stack"
                                }), v.jsx("div", {
                                    className: "grid grid-cols-7 mx-auto mt-5 gap-4 justify-items-center",
                                    children: ek.slice(0, 7).map( (Z, se) => v.jsx(tk, {
                                        theme: H,
                                        ...Z
                                    }, se))
                                }), v.jsx("div", {
                                    className: "grid grid-cols-7 mx-auto mt-5 gap-4 justify-items-center",
                                    children: ek.slice(7).map( (Z, se) => v.jsx(tk, {
                                        theme: H,
                                        ...Z
                                    }, se))
                                })]
                            })
                        })]
                    })
                })]
            }), v.jsx(hr, {
                children: () => v.jsx(Xbe, {
                    initialView: l,
                    chatStarted: n,
                    isStreaming: r,
                    previewRef: c,
                    onPreviewReload: () => {
                        p?.( ({type: Z}) => Z !== "preview")
                    }
                })
            }), !n && v.jsxs("footer", {
                id: "footer",
                className: "flex gap-3.5 ml-auto items-center justify-center text-sm text-bolt-elements-textTertiary py-2 px-4",
                children: [Zbe.map( ({icon: Z, href: se}, ae) => v.jsx("a", {
                    "data-icon": Z,
                    href: se,
                    className: `${Z} hover:text-bolt-elements-textPrimary`,
                    target: "_blank"
                }, ae)), v.jsx("div", {
                    className: "dot"
                }), Qbe.map( ({text: Z, href: se}, ae) => v.jsx("a", {
                    href: se,
                    target: "_blank",
                    className: "hover:text-bolt-elements-textPrimary transition-theme",
                    children: Z
                }, ae)), v.jsx("div", {
                    className: "dot"
                }), v.jsx("a", {
                    href: "https://stackblitz.com",
                    className: be(Sn.StackBlitzLogo, "hover:text-bolt-elements-textPrimary transition-theme"),
                    target: "_blank"
                })]
            })]
        })]
    })
}
);
function tk({href: t, icon: e, style: n, tooltip: r, theme: i}) {
    return v.jsxs(Vs, {
        delayDuration: 300,
        children: [v.jsx(qo, {
            asChild: !0,
            children: v.jsx("a", {
                href: t,
                children: v.jsx("div", {
                    className: be(`${e}-${i} transition-theme text-4xl`, n?.default ?? "opacity-25", n?.hover ?? "hover:opacity-65")
                })
            })
        }), v.jsx(Ko, {
            children: v.jsx(na, {
                side: "bottom",
                sideOffset: 6,
                children: r
            })
        })]
    })
}
function dye() {
    const t = {};
    return t.promise = new Promise( (e, n) => {
        t.resolve = e,
        t.reject = n
    }
    ),
    t
}
const fye = () => (S.useEffect( () => {
    function t(n) {
        return n.preventDefault(),
        n.returnValue = "Bolt is still working, are you sure you want to leave?",
        n.returnValue
    }
    const e = me.isStreaming.subscribe(n => {
        n ? window.addEventListener("beforeunload", t) : window.removeEventListener("beforeunload", t)
    }
    );
    return () => {
        e(),
        window.removeEventListener("beforeunload", t)
    }
}
, []),
null)
  , nk = 60
  , zF = S.memo( ({open: t, requestStatus: e, onUpgrade: n, onRetry: r, onClose: i}) => {
    const [s,o] = S.useState(nk)
      , [a,l] = S.useState(!0)
      , c = S.useCallback( () => {
        o(nk),
        l(!1)
    }
    , []);
    return S.useEffect( () => {
        let u;
        return t && s > 0 && !a && (u = setTimeout( () => {
            o(h => h - 1)
        }
        , 1e3)),
        () => clearTimeout(u)
    }
    , [t, s, a]),
    S.useEffect( () => {
        s <= 0 && (l(!0),
        r(),
        Rr({
            action: Ir.Track,
            payload: {
                event: Yr.BoltConcurrentFreeUsersRetry
            }
        }))
    }
    , [s, t, c]),
    S.useEffect( () => {
        a && e === "ERROR" && c()
    }
    , [a, e]),
    S.useEffect( () => {
        t && c()
    }
    , [t, c]),
    v.jsxs(Vo, {
        open: t,
        maxWidth: 600,
        showCloseButton: !0,
        onClose: i,
        children: [v.jsx(Os, {
            children: "Heavy usage"
        }), v.jsxs(Ns, {
            children: [a ? v.jsx("div", {
                className: "flex mb-4",
                children: v.jsx(n6, {
                    text: "Retrying"
                })
            }) : v.jsxs("p", {
                className: "mb-4",
                children: ["We are currently experiencing heavy usage. We will retry your request in", " ", v.jsx("span", {
                    className: "font-bold",
                    children: s
                }), " seconds."]
            }), v.jsx("p", {
                children: "Or upgrade now to skip the line!"
            })]
        }), v.jsx(Mu, {
            children: v.jsx(Gi, {
                onClick: n,
                type: "primary",
                children: "Upgrade"
            })
        })]
    })
}
);
zF.displayName = "RateLimitDialog";
const rk = nr("useProjects");
function pye() {
    const [t,e] = S.useState(!1)
      , [n,r] = S.useState();
    S.useEffect( () => {
        Ne.registerConflictListener( (a, l) => {
            r({
                lastEditor: a,
                editedAt: l
            }),
            e(!0)
        }
        );
        const o = Ne.registerForkListener(i);
        return () => {
            o()
        }
    }
    , []);
    const i = S.useCallback(async () => {
        try {
            await vP(),
            e(!1)
        } catch (o) {
            throw rk.error(o),
            ct.error("Issues connecting to StackBlitz"),
            new Error("Failed to fork project")
        }
    }
    , [])
      , s = S.useCallback(async () => {
        try {
            const o = Ne.getSlug()
              , a = Ne.getEditedAt();
            bn(o),
            bn(a);
            const l = await DP({
                slug: o,
                editedAt: a,
                files: me.files.get(),
                force: !0
            });
            if (!l)
                return;
            Ne.setEditedAt(l.editedAt),
            e(!1)
        } catch (o) {
            throw rk.error(o),
            ct.error("Issues connecting to StackBlitz"),
            new Error("Failed to overwrite project")
        }
    }
    , []);
    return {
        onForkProject: i,
        onOverwriteProject: s,
        conflict: t,
        conflictData: n
    }
}
function mye(t) {
    const [e,n] = S.useState(!1)
      , r = t6();
    S.useEffect( () => {
        t && n(!0)
    }
    , [t]),
    S.useEffect( () => {
        e && (r.load("/api/token"),
        n(!1))
    }
    , [e, r]),
    S.useEffect( () => {
        if (!r.data)
            return;
        const {token: i, expiresAt: s} = r.data;
        fX(i);
        const o = setTimeout( () => {
            n(!0)
        }
        , gye(s));
        return () => {
            clearTimeout(o)
        }
    }
    , [r.data])
}
function gye(t) {
    const e = Math.abs(t - Date.now());
    return Math.max(e + 6e4, 0)
}
class _ye {
    async writeFile(e, n) {
        return me.writeFile(Fn(e), n)
    }
    async removeFile(e) {
        return me.removeFile(Fn(e))
    }
    async rmdir(e) {
        return me.removeDirectory(Fn(e))
    }
    async mkdir(e) {
        return me.createDirectory(Fn(e))
    }
}
const bye = new _ye;
function yye(t) {
    const e = me.files.get();
    ea.checkout(t, e, bye)
}
const ik = nr("Chat");
function vye({startOpen: t}) {
    _r.trace("Chat");
    const {storeMessageHistory: e} = Yv({
        projectReady: !0
    });
    return v.jsx(wx, {
        legacyURLPrompt: !0,
        startOpen: t,
        storeMessageHistory: e,
        initialMessages: []
    })
}
function Sve() {
    _r.trace("ProjectImport");
    const {slug: t} = Fl();
    S.useEffect( () => {
        Ne.setSlug(t)
    }
    , [t]);
    const {initialMessages: e, ready: n, chatHistory: r} = tX()
      , {storeMessageHistory: i} = Yv({
        projectReady: n,
        chatHistory: r
    });
    return v.jsx(wx, {
        disableInput: !0,
        initialMessages: [...e],
        storeMessageHistory: i
    })
}
function wve() {
    _r.trace("GithubImport");
    const {initialMessages: t, ready: e} = nX()
      , {storeMessageHistory: n} = Yv({
        projectReady: e
    });
    return v.jsx(wx, {
        disableInput: !0,
        initialMessages: t,
        storeMessageHistory: n
    })
}
const xye = {
    toggleTerminal: () => me.toggleTerminal()
};
function Eye() {
    Kt.freeUserRateLimited.set(!1),
    He.showPricingOverlay()
}
function Sye() {
    Kt.freeUserRateLimited.set(!1)
}
const wx = S.memo(t => {
    _r.trace("ChatImpl");
    const {initialMessages: e, storeMessageHistory: n, legacyURLPrompt: r, disableInput: i, startOpen: s} = t;
    kbe(xye);
    const o = S.useRef(null)
      , a = S.useRef(null)
      , l = S.useRef(null)
      , c = S.useRef(null)
      , u = Ie(He.showChat)
      , h = Ie(He.fileSelections)
      , d = Ie(He.attachments)
      , f = Ie(He.started)
      , g = Ie(mn)
      , _ = Ie(Ne.projectTooBig)
      , m = Ie(He.requestStatus)
      , p = Ie(Kt.rateLimitReached)
      , b = Ie(Kt.freeUserRateLimited)
      , y = Ie(me.isStreaming)
      , [x,E] = mU()
      , w = Ie(Kt.loggedIn)
      , [A,C] = S.useState(w)
      , [k,I] = S.useState(!1)
      , [N,O] = S.useState(i)
      , [M,H] = S.useState()
      , [$,J] = S.useState(!1);
    mye(A),
    S.useEffect( () => {
        C(w)
    }
    , [w]),
    l.current == null && (l.current = dye());
    function Q() {
        return A ? !0 : (I(!0),
        l.current.promise)
    }
    function ee() {
        I(!1),
        l.current.resolve(!1)
    }
    const {onForkProject: D, onOverwriteProject: L, conflict: z, conflictData: V} = pye()
      , {messages: B, input: Z, handleInputChange: se, setInput: ae, reload: G, stop: j, resolveProblems: oe, clearProblems: le, setMessages: de, append: ne, reloadPreview: pe} = wbe({
        initialMessages: e,
        previewRef: o,
        storeMessageHistory: n,
        resetInput() {
            c.current ? ae(c.current) : ae(""),
            a.current?.focus()
        }
    })
      , [Te] = uk();
    S.useEffect( () => {
        const Y = g.chatLoadingStatus;
        if (g.messages.length > 0 && (B.findIndex(re => re.id === im) === -1 || Y === "LOADED")) {
            Y === "LOADED" && mn.setKey("chatLoadingStatus", "DONE"),
            de([...g.messages]),
            O(!1);
            const re = Te.get("prompt");
            re && P(re)
        }
    }
    , [g.messages, g.chatLoadingStatus, _]),
    S.useEffect( () => {
        const Y = Te.get("prompt");
        return r && Y && P(Y),
        () => j()
    }
    , []),
    S.useEffect( () => {
        p && O(!0)
    }
    , [p]);
    const {enhancingPrompt: Ce, promptEnhanced: Re, enhancePrompt: we, resetEnhancer: ze} = Abe()
      , qe = f ? 400 : 200
      , et = S.useCallback(Y => {
        me.hasPersistedChanges || (Y.preventDefault(),
        me.saveFileHistory())
    }
    , [me])
      , $t = S.useCallback(async Y => {
        if (!await Q())
            return;
        if (He.attachments.get().length >= h_) {
            ct.error(`You can only upload a maximum of ${h_} files`);
            return
        }
        if (Y.size > I6) {
            ct.error(`The file size exceeds the maximum limit of ${Dy} MiB`);
            return
        }
        const re = He.addAttachment({
            file: Y,
            uploading: !0
        });
        try {
            const ce = new FormData;
            ce.append("file", Y),
            await Bu({
                action: async () => {
                    const Be = await fetch("/api/upload", {
                        method: "POST",
                        body: ce
                    });
                    if (!Be.ok)
                        throw new Error("Failed to upload file");
                    const {key: Ke} = await Be.json();
                    He.updateAttachment(re.id, {
                        storageKey: Ke
                    })
                }
                ,
                onStateUpdate: Be => {
                    Be || He.updateAttachment(re.id, {
                        uploading: !1
                    })
                }
                ,
                spinnerDelay: 0,
                minDuration: 200
            })
        } catch (ce) {
            He.removeAttachment(re),
            ik.error(ce),
            ct.error("Failed to upload file")
        }
    }
    , [])
      , {isDragging: Jt, handleDrop: _t} = J0e($t);
    S.useLayoutEffect( () => {
        He.started.set(e.length > 0);
        const Y = He.fileSelections.subscribe( () => {
            a.current?.focus()
        }
        );
        return window.addEventListener("beforeunload", et),
        () => {
            Y(),
            window.removeEventListener("beforeunload", et)
        }
    }
    , []);
    const St = S.useCallback(Y => {
        He.removeFileSelection(Y)
    }
    , [])
      , it = S.useCallback(Y => {
        He.removeAttachment(Y)
    }
    , [])
      , he = () => {
        const Y = a.current;
        Y && (Y.scrollTop = Y.scrollHeight)
    }
      , Se = S.useCallback( () => {
        j("aborted-by-user"),
        He.aborted.set(!0),
        me.abortAllActions()
    }
    , [j])
      , De = S.useCallback(Y => {
        H({
            message: Y
        })
    }
    , [])
      , Ge = S.useCallback(Y => {
        H({
            message: Y,
            undo: !0
        })
    }
    , [])
      , F = S.useCallback( () => {
        M && Bu({
            action: async () => {
                const {message: Y} = M;
                await yye(Y.messageId ?? Y.id),
                de(re => {
                    const ce = [];
                    for (const Ke of re)
                        if (ce.push(Ke),
                        Ke.id === Y.id)
                            break;
                    const Be = Ne.getSlug();
                    return Un && Be && rP(Un, {
                        slug: Be,
                        lastAssistantMessageId: Y.messageId ?? Y.id
                    }),
                    ce
                }
                ),
                H(void 0),
                pe(),
                ct.success("Successfully reverted changes")
            }
            ,
            onStateUpdate: J
        })
    }
    , [M]);
    S.useLayoutEffect( () => {
        const Y = a.current;
        if (Y) {
            Y.style.height = "auto";
            const re = Y.scrollHeight;
            Y.style.height = `${Math.min(re, qe)}px`,
            Y.style.overflowY = re > qe ? "auto" : "hidden"
        }
    }
    , [Z, a]);
    const R = async () => {
        f || (await Promise.all([E("#announcement", {
            opacity: 0,
            display: "none"
        }, {
            duration: .1
        }), E("#example-prompts-and-stacks", {
            opacity: 0,
            display: "none"
        }, {
            duration: .1
        }), E("#footer", {
            opacity: 0,
            display: "none"
        }, {
            duration: .1
        }), E("#intro", {
            opacity: 0,
            flex: 1
        }, {
            duration: .2,
            ease: Ft
        })]),
        He.started.set(!0))
    }
      , P = async (Y=Z) => {
        if (!await Q() || (Ne.shouldFork() && !Ne.isForking.get() && (Ne.isForking.set(!0),
        D()),
        Y.length === 0 || y))
            return !1;
        He.aborted.set(!1);
        let re = !1;
        if (!f) {
            pX().then(ka => {
                Ne.updateProject(ka),
                Gv(ka.slug)
            }
            ).catch(ka => {
                ik.error(ka),
                ct.error("Failed to create project")
            }
            ),
            re = !0;
            const br = new AbortController
              , fo = He.aborted.subscribe(ka => {
                ka && (me.isStreaming.set(!1),
                br.abort("Streaming aborted"))
            }
            );
            No.tryFetchTemplate(Y, br.signal).finally( () => {
                fo()
            }
            )
        }
        await me.saveAllFiles(),
        R(),
        h.length > 0 && He.resetFileSelections();
        const ce = Object.keys(me.lockedFiles.get())
          , Be = Object.keys(me.targetedFiles.get());
        let Ke;
        (ce.length > 0 || Be.length > 0) && (Ke = {
            lockedFiles: ce,
            targetedFiles: Be
        });
        const bt = B.findLast( ({id: br, role: fo}) => fo === "assistant" && br !== sm)
          , mt = Ne.getProjectId();
        if (bt && mt) {
            const br = bt.messageId ?? bt.id;
            ea.create(mt, br, me.files.get())
        }
        const yt = {
            type: "chat",
            id: Gh(),
            status: re ? "complete" : "streaming",
            role: "user",
            input: Y,
            content: Y,
            experimental_attachments: d.map( ({file: br, storageKey: fo}) => ({
                name: br.name,
                contentType: br.type,
                url: fo
            })),
            fileSelections: h,
            focusedFiles: Ke
        };
        return re ? (me.isStreaming.set(!0),
        de( () => [yt]),
        bn(No.ready),
        No.ready.then(br => {
            br && de(fo => [br, ...fo])
        }
        ).finally( () => {
            He.aborted.get() || G()
        }
        )) : ne(yt),
        He.resetAttachments(),
        ae(""),
        c.current = Y,
        a.current?.focus(),
        ze(),
        a.current?.blur(),
        B.length === 0 && Rr({
            action: Ir.Track,
            payload: {
                event: Yr.ChatCreated,
                properties: {
                    message: Y
                }
            }
        }),
        Rr({
            action: Ir.Track,
            payload: {
                event: Yr.MessageSent,
                properties: {
                    message: Y
                }
            }
        }),
        !0
    }
      , q = () => {
        if (a.current) {
            He.requestStatus.set("PENDING");
            const Y = new KeyboardEvent("keydown",{
                key: "Enter",
                code: "Enter",
                which: 13,
                keyCode: 13,
                bubbles: !0,
                cancelable: !0
            });
            a.current.dispatchEvent(Y)
        }
    }
    ;
    return S.useEffect( () => {
        const Y = He.events.on("sendChatMessage", re => {
            P(re.detail)
        }
        );
        return () => {
            Y()
        }
    }
    , [P]),
    v.jsxs(v.Fragment, {
        children: [v.jsx($F, {
            ref: x,
            textareaRef: a,
            input: Z,
            showChat: u,
            chatStarted: e.length > 0 || f,
            isStreaming: y,
            isDragging: Jt,
            disableInput: N,
            initialView: s ? "open" : "closed",
            enhancingPrompt: Ce,
            promptEnhanced: Re,
            fileSelections: h,
            attachments: d,
            onRollback: De,
            onUndo: Ge,
            sendMessage: P,
            handleDrop: _t,
            handleInputChange: se,
            onRemoveFileSelection: St,
            onRemoveAttachment: it,
            onUploadFile: $t,
            handleStop: Se,
            messages: B,
            previewRef: o,
            resolveProblems: oe,
            clearProblems: le,
            enhancePrompt: async () => {
                await Q() && we(Z, Y => {
                    ae(Y),
                    he()
                }
                )
            }
            ,
            resubmit: Y => {
                c.current === Z && ae(""),
                Y.error?.code === "free-user-rate-limited" && Rr({
                    action: Ir.Track,
                    payload: {
                        event: Yr.BoltConcurrentFreeUsersRetry
                    }
                }),
                de(re => {
                    const ce = [...re]
                      , Be = ce.findIndex( ({id: mt}) => mt === Y.id)
                      , Ke = ce.slice(0, Be + 1).findLastIndex( ({role: mt}) => mt === "user");
                    ce.push({
                        ...ce[Ke],
                        status: "streaming",
                        ignore: !1,
                        error: void 0
                    }),
                    ce.splice(Ke, 1);
                    const bt = ce.findIndex( ({role: mt}) => mt === "user");
                    return ce.slice(bt)
                }
                ),
                G()
            }
        }), v.jsxs(Vo, {
            open: k,
            onClose: ee,
            maxWidth: 600,
            children: [v.jsx(Ah, {
                children: v.jsx(Os, {
                    children: "Login"
                })
            }), v.jsx(Ns, {
                children: v.jsxs("div", {
                    className: "flex flex-col items-center w-full p-5 text-center",
                    children: [v.jsx("h2", {
                        className: "font-medium text-xl mb-1",
                        children: "Continue with StackBlitz"
                    }), v.jsx("span", {
                        className: "text-sm text-bolt-elements-textSecondary mb-6",
                        children: "To use Bolt you must log into an existing account or create one."
                    }), v.jsxs("div", {
                        className: "flex flex-col gap-4",
                        children: [v.jsx(Lf, {
                            onSuccess: () => {
                                I(!1),
                                l.current.resolve(!0)
                            }
                            ,
                            children: Y => v.jsx(c_, {
                                size: "md",
                                minWidth: 300,
                                minHeight: 40,
                                ...Y
                            })
                        }), v.jsx(Lf, {
                            onSuccess: () => {
                                I(!1),
                                l.current.resolve(!0)
                            }
                            ,
                            children: Y => v.jsx(c_, {
                                text: "Sign Up",
                                variant: "primary",
                                size: "md",
                                minWidth: 300,
                                minHeight: 40,
                                ...Y
                            })
                        })]
                    }), v.jsx("p", {
                        className: "mt-6 text-sm text-bolt-elements-textTertiary",
                        children: "By using Bolt, you agree to the collection of usage data for analytics."
                    })]
                })
            })]
        }), v.jsxs(Vo, {
            open: z,
            maxWidth: 600,
            showCloseButton: !1,
            children: [v.jsx(Os, {
                children: "Saving could overwrite a more recent version"
            }), v.jsxs(Ns, {
                children: [v.jsx("p", {
                    children: "This project was updated recently from another device or in another browser tab."
                }), V && v.jsxs("p", {
                    className: "mt-1",
                    children: ["Last saved by ", v.jsxs("span", {
                        className: "font-semibold",
                        children: [" ", V.lastEditor]
                    }), " ", _1(V.editedAt), "."]
                })]
            }), v.jsxs(Mu, {
                children: [v.jsx(Gi, {
                    type: "secondary",
                    disabled: !1,
                    onClick: D,
                    children: "Fork this project"
                }), v.jsx(Gi, {
                    type: "danger",
                    onClick: L,
                    children: "Save and overwrite existing project"
                })]
            })]
        }), v.jsxs(Vo, {
            open: !!M,
            maxWidth: 600,
            showCloseButton: !1,
            closeOnBackdropClick: !$,
            onClose: () => H(void 0),
            children: [v.jsx(Os, {
                children: "Revert to Previous Version"
            }), v.jsxs(Ns, {
                children: [v.jsx("p", {
                    children: "You are about to revert your project to a previous state."
                }), v.jsxs("p", {
                    className: "my-6 bg-alpha-orange-10 border-l border-l-2 border-orange-500 p-2 px-4 text-orange-600 dark:text-orange-500",
                    children: ["This action will undo all", " ", M?.undo ? "recent changes" : "changes made since the selected version", ". Your current work will be lost and cannot be recovered."]
                }), v.jsx("p", {
                    children: "Are you sure you want to proceed?"
                })]
            }), v.jsxs(Mu, {
                children: [v.jsx(Gi, {
                    type: "secondary",
                    disabled: $,
                    onClick: () => H(void 0),
                    children: "Cancel"
                }), v.jsx(Gi, {
                    type: "warn",
                    disabled: $,
                    minWidth: 30,
                    onClick: F,
                    children: $ ? v.jsxs("div", {
                        className: "flex items-center gap-1.5",
                        children: [v.jsx("div", {
                            className: "i-svg-spinners:90-ring-with-bg text-lg"
                        }), "Reverting"]
                    }) : "Revert now"
                })]
            })]
        }), v.jsx(zF, {
            open: (m === "ERROR" || m === "PENDING") && b,
            onRetry: q,
            onUpgrade: Eye,
            onClose: Sye,
            requestStatus: m
        }), v.jsx(fye, {})]
    })
}
);
function wye() {
    return {
        onProjectVisibilityChange: S.useCallback(async e => {
            const n = Ne.visibility.get();
            try {
                const r = Ne.getSlug();
                bn(r),
                Ne.visibility.set(e),
                await gX(r, e),
                ct.success("Project visibility updated")
            } catch (r) {
                throw pa.error(r),
                n && Ne.visibility.set(n),
                ct.error("Failed to update the project visibility. Please try it again."),
                new Error("Failed to update project visibility")
            }
        }
        , [])
    }
}
const sk = [{
    iconClassName: "i-ph:globe",
    value: "public",
    label: "Public",
    description: void 0,
    currentLabel: "This project is public"
}, {
    iconClassName: "i-ph:eye-slash",
    value: "secret",
    label: "Secret",
    description: "accessible by URL",
    currentLabel: "This project is secret"
}, {
    iconClassName: "i-ph:lock-simple",
    value: "private",
    label: "Private",
    description: void 0,
    currentLabel: "This project is private"
}]
  , Cye = {
    open: {
        y: 0,
        opacity: 1,
        transition: {
            duration: .15,
            ease: Ft
        }
    },
    close: {
        y: 6,
        opacity: 0,
        transition: {
            duration: .15,
            ease: Ft
        }
    }
}
  , Tye = S.memo( () => {
    const t = Ie(Ne.visibility)
      , [e,n] = S.useState(!1)
      , {onProjectVisibilityChange: r} = wye()
      , i = sk.find(o => o.value === t)
      , s = S.useCallback( () => {
        n(o => !o)
    }
    , []);
    return !t || !i ? null : v.jsxs(MN, {
        open: e,
        modal: !1,
        onOpenChange: s,
        children: [v.jsx(ga, {
            children: v.jsxs(Vs, {
                children: [v.jsx(qo, {
                    asChild: !0,
                    children: v.jsxs(BN, {
                        className: be("inline-flex items-center gap-1.5 px-1 py-1.5 bg-transparent hover:bg-bolt-elements-item-backgroundActive border border-transparent rounded-md hover:border-bolt-elements-borderColor", {
                            "bg-bolt-elements-item-backgroundActive border-bolt-elements-borderColor": e
                        }),
                        children: [v.jsx("div", {
                            className: i.iconClassName
                        }), v.jsx("div", {
                            className: e ? "i-ph:caret-up" : "i-ph:caret-down"
                        })]
                    })
                }), v.jsx(Ko, {
                    children: v.jsxs(na, {
                        sideOffset: 3,
                        children: [i.currentLabel, v.jsx(Zk, {})]
                    })
                })]
            })
        }), v.jsx(hs, {
            children: e && v.jsx(FN, {
                forceMount: !0,
                children: v.jsx(jN, {
                    className: "z-visibility-dropdown",
                    asChild: !0,
                    forceMount: !0,
                    avoidCollisions: !1,
                    sideOffset: 3,
                    align: "end",
                    children: v.jsx(It.div, {
                        initial: "close",
                        animate: "open",
                        exit: "close",
                        variants: Cye,
                        children: v.jsxs("div", {
                            className: "bg-bolt-elements-background-depth-1 dark:bg-bolt-elements-background-depth-2 px-4 py-3 border border-bolt-elements-borderColor rounded-md text-sm select-none",
                            children: [v.jsxs("fieldset", {
                                children: [v.jsx("legend", {
                                    className: "font-semibold mb-3",
                                    children: "Project visibility"
                                }), v.jsx("div", {
                                    className: "flex flex-col gap-1.5",
                                    children: sk.map( ({value: o, label: a, description: l}) => v.jsxs("label", {
                                        className: "inline-flex items-center grow-0",
                                        children: [v.jsx("input", {
                                            className: "accent-bolt-elements-button-primary-background",
                                            type: "radio",
                                            name: "visibility",
                                            value: o,
                                            onChange: c => r(c.target.value),
                                            checked: o === t
                                        }), v.jsxs("div", {
                                            className: "flex-inline items-center gap-1.5",
                                            children: [v.jsx("div", {
                                                className: be({
                                                    "i-ph:globe": o === "public",
                                                    "i-ph:eye-slash": o === "secret",
                                                    "i-ph:lock-simple": o === "private"
                                                }, "text-base ms-2")
                                            }), v.jsx("span", {
                                                children: a
                                            }), l && v.jsxs("span", {
                                                children: ["(", l, ")"]
                                            })]
                                        })]
                                    }, o))
                                })]
                            }), v.jsx(HN, {
                                className: "fill-bolt-elements-borderColor"
                            })]
                        })
                    })
                })
            })
        })]
    })
}
)
  , Aye = S.memo( () => {
    const t = Ie(wP)
      , e = Ie(Ne.canManage);
    return v.jsxs(v.Fragment, {
        children: [v.jsx("span", {
            className: "max-w-96 truncate",
            children: t
        }), t && e && v.jsx(Tye, {})]
    })
}
)
  , kye = () => {
    He.events.dispatch("sendChatMessage", "Deploy this application.")
}
  , Rye = () => {
    const e = !Ie(Ne.getSlugStore());
    return v.jsxs(qi, {
        className: "flex gap-1",
        variant: "primary",
        size: "sm",
        disabled: e,
        onClick: () => kye(),
        children: [v.jsx("div", {
            className: "i-ph:rocket-launch text-lg"
        }), "Deploy"]
    })
}
;
function Iye(t) {
    window.open(`${om}/edit/${t}`)
}
const Pye = () => {
    const e = !Ie(Ne.getSlugStore());
    return v.jsxs(qi, {
        className: "flex gap-1.7",
        variant: "secondary",
        size: "sm",
        disabled: e,
        onClick: () => Iye(Ne.getSlug()),
        children: [v.jsx("svg", {
            width: "11",
            height: "16",
            children: v.jsx("path", {
                fill: "currentColor",
                d: "M4.67 9.85a.3.3 0 0 0-.27-.4H.67a.3.3 0 0 1-.21-.49l7.36-7.9c.22-.24.6 0 .5.3l-1.75 4.8a.3.3 0 0 0 .28.39h3.72c.26 0 .4.3.22.49l-7.37 7.9c-.21.24-.6 0-.49-.3l1.74-4.8Z"
            })
        }), "Open in StackBlitz"]
    })
}
  , Dye = () => {
    const [t,e] = S.useState(!1)
      , r = !Ie(Ne.getSlugStore()) || t;
    async function i(s) {
        await Bu({
            onStateUpdate: e,
            action: async () => {
                const a = await (await Nr).internal.serialize(jt, {
                    excludes: ["node_modules"],
                    format: "zip"
                });
                sP({
                    blob: new Blob([a],{
                        type: "application/zip"
                    }),
                    filename: `project-bolt-${s}.zip`
                })
            }
        })
    }
    return v.jsxs(qi, {
        className: "flex gap-1.7",
        variant: "secondary",
        size: "sm",
        disabled: r,
        onClick: () => i(Ne.getSlug()),
        children: [t ? v.jsx("div", {
            className: "i-svg-spinners:90-ring-with-bg"
        }) : v.jsx("div", {
            className: "i-ph:download-simple"
        }), "Download"]
    })
}
;
function Lye({}) {
    return v.jsx(ga, {
        children: v.jsx(Vs, {
            delayDuration: 300,
            children: v.jsxs("div", {
                className: "flex gap-2",
                children: [v.jsx(Dye, {}), v.jsx(Pye, {}), v.jsx(Rye, {})]
            })
        })
    })
}
const ok = S.memo( ({text: t, variant: e}) => v.jsx(Lf, {
    children: ({loginPending: n, onLogin: r}) => v.jsx(c_, {
        text: t,
        variant: e,
        minWidth: 0,
        minHeight: 28,
        loginPending: n,
        onLogin: r
    })
}));
function Oye() {
    const t = Ie(Kt.loggedIn)
      , e = Ie(He.started);
    return v.jsxs("header", {
        className: be("flex select-none selection-accent items-center bg-bolt-elements-background-depth-1 pl-5 pr-4 border-b h-[var(--header-height)]", {
            "border-transparent": !e,
            "border-bolt-elements-borderColor": e
        }),
        children: [v.jsx("div", {
            className: "flex grow-1 basis-60 items-center gap-2 z-logo text-bolt-elements-textPrimary cursor-pointer",
            children: v.jsx("a", {
                href: "/",
                className: "text-2xl font-semibold text-accent flex items-center",
                children: v.jsx("span", {
                    className: "i-bolt:logos-bolt?mask w-[46px] inline-block"
                })
            })
        }), v.jsx("div", {
            className: "flex-1 select-text px-4 text-sm text-center text-bolt-elements-textPrimary",
            children: v.jsx(hr, {
                children: () => v.jsx("div", {
                    className: "relative flex items-center justify-center gap-1.5",
                    children: v.jsx(Aye, {})
                })
            })
        }), v.jsx(hr, {
            children: () => v.jsxs("div", {
                className: "flex grow-1 basis-60 justify-end items-center gap-1.5",
                children: [!t && v.jsxs(v.Fragment, {
                    children: [v.jsx(ok, {
                        text: "Sign In",
                        variant: "secondary"
                    }), v.jsx(ok, {
                        text: "Get Started",
                        variant: "primary"
                    })]
                }), e && t && v.jsx(Lye, {})]
            })
        })]
    })
}
const Cve = () => {
    const t = "https://bolt.new/social_preview_index.jpg"
      , e = "Prompt, run, edit & deploy web apps"
      , n = "bolt.new";
    return [{
        title: n
    }, {
        name: "description",
        content: e
    }, {
        property: "og:type",
        content: "object"
    }, {
        property: "og:site_name",
        content: "bolt.new"
    }, {
        property: "og:title",
        content: n
    }, {
        property: "og:image",
        content: t
    }, {
        name: "og:description",
        content: e
    }, {
        name: "twitter:card",
        content: "summary_large_image"
    }, {
        name: "twitter:title",
        content: n
    }, {
        name: "twitter:description",
        content: e
    }, {
        name: "twitter:image",
        content: t
    }, {
        name: "twitter:site",
        content: "@StackBlitz"
    }]
}
;
function Tve() {
    return v.jsx(Nye, {
        children: v.jsx(hr, {
            fallback: v.jsx($F, {}),
            children: () => v.jsx(vye, {})
        })
    })
}
function Nye({children: t}) {
    const {user: e, loggedIn: n} = Fl()
      , [r,i] = S.useState(!1);
    return S.useEffect( () => {
        if (new URLSearchParams(window.location.search).get("autoAuth") !== null) {
            const o = new URL(window.location.href);
            o.searchParams.delete("autoAuth"),
            n ? window.history.replaceState({}, "", o) : (i(!0),
            ZF({
                redirect: o
            }),
            e6.startAuthFlow())
        }
    }
    , []),
    S.useEffect( () => {
        e && Kt.setUser(e),
        Kt.loggedIn.set(n)
    }
    , [e]),
    !r && v.jsxs("div", {
        className: "flex flex-col h-full w-full bg-bolt-elements-background-depth-1",
        children: [v.jsx(Oye, {}), t]
    })
}
export {hg as A, lt as B, AB as C, Ufe as D, Oe as E, Kr as F, wve as G, Ql as H, Nye as I, rl as J, Cpe as K, oy as L, on as M, hB as N, zp as O, Sve as P, Cve as Q, Tve as R, en as T, Kfe as a, tr as b, ot as c, Bt as d, _ve as e, Tpe as f, vve as g, gve as h, gpe as i, En as j, ge as k, Eve as l, yve as m, bve as n, dpe as o, pve as p, xve as q, eme as r, ope as s, te as t, hpe as u, fve as v, qpe as w, mi as x, lg as y, co as z};

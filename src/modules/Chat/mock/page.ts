
export const TEMPLATE_FILES = {
    id: 'myProject',
    files: {
    ".dalaran/prompt": "对于我要求你制作的所有设计，请确保它们美观，而不是千篇一律。创建功能完整且适合生产环境的网页。\n\n此模板默认支持 JSX 语法与 Tailwind CSS 类，React hooks，@alifd/next组件库和lucide-react图标。除非绝对必要或我主动要求，否则请勿安装其他组件库、图标等包\n\n@alifd/next、react、react-dom、react-router-dom、moment这些库已经被external处理过了，不需要通过npm来额外安装\n\n\n\n# 组件库(Next)\n组件库的包名是@alifd/next，请用以下内容更新你所掌握的关于fusion组件库的信息，信息有冲突的时候以我为准\n组件中没有声明组件属性就不代表该组件没有组件属性，生成的时候也不需要，没有声明的组件在生成过程中不要凭空捏造\n必要的情况下支持通过Tailwind来设置className的值，来改变组件的样式表达，比如\n```\n<Button className=\"mt-8 w-24\">\n```\n\n## 组件全局说明\n1. 所有组件的通用属性如下\n```typescript\ninterface CProp{\n  className?: string // 组件样式名\n}\n```\n\n2. 表单类组件的通用属性如下\n```typescript\ninterface FProp{\n  className?: string // 组件样式名\n  defaultValue?: string //默认值，\n  label?: string //标题\n  placeholder?: string //占位符文本，一般请选择、请输入是placeholder\n  required?: Boolean //是否必填，label内容左侧含有 * 号 就为true否则为false\n  help?: string //校验未通过的提示文案，通常是文本内容，颜色一般是红色\n  disabled?: Boolean //是否禁用，如果是置灰的话取值true\n  onChange?: (value: string) => void //表单项值改变时的回调\n}\n```\n\n## 布局组件\n\n### Grid.Row \n栅格行组件\n属性如下\n```\ninterface RowProp{\n  gutter?: number // 列间隔\n  fixedWidth?: // 固定宽度,可选值:xxs(320px),xs(480px),s(720px),m(990px),l(1200px),xl(1500px)\n  align?: // 垂直对齐方式,可选值:top, middle, bottom, baseline, stretch(占满容器的高度)\n  justify?: // 水平对齐方式,可选值:start, end, center, space-around, space-between\n}\n```\n### Grid.Col\n栅格列组件,响应式列采用24列栅格体系和5分比实现，以满足2，3，4，5，6分比布局等多种情况，固定列采用 20px 宽度作为单位栅格,推荐使用9，10，12，14，16，18，24，但同时也提供了从1到30的所有栅格,也可根据需求定制固定栅格列\n属性如下\n```\ninterface ColProp{\n  span?: number // 响应式列宽度 可选值1-24\n  fixedSpan?: number // 固定列宽度，宽度值为20 * 栅格数, 可选值1-30\n  offset?: number // 列偏移 可选值1-24\n  fixedOffset?: number // 固定列偏移，宽度值为20 * 栅格数, 可选值1-30\n}\n```\n\n\n\n## 表单类组件\n\n\n### Input \n单行输入框\n属性如下\n```\ninterface InputProp{\n  showLimitHint?: boolean; // 是否显示输入字数数, 组件右侧会显示`已输出字符串数/最大长度`\n  maxLength?: number; //最大长度\n  readOnly?: boolean; //是否只读\n  disabled?: boolean; //是否禁用，出现斜着的条纹背景是true\n  placehold?: string; //输入提示，文字颜色是灰色，用来提醒用户输入什么样的内容\n  label?: string; //标题，输出框左侧的文案\n  defaultValue?: string; //输入值，颜色不会是灰色\n  addonTextBefore?: string // 输入框前附加文字\n  addonTextAfter?: string // 输入框后附加文字\n}\n```\n\n### Input.TextArea \n多行输入框\n属性如下跟Input相同\n\n\n### Checkbox.Group \n一组复选框容器\n属性如下\n```\ninterface Checkbox.GroupProp{\n  value?: string | string[]; // 复选框值\n  dataSource: {label: string, value: any}[] //可选项列表\n  onChange?: (value: string[]) => void; //复选框值改变时的回调\n  direction?: string; //Checkbox排列方向，默认hoz,可选值hoz(水平), ver(垂直)\n}\n```\n示例如下\n```\n  const dataSource = [\n    {\n      label: 'Apple',\n      value: 'apple'\n    },{\n      label: 'Watermelon',\n      value: 'watermelon'\n    }\n  ]\n\n <Checkbox.Group dataSource={dataSource}></Checkbox.Group>\n```\n\n### Checkbox \n复选框\n属性如下\n```\ninterface CheckboxProp{\n  id: string;\n  value: string; // 单选框值\n  children: string; // 单选框文本\n}\n```\n\n### Radio.Group\n一组单选框容器\n属性如下\n```\ninterface Radio.GroupProp{\n  value?: string; // 单选框值\n  dataSource: {label: string, value: any}[] //可选项列表\n  onChange?: (value: any) => void; //单选框值改变时的回调\n  shape?: string; //单选框形状，默认normal,可选值:normal(圆圈态), button(按钮态)\n}\n```\n示例如下\n```\n  const dataSource = [\n    {\n      label: 'Apple',\n      value: 'apple'\n    },{\n      label: 'Watermelon',\n      value: 'watermelon'\n    }\n  ]\n <Radio.Group dataSource={dataSource}></Radio.Group>\n```\n### Radio \n单选框\n属性如下\n```\ninterface RadioProp{\n  id: string;\n  value: string; // 单选框值\n  children: string; // 单选框文本\n}\n```\n\n### Select \n下拉选择器\n属性如下\n```\ninterface SelectProp<T={value: string, label: string, [key:string]?: any}>{\n  dataSource: T[] //数据源， label是显示的文本，value是值，如果识别为空的话，可以根据语义生成mock数据\n  mode?: string //模式， 可选值single、multiple, tag\n  hasSelectAll:boolean\t多选模式下是否有全选功能,mode为multiple时，表示是否能全选,在所有选项列表顶部会展示一个全选区域\n  showSearch?: boolean //开启搜索\n  value?: string //当前选中值\n  valueRender?: (item: T) => JSXElement //  选择值的渲染方法\n  itemRender?: (item: T, searchValue: string) => JSXElement //下拉选项的渲染方法，searchValue为搜索关键字(如果开启了搜索)\n  filterLocal?: boolean //是否开启本地过滤\n  filter?: (key: string, item: T) => boolean // key为搜索关键字, 返回是否匹配\n  hasClear?: boolean //是否有清除按钮\n  tagInline?: boolean //是否是标签内联\n  tagClosable?: boolean // 是否可以关闭标签\n  menuProps?: { // 下拉菜单定制配置,header和footer可以定制下拉菜单的头部和底部内容\n    header?: JSXElement //头部内容\n    footer?: JSXElement //底部内容\n  }\n}\n```\n示例如下:\n```jsx\nconst dataSource = [\n    { value: \"Lilith\", age: 22, gender: \"F\" },\n    { value: \"Tom Cat\", age: 28, gender: \"M\" }\n];\n\nconst valueRender = v => {\n  return v.value+ \"/\" + v.gender + \"/\" +v.age;\n};\n\nconst itemRender = v=>{\n  return <span>{v.value}</span>;\n}\n\nreturn (\n  <Select\n    mode=\"multiple\"\n    filterLocal\n    valueRender={valueRender}\n    itemRender={itemRender}\n    dataSource={dataSource}\n  />\n```\n\n### Button \n按钮\n属性如下\n```\ninterface ButtonProp{\n  type: string; // 按钮类型,默认值是normal,可选值primary(有个很明显的背景色), secondary(文字颜色是蓝色), normal\n  children: JSXElemnt | string; //按钮里面的内容\n}\n```\n\n### DatePicker2\n日期选择组件\n\n\n### DatePicker2.RangePicker\n时间区间选择组件\n属性如下\n```\ninterface RPickerProp{\n  mode: string; // 可选值date、month、year, week, quarter\n}\n```\n\n### Upload \n上传\n属性如下\n```\n\ninterface UploadProp{\n  shape?: string; //上传按钮形状，可选值:card\n  size?: string; //可选值:small,medium,large\n  children: JSXElemnt | string; // 上传组件文本，当listType有值是，无需生成该属性\n  defaultValue?: {name: string, imgURL: string}[]; //上传的文件列表，当listType有值是，通过该属性渲染内容\n  listType?: string; //列表类型,可选值: text(文字)，image(图片)，card(卡片)\n}\n\n```\n### Upload.Card \n卡片列表上传组件\n属性如下\n```\ninterface Upload.CardProp extends UploadProp{\n  listType: string ; //列表类型,默认值为且只能是card(卡片)\n}\n```\n\n### Upload.Dragger \n拖拽上传组件\n属性如下\n```\ninterface Upload.DraggerProp extends UploadProp{\n  children?: string | JSXElement; //拖拽上传组件里的文案\n}\n```\n\n\n### Search \n搜索\n属性如下\n```interface SearchProp{\n  shape?: string\t//形状，可选值:'normal', 'simple'\n  type?: string //类型 shape=normal的时候 取值primary或secondary; shape=simple: 取值normal或dark;\n}\n```\n\n### Rating \n评分\n属性如下\n```interface RatingProp{\n  value: numebr; //评分值\n  count: 评分的总数; //评分总数\n  allowHalf?: boolean; //是否允许半星评分\n}\n```\n\n### Switch\n开关切换器\n属性如下\n```interface SwitchProp{\n  checked: boolean; //是否选中\n  disabled: boolean; //是否禁用\n  children: string | JSXElement; //开关文本\n}\n```\n\n## 导航类类组件\n\n### Tab \n选项卡切换容器\n属性如下\n```\n{\n  shape: string  // 可以通过 shape 属性配置选项卡的类型，默认值pure，可选值包括：\npure：普通选项卡(默认)，特点是选中tab底部边框色高亮，非选中边框没有颜色; \nwrapped：包裹型选项卡, 特点是有背景色和边框; \ntext：文本型选项卡,特点是没有背景色和边框，纯文本; \ncapsule：胶囊型选项卡,特点是有背景色和边框，选项卡之间没有间距，像胶囊一样，可以有多行\n}\n```\n示例如下:\n```jsx\n<Tab>\n  <Tab.Item title=\"Tab1\" />\n  <Tab.Item title={<div>Custom Tab</div>} /> //自定义tab选项卡标题\n</Tab>\n```\n\n### Tab.Item \n选项卡切换容器里的选项卡，不能有子元素\n属性如下\n```\n{\n  title: string | JSXElement //选项卡标题,可以是字符串或者JSX组件\n  disabled?: boolean //是否被禁用\n}\n```\n\n\n### Pagination \n翻页器\n属性如下\n```\n{\n  type?: string //展示类型，可选值normal, simple, mini\n  shape?: string //前进后退按钮样式，可选值normal, arrow-only, arrow-prev-only, no-border\n  disabled?: boolean //是否被禁用\n  total?: number //总记录数\n  pageSize?: number //每页显示记录数\n}\n```\n\n\n### Step \n步骤条，需要配合Step.Item使用\n属性如下\n```\n{\n  shape?: string //展示的类型，可选值circle, arrow, dot\n  direction?: boolean //展示方向，可选值hoz, ver\n  labelPlacement?: 横向布局时( direction 为 hoz )的内容排列, 可选值hoz, ver\n  itemRender?:(index: Number, status: String) => JSXElement //index-节点索引,status-节点状态, Step.Item 默认有三种状态，分别是 wait, process,finish\n}\n```\n\n### Step.Item \n步骤条，作为Step的子节点使用\n属性如下\n```\n{\n  title?: JSXElement | string; //标题\n  icon?: string; //图标\n  content?: JSXElement | string; //内容填充\n  itemRender?:(index: Number, status: String) => JSXElement //跟Step组件的属性一样，且会覆盖\n}\n```\n\n\n## 数据展示类组件\n\n### Tag.Group\n标签组，跟Tag配合使用来渲染一组Tag，子节点只能是Tag组件\n\n### Tag \n标签\n无需通过className来设置padding和border属性\n属性如下\n```\ninterface TagProp{\n  size: string; //高度30px为small,高度36px为medium,高度42px以上为large,默认设置small,可选值:small,medium,large\n  children: string; // 标签文本\n  type: string; //标签类型,默认值normal,可选值primary, normal\n  color?: string; // 标签颜色,有内置颜色blue,green,orange,red,turquoise,yellow,可以搭配type属性来实现实心和空心标签的颜色,也支持自定义hex,但只支持实心标签\n}\n```\n\n### Tag.Closeable \n可关闭的标签，右侧带删除图标\n\n\n### Menu \n提供导航的菜单列表\n还有一些跟Menu组合使用的子组件\nMenu.SubMenu // 子菜单组件\nMenu.Item // 菜单项组件\nMenu.Divider // 菜单分割线组件\n属性如下\n```\ninterface MenuProp{\n  size: string; //可选值:small,medium,large\n  mode?: string; //菜单展开模式,可选值:inline,popup\n}\n```\n示例如下\n```jsx\n<Menu className=\"my-menu\" mode=\"popup\">\n  <Item key=\"1\">Option 1</Item>\n  <Divider key=\"divider\" />\n  <SubMenu key=\"sub-1\" label=\"Popup menu 1\">\n    <Item key=\"popup-1-1\">Popup option 11</Item>\n    <Item key=\"popup-1-2\">Popup option 12</Item>\n  </SubMenu>\n  <SubMenu key=\"sub-2\" label=\"Popup menu 2\">\n    <Item key=\"popup-2-1\">Popup option 21</Item>\n  </SubMenu>\n</Menu>,\n```\n\n### Menu.SubMenu\n子菜单组件\n属性如下\n```\ninterface SubMenuProp{\n  label?: string // 子菜单文案\n  disabled?: boolean;// 是否禁用\n  mode?: string; //菜单展开模式，会覆盖Menu组件的mode，可选值:inline,popup\n  children: JSXElement | string; //菜单项内容\n}\n```\n\n### Menu.Item\n菜单项组件\n属性如下\n```\ninterface Menu.ItemProp{\n  disabled?: boolean;// 是否禁用\n  children: JSXElement | string; //菜单项内容\n}\n```\n\n### Menu.Divider\n菜单分割线\n\n### Table \n表格，渲染内容是表名和表内容，也可能会包含表单组件，其他内容不属于表格组件范畴\n属性如下\n```\ninterface TableDataSourceItem{ //表格数据每一项的类型定义\n  [key:string]: any\n  children?:TableDataSourceItem[]; //当表格是tree模式，数据里通过该属性来表达树形结构\n}\n\ninterface TableColumnItem{ //表头每一列的类型定义\n  title?: string, //列名，表格表头显示的内容，可以为空\n  children?: TableColumnItem[] //当表格是多表头时，通过该属性来实现多层级\n  dataIndex: string, // 制定列对应的数据字段，支持a.b形式的快速取值，可以为空\n  sortable: Boolean, // 是否支持排序\n  colSpan?: number, // 横跨的格数，设置为0表示此列表头被合并，不展示\n  cell: (value: any, index: number, record: any) => JSXElement //行渲染的函数，返回JSX，当渲染内容是字符串或者数字时，无需生成该属性，是复杂UI的时候生成jsx片段，该函数内不能使用react hook\n}\n\n/**\n * \n * \t特别是Table的props.columns是每一列的信息包括列头和body内容请一定要识别出来\n * \t当表格数据为空时新增属性emptyContent，内容是展示文案\n *  列表第一列如果有+或-，表示列表是可展开的，不带+或-的行就是展开的行，请在props.expandedRowRender中把展开的内容按照Table组件的属性识别出来，只识别展开的行\n *  列表第一项存在箭头的情况下，表示是Tree模式，isTree属性为true\n *  操作项列一般是最后一列且没有列名，如果出现这种情况，在props.columns中增加一个没有列名的操作项列\n *  当出现有合并单元格的表格时，需要通过cellProps来为每个单元格设置属性，通过TableColumnItem中的colSpan来设置表头合并项\n */\ninterface TableProp{\n  hasBorder?: boolean // 是否有边框，默认为true\n  isZebra?: boolean // 行是否展示斑马线，默认为false\n  crossline?: boolean // 在hover表格行列时出现十字参考轴时候为true\n  rowSelection?:{\n    mode: string //每一行的第一列是否有可选择框，没有则为空，单选是single，多选是multiple，默认为空字符串\n  } | undefined,  // 第一列不是选择框则为不需要生成该属性 \n  expandedRowRender?: ()=>JSXElement | undefine // 表格行展开的内容。当表格第一列有+或-时就表示表格行可被展开，生成一个可以返回JSX的函数，如果没有就不生成该属性\n  emptyContent: JSXElement // 表格数据为空的时候的表格展现的内容\n  isTree?: boolean //tree模式的表格则为true\n  indent?: boolean // 在tree模式下的缩进尺寸， 仅在isTree为true时候有效\n  primaryKey?: string // dataSource中数据的主键，当isTree为true的时候，该值不能为空\n  columns: TableColumnItem[],\n  dataSource : TableDataSourceItem[] // 表格数据，key跟columns中的dataIndex对应，只需要输出不超过三条数据即可\n  cellProps?: (rowIndex: number, colIndex: number, dataIndex: string, record: any)=> {rowSpan: number, colSpan: number} //设置单元格的属性，通过该属性可以进行合并单元格\n}\n```\n示例如下:\n```jsx\n<Table\n  columns={[\n    {\n      title: 'Name',\n      dataIndex: 'name',\n      cell: (value, index, record) => <div className=\"flex items-center\">\n        <img ariaHidden=\"true\" src={record.logo} className=\"mr-1\" />\n        <span>{record.name}</span>\n      </div>,\n    },\n    {\n      title: 'Age',\n      dataIndex: 'age',\n    },\n    {\n      title: 'Address',\n      dataIndex: 'address',\n    },\n  ]},\n  dataSource={[{\n    name: 'John', \n    logo: 'https://m.cnd.com/sadasda/123',\n    age: 32, \n    address: 'New York No. 1 Lake Park'\n  }, {\n    name: 'Jim', \n    logo: 'https://m.cnd.com/sadasda/123',\n    age: 42, \n    address: 'London No. 1 Lake Park'\n  }]}\n>\n\n</Table>\n```\n\n\n### Badge \n徽标，图标或者文本右上角的数字\n图片里有红色的圆形背景才能识别为Badge\n属性如下\n```\ninterface BadgeProp{\n  count: number; // 展示的数字或文案\n  dot?: boolean; // 不展示数字，只展示一个小红点\n  overflowCount?: number; // 展示封顶的数字值\n  content?: string; // 自定义徽标中的内容\n  children?: JSXElement; // 徽标依托的内容，可以为空，一般显示在其右上方\n}\n```\n示例如下:\n```jsx\n//在该元素右上角渲染徽标，内容是5\n<Badge count={5}>\n  <span className=\"basic-example\"></span> \n</Badge>\n```\n\n### Slider \n轮播\n\n\n### Timeline\n垂直展示的时间流信息，跟Timeline.Item配合使用\n属性如下\n```\ninterface TimelineProp{\n  mode?: string; //展示模式，可选值:left, alternate\n}\n```\n示例如下:\n```jsx\n<Timeline>\n  <TimelineItem\n    title=\"Receipt\"\n    state=\"process\"\n    icon=\"smile\"\n    time=\"2017-10-21\"\n  />\n  <TimelineItem\n    title=\"Ship\"\n    dot={<span style={{ fontSize: \"14px\" }}> 😂 </span>}\n    state=\"success\"\n    content=\"Congratulations, successful orders!\"\n    time=\"2017-10-22\"\n  />\n</Timeline>\n```\n\n### Timeline.Item\n一条时间流信息\n属性如下\n```\ninterface Timeline.ItemProp{\n  title: string //标题\n  time?: string | JSXElement // 格式化后的时间\n  state: string //状态 ,可选值:process, success, error\n  content?: string | JSXElement // 右侧内容\n  timeLeft?: string | JSXElement // 左侧时间 \n  dot?: JSXElement // 标题旁边的节点自定义渲染内容\n}\n```\n\n### Tree \n树形控件\n属性如下\n```\ninterface ITreeNode{\n  label: string // 节点名称\n  key: string // 节点key\n  children: ITreeNode[] // 子节点\n}\ninterface TreeProp{\n  dataSource: ITreeNode[] // 树形数据源\n}\n```\n\n### Card\n通用的卡片组件容器\n可以任意组合Card.Media、Card.Header、Card.Content、Card.Divider、Card.Actions中一个或多个一起使用\n\n属性如下\n```\ninterface CardProp{\n  free: boolean; //默认值true\n  children?: string | JSXElement; //卡片内容\n}\n```\n示例如下:\n```jsx\n// 卡片横向布局，图片在左，标题、内容和操作按钮在右\n<Card free className=\"w-full flex justify-between\">\n  <Card.Media className=\"w-52\" image=\"https://img.alicdn.com/tfs/TB1FNIOSFXXXXaWXXXXXXXXXXXX-260-188.png\" />\n  <div className=\"flex flex-col flex-1 items-stretch\">\n    <Card.Header\n      title=\"Title\"\n      subTitle=\"Sub Title\"\n      extra={\n        <Button type=\"primary\" text>\n          Link\n        </Button>\n      }\n    />\n    <Card.Content>\n      Lorem ipsum dolor sit amet, est viderer iuvaret perfecto et.\n    </Card.Content>\n    <Card.Actions className=\"text-right\">\n      <Button type=\"primary\" key=\"action1\">\n        Action 1\n      </Button>\n      <Button type=\"primary\" key=\"action2\" text>\n        Action 2\n      </Button>\n    </Card.Actions>\n  </div>\n</Card>\n\n// 卡片纵向布局，图片在上，标题、内容和操作按钮在下\n<Card free className=\"w-full\">\n  <Card.Header\n    title=\"Title\"\n  />\n  <Card.Content>\n    Lorem ipsum dolor sit amet, est viderer iuvaret perfecto et.\n  </Card.Content>\n</Card>\n```\n\n### Card.Media\n卡片图片组件，用来展示卡片的图片，横向卡片需要设置宽度，纵向布局需要设置高度\n属性如下\n```\ninterface Card.MediaProp{\n  image: string // 图片地址\n}\n```\n### Card.Header\n卡片标题组件，用来展示卡片的图片\n属性如下\n```\ninterface Card.HeaderProp{\n  title: string // 卡片标题\n  subTitle: string // 卡片副标题\n  extra?: JSXElement // 卡片标题的右侧内容，一般是多个按钮或者链接的组合\n}\n```\n### Card.Content\n卡片内容组件，用来展示卡片的主体内容\n属性如下\n```\ninterface Card.ContentProp{\n  children: JSXElemen // 卡片主体内容\n}\n\n### Card.Divider\n卡片的分割线\n\n### Card.Actions\n卡片的操作按钮组，子组件基本是按钮或者链接\n\n\n### Collapse\n折叠面板，用于折叠和展开内容区域，对复杂区域进行分组和隐藏，保持页面的整洁。\n属性如下\n```\ninterface CollapseProp{\n  dataSource?: {title: string, content: JSXElement, disabled?: boolean}[] // 面板数据源,title-面板标题, content-面板内容，disabled-是否禁用\n  expandedKeys?: string[] // 当前展开的面板的 key 数组\n  defaultExpandedKeys?: string[] // 初始化时默认展开的面板的 key 数组\n  accordion?: boolean // 是否开启手风琴模式，开启后每次只能展开一个面板，默认false\n  onExpand: (key: string) => void // 面板展开状态变化时的回调函数\n}\n```\n\n\n## 反馈类组件\n\n### Message \n消息提示，用于向用户传达即时信息或通知\n属性如下\n```\ninterface MessageProp{\n  title: string // 标题\n  type: string // 类型，可选值success, warning, error, notice, help, loading\n  children?: string| JSXElement // 内容\n  closeable?: boolean // 是否可关闭\n}\n```\n\n### Dialog \n弹窗\n属性如下\n```\ninterface DialogProp{\n  v2: string // 默认值 true\n  visible: boolean // 默认值是true\n  title: string // 标题\n  footer?: boolean | JSXElement // 底部内容, 设置为false则不显示，默认值是[<Button type=\"primary\">确定</Button>, <Button>取消</Button>]\n  children?: string| JSXElement // 内容\n}\n```\n\n### Drawer\n抽屉是用于在不离开主路径的情况下，提供用户快速执行简单的操作、确认用户信息或反馈提示的辅助窗口，一般是从右侧滑出\n属性如下\n```\ninterface DrawerProp{\n  title: string | JSXElement //标题\n  visible: boolean // 默认值是true\n  hasMask?: boolean // 是否显示遮罩,默认值是true\n  children?: string | JSXElement //抽屉内容\n}\n```\n\n\n# 解决方案集合(merchant-solutions)\n以下会列出一些常用的解决方案,当出现符合的场景,务必按照以下解决方案来完成代码生成\n\n## 表单解决方案(merchant-form)\n负责表单代码生成，使用Form和Form.Item组合来完成表单项的组合，使用Field来对表单的数据和行为进行管理\n表单生成请使用该方案来完成代码生成\n以下是各个部分的详细说明,具体用法可以参考后面的示例\n### 表单包裹组件\n#### Form\n表单容器组件,整体代表一个表单，配合Form.Item使用,也可以组合Grid.Row和Grid.Col来实现灵活布局,使用Field来管理表单数据\n\n属性如下\n```\ninterface FormProp{\n  inline?: boolean // 所有Form.Item是否是行内布局\n  fullWidth: boolean // 单个Form.Item是否是100%宽度，默认设置成true\n  labelAlign: string // 标签位置, 默认取值left，如果标签在其对应表单项上方取值top，在内部取值inset，可选值：top(标签在表单项上边), left(标签在表单项左边), inset(标签在表单项里面)\n  labelTextAlign?: string // 标签的左右对齐方式,可选值left, right\n  colon?: boolean //是否显示标签后的冒号\n  labelCol: ColProp //标签布局，请根据标签宽度设置\n  wrapperCol: ColProp //表单项布局，请根据表单项宽度设置\n  field: Field //表单数据管理实例，这是必填项，用于表单数据管理和校验,表单的初始值也需要通过Field来设置\n}\n```\n\n#### Form.Item\n表单项组件，用来包裹表单类组件或者自定义表单组件\nForm.Item子节点只能包括一个表单类组件，如果存在多个表单类组件，需要把它们整体封装成一个自定义表单组件\n属性如下\n```\ninterface Form.ItemProp{\n  label?: string // 标签文本\n  help?: string | JSXElement; //自定义提示信息，文本颜色一般是红色，会根据校验规则自动生成展示在表单项下面\n  name: string; //表单项名称, 配合Field使用，声明表单项的数据源的字段名，可以根据label的语义来生成英文单词，驼峰写法\n  children?:  JSXElement; //表单项内容\n  required?: boolean; //是否必填，标签旁边有红色星号则为true，否则为false\n}\n```\n\n#### Form.Submit\n表单提交按钮，语义上是提交表单内容的按钮就是Form.Submit\n属性如下\n```\ninterface Button.SubmitProp{\n  type: string //默认值primary\n  children: JSXElemnt | string; //按钮里面的内容\n}\n```\n\n#### Form.Reset\n表单重置按钮，语义上是取消或者重置表单内容的按钮就是Form.Reset\n```\ninterface Button.ResetProp{\n  children: JSXElemnt | string; //按钮里面的内容\n}\n```\n\n### 表单数据管理工具\n也需要从@alifd/next导入\n#### Field\n它不是组件，是工具库，涉及到表单数据操作、校验的地方都可以用Field来管理数据。和组件关联后可以自动对表单数据进行回写、读取、校验\n类说明如下\n```typescript\ninterface FieldOption{\n  parseName: boolean // 不用理解该含义，默认设置成true\n}\n\ninterface FieldRule{\n  required: boolean // 是否必填\n  pattern?: string // 校验正则表达式\n  minLength?: number // 输入字符串最小长度\n  maxLength?: number // 输入字符串最大长度\n  min?: number // 输入数字最小值\n  max?: number // 输入数字最大值\n  message?: string // 校验失败提示信息\n}\n\ninterface FieldInitOption{\n  values?: {[key: string]: any} // 表单初始化数据, key为表单项的name，支持带'.',如'a.b.c'\n  valueName: string // 表单组件值的属性名称,默认值是value,比如Checkbox的valueName是checked，Input是value\n  getValueFormatter?: (value: any)=> any // 格式化表单组件值的方法，用于处理组件返回的原始值，返回处理后的值\n  setValueFormatter?: (value: any)=> any // 格式化表单组件值的方法，用于处理组件设置的原始值，返回处理后的值\n  rules?: Array<FieldRule> // 表单组件的校验规则\n}\n\n\nclass Field{\n  static useField: (opt: FieldOption) => Field; //这是react hook,返回Field实例,opt必须设置\n  init(name: string, opt?: FieldInitOption) // 表单项初始化函数，name为表单项的name，必填项，配合Form使用时，如果Form.Item设置了name，则无需通过init来再次初始化，除非需要通过opt来进行额外配置\n  getValues(names?: string[]):void // 获取Form一组表单项的值，如不传入参数，则获取全部表单组件的值\n  getValue(names: string) // 获取Form下单个表单项的值\n  setValues(values: object) // 设置Form下一组表单项的值(会触发render，请遵循react时机使用)，\n  setValue(name: string, value: any) // 设置单个表单项的值(会触发render，请遵循react时机使用)\n  addArrayValue(name: string, index:number, value: any) // name 是数组格式的数据,从index位置添加 value(会触发render)\n  removeArrayValue(name: string, index: number) // 从 name 是数组格式的数据中移除 index 位置的值(会触发render)\n}\n```\n\n## 示例\n### 使用Form、Form.Item和Field的表单解决方案示例\n```jsx\nimport { useCallback, useEffect } from 'react'\nimport { Field, Input, Switch, Form, Grid } from '@alifd/next';\n\n// 自定义表单组件，属性需要包括value和onChange，value表示表单项的值，当表单项值变更的时候触发onChange事件\nfunction CustomItem({value, onChange}: {value: any, onChange: (value: string) => void}){\n  const customField = Field.useField({ \n    parseName: true,\n    onChange: (name: string, value:any)=> {\n      onChange && onChange(Object.assign({}, customField.getValues(), {[name]: value}));\n    }\n  });\n\n  useEffect(() => {\n    customField.setValues(value);\n  }, [value]);\n\n  return <Form labelCol={{span: 4}} wrapperCol={{span: 14 }} fullWidth labelAlign=\"inset\" field={customField}>\n    <Form.Item name=\"province\" label=\"省\">\n      <Input />\n    </Form.Item>\n    <Form.Item name=\"city\" label=\"市\">\n      <Input />\n    </Form.Item>\n  </Form>\n}\n\nfunction Page(){\n    const field = Field.useField({ //通过useField这个react hook初始化field实例\n      parseName: true\n    });\n\n    const onSubmit = useCallback( //表单提交回调\n      (value: any, error: any, field: Field) => {\n        //todo \n      },\n      [],\n    );\n\n    const { init, getValue } = field;\n    return <div>\n      {/*field接管Form表单的数据管理，表单项的值变更会触发整个函数组件重新渲染*/}\n      <Form labelCol={{span: 4}} wrapperCol={{span: 14 }} fullWidth  field={field}>\n        <Form.Item  label=\"Input Something：\">\n          <Grid.Row gutter=\"4\">\n            <Grid.Col>\n              <Form.Item\n                name=\"firstname\"\n                label=\"姓\"\n                required\n              >\n                <Input placeholder=\"Please enter...\" />\n              </Form.Item>\n            </Grid.Col>\n            <Grid.Col>\n              <Form.Item\n                name=\"secondname\"\n                label=\"名\"\n                required\n              >\n                {/* 包裹的Form.Item设置了name，Input则无需通过Field实例的init来设置了*/}\n                <Input placeholder=\"need onChange\" /> \n              </Form.Item>\n            </Grid.Col>\n          </Grid.Row>\n        </Form.Item>\n        <Form.Item label=\"adult\">\n          {/* Form.Item没设置name，需要通过Field实例的init方法来设置name和相关配置，name可以根据Form.Item的label的语义来生成 */}\n          <Switch {...init('isAdult', { \n              initValue: 1,\n              getValueFormatter: (value) => value ? 1 : 0,\n              setValueFormatter: (value) => value === 1\n            })}/>\n        </Form.Item>\n        <Form.Item name=\"needAddress\" label=\"是否展示地址\">\n          <Switch>\n        </Form.Item>\n        {\n          /* 通过getValue获取其他表单项的值来做逻辑联动 */\n          getValue('needAddress') ? <Form.Item name=\"address\" label=\"地址\">\n            {/* 把多个表单类组件封装成自定义表单组件 */}\n            <CustomItem />\n          </Form.Item> : <></>\n        }\n        <Form.Item label=\" \">\n          <Form.Submit validate type=\"primary\" onClick={onSubmit}>\n            Submit\n          </Form.Submit>\n          <Form.Reset>Reset</Form.Reset>\n        </Form.Item>\n      </Form>\n      <pre style={{marginTop: 8}}>当前选中的地址:{{JSON.stringify(getValue('address'), null, 2)}}</pre>\n    </div>\n}\nexport default Page;\n```\n\n\n## 注意事项\n1.需要生成多个表单组件的时候,使用Form和Form.Item组合来完成表单项的组合,Field来管理表单状态和交互,不要出现Form组件的并行\n2.表单项的name有两种设置方式，第一种是通过Form.Item的name属性，第二种是通过Field实例的init方法，推荐使用第一种，当需要对表单项检验规则、值做定制逻辑的时候，使用第二种,name的值可以根据Form.Item的label的语义来生成\n3.如果某一表单项的内容是由多个表单类组件组成，使用表单解决方案来生成他们，封装成自定义组件，组件属性里接收value和onChange\n\n\n\n\n# 限制和要求\n禁止使用useState联合表单项的value和onChange来单独维护表单项状态,使用Field来读取和设置表单值,表单值更新Field会自动触发整个函数组件的重新渲染\n优先参考解决方案集合(merchant-solutions)中各个解决方案来完成代码生成\n\n",
    ".gitignore": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n",
    "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\"/>\n        <link rel=\"icon\" href=\"data:;base64,=\"/>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"/>\n        <meta name=\"theme-color\" content=\"#000000\"/>\n        <link crossorigin=\"anonymous\" id=\"@alife/theme-sellerpc\" rel=\"stylesheet\" type=\"text/css\" href=\"https://gw.alipayobjects.com/os/lib/alife/theme-sellerpc/0.7.10/??dist/next.min.css,variables.css,dist/next.var.min.css\" />\n        <!-- <link crossorigin=\"anonymous\" id=\"iconfont\" rel=\"stylesheet\" type=\"text/css\" href=\"https://at.alicdn.com/t/a/font_1613397_xq36rgmkwnl.css\" /> -->\n        <script crossorigin=\"anonymous\" id=\"react\" src=\"https://g.alicdn.com/code/lib/react/17.0.1/umd/react.development.js\"></script>\n        <script crossorigin=\"anonymous\" id=\"react-dom\" src=\"https://g.alicdn.com/code/lib/react-dom/17.0.1/umd/react-dom.development.js\"></script>\n        <script crossorigin=\"anonymous\" id=\"moment\" src=\"https://g.alicdn.com/code/lib/moment.js/2.27.0/moment-with-locales.min.js\"></script>\n        <script crossorigin=\"anonymous\" id=\"@alifd/next\" src=\"https://g.alicdn.com/code/lib/alifd__next/1.25.49/next.min.js\"></script>\n        <script crossorigin=\"anonymous\" id=\"react-router-dom\" src=\"https://gw.alipayobjects.com/os/lib/react-router-dom/5.2.0/umd/react-router-dom.min.js\"></script>\n        <!-- <script crossorigin=\"anonymous\" id=\"\" src=\"https://g.alicdn.com/mtb/lib-mtop/2.6.1/mtop.js\"></script> -->\n        <script>\n            window.$QMSMicroMods = {};\n        </script>\n        <title>Merchant Material devServer</title>\n    </head>\n    <body>\n        <div id=\"ai-chat\"></div>\n        <div id='icestark-container'></div>\n        <div id='root'></div>\n        <script type=\"module\" src=\"/src/main.tsx\"></script>\n    </body>\n</html>\n",
    "package.json": "{\n  \"name\": \"my-project\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^17.0.1\",\n    \"@types/react-dom\": \"^17.0.1\",\n    \"@vitejs/plugin-react\": \"^4.3.1\",\n    \"lucide-react\": \"^0.456.0\",\n    \"autoprefixer\": \"^10.4.18\",\n    \"postcss\": \"^8.4.35\",\n    \"tailwindcss\": \"^3.4.1\",\n    \"rollup-plugin-external-globals\": \"^0.12.0\",\n    \"vite\": \"^5.4.2\"\n  }\n}\n\n",
    "postcss.config.js": "export default {\n    plugins: {\n        tailwindcss: {},\n        autoprefixer: {}\n    }\n};",
    "src/App.tsx": "import React from 'react';\n\n\nfunction App() {\n    return (\n    <div className=\"min-h-screen bg-gray-100 flex items-center justify-center\">\n        <p>开始提示（或编辑）以见证奇迹发生 :)</p>\n    </div>\n    );\n}\n\nexport default App",
    "src/index.css": "@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* #root{\n    height: 100vw;\n    width: 100%;\n} */",
    "src/main.tsx": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.tsx';\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n",
    "src/vite-env.d.ts": "/// <reference types=\"vite/client\" />\n",
    "tailwind.config.js": "/** @type {import('tailwindcss').Config} */\nexport default {\n    content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],\n    theme: {\n        extend: {},\n    },\n    plugins: [],\n};\n",
    "tsconfig.app.json": "{\n    \"compilerOptions\": {\n        \"target\": \"ES2020\",\n        \"useDefineForClassFields\": true,\n        \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n        \"module\": \"ESNext\",\n        \"skipLibCheck\": true,\n        /* Bundler mode */\n        \"moduleResolution\": \"bundler\",\n        \"allowImportingTsExtensions\": true,\n        \"isolatedModules\": true,\n        \"moduleDetection\": \"force\",\n        \"noEmit\": true,\n        \"jsx\": \"react-jsx\",\n        /* Linting */\n        \"strict\": true,\n        \"noUnusedLocals\": true,\n        \"noUnusedParameters\": true,\n        \"noFallthroughCasesInSwitch\": true\n    },\n    \"include\": [\"src\"]\n}",
    "tsconfig.json": "{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" }\n  ]\n}\n",
    "tsconfig.node.json": "{\n    \"compilerOptions\": {\n        \"target\": \"ES2022\",\n        \"lib\": [\"ES2023\"],\n        \"module\": \"ESNext\",\n        \"skipLibCheck\": true,\n        /* Bundler mode */\n        \"moduleResolution\": \"bundler\",\n        \"allowImportingTsExtensions\": true,\n        \"isolatedModules\": true,\n        \"moduleDetection\": \"force\",\n        \"noEmit\": true,\n        /* Linting */\n        \"strict\": true,\n        \"noUnusedLocals\": true,\n        \"noUnusedParameters\": true,\n        \"noFallthroughCasesInSwitch\": true\n    },\n    \"include\": [\"vite.config.ts\"]\n}",
    "vite.config.ts": "import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport externalGlobals from \"rollup-plugin-external-globals\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react({\n      jsxRuntime: 'classic'\n    }),\n    externalGlobals({\n      react: 'React',\n      'react-dom': 'ReactDOM',\n      moment: 'moment',\n      'react-router-dom': 'ReactRouterDOM',\n      '@alife/next': 'Next',\n      '@alifd/next': 'Next'\n    })\n  ]\n});\n"
}
}
